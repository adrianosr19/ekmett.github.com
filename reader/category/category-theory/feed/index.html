<?xml version="1.0" encoding="UTF-8"?>
<rss version="2.0"
	xmlns:content="http://purl.org/rss/1.0/modules/content/"
	xmlns:wfw="http://wellformedweb.org/CommentAPI/"
	xmlns:dc="http://purl.org/dc/elements/1.1/"
	xmlns:atom="http://www.w3.org/2005/Atom"
	xmlns:sy="http://purl.org/rss/1.0/modules/syndication/"
	xmlns:slash="http://purl.org/rss/1.0/modules/slash/"
	>

<channel>
	<title>The Comonad.Reader &#187; Category Theory</title>
	<atom:link href="http://comonad.com/reader/category/category-theory/feed/" rel="self" type="application/rss+xml" />
	<link>http://comonad.com/reader</link>
	<description>types, (co)monads, substructural logic</description>
	<lastBuildDate>Sun, 23 Sep 2012 03:43:13 +0000</lastBuildDate>
	<generator>http://wordpress.org/?v=2.8.4</generator>
	<language>en</language>
	<sy:updatePeriod>hourly</sy:updatePeriod>
	<sy:updateFrequency>1</sy:updateFrequency>
			<item>
		<title>Unnatural Transformations and Quantifiers</title>
		<link>http://comonad.com/reader/2012/unnatural-transformations-and-quantifiers/</link>
		<comments>http://comonad.com/reader/2012/unnatural-transformations-and-quantifiers/#comments</comments>
		<pubDate>Sun, 23 Sep 2012 03:43:13 +0000</pubDate>
		<dc:creator>Dan Doel</dc:creator>
				<category><![CDATA[Category Theory]]></category>
		<category><![CDATA[Haskell]]></category>
		<category><![CDATA[Kan Extensions]]></category>
		<category><![CDATA[Mathematics]]></category>
		<category><![CDATA[Monads]]></category>

		<guid isPermaLink="false">http://comonad.com/reader/?p=660</guid>
		<description><![CDATA[Recently, a fellow in category land discovered a fact that we in Haskell land have actually known for a while (in addition to things most of us probably don't). Specifically, given two categories  and , a functor , and provided some conditions in  hold, there exists a monad , the codensity monad of [...]]]></description>
			<content:encoded><![CDATA[<p>Recently, a fellow in category land <a href="http://golem.ph.utexas.edu/category/2012/09/where_do_monads_come_from.html">discovered</a> a fact that we in Haskell land have actually known for a while (in addition to things most of us probably don't). Specifically, given two categories <img src='../../../../latex/db5f7b3e9934fbc5a2859d88c4ba84a3.png' title='$\mathcal{C}$' alt='$\mathcal{C}$' align=absmiddle> and <img src='../../../../latex/eaf85f2b753a4c7585def4cc7ecade43.png' title='$\mathcal{D}$' alt='$\mathcal{D}$' align=absmiddle>, a functor <img src='../../../../latex/28408c9aaded61e50623807633e3ce37.png' title='$G : \mathcal{C} \rightarrow \mathcal{D}$' alt='$G : \mathcal{C} \rightarrow \mathcal{D}$' align=absmiddle>, and provided some conditions in <img src='../../../../latex/eaf85f2b753a4c7585def4cc7ecade43.png' title='$\mathcal{D}$' alt='$\mathcal{D}$' align=absmiddle> hold, there exists a monad <img src='../../../../latex/e049fb90e6d941ff5046ca1c48041c8b.png' title='$T^G$' alt='$T^G$' align=absmiddle>, the codensity monad of <img src='../../../../latex/5201385589993766eea584cd3aa6fa13.png' title='$G$' alt='$G$' align=absmiddle>.</p>
<p>In category theory, the codensity monad is given by the rather frightening expression:</p>
<p><img src='../../../../latex/050bb5034bed82159df4c52c89c07f3c.png' title='$ T^G(a) = \int_r \left[\mathcal{D}(a, Gr), Gr\right] $' alt='$ T^G(a) = \int_r \left[\mathcal{D}(a, Gr), Gr\right] $' align=absmiddle></p>
<p>Where the integral notation denotes an <a href="../../../2008/kan-extension-iii/index.html">end</a>, and the square brackets denote a <a href="http://nlab.mathforge.org/nlab/show/power">power</a>, which allows us to take what is essentially an exponential of the objects of <img src='../../../../latex/eaf85f2b753a4c7585def4cc7ecade43.png' title='$\mathcal{D}$' alt='$\mathcal{D}$' align=absmiddle> by objects of <img src='../../../../latex/76105ebc974ce8a02de91bcaf0d6d25f.png' title='$\mathcal{V}$' alt='$\mathcal{V}$' align=absmiddle>, where <img src='../../../../latex/eaf85f2b753a4c7585def4cc7ecade43.png' title='$\mathcal{D}$' alt='$\mathcal{D}$' align=absmiddle> is <a href="http://nlab.mathforge.org/nlab/show/enriched+category">enriched</a> in <img src='../../../../latex/76105ebc974ce8a02de91bcaf0d6d25f.png' title='$\mathcal{V}$' alt='$\mathcal{V}$' align=absmiddle>. Provided the above end exists, <img src='../../../../latex/e049fb90e6d941ff5046ca1c48041c8b.png' title='$T^G$' alt='$T^G$' align=absmiddle> is a monad regardless of whether <img src='../../../../latex/5201385589993766eea584cd3aa6fa13.png' title='$G$' alt='$G$' align=absmiddle> has an <a href="../../../2008/kan-extensions-ii/index.html">adjoint</a>, which is the usual way one thinks of functors (in general) giving rise to monads.</p>
<p>It also turns out that this construction is a sort of generalization of the adjunction case. If we do have <img src='../../../../latex/754907e967821ca061438630f9c72a7d.png' title='$F \dashv G$' alt='$F \dashv G$' align=absmiddle>, this gives rise to a monad <img src='../../../../latex/a095e64d5e4cfbbc3f2bdfd533130212.png' title='$GF$' alt='$GF$' align=absmiddle>. But, in such a case, <img src='../../../../latex/1e0adde1d1e9eba3705ea3cd2880c6f8.png' title='$T^G \cong GF$' alt='$T^G \cong GF$' align=absmiddle>, so the codensity monad is the same as the monad given by the adjunction when it exists, but codensity may exist when there is no adjunction.</p>
<p>In Haskell, this all becomes a bit simpler (to my eyes, at least). Our category <img src='../../../../latex/eaf85f2b753a4c7585def4cc7ecade43.png' title='$\mathcal{D}$' alt='$\mathcal{D}$' align=absmiddle> is always <img src='../../../../latex/129cf6e597bd76a4da1b575b1fa73b20.png' title='$\mathbf{Hask}$' alt='$\mathbf{Hask}$' align=absmiddle>, which is enriched in itself, so powers are just function spaces. And all the functors we write will be rather like <img src='../../../../latex/129cf6e597bd76a4da1b575b1fa73b20.png' title='$\mathbf{Hask}$' alt='$\mathbf{Hask}$' align=absmiddle> (objects will come from kinds we can quantify over), so ends of functors will look like <code>forall r. F r r</code> where <img src='../../../../latex/b075975319f2e91538b5f7f577347d83.png' title='$F : \mathcal{C}^{op} \times \mathcal{C} \rightarrow \mathbf{Hask}$' alt='$F : \mathcal{C}^{op} \times \mathcal{C} \rightarrow \mathbf{Hask}$' align=absmiddle>. Then:<br />
<code><br />
newtype Codensity f a = Codensity (forall r. (a -> f r) -> f r)<br />
</code></p>
<p>As mentioned, we've known for a while that we can write a Monad instance for <code>Codensity f</code> without caring at all about <code>f</code>.</p>
<p>As for the adjunction correspondence, consider the adjunction between products and exponentials: <img src='../../../../latex/179c9a295a34edbdbd4b2f184a62cdc9.png' title='$ - \times S \dashv S \rightarrow - $' alt='$ - \times S \dashv S \rightarrow - $' align=absmiddle></p>
<p>This gives rise to the monad <img src='../../../../latex/4da4a1547d8498791e0069e7616d7040.png' title='$S \rightarrow (- \times S)$' alt='$S \rightarrow (- \times S)$' align=absmiddle>, the state monad. According to the facts above, we should have that <code>Codensity (s ->)</code> (excuse the sectioning) is the same as state, and if we look, we see:<br />
<code><br />
forall r. (a -> s -> r) -> s -> r<br />
</code></p>
<p>which is the continuation passing, or Church (or <a href="http://comments.gmane.org/gmane.comp.lang.haskell.cafe/100508">Boehm-Berarducci</a>) encoding of the monad.</p>
<p>Now, it's also well known that for any monad, we can construct an adjunction that gives rise to it. There are multiple ways to do this, but the most accessible in Haskell is probably via the Kleisli category. So, given a monad <img src='../../../../latex/fb97d38bcc19230b0acd442e17db879c.png' title='$M$' alt='$M$' align=absmiddle> on <img src='../../../../latex/129cf6e597bd76a4da1b575b1fa73b20.png' title='$\mathbf{Hask}$' alt='$\mathbf{Hask}$' align=absmiddle>, there is a category <img src='../../../../latex/a4b150035aa58ceef406ef607d2c3c70.png' title='$\mathbf{Hask}_M$' alt='$\mathbf{Hask}_M$' align=absmiddle> with the same objects, but where <img src='../../../../latex/bc31ad3fd58dd9ca8691a1719354e0fb.png' title='$\mathbf{Hask}_M(a, b) = \mathbf{Hask}(a, Mb)$' alt='$\mathbf{Hask}_M(a, b) = \mathbf{Hask}(a, Mb)$' align=absmiddle>. The identity for each object is <code>return</code> and composition of arrows is:<br />
<code><br />
(f >=> g) x = f x >>= g<br />
</code></p>
<p>Our two functors are:<br />
<code><br />
F a = a<br />
F f = return . f</p>
<p>U a = M a<br />
U f = (>>= f)<br />
</code></p>
<p>Verifying that <img src='../../../../latex/388ff8dfabfc1466d587e51adb83212a.png' title='$F \dashv U$' alt='$F \dashv U$' align=absmiddle> requires only that <img src='../../../../latex/1f96b28abbe86107fdb6e1a8ffe2ea35.png' title='$\mathbf{Hask}_M(F-, =) \cong \mathbf{Hask}(-, U\!\!=)$' alt='$\mathbf{Hask}_M(F-, =) \cong \mathbf{Hask}(-, U\!\!=)$' align=absmiddle>, but this is just <img src='../../../../latex/d29fe5c1dc21ef08d41e2b5f780f1521.png' title='$\mathbf{Hask}(-, M\!\!=) \cong \mathbf{Hask}(-, M\!\!=)$' alt='$\mathbf{Hask}(-, M\!\!=) \cong \mathbf{Hask}(-, M\!\!=)$' align=absmiddle>, which is a triviality. Now we should have that <img src='../../../../latex/bf2765813f7499243599cc3bf3e7f73b.png' title='$T^U = M$' alt='$T^U = M$' align=absmiddle>.</p>
<p>So, one of the simplest monads is reader, <img src='../../../../latex/0b94f1fc58a44d88f75b94e136f017db.png' title='$(e \rightarrow)$' alt='$(e \rightarrow)$' align=absmiddle>. Now, <img src='../../../../latex/6bac6ec50c01592407695ef84f457232.png' title='$U$' alt='$U$' align=absmiddle> just takes objects in the Kleisli category (which are objects in <img src='../../../../latex/129cf6e597bd76a4da1b575b1fa73b20.png' title='$\mathbf{Hask}$' alt='$\mathbf{Hask}$' align=absmiddle>) and applies <img src='../../../../latex/fb97d38bcc19230b0acd442e17db879c.png' title='$M$' alt='$M$' align=absmiddle> to them, so we should have <code>Codensity (e ->)</code> is reader. But earlier we had <code>Codensity (e ->)</code> was state. So reader is state, right?</p>
<p>We can actually arrive at this result another way. One of the most famous pieces of category theory is the <a href="http://blog.sigfpe.com/2006/11/yoneda-lemma.html">Yoneda lemma</a>, which states that the following correspondence holds for any functor <img src='../../../../latex/d15d65be74350891964d514d80d23f4e.png' title='$F : \mathcal{C} \rightarrow \mathbf{Set}$' alt='$F : \mathcal{C} \rightarrow \mathbf{Set}$' align=absmiddle>:</p>
<p><img src='../../../../latex/291bd125d994fd0c7d00a147403dc44e.png' title='$ Fa \,\, \cong \, \mathbf{Set}^\mathcal{C}\left(C(a,-), F\right) $' alt='$ Fa \,\, \cong \, \mathbf{Set}^\mathcal{C}\left(C(a,-), F\right) $' align=absmiddle></p>
<p>This also works for any functor into <img src='../../../../latex/129cf6e597bd76a4da1b575b1fa73b20.png' title='$\mathbf{Hask}$' alt='$\mathbf{Hask}$' align=absmiddle> and looks like:<br />
<code><br />
F a ~= forall r. (a -> r) -> F r<br />
</code></p>
<p>for <img src='../../../../latex/e426801111acba9fcbd11a4bde602af4.png' title='$F : \mathbf{Hask} \rightarrow \mathbf{Hask}$' alt='$F : \mathbf{Hask} \rightarrow \mathbf{Hask}$' align=absmiddle>. But we also have our functor <img src='../../../../latex/d721b9a42081d5f73eec6b96d40c8f87.png' title='$U : \mathbf{Hask}_M \rightarrow \mathbf{Hask}$' alt='$U : \mathbf{Hask}_M \rightarrow \mathbf{Hask}$' align=absmiddle>, which should look more like:</p>
<p><code> U a ~= forall r. (a -> M r) -> U r<br />
M a ~= forall r. (a -> M r) -> M r</code></p>
<p>So, we fill in <code>M = (e ->)</code> and get that reader is isomorphic to state, right? What's going on?</p>
<p>To see, we have to take a closer look at natural transformations. Given two categories <img src='../../../../latex/db5f7b3e9934fbc5a2859d88c4ba84a3.png' title='$\mathcal{C}$' alt='$\mathcal{C}$' align=absmiddle> and <img src='../../../../latex/eaf85f2b753a4c7585def4cc7ecade43.png' title='$\mathcal{D}$' alt='$\mathcal{D}$' align=absmiddle>, and functors <img src='../../../../latex/f9715681e693462be2b2901abbdce20e.png' title='$F, G : \mathcal{C} \rightarrow \mathcal{D}$' alt='$F, G : \mathcal{C} \rightarrow \mathcal{D}$' align=absmiddle>, a natural transformation <img src='../../../../latex/08bda09160c0fde7f63da195d07031c3.png' title='$\phi : F \Rightarrow G$' alt='$\phi : F \Rightarrow G$' align=absmiddle> is a family of maps <img src='../../../../latex/86b3a786efd28fc240d095754564a874.png' title='$\phi_a : Fa \rightarrow Ga$' alt='$\phi_a : Fa \rightarrow Ga$' align=absmiddle> such that for every <img src='../../../../latex/78c2fecc46b4ab88b04b97e64cc513f7.png' title='$f : a \rightarrow b$' alt='$f : a \rightarrow b$' align=absmiddle> the following diagram commutes:</p>
<div style="text-align: center"><img src='../../../../latex/f3b765d571311e2ac37cb7a4d5c849d6.png' title='$ \bfig \square&amp;lt;1000,1000&gt;[Fa`Ga`Fb`Gb;\phi_a`Ff`Gf`\phi_b]\efig $' alt='$ \bfig \square&amp;lt;1000,1000&gt;[Fa`Ga`Fb`Gb;\phi_a`Ff`Gf`\phi_b]\efig $' align=absmiddle></div>
<p>The key piece is what the morphisms look like. It's well known that parametricity ensures the naturality of <code>t :: forall a. F a -> G a</code> for <img src='../../../../latex/764d49adf41244778f7b1f65677bd4ec.png' title='$F, G : \mathbf{Hask} \rightarrow \mathbf{Hask}$' alt='$F, G : \mathbf{Hask} \rightarrow \mathbf{Hask}$' align=absmiddle>, and it also works when the source is <img src='../../../../latex/142c3f0a398b3921283c65dba9b426f6.png' title='$\mathbf{Hask}^{op}$' alt='$\mathbf{Hask}^{op}$' align=absmiddle>. It should also work for a category, call it <img src='../../../../latex/b7581780b90f85bba660172715c3991e.png' title='$\mathbf{Hask}^{\sim}$' alt='$\mathbf{Hask}^{\sim}$' align=absmiddle>, which has Haskell types as objects, but where <img src='../../../../latex/90c1cbbbf7ae5d1def60bc7bd8600cc1.png' title='$\mathbf{Hask}^{\sim}(a, b) = \mathbf{Hask}(a, b) \times \mathbf{Hask}(b, a)$' alt='$\mathbf{Hask}^{\sim}(a, b) = \mathbf{Hask}(a, b) \times \mathbf{Hask}(b, a)$' align=absmiddle>, which is the sort of category that <code>newtype Endo a = Endo (a -> a)</code> is a functor from. So we should be at liberty to say:<br />
<code><br />
Codensity Endo a = forall r. (a -> r -> r) -> r -> r ~= [a]<br />
</code></p>
<p>However, hom types for <img src='../../../../latex/a4b150035aa58ceef406ef607d2c3c70.png' title='$\mathbf{Hask}_M$' alt='$\mathbf{Hask}_M$' align=absmiddle> are not merely made up of <img src='../../../../latex/129cf6e597bd76a4da1b575b1fa73b20.png' title='$\mathbf{Hask}$' alt='$\mathbf{Hask}$' align=absmiddle> hom types on the same arguments, so naturality turns out not to be guaranteed. A functor <img src='../../../../latex/46cde8a293393bfb788e2146a377dfd6.png' title='$F : \mathbf{Hask}_M \rightarrow \mathbf{Hask}$' alt='$F : \mathbf{Hask}_M \rightarrow \mathbf{Hask}$' align=absmiddle> must take a Kleisli arrow <img src='../../../../latex/4f2fe22635b432c01d95ba33d4fc994e.png' title='$f : b \rightarrow Mc$' alt='$f : b \rightarrow Mc$' align=absmiddle> to an arrow <img src='../../../../latex/ec40c947207bed2928a683a7a8014fb7.png' title='$Ff : Fb \rightarrow Fc$' alt='$Ff : Fb \rightarrow Fc$' align=absmiddle>, and transformations must commute with that mapping. So, if we look at our use of Yoneda, we are considering transformations <img src='../../../../latex/47051979f30f700aee1fda6eab3554f3.png' title='$\phi : \mathbf{Hask}_M(a, -) \Rightarrow U$' alt='$\phi : \mathbf{Hask}_M(a, -) \Rightarrow U$' align=absmiddle>:</p>
<div style="text-align: center"><img src='../../../../latex/b2ed6d7df91f89030039a41b41533753.png' title='$ \bfig\square&amp;lt;1000,1000&gt;[\mathbf{Hask}_M(a,b)`Ub`\mathbf{Hask}_M(a,c)`Uc;\phi_a`\mathbf{Hask}_M(a,f)`Uf`\phi_h]\efig $' alt='$ \bfig\square&amp;lt;1000,1000&gt;[\mathbf{Hask}_M(a,b)`Ub`\mathbf{Hask}_M(a,c)`Uc;\phi_a`\mathbf{Hask}_M(a,f)`Uf`\phi_h]\efig $' align=absmiddle></div>
<p>Now, <img src='../../../../latex/7bb5b195ef8bd7e285fdf865d6e658a0.png' title='$\mathbf{Hask}_M(a,b) = \mathbf{Hask}(a, Mb)$' alt='$\mathbf{Hask}_M(a,b) = \mathbf{Hask}(a, Mb)$' align=absmiddle> and <img src='../../../../latex/9c2c2564bc88a3ea51f03f36675984c1.png' title='$Ub = Mb$' alt='$Ub = Mb$' align=absmiddle>. So</p>
<p><code>t :: forall r. (a -> M r) -> M r</code></p>
<p>will get us the right type of maps. But, the above commutative square corresponds to the condition that for all <code>f :: b -> M c</code>:<br />
<code><br />
t . (>=> f) = (>>= f) . t<br />
</code></p>
<p>So, if we have <code>h :: a -> M b</code>, Kleisli composing it with <code>f</code> and then feeding to <code>t</code> is the same as feeding <code>h</code> to <code>t</code> and then binding the result with <code>f</code>.</p>
<p>Now, if we go back to reader, we can consider the reader morphism:<br />
<code><br />
f = const id :: a -> e -> e<br />
</code></p>
<p>For all relevant <code>m</code> and <code>g</code>, <code> m >>= f = id</code> and <code>g >=> f = f</code>. So the<br />
naturality condition here states that <code>t f = id</code>.</p>
<p>Now, <code>t :: forall r. (a -> e -> r) -> e -> r</code>. The general form of these is state actions (I've split <code>e -> (a, e)</code> into two pieces):</p>
<pre language="haskell">
t f e = f (v e) (st e)
  where
  rd :: e -> a
  st :: e -> e
</pre>
<p>If <code>f = const id</code>, then:</p>
<pre language="haskell">
t (const id) e = st e
 where
 st :: e -> e
</pre>
<p>But our naturality condition states that this must be the identity, so we must have <code>st = id</code>. That is, the naturality condition selects <code>t</code> for which the corresponding state action does not change the state, meaning it is equivalent to a reader action! Presumably the definition of an end (which involves dinaturality) enforces a similar condition, although I won't work through it, as it'd be rather more complicated.</p>
<p>However, we have learned a lesson. Quantifiers do not necessarily enforce (di)naturality for every category with objects of the relevant kind. It is important to look at the hom types, not just the objects .In this case, the point of failure seems to be the common, extra <code>s</code>. Even though the type contains nautral transformations for the similar functors over <img src='../../../../latex/129cf6e597bd76a4da1b575b1fa73b20.png' title='$\mathbf{Hask}$' alt='$\mathbf{Hask}$' align=absmiddle>, they can (in general) still manipulate the shared parameter in ways that are not natural for the domain in question.</p>
<p>I am unsure of how exactly one could enforce the above condition in (Haskell's) types. For instance, if we consider:</p>
<p><code>forall r m. Monad m => (a -> m r) -> m r</code></p>
<p>This still contains transformations of the form:</p>
<p><code> t k = k a >> k a </code></p>
<p>And for this to be natural would require:</p>
<p><code> (k >=> f) a >> (k >=> f) a = (k a >> k a) >>= f </code></p>
<p>Which is not true for all possible instantiations of f. It seems as though leaving <code>m</code> unconstrained would be sufficient, as all that could happen is <code>t</code> feeding a value to <code>k</code> and yielding the result, but it seems likely to be over-restrictive.</p>
]]></content:encoded>
			<wfw:commentRss>http://comonad.com/reader/2012/unnatural-transformations-and-quantifiers/feed/</wfw:commentRss>
		<slash:comments>1</slash:comments>
		</item>
		<item>
		<title>Catamorphism Knol</title>
		<link>http://comonad.com/reader/2012/catamorphism-knol/</link>
		<comments>http://comonad.com/reader/2012/catamorphism-knol/#comments</comments>
		<pubDate>Sun, 27 May 2012 18:17:24 +0000</pubDate>
		<dc:creator>Edward Kmett</dc:creator>
				<category><![CDATA[Category Theory]]></category>

		<guid isPermaLink="false">http://comonad.com/reader/?p=579</guid>
		<description><![CDATA[I was contacted by someone who wanted to read my old catamorphism knol, despite the fact that Google Knol is no more. 
Fortunately, while it was rather inconvenient that they shut down Google Knol completely, and I'll forever remember a knol as a "unit of abandonment", Google did provide a nice way to download at [...]]]></description>
			<content:encoded><![CDATA[<p>I was contacted by someone who wanted to read my old catamorphism knol, despite the fact that Google Knol is no more. </p>
<p>Fortunately, while it was rather inconvenient that they shut down Google Knol completely, and I'll forever remember a knol as a "unit of abandonment", Google did provide a nice way to download at least your own user content and for that I am grateful.</p>
<p>I have fixed up the internal linkage as much as possible and have placed a copy of the original article below.</p>
<p><a href="../../../../haskell/catamorphisms.html">Catamorphisms: A Knol</a></p>
<p>Sadly, as I am not "Dark Magus", I am unable to download the Russian translation. If anyone knows how to contact him, I would love to obtain and preserve a copy of the translation as well.</p>
]]></content:encoded>
			<wfw:commentRss>http://comonad.com/reader/2012/catamorphism-knol/feed/</wfw:commentRss>
		<slash:comments>4</slash:comments>
		</item>
		<item>
		<title>What Constraints Entail: Part 1</title>
		<link>http://comonad.com/reader/2011/what-constraints-entail-part-1/</link>
		<comments>http://comonad.com/reader/2011/what-constraints-entail-part-1/#comments</comments>
		<pubDate>Thu, 03 Nov 2011 05:46:11 +0000</pubDate>
		<dc:creator>Edward Kmett</dc:creator>
				<category><![CDATA[Category Theory]]></category>
		<category><![CDATA[Constraint Kinds]]></category>
		<category><![CDATA[Haskell]]></category>
		<category><![CDATA[Logic]]></category>
		<category><![CDATA[Monads]]></category>
		<category><![CDATA[Type Hackery]]></category>
		<category><![CDATA[Uncategorized]]></category>

		<guid isPermaLink="false">http://comonad.com/reader/?p=430</guid>
		<description><![CDATA[Max Bolingbroke has done a wonderful job on adding Constraint kinds to GHC.
Constraint Kinds adds a new kind Constraint, such that Eq :: * -> Constraint, Monad :: (* -> *) -> Constraint, but since it is a kind, we can make type families for constraints, and even parameterize constraints on constraints. 
So, let's play [...]]]></description>
			<content:encoded><![CDATA[<p>Max Bolingbroke has done a wonderful job on adding Constraint kinds to GHC.</p>
<p>Constraint Kinds adds a new kind <code>Constraint</code>, such that <code>Eq :: * -> Constraint</code>, <code>Monad :: (* -> *) -> Constraint</code>, but since it is a kind, we can make type families for constraints, and even parameterize constraints <em>on</em> constraints. </p>
<p>So, let's play with them and see what we can come up with!</p>
<p><span id="more-430"></span></p>
<h2>A Few Extensions</h2>
<p>First, we'll need a few language features:</p>
<pre class="haskell">&nbsp;
<span style="color: #5d478b; font-style: italic;">{-# LANGUAGE
  CPP,
  ScopedTypeVariables,
  FlexibleInstances,
  FlexibleContexts,
  ConstraintKinds,
  KindSignatures,
  TypeOperators,
  FunctionalDependencies,
  Rank2Types,
  StandaloneDeriving,
  GADTs
  #-}</span>
&nbsp;</pre>
<p>Because of the particular version of GHC I'm using I'll also need</p>
<pre class="haskell">&nbsp;
<span style="color: #5d478b; font-style: italic;">{-# LANGUAGE UndecidableInstances #-}</span>
#define UNDECIDABLE
&nbsp;</pre>
<p>but this bug has been fixed in the current version of GHC Head. I'll be explicit about any instances that need UndecidableInstances by surrounding them in an <code>#ifdef UNDECIDABLE</code> block.</p>
<h2>Explicit Dictionaries</h2>
<p>So with that out of the way, let's import some definitions</p>
<pre class="haskell">&nbsp;
<span style="color: #06c; font-weight: bold;">import</span> Control.<a href="http://haskell.org/ghc/docs/latest/html/libraries/base/Prelude.html#t:Monad"><span style="background-color: #efefbf; font-weight: bold;">Monad</span></a>
<span style="color: #06c; font-weight: bold;">import</span> Control.<a href="http://haskell.org/ghc/docs/latest/html/libraries/base/Prelude.html#t:Monad"><span style="background-color: #efefbf; font-weight: bold;">Monad</span></a>.Instances
<span style="color: #06c; font-weight: bold;">import</span> Control.Applicative
<span style="color: #06c; font-weight: bold;">import</span> Data.Monoid
<span style="color: #06c; font-weight: bold;">import</span> Data.Complex
<span style="color: #06c; font-weight: bold;">import</span> Data.Ratio
<span style="color: #06c; font-weight: bold;">import</span> Unsafe.Coerce
&nbsp;</pre>
<p>and make one of our own that shows what we get out of making Constraints into a kind we can manipulate like any other.</p>
<pre class="haskell">&nbsp;
<span style="color: #06c; font-weight: bold;">data</span> Dict a <span style="color: #06c; font-weight: bold;">where</span>
  Dict :: a =&gt; Dict a
&nbsp;</pre>
<p>Previously, we coud make a Dict like data type for any one particular class constraint that we wanted to capture, but now we can write this type once and for all. The act of pattern matching on the Dict constructor will bring the constraint 'a' into scope.</p>
<p>Of course, in the absence of incoherent and overlapping instances there is at most one dictionary of a given type, so we could make instances, like we can for any other data type, but standalone deriving is smart enough to figure these out for me. (Thanks copumpkin!)</p>
<pre class="haskell">&nbsp;
<span style="color: #06c; font-weight: bold;">deriving</span> <span style="color: #06c; font-weight: bold;">instance</span> <a href="http://haskell.org/ghc/docs/latest/html/libraries/base/Prelude.html#t:Eq"><span style="background-color: #efefbf; font-weight: bold;">Eq</span></a> <span style="color: green;">&#40;</span>Dict a<span style="color: green;">&#41;</span>
<span style="color: #06c; font-weight: bold;">deriving</span> <span style="color: #06c; font-weight: bold;">instance</span> <a href="http://haskell.org/ghc/docs/latest/html/libraries/base/Prelude.html#t:Ord"><span style="background-color: #efefbf; font-weight: bold;">Ord</span></a> <span style="color: green;">&#40;</span>Dict a<span style="color: green;">&#41;</span>
<span style="color: #06c; font-weight: bold;">deriving</span> <span style="color: #06c; font-weight: bold;">instance</span> <a href="http://haskell.org/ghc/docs/latest/html/libraries/base/Prelude.html#t:Show"><span style="background-color: #efefbf; font-weight: bold;">Show</span></a> <span style="color: green;">&#40;</span>Dict a<span style="color: green;">&#41;</span>
&nbsp;</pre>
<p>If we're willing to turn on UndecidableInstances to enable the polymorphic constraint we can even add:</p>
<pre class="haskell">&nbsp;
#ifdef UNDECIDABLE
<span style="color: #06c; font-weight: bold;">deriving</span> <span style="color: #06c; font-weight: bold;">instance</span> a =&gt; <a href="http://haskell.org/ghc/docs/latest/html/libraries/base/Prelude.html#t:Read"><span style="background-color: #efefbf; font-weight: bold;">Read</span></a> <span style="color: green;">&#40;</span>Dict a<span style="color: green;">&#41;</span>
<span style="color: #06c; font-weight: bold;">instance</span> a =&gt; Monoid <span style="color: green;">&#40;</span>Dict a<span style="color: green;">&#41;</span> <span style="color: #06c; font-weight: bold;">where</span>
  mappend Dict Dict = Dict
  mempty = Dict
#endif
&nbsp;</pre>
<p>and similar polymorphically constrained instances for <code>Enum</code>, <code>Bounded</code>, etc.</p>
<h2>Entailment</h2>
<p>For that we'll need a notion of entailment.</p>
<pre class="haskell">&nbsp;
<span style="color: #06c; font-weight: bold;">infixr</span> <span style="color: red;">9</span> :-
<span style="color: #06c; font-weight: bold;">newtype</span> a :- b = Sub <span style="color: green;">&#40;</span>a =&gt; Dict b<span style="color: green;">&#41;</span>
&nbsp;
<span style="color: #06c; font-weight: bold;">instance</span> <a href="http://haskell.org/ghc/docs/latest/html/libraries/base/Prelude.html#t:Eq"><span style="background-color: #efefbf; font-weight: bold;">Eq</span></a> <span style="color: green;">&#40;</span>a :- b<span style="color: green;">&#41;</span> <span style="color: #06c; font-weight: bold;">where</span>
  _ == _ = <a href="http://haskell.org/ghc/docs/latest/html/libraries/base/Prelude.html#v:True"><span style="font-weight: bold;">True</span></a>
&nbsp;
<span style="color: #06c; font-weight: bold;">instance</span> <a href="http://haskell.org/ghc/docs/latest/html/libraries/base/Prelude.html#t:Ord"><span style="background-color: #efefbf; font-weight: bold;">Ord</span></a> <span style="color: green;">&#40;</span>a :- b<span style="color: green;">&#41;</span> <span style="color: #06c; font-weight: bold;">where</span>
  <a href="http://haskell.org/ghc/docs/latest/html/libraries/base/Prelude.html#v:compare"><span style="font-weight: bold;">compare</span></a> _ _ = EQ
&nbsp;
<span style="color: #06c; font-weight: bold;">instance</span> <a href="http://haskell.org/ghc/docs/latest/html/libraries/base/Prelude.html#t:Show"><span style="background-color: #efefbf; font-weight: bold;">Show</span></a> <span style="color: green;">&#40;</span>a :- b<span style="color: green;">&#41;</span> <span style="color: #06c; font-weight: bold;">where</span>
  showsPrec d _ = <a href="http://haskell.org/ghc/docs/latest/html/libraries/base/Prelude.html#v:showParen"><span style="font-weight: bold;">showParen</span></a> <span style="color: green;">&#40;</span>d &gt; <span style="color: red;">10</span><span style="color: green;">&#41;</span> $
    <a href="http://haskell.org/ghc/docs/latest/html/libraries/base/Prelude.html#v:showString"><span style="font-weight: bold;">showString</span></a> <span style="color: #3c7331;">&quot;Sub Dict&quot;</span>
&nbsp;</pre>
<p>Here we're saying that <code>Sub</code> takes one argument, which is a computation that when implicitly given a constraint of type <em>a</em>, can give me back a dictionary for the type <em>b</em>. Moreover, as a newtype it adds no overhead that isn't aleady present in manipulating terms of type (a => Dict b) directly.</p>
<p>The simplest thing we can define with this is that entailment is reflexive.</p>
<pre class="haskell">&nbsp;
refl :: a :- a
refl = Sub Dict
&nbsp;</pre>
<p>Max has already written up a nice restricted monad example using these, but what I want to play with today is the category of substitutability of constraints, but there are a few observations I need to make, first.</p>
<p>ConstraintKinds overloads <code>()</code> and <code>(a,b)</code> to represent the trivial constraint and the product of two constraints respectively. </p>
<p>The latter is done with a bit of a hack, which we'll talk about in a minute, but we can use the former as a terminal object for our category of entailments.</p>
<pre lang="haskell>
top :: a :- ()
top = Sub Dict
</pre>
<p>We can weaken the constraint, in a manner similar to fst or snd:</p>
<pre class="haskell">&nbsp;
weaken1 :: <span style="color: green;">&#40;</span>a, b<span style="color: green;">&#41;</span> :- a
weaken1 = Sub Dict
&nbsp;
weaken2 :: <span style="color: green;">&#40;</span>a, b<span style="color: green;">&#41;</span> :- b
weaken2 = Sub Dict
&nbsp;</pre>
<p>Constraints are idempotent, so we can duplicate one, perhaps as a prelude to transforming one of them into something else.</p>
<pre class="haskell">&nbsp;
contract :: a :- <span style="color: green;">&#40;</span>a, a<span style="color: green;">&#41;</span>
contract = Sub Dict
&nbsp;</pre>
<p>But to do much more complicated, we're going to need a notion of substitution, letting us use our entailment relation to satisfy obligations.</p>
<pre class="haskell">&nbsp;
<span style="color: #06c; font-weight: bold;">infixl</span> <span style="color: red;">1</span> \\ <span style="color: #5d478b; font-style: italic;">-- required comment</span>
<span style="color: green;">&#40;</span>\\<span style="color: green;">&#41;</span> :: a =&gt; <span style="color: green;">&#40;</span>b =&gt; r<span style="color: green;">&#41;</span> -&gt; <span style="color: green;">&#40;</span>a :- b<span style="color: green;">&#41;</span> -&gt; r
r \\ Sub Dict = r
&nbsp;</pre>
<p>The type says that given that a constraint <em>a</em> can be satisfied, a computation that needs a constraint of type <em>b</em> to be satisfied in order to obtain a result, and the fact that <em>a</em> entails <em>b</em>, we can compute the result. </p>
<p>The constraint <em>a</em> is satisfied by the type signature, and the fact that we get quietly passed whatever dictionary is needed. Pattern matching on Sub brings into scope a computation of type <code>(a => Dict b)</code>, and we are able to discharge the <em>a</em> obligation, using the dictionary we were passed, Pattern matching on <code>Dict</code> forces that computation to happen and brings b into scope, allowing us to meet the obligation of the computation of r. All of this happens for us behind the scenes just by pattern matching.</p>
<p>So what can we do with this?</p>
<p>We can use \\ to compose constraints.</p>
<pre class="haskell">&nbsp;
trans :: <span style="color: green;">&#40;</span>b :- c<span style="color: green;">&#41;</span> -&gt; <span style="color: green;">&#40;</span>a :- b<span style="color: green;">&#41;</span> -&gt; a :- c
trans f g = Sub $ Dict \\ f \\ g
&nbsp;</pre>
<p>In fact, the way the dictionaries get plumbed around inside the argument to Sub is rather nice, because we can give that same definition different type signatures, letting us make (,) more product-like, giving us the canonical product morphism to go with the weakenings/projections we defined above.</p>
<pre class="haskell">&nbsp;
<span style="color: green;">&#40;</span>&amp;&amp;&amp;<span style="color: green;">&#41;</span> :: <span style="color: green;">&#40;</span>a :- b<span style="color: green;">&#41;</span> -&gt; <span style="color: green;">&#40;</span>a :- c<span style="color: green;">&#41;</span> -&gt; a :- <span style="color: green;">&#40;</span>b, c<span style="color: green;">&#41;</span>
f &amp;&amp;&amp; g = Sub $ Dict \\ f \\ g
&nbsp;</pre>
<p>And since we're using it as a product, we can make it act like a bifunctor also using the same definition.</p>
<pre class="haskell">&nbsp;
<span style="color: green;">&#40;</span>***<span style="color: green;">&#41;</span> :: <span style="color: green;">&#40;</span>a :- b<span style="color: green;">&#41;</span> -&gt; <span style="color: green;">&#40;</span>c :- d<span style="color: green;">&#41;</span> -&gt; <span style="color: green;">&#40;</span>a, c<span style="color: green;">&#41;</span> :- <span style="color: green;">&#40;</span>b, d<span style="color: green;">&#41;</span>
f *** g = Sub $ Dict \\ f \\ g
&nbsp;</pre>
<h2>Limited Sub-Superkinding?</h2>
<p>Ideally we'd be able to capture something like that bifunctoriality using a type like</p>
<pre class="haskell">&nbsp;
#if <span style="color: red;">0</span>
<span style="color: #06c; font-weight: bold;">class</span> BifunctorS <span style="color: green;">&#40;</span>p :: Constraint -&gt; Constraint -&gt; Constraint<span style="color: green;">&#41;</span> <span style="color: #06c; font-weight: bold;">where</span>
  bimapS :: <span style="color: green;">&#40;</span>a :- b<span style="color: green;">&#41;</span> -&gt; <span style="color: green;">&#40;</span>c :- d<span style="color: green;">&#41;</span> -&gt; p a c :- p b d
#endif
&nbsp;</pre>
<p>In an even more ideal world, it would be enriched using something like</p>
<pre class="haskell">&nbsp;
#ifdef POLYMORPHIC_KINDS
<span style="color: #06c; font-weight: bold;">class</span> Category <span style="color: green;">&#40;</span>k :: x -&gt; x -&gt; *<span style="color: green;">&#41;</span> <span style="color: #06c; font-weight: bold;">where</span>
  <a href="http://haskell.org/ghc/docs/latest/html/libraries/base/Prelude.html#v:id"><span style="font-weight: bold;">id</span></a> :: k a a
  <span style="color: green;">&#40;</span>.<span style="color: green;">&#41;</span> :: k b c -&gt; k a b -&gt; k a c
<span style="color: #06c; font-weight: bold;">instance</span> Category <span style="color: green;">&#40;</span>:-<span style="color: green;">&#41;</span> <span style="color: #06c; font-weight: bold;">where</span>
  <a href="http://haskell.org/ghc/docs/latest/html/libraries/base/Prelude.html#v:id"><span style="font-weight: bold;">id</span></a> = refl
  <span style="color: green;">&#40;</span>.<span style="color: green;">&#41;</span> = trans
#endif
&nbsp;</pre>
<p>where x is a <strong>kind variable</strong>, then we could obtain a more baroque and admittedly far less thought-out bifunctor class like:</p>
<pre class="haskell">&nbsp;
#if <span style="color: red;">0</span>
<span style="color: #06c; font-weight: bold;">class</span> Bifunctor <span style="color: green;">&#40;</span>p :: x -&gt; y -&gt; z<span style="color: green;">&#41;</span> <span style="color: #06c; font-weight: bold;">where</span>
  <span style="color: #06c; font-weight: bold;">type</span> <a href="http://haskell.org/ghc/docs/latest/html/libraries/base/Prelude.html#v:Left"><span style="font-weight: bold;">Left</span></a> p :: x -&gt; x -&gt; *
  <span style="color: #06c; font-weight: bold;">type</span> <a href="http://haskell.org/ghc/docs/latest/html/libraries/base/Prelude.html#v:Left"><span style="font-weight: bold;">Left</span></a> p = <span style="color: green;">&#40;</span>-&gt;<span style="color: green;">&#41;</span>
  <span style="color: #06c; font-weight: bold;">type</span> <a href="http://haskell.org/ghc/docs/latest/html/libraries/base/Prelude.html#v:Right"><span style="font-weight: bold;">Right</span></a> p :: y -&gt; y -&gt; *
  <span style="color: #06c; font-weight: bold;">type</span> <a href="http://haskell.org/ghc/docs/latest/html/libraries/base/Prelude.html#v:Right"><span style="font-weight: bold;">Right</span></a> p = <span style="color: green;">&#40;</span>-&gt;<span style="color: green;">&#41;</span>
  <span style="color: #06c; font-weight: bold;">type</span> Cod p :: z -&gt; z -&gt; *
  <span style="color: #06c; font-weight: bold;">type</span> Cod p = <span style="color: green;">&#40;</span>-&gt;<span style="color: green;">&#41;</span>
  bimap :: <a href="http://haskell.org/ghc/docs/latest/html/libraries/base/Prelude.html#v:Left"><span style="font-weight: bold;">Left</span></a> p a b -&gt; <a href="http://haskell.org/ghc/docs/latest/html/libraries/base/Prelude.html#v:Right"><span style="font-weight: bold;">Right</span></a> p c d -&gt; Cod p <span style="color: green;">&#40;</span>p a c<span style="color: green;">&#41;</span> <span style="color: green;">&#40;</span>p b d<span style="color: green;">&#41;</span>
#endif
&nbsp;</pre>
<p>Or even more more ideally, you could use the fact that we can directly define product categories!</p>
<p>Since they are talking about kind-indexing for classes and type families, we could have separate bifunctors for (,) for both kinds * and Constraint.</p>
<p>The current constraint kind code uses a hack to let (a,b) be used as a type inhabiting * and as the syntax for constraints. This hack is limited however. It only works when the type (,) is fully applied to its arguments. Otherwise you'd wind up with the fact that the type (,) needs to have both of these kinds:</p>
<pre class="haskell">&nbsp;
<span style="color: #5d478b; font-style: italic;">-- (,) :: Constraint -&gt; Constraint -&gt; Constraint and</span>
<span style="color: #5d478b; font-style: italic;">-- (,) :: * -&gt; * -&gt; *</span>
&nbsp;</pre>
<p>What is currently done is that the kind magically switches for <code>()</code> and <code>(,)</code> in certain circumstances. GHC already had some support for this because it parses <code>(Foo a, Bar b)</code> as a type in <code>(Foo a, Bar b) => Baz a b</code> before transforming it into a bunch of constraints.</p>
<p>Since we already have a notion of sub-kinding at the kind level, we could solve this for <code>()</code> by making up a new kind, say, <code>???</code> which is the subkind of both <code>*</code> and <code>Constraint</code>, but this would break the nice join lattice properties of the current system.</p>
<p>[Edit: in the initial draft, I had said superkind]</p>
<pre class="haskell">&nbsp;
<span style="color: #5d478b; font-style: italic;">--    ?</span>
<span style="color: #5d478b; font-style: italic;">--   / \</span>
<span style="color: #5d478b; font-style: italic;">-- (#)  ??</span>
<span style="color: #5d478b; font-style: italic;">--     /  \</span>
<span style="color: #5d478b; font-style: italic;">--    #    *  Constraint</span>
<span style="color: #5d478b; font-style: italic;">--          \ /</span>
<span style="color: #5d478b; font-style: italic;">--          ???</span>
&nbsp;</pre>
<p>But this doesn't address the kind of <code>(,)</code> above. With the new polymorphic kinds that Brent Yorgey and company have been working on and a limited notion of sub-superkinding, this could be resolved by making a new super-kind <code>@</code> that is the super-kind of both <code>*</code> and <code>Constraint</code>, and which is a sub-superkind of the usual unnamed Box superkind. </p>
<pre class="haskell">&nbsp;
<span style="color: #5d478b; font-style: italic;">-- Box</span>
<span style="color: #5d478b; font-style: italic;">--  |</span>
<span style="color: #5d478b; font-style: italic;">--  @</span>
&nbsp;</pre>
<p>Then we can have:</p>
<pre class="haskell">&nbsp;
<span style="color: #5d478b; font-style: italic;">-- (,) :: forall (k :: @). k -&gt; k -&gt; k</span>
<span style="color: #5d478b; font-style: italic;">-- () :: forall (k :: @). k</span>
&nbsp;</pre>
<p>and kind checking/inference will do the right thing about keeping the kind ambiguous for types like <code>(,) () :: forall (k :: @). k</code></p>
<p>This would get rid of the hack and let me make a proper bifunctor for <code>(,)</code> in the category of entailments.</p>
<p>The version of GHC head I'm working with right now doesn't support polymorphic kinds, so I've only been playing with these in a toy type checker, but I'm really looking forward to being able to have product categories!</p>
<h2>Stay Tuned</h2>
<p><a href="../../../2011/what-constraints-entail-part-2/index.html">Next</a>, we'll go over how to reflect the class and instance declarations so we can derive entailment of a superclass for a class, and the entailment of instances.</p>
<p>[<a href="https://github.com/ekmett/constraints/blob/master/Data/Constraint.hs">Source</a>]</p>
]]></content:encoded>
			<wfw:commentRss>http://comonad.com/reader/2011/what-constraints-entail-part-1/feed/</wfw:commentRss>
		<slash:comments>4</slash:comments>
		</item>
		<item>
		<title>Homotopy and Directed Type Theory Slides</title>
		<link>http://comonad.com/reader/2011/homotopy-and-directed-type-theory-slides/</link>
		<comments>http://comonad.com/reader/2011/homotopy-and-directed-type-theory-slides/#comments</comments>
		<pubDate>Fri, 28 Oct 2011 02:38:34 +0000</pubDate>
		<dc:creator>Edward Kmett</dc:creator>
				<category><![CDATA[Boston Haskell]]></category>
		<category><![CDATA[Category Theory]]></category>
		<category><![CDATA[Haskell]]></category>
		<category><![CDATA[Type Theory]]></category>

		<guid isPermaLink="false">http://comonad.com/reader/?p=425</guid>
		<description><![CDATA[As requested, here are the slides from Dan Doel's excellent presentation on Homotopy and Directed Type Theory from this past Monday's Boston Haskell.
]]></description>
			<content:encoded><![CDATA[<p>As requested, here are the slides from Dan Doel's excellent presentation on <a href='../../../wp-content/uploads/2011/10/slides.pdf'>Homotopy and Directed Type Theory</a> from this past Monday's <a href="http://groups.google.com/group/bostonhaskell/browse_thread/thread/9892caece9ebb4d4">Boston Haskell</a>.</p>
]]></content:encoded>
			<wfw:commentRss>http://comonad.com/reader/2011/homotopy-and-directed-type-theory-slides/feed/</wfw:commentRss>
		<slash:comments>0</slash:comments>
		</item>
		<item>
		<title>Free Modules and Functional Linear Functionals</title>
		<link>http://comonad.com/reader/2011/free-modules-and-functional-linear-functionals/</link>
		<comments>http://comonad.com/reader/2011/free-modules-and-functional-linear-functionals/#comments</comments>
		<pubDate>Mon, 11 Jul 2011 20:58:04 +0000</pubDate>
		<dc:creator>Edward Kmett</dc:creator>
				<category><![CDATA[Algorithms]]></category>
		<category><![CDATA[Category Theory]]></category>
		<category><![CDATA[Data Structures]]></category>
		<category><![CDATA[Haskell]]></category>
		<category><![CDATA[Linear Algebra]]></category>
		<category><![CDATA[Monads]]></category>
		<category><![CDATA[Monoids]]></category>
		<category><![CDATA[Type Hackery]]></category>

		<guid isPermaLink="false">http://comonad.com/reader/?p=356</guid>
		<description><![CDATA[Today I hope to start a new series of posts exploring constructive abstract algebra in Haskell.  
In particular, I want to talk about a novel encoding of linear functionals, polynomials and linear maps in Haskell, but first we're going to have to build up some common terminology.
Having obtained the blessing of Wolfgang Jeltsch, I [...]]]></description>
			<content:encoded><![CDATA[<p>Today I hope to start a new series of posts exploring constructive abstract algebra in Haskell.  </p>
<p>In particular, I want to talk about a novel encoding of linear functionals, polynomials and linear maps in Haskell, but first we're going to have to build up some common terminology.</p>
<p>Having obtained the blessing of Wolfgang Jeltsch, I replaced the <a href="http://hackage.haskell.org/package/algebra">algebra</a> package on hackage with something... bigger, although still very much a work in progress.</p>
<p><span id="more-356"></span></p>
<p><strong>(Infinite) Modules over Semirings</strong></p>
<p>Recall that a vector space <strong>V</strong> over a field <strong>F</strong> is given by an additive Abelian group on <strong>V</strong>, and a scalar multiplication operator<br />
   <code>(.*) :: F -> V -> V</code> subject to distributivity laws</p>
<pre class="haskell">&nbsp;
s .* <span style="color: green;">&#40;</span>u + v<span style="color: green;">&#41;</span> = s .* u + s .* v
<span style="color: green;">&#40;</span>s + t<span style="color: green;">&#41;</span> .* v = s .* v + t .* v
&nbsp;</pre>
<p>and associativity laws</p>
<pre class="haskell">&nbsp;
   <span style="color: green;">&#40;</span>s * t<span style="color: green;">&#41;</span> .* v = s .* <span style="color: green;">&#40;</span>t .* v<span style="color: green;">&#41;</span>
&nbsp;</pre>
<p>and respect of the unit of the field.</p>
<pre class="haskell">&nbsp;
   <span style="color: red;">1</span> .* v = v
&nbsp;</pre>
<p>Since multiplication on a field is commutative, we can also add</p>
<pre class="haskell">&nbsp;
  <span style="color: green;">&#40;</span>*.<span style="color: green;">&#41;</span> :: V -&gt; F -&gt; V
  v *. f = f .* v
&nbsp;</pre>
<p>with analogous rules.</p>
<p>But when F is only a <a href="http://en.wikipedia.org/wiki/Ring_(mathematics)">Ring</a>, we call the analogous structure a module, and in a ring, we can't rely on the commutativity of multiplication, so we may have to deal left-modules and right-modules, where only one of those products is available.</p>
<p>We can weaken the structure still further. If we lose the negation in our Ring we and go to a <a href="http://en.wikipedia.org/wiki/Semiring">Rig</a> (often called a Semiring), now our module is an additive moniod.</p>
<p>If we get rid of the additive and multiplicative unit on our Rig we get down to what some authors call a Ringoid, but which we'll call a <a href="http://hackage.haskell.org/packages/archive/algebra/0.3.0/doc/html/Numeric-Semiring-Class.html">Semiring</a> here, because it makes the connection between semiring and semigroup clearer, and the <em>-oid</em> suffix is dangerously overloaded due to category theory.</p>
<p>First we'll define additive semigroups, because I'm going to need both additive and multiplicative monoids over the same types, and Data.Monoid has simultaneously too much and too little structure.</p>
<pre class="haskell">&nbsp;
<span style="color: #5d478b; font-style: italic;">-- (a + b) + c = a + (b + c)</span>
<span style="color: #06c; font-weight: bold;">class</span> Additive m <span style="color: #06c; font-weight: bold;">where</span>
  <span style="color: green;">&#40;</span>+<span style="color: green;">&#41;</span> :: m -&gt; m -&gt; m
  replicate1p :: Whole n =&gt; n -&gt; m -&gt; m <span style="color: #5d478b; font-style: italic;">-- (ignore this for now)</span>
  <span style="color: #5d478b; font-style: italic;">-- ...</span>
&nbsp;</pre>
<p>their Abelian cousins</p>
<pre class="haskell">&nbsp;
<span style="color: #5d478b; font-style: italic;">-- a + b = b + a</span>
<span style="color: #06c; font-weight: bold;">class</span> Additive m =&gt; Abelian m
&nbsp;</pre>
<p>and Multiplicative semigroups</p>
<pre class="haskell">&nbsp;
<span style="color: #5d478b; font-style: italic;">-- (a * b) * c = a * (b * c)</span>
<span style="color: #06c; font-weight: bold;">class</span> Multiplicative m <span style="color: #06c; font-weight: bold;">where</span>
  <span style="color: green;">&#40;</span>*<span style="color: green;">&#41;</span> :: m -&gt; m -&gt; m
  pow1p :: Whole n =&gt; m -&gt; n -&gt; m
  <span style="color: #5d478b; font-style: italic;">-- ...</span>
&nbsp;</pre>
<p>Then we can define a semirings</p>
<pre class="haskell">&nbsp;
<span style="color: #5d478b; font-style: italic;">-- a*(b + c) = a*b + a*c</span>
<span style="color: #5d478b; font-style: italic;">-- (a + b)*c = a*c + b*c</span>
<span style="color: #06c; font-weight: bold;">class</span> <span style="color: green;">&#40;</span>Additive m, Abelian m, Multiplicative m<span style="color: green;">&#41;</span> =&gt; Semiring
&nbsp;</pre>
<p>With that we can define modules over a semiring:</p>
<pre class="haskell">&nbsp;
<span style="color: #5d478b; font-style: italic;">-- r .* (x + y) = r .* x + r .* y</span>
<span style="color: #5d478b; font-style: italic;">-- (r + s) .* x = r .* x + s .* x</span>
<span style="color: #5d478b; font-style: italic;">-- (r * s) .* x = r .* (s .* x)</span>
<span style="color: #06c; font-weight: bold;">class</span> <span style="color: green;">&#40;</span>Semiring r, Additive m<span style="color: green;">&#41;</span> =&gt; LeftModule r m
   <span style="color: green;">&#40;</span>.*<span style="color: green;">&#41;</span> :: r -&gt; m -&gt; m
&nbsp;</pre>
<p>and analogously:</p>
<pre class="haskell">&nbsp;
<span style="color: #06c; font-weight: bold;">class</span> <span style="color: green;">&#40;</span>Semiring r, Additive m<span style="color: green;">&#41;</span> =&gt; RightModule r m
   <span style="color: green;">&#40;</span>*.<span style="color: green;">&#41;</span> :: m -&gt; r -&gt; m
&nbsp;</pre>
<p>For instance every additive semigroup forms a semiring module over the positive natural numbers (1,2..) using replicate1p.</p>
<p>If we know that our addition forms a monoid, then we can form a module over the naturals as well</p>
<pre class="haskell">&nbsp;
<span style="color: #5d478b; font-style: italic;">-- | zero + a = a = a + zero</span>
<span style="color: #06c; font-weight: bold;">class</span>
    <span style="color: green;">&#40;</span>LeftModule Natural m,
    RightModule Natural m
    <span style="color: green;">&#41;</span> =&gt; AdditiveMonoid m <span style="color: #06c; font-weight: bold;">where</span>
   zero :: m
   replicate :: Whole n =&gt; n -&gt; m -&gt; m
&nbsp;</pre>
<p>and if our addition forms a group, then we can form a module over the integers</p>
<pre class="haskell">&nbsp;
<span style="color: #5d478b; font-style: italic;">-- | a + negate a = zero = negate a + a</span>
<span style="color: #06c; font-weight: bold;">class</span>
    <span style="color: green;">&#40;</span>LeftModule <a href="http://haskell.org/ghc/docs/latest/html/libraries/base/Prelude.html#t:Integer"><span style="background-color: #efefbf; font-weight: bold;">Integer</span></a> m
    , RightModule <a href="http://haskell.org/ghc/docs/latest/html/libraries/base/Prelude.html#t:Integer"><span style="background-color: #efefbf; font-weight: bold;">Integer</span></a> m
    <span style="color: green;">&#41;</span> =&gt; AdditiveGroup m <span style="color: #06c; font-weight: bold;">where</span>
  <a href="http://haskell.org/ghc/docs/latest/html/libraries/base/Prelude.html#v:negate"><span style="font-weight: bold;">negate</span></a> :: m -&gt; m
  times :: <a href="http://haskell.org/ghc/docs/latest/html/libraries/base/Prelude.html#t:Integral"><span style="background-color: #efefbf; font-weight: bold;">Integral</span></a> n =&gt; n -&gt; m -&gt; m
  <span style="color: #5d478b; font-style: italic;">-- ...</span>
&nbsp;</pre>
<p><strong>Free Modules over Semirings</strong></p>
<p>A free module on a set E, is a module where the basis vectors are elements of E. Basically it is |E| copies of some (semi)ring.</p>
<p>In Haskell we can represent the free module of a ring directly by defining the action of the (semi)group pointwise.</p>
<pre class="haskell">&nbsp;
<span style="color: #06c; font-weight: bold;">instance</span> Additive m =&gt; Additive <span style="color: green;">&#40;</span>e -&gt; m<span style="color: green;">&#41;</span> <span style="color: #06c; font-weight: bold;">where</span>
   f + g = \x -&gt; f x + g x
&nbsp;
<span style="color: #06c; font-weight: bold;">instance</span> Abelian m =&gt; Abelian <span style="color: green;">&#40;</span>e -&gt; m<span style="color: green;">&#41;</span>
&nbsp;
<span style="color: #06c; font-weight: bold;">instance</span> AdditiveMonoid m =&gt; AdditiveMonoid <span style="color: green;">&#40;</span>e -&gt; m<span style="color: green;">&#41;</span> <span style="color: #06c; font-weight: bold;">where</span>
   zero = <a href="http://haskell.org/ghc/docs/latest/html/libraries/base/Prelude.html#v:const"><span style="font-weight: bold;">const</span></a> zero
&nbsp;
<span style="color: #06c; font-weight: bold;">instance</span> AdditiveGroup m =&gt; AdditveGroup <span style="color: green;">&#40;</span>e -&gt; m<span style="color: green;">&#41;</span> <span style="color: #06c; font-weight: bold;">where</span>
   f - g = \x -&gt; f x - g x
&nbsp;</pre>
<p>We could define the following</p>
<pre class="haskell">&nbsp;
<span style="color: #06c; font-weight: bold;">instance</span> Semiring r =&gt; LeftModule r <span style="color: green;">&#40;</span>e -&gt; m<span style="color: green;">&#41;</span> <span style="color: #06c; font-weight: bold;">where</span>
   r .* f = \x -&gt; r * f x
&nbsp;</pre>
<p>but then we'd have trouble dealing with the Natural and Integer constraints above, so instead we lift modules</p>
<pre class="haskell">&nbsp;
<span style="color: #06c; font-weight: bold;">instance</span> LeftModule r m =&gt; LeftModule r <span style="color: green;">&#40;</span>e -&gt; m<span style="color: green;">&#41;</span> <span style="color: #06c; font-weight: bold;">where</span>
   <span style="color: green;">&#40;</span>.*<span style="color: green;">&#41;</span> m f e = m .* f e
&nbsp;
<span style="color: #06c; font-weight: bold;">instance</span> RightModule r m =&gt; RightModule r <span style="color: green;">&#40;</span>e -&gt; m<span style="color: green;">&#41;</span> <span style="color: #06c; font-weight: bold;">where</span>
   <span style="color: green;">&#40;</span>*.<span style="color: green;">&#41;</span> f m e = f e *. m
&nbsp;</pre>
<p>We <strong>could</strong> go one step further and define multiplication pointwise, but while the direct product of |e| copies of a ring _does_ define a ring, and this ring is the one provided by the Conal Elliot's <a href="http://code.haskell.org/vector-space/"><code>vector-space</code></a> package, it isn't the most general ring we could construct. But we'll need to take a detour first.</p>
<p><strong>Linear Functionals</strong></p>
<p>A Linear functional f on a module M is a linear function from a M to its scalars R.</p>
<p>That is to say that, f : M -> R such that</p>
<pre class="haskell">&nbsp;
f <span style="color: green;">&#40;</span>a .* x + y<span style="color: green;">&#41;</span> = a * f x + f y
&nbsp;</pre>
<p>Consequently linear functionals also form a module over R. We call this module the dual module M*.</p>
<p>Dan Piponi has blogged about these dual vectors (or covectors) in the context of trace diagrams.</p>
<p>If we limit our discussion to free modules, then M = E -> R, so a linear functional on M looks like <code>(E -> R) -> R</code><br />
<em>subject to additional linearity constraints</em> on the result arrow. </p>
<p>The main thing we're not allowed to do in our function is apply our function from E -> R to two different E's and then multiply the results together. Our pointwise definitions above satisfy those linearity constraints, but for example:</p>
<pre class="haskell">&nbsp;
bad f = f <span style="color: red;">0</span> * f <span style="color: red;">0</span>
&nbsp;</pre>
<p>does not.</p>
<p>We <em>could</em> capture this invariant in the type by saying that instead we want</p>
<pre class="haskell">&nbsp;
<span style="color: #06c; font-weight: bold;">newtype</span> LinearM r e =
  LinearM <span style="color: green;">&#123;</span>
    runLinearM :: <span style="color: #06c; font-weight: bold;">forall</span> r. LeftModule r m =&gt; <span style="color: green;">&#40;</span>e -&gt; m<span style="color: green;">&#41;</span> -&gt; m
  <span style="color: green;">&#125;</span>
&nbsp;</pre>
<p>we'd have to make a new such type every time we subclassed Semiring. I'll leave further exploration of this more exotic type to another time. (Using some technically illegal module instances we can recover more structure that you'd expect.)</p>
<p>Now we can package up the type of covectors/linear functionals:</p>
<pre class="haskell">&nbsp;
<span style="color: #06c; font-weight: bold;">infixr</span> <span style="color: red;">0</span> $*
<span style="color: #06c; font-weight: bold;">newtype</span> Linear r a = Linear <span style="color: green;">&#123;</span> <span style="color: green;">&#40;</span>$*<span style="color: green;">&#41;</span> :: <span style="color: green;">&#40;</span>a -&gt; r<span style="color: green;">&#41;</span> -&gt; r <span style="color: green;">&#125;</span>
&nbsp;</pre>
<p>The sufficiently observant may have already noticed that this type is the same as the Cont monad (subject to the linearity restriction on the result arrow).</p>
<p>In fact the <code>Functor</code>, <code>Monad</code>, <code>Applicative</code> instances for <code>Cont</code> all carry over, and <strong>preserve linearity</strong>. </p>
<p>(We lose <code>callCC</code>, but that is at least partially due to the fact that <code>callCC</code> has a less than ideal type signature.)</p>
<p>In addition we get a number of additional instances for <code>Alternative</code>, <code>MonadPlus</code>, by exploiting the knowledge that r is ring-like:</p>
<pre class="haskell">&nbsp;
<span style="color: #06c; font-weight: bold;">instance</span> AdditiveMonoid r =&gt; Alternative <span style="color: green;">&#40;</span>Linear r a<span style="color: green;">&#41;</span> <span style="color: #06c; font-weight: bold;">where</span>
  Linear f &lt; |&gt; Linear g = Linear <span style="color: green;">&#40;</span>f + g<span style="color: green;">&#41;</span>
  empty = Linear zero
&nbsp;</pre>
<p>Note that the <code>(+)</code> and <code>zero</code> there are the ones defined on functions from our earlier free module construction!</p>
<p><strong>Linear Maps</strong></p>
<p>Since <code>Linear r</code> is a monad, <code>Kleisli (Linear r)</code> forms an <code>Arrow</code>:</p>
<pre class="haskell">&nbsp;
b -&gt; <span style="color: green;">&#40;</span><span style="color: green;">&#40;</span>a -&gt; r<span style="color: green;">&#41;</span> ~&gt; r<span style="color: green;">&#41;</span>
&nbsp;</pre>
<p>where the ~> denotes the arrow that is constrained to be linear.</p>
<p>If we swap the order of the arguments so that</p>
<pre class="haskell">&nbsp;
<span style="color: green;">&#40;</span>a -&gt; r<span style="color: green;">&#41;</span> ~&gt; <span style="color: green;">&#40;</span>b -&gt; r<span style="color: green;">&#41;</span>
&nbsp;</pre>
<p>this arrow has a very nice meaning! (See <a href="http://hackage.haskell.org/packages/archive/algebra/0.4.0/doc/html/Numeric-Map-Linear.html">Numeric.Map.Linear</a>)</p>
<pre class="haskell">&nbsp;
<span style="color: #06c; font-weight: bold;">infixr</span> <span style="color: red;">0</span> $#
<span style="color: #06c; font-weight: bold;">newtype</span> Map r b a = Map <span style="color: green;">&#123;</span> <span style="color: green;">&#40;</span>$#<span style="color: green;">&#41;</span> :: <span style="color: green;">&#40;</span>a -&gt; r<span style="color: green;">&#41;</span> -&gt; <span style="color: green;">&#40;</span>b -&gt; r<span style="color: green;">&#41;</span> <span style="color: green;">&#125;</span>
&nbsp;</pre>
<p><code>Map r b a</code> represents the type of <a href="http://en.wikipedia.org/wiki/Linear_map">linear maps</a> from <code>a -> b</code>. Unfortunately due to contravariance the arguments wind up in the "wrong" order.</p>
<pre class="haskell">&nbsp;
<span style="color: #06c; font-weight: bold;">instance</span> Category <span style="color: green;">&#40;</span>Map r<span style="color: green;">&#41;</span> <span style="color: #06c; font-weight: bold;">where</span>
  Map f . Map g = Map <span style="color: green;">&#40;</span>g . f<span style="color: green;">&#41;</span>
  <a href="http://haskell.org/ghc/docs/latest/html/libraries/base/Prelude.html#v:id"><span style="font-weight: bold;">id</span></a> = Map <a href="http://haskell.org/ghc/docs/latest/html/libraries/base/Prelude.html#v:id"><span style="font-weight: bold;">id</span></a>
&nbsp;</pre>
<p>So we can see that a linear map from a module A with basis <code>a</code> to a vector space with basis <code>b</code> effectively consists of |b| linear functionals on A.</p>
<p><code>Map r b a</code> provides a lot of structure. It is a valid instance of <a href="https://github.com/ekmett/algebra/blob/master/Numeric/Map/Linear.hs">an insanely large number of classes</a>.</p>
<p><strong>Vectors and Covectors</strong></p>
<p>In physics, we sometimes call linear functionals <a href="http://www.euclideanspace.com/maths/algebra/vectors/related/covector/index.htm">covectors</a> or covariant vectors, and if we're feeling particularly loquacious, we'll refer to vectors as contravariant vectors.</p>
<p>This has to do with the fact that when you change basis, you change map the change over covariant vectors covariantly, and map the change over vectors contravariantly. (This distinction is beautifully captured by <a href="http://en.wikipedia.org/wiki/Einstein_notation">Einstein's summation notation</a>.)</p>
<p>We also have a notion of <a href="http://en.wikipedia.org/wiki/Covariance_and_contravariance_(computer_science)">covariance and contravariance in computer science</a>! </p>
<p>Functions vary covariantly in their result, and contravariant in their argument. <code>E -> R</code> is contravariant in E. But we chose this representation for our free modules, so the vectors in our free vector space (or module) are contravariant in E.</p>
<pre class="haskell">&nbsp;
<span style="color: #06c; font-weight: bold;">class</span> Contravariant f <span style="color: #06c; font-weight: bold;">where</span>
  contramap :: <span style="color: green;">&#40;</span>a -&gt; b<span style="color: green;">&#41;</span> -&gt; f a -&gt; f b
&nbsp;
<span style="color: #5d478b; font-style: italic;">-- | Dual function arrows.</span>
<span style="color: #06c; font-weight: bold;">newtype</span> Op a b = Op <span style="color: green;">&#123;</span> getOp :: b -&gt; a <span style="color: green;">&#125;</span> 
&nbsp;
<span style="color: #06c; font-weight: bold;">instance</span> Contravariant <span style="color: green;">&#40;</span>Op a<span style="color: green;">&#41;</span> <span style="color: #06c; font-weight: bold;">where</span>
  contramap f g = Op <span style="color: green;">&#40;</span>getOp g . f<span style="color: green;">&#41;</span>
&nbsp;</pre>
<p>On the other hand <code>(E -> R) ~> R</code> varies covariantly with the change of <code>E</code>.</p>
<p>as witnessed by the fact that it is a <code>Functor</code>.</p>
<pre class="haskell">&nbsp;
<span style="color: #06c; font-weight: bold;">instance</span> <a href="http://haskell.org/ghc/docs/latest/html/libraries/base/Prelude.html#t:Functor"><span style="background-color: #efefbf; font-weight: bold;">Functor</span></a> <span style="color: green;">&#40;</span>Linear r<span style="color: green;">&#41;</span> <span style="color: #06c; font-weight: bold;">where</span>
  <a href="http://haskell.org/ghc/docs/latest/html/libraries/base/Prelude.html#v:fmap"><span style="font-weight: bold;">fmap</span></a> f m = Linear $ \k -&gt; m $* k . f
&nbsp;</pre>
<p>We have lots of classes for manipulating covariant structures, and most of them apply to both (Linear r) and (Map r b).</p>
<p><strong>Other Representations and Design Trade-offs</strong></p>
<p>One common representation of vectors in a free vector space is as some kind of normalized list of scalars and basis vectors. In particular, David Amos's wonderful <a href="http://www.polyomino.f2s.com/david/haskell/main.html">HaskellForMaths</a> uses</p>
<pre class="haskell">&nbsp;
<span style="color: #06c; font-weight: bold;">newtype</span> Vect r a = Vect <span style="color: green;">&#123;</span> runVect :: <span style="color: green;">&#91;</span><span style="color: green;">&#40;</span>r,a<span style="color: green;">&#41;</span><span style="color: green;">&#93;</span> <span style="color: green;">&#125;</span>
&nbsp;</pre>
<p>for free vector spaces, only considering them up to linearity, paying for normalization as it goes.</p>
<p>Given the insight above we can see that Vect isn't a representation of vectors in the free vector space, but instead represents the covectors of that space, quite simply because Vect r a varies covariantly with change of basis!</p>
<p>Now the price of using the <code>Monad</code> on <code>Vect r</code> is that the monad denormalizes the representation. In particular, you can have multiple copies of the same basis vector., so any function that uses <code>Vect r a</code> has to merge them together.</p>
<p>On the other hand with the directly encoded linear functionals we've described here, we've placed no obligations on the consumer of a linear functional. They can feed the directly encoded linear functional <strong>any vector</strong> they want! </p>
<p>In fact, it'll even be quite a bit more efficient to compute, </p>
<p>To see this, just consider:</p>
<pre class="haskell">&nbsp;
<span style="color: #06c; font-weight: bold;">instance</span> MultiplicativeMonoid r =&gt; <a href="http://haskell.org/ghc/docs/latest/html/libraries/base/Prelude.html#t:Monad"><span style="background-color: #efefbf; font-weight: bold;">Monad</span></a> <span style="color: green;">&#40;</span>Vect r<span style="color: green;">&#41;</span> <span style="color: #06c; font-weight: bold;">where</span>
   <a href="http://haskell.org/ghc/docs/latest/html/libraries/base/Prelude.html#v:return"><span style="font-weight: bold;">return</span></a> a = Vect <span style="color: green;">&#91;</span><span style="color: green;">&#40;</span><span style="color: red;">1</span>,a<span style="color: green;">&#41;</span><span style="color: green;">&#93;</span>
   Vect <span style="color: #06c; font-weight: bold;">as</span> &gt;&gt;= f = Vect
       <span style="color: green;">&#91;</span> <span style="color: green;">&#40;</span>p*q, b<span style="color: green;">&#41;</span> | <span style="color: green;">&#40;</span>p,a<span style="color: green;">&#41;</span> &lt; - <span style="color: #06c; font-weight: bold;">as</span>, <span style="color: green;">&#40;</span>q,b<span style="color: green;">&#41;</span> &lt;- runVect <span style="color: green;">&#40;</span>f b<span style="color: green;">&#41;</span> <span style="color: green;">&#93;</span>
&nbsp;</pre>
<p>Every >>= must pay for multiplication. Every return will multiply the element by one. On the other hand, the price of return and bind in Linear r is function application.</p>
</pre>
<pre class="haskell">&nbsp;
<span style="color: #06c; font-weight: bold;">instance</span> <a href="http://haskell.org/ghc/docs/latest/html/libraries/base/Prelude.html#t:Monad"><span style="background-color: #efefbf; font-weight: bold;">Monad</span></a> <span style="color: green;">&#40;</span>Linear r<span style="color: green;">&#41;</span> <span style="color: #06c; font-weight: bold;">where</span>
  <a href="http://haskell.org/ghc/docs/latest/html/libraries/base/Prelude.html#v:return"><span style="font-weight: bold;">return</span></a> a = Linear $ \k -&gt; k a
  m &gt;&gt;= f = Linear $ \k -&gt; m $* \a -&gt; f a $* k
&nbsp;</pre>
<p><strong>A Digression on Free Linear Functionals</strong></p>
<p>To wax categorical for a moment, we can construct a forgetful functor <code>U : Vect_F -> Set</code> that takes a vector space over F to just its set of covectors.</p>
<pre lang="haskell>
U (V,F,+,.*) = V ~> F
</pre>
<p>Then we can construct <code>F : Set -> Vect_F</code> which takes a set E and gives the vector space</p>
<pre class="haskell">&nbsp;
F E = <span style="color: green;">&#40;</span>E -&gt; F, F,\f g x -&gt; f x + g x ,\r f x -&gt; r * f x<span style="color: green;">&#41;</span>
&nbsp;</pre>
<p>using the pointwise constructions we built earlier.</p>
<p>Then in a classical setting, you can show that F is left adjoint to U.</p>
<p>In particular the witnesses of this adjunction provide the linear map from (E -> F) to V and the function E -> (V ~> F) giving a linear functional on V for each element of E.</p>
<p>In a classical setting you can go a lot farther, and show that all vector spaces (but not all modules) are free.</p>
<p>But in a constructive setting, such as Haskell, we need a fair bit to go back and forth, in particular we wind up need E to be finitely enumerable to go one way, and for it to have decidable equality to go in the other. The latter is fairly easy to see, because even going from <code>E -> (E -> F)</code> requires that we can define and partially apply something like <a href="http://en.wikipedia.org/wiki/Kronecker_delta">Kronecker's delta</a>:</p>
<pre class="haskell">&nbsp;
delta :: <span style="color: green;">&#40;</span>Rig r, <a href="http://haskell.org/ghc/docs/latest/html/libraries/base/Prelude.html#t:Eq"><span style="background-color: #efefbf; font-weight: bold;">Eq</span></a> a<span style="color: green;">&#41;</span> =&gt; e -&gt; e -&gt; r
delta i j | i == j = one
             | <a href="http://haskell.org/ghc/docs/latest/html/libraries/base/Prelude.html#v:otherwise"><span style="font-weight: bold;">otherwise</span></a> = zero
&nbsp;</pre>
<p><strong>The Price of Power</strong></p>
<p>The price we pay is that, given a <code>Rig</code>, we can go from <code>Vect r a</code> to <code>Linear r a</code> but going back requires <code>a</code> to be be finitely enumerable (or for our functional to satisfy other exotic side-conditions).  </p>
<pre class="haskell">&nbsp;
vectMap :: Rig r =&gt; Vect r a -&gt; Linear r a
vectMap <span style="color: green;">&#40;</span>Vect <span style="color: #06c; font-weight: bold;">as</span><span style="color: green;">&#41;</span> = Map $ \k -&gt; <a href="http://haskell.org/ghc/docs/latest/html/libraries/base/Prelude.html#v:sum"><span style="font-weight: bold;">sum</span></a> <span style="color: green;">&#91;</span> r * k a | <span style="color: green;">&#40;</span>r, a<span style="color: green;">&#41;</span> &lt; - <span style="color: #06c; font-weight: bold;">as</span> <span style="color: green;">&#93;</span>
&nbsp;</pre>
<p>You can still probe <code>Linear r a</code> for individual coefficients, or pass it a vector for polynomial evaluation very easily, but for instance determining a degree of a polynomial efficiently requires attaching more structure to your semiring, because the only value you can get out of <code>Linear r a</code> is an <code>r</code>.</p>
<p><strong>Optimizing Linear Functionals</strong></p>
<p>In both the <code>Vect r</code> and <code>Linear r</code> cases, excessive use of <code>(>>=)</code> without somehow normalizing or tabulating your data will cause a <strong>lot</strong> of repeated work. </p>
<p>This is perhaps easiest to see from the fact that <code>Vect r</code> never used the addition of <code>r</code>, so it distributed everything into a kind of disjunctive normal form. <code>Linear r</code> does the same thing.</p>
<p>If you look at the Kleisli arrows of <code>Vect r</code> or <code>Linear r</code> as linear mappings, then you can see that Kleisli composition is going to explode the number of terms. </p>
<p>So how can we collapse back down?</p>
<p>In the <code>Kleisli (Vect r)</code> case we usually build up a map as we walk through the list then spit the list back out in order having added up like terms.</p>
<p>In the <code>Map r</code> case, we can do better. My <a href="http://hackage.haskell.org/package/representable-tries"><code>representable-tries</code></a> package provides a readily instantiable <code>HasTrie</code> class, and the method:</p>
</pre>
<pre class="haskell">&nbsp;
memo :: HasTrie a =&gt; <span style="color: green;">&#40;</span>a -&gt; r<span style="color: green;">&#41;</span> -&gt; a -&gt; r
&nbsp;</pre>
<p>which is responsible for providing a memoized version of the function from <code>a -> r</code> in a purely functional way. This is obviously a linear map!</p>
<pre class="haskell">&nbsp;
memoMap :: HasTrie a =&gt; Map r a a
memoMap = Map memo
&nbsp;</pre>
<p>We can also flip memo around and memoize linear functionals.</p>
<pre class="haskell">&nbsp;
memoLinear :: HasTrie a =&gt; a -&gt; Linear r a
memoLinear = Linear . <a href="http://haskell.org/ghc/docs/latest/html/libraries/base/Prelude.html#v:flip"><span style="font-weight: bold;">flip</span></a> memo
&nbsp;</pre>
<p>Next time, (co)associative (co)algebras and the myriad means of multiplying (co)vectors!</p>
]]></content:encoded>
			<wfw:commentRss>http://comonad.com/reader/2011/free-modules-and-functional-linear-functionals/feed/</wfw:commentRss>
		<slash:comments>9</slash:comments>
		</item>
		<item>
		<title>A Product of an Imperfect Union</title>
		<link>http://comonad.com/reader/2011/a-product-of-an-imperfect-union/</link>
		<comments>http://comonad.com/reader/2011/a-product-of-an-imperfect-union/#comments</comments>
		<pubDate>Fri, 01 Jul 2011 03:49:10 +0000</pubDate>
		<dc:creator>Edward Kmett</dc:creator>
				<category><![CDATA[Category Theory]]></category>
		<category><![CDATA[Comonads]]></category>
		<category><![CDATA[Haskell]]></category>
		<category><![CDATA[Kan Extensions]]></category>
		<category><![CDATA[Monads]]></category>

		<guid isPermaLink="false">http://comonad.com/reader/?p=337</guid>
		<description><![CDATA[In the last few posts, I've been talking about how we can derive monads and monad transformers from comonads. Along the way we learned that there are more monads than comonads in Haskell.
The question I hope to answer this time, is whether or not we turn any Haskell Comonad into a comonad transformer.

Comonads from Comonads
In [...]]]></description>
			<content:encoded><![CDATA[<p>In the last few posts, I've been talking about how we can derive <a href="../../../2011/monads-from-comonads/index.html">monads</a> and <a href="../../../2011/monad-transformers-from-comonads/index.html">monad transformers</a> from comonads. Along the way we learned that there are more monads than comonads in Haskell.</p>
<p>The question I hope to answer this time, is whether or not we turn any Haskell <code>Comonad</code> into a <a href="http://hackage.haskell.org/packages/archive/comonad-transformers/1.8.0/doc/html/Control-Comonad-Trans-Class.html">comonad transformer</a>.</p>
<p><span id="more-337"></span></p>
<p><strong>Comonads from Comonads</strong></p>
<p>In <a href="../../../2011/monads-from-comonads/index.html">Monads from Comonads</a>, we built the comonad-to-monad transformer</p>
<pre class="haskell">&nbsp;
<span style="color: #06c; font-weight: bold;">newtype</span> Co w m a = Co <span style="color: green;">&#40;</span><span style="color: #06c; font-weight: bold;">forall</span> r. w <span style="color: green;">&#40;</span>a -&gt; r<span style="color: green;">&#41;</span> -&gt; r<span style="color: green;">&#41;</span>
&nbsp;</pre>
<p>by sandwiching a <code>Comonad</code> <em>w</em> in the middle of a trivial Codensity monad, then proceeded to show that at least in the case where our comonad was given rise to by an adjunction <code>f -| g : Hask -> Hask</code>, we could reason about this as if we had</p>
<pre class="haskell">&nbsp;
Co w ~ Co <span style="color: green;">&#40;</span>f . g<span style="color: green;">&#41;</span> ~ g . f
&nbsp;</pre>
<p>Now, <code>Codensity</code> monads are a right <a href="http://en.wikipedia.org/wiki/Kan_extension">Kan extension</a>. </p>
<p>So, what happens if we try to do the same thing to a Left Kan extension?</p>
<p>Using</p>
<pre class="haskell">&nbsp;
<span style="color: #5d478b; font-style: italic;">{-# LANGUAGE GADTs, FlexibleInstances #-}</span>
&nbsp;
<span style="color: #06c; font-weight: bold;">import</span> Control.<a href="../../../../haskell/category-extras/dist/doc/html/category-extras/Control-Comonad.html#t:Comonad"><span style="background-color: #efefbf; font-weight: bold;">Comonad</span></a>
<span style="color: #06c; font-weight: bold;">import</span> Control.<a href="../../../../haskell/category-extras/dist/doc/html/category-extras/Control-Comonad.html#t:Comonad"><span style="background-color: #efefbf; font-weight: bold;">Comonad</span></a>.Trans.Class
&nbsp;</pre>
<p>we can define</p>
<pre class="haskell">&nbsp;
<span style="color: #06c; font-weight: bold;">data</span> L w a <span style="color: #06c; font-weight: bold;">where</span>
  L :: w <span style="color: green;">&#40;</span>r -&gt; a<span style="color: green;">&#41;</span> -&gt; r -&gt; L w a
&nbsp;</pre>
<p>and a number of instances pop out for free, cribbed largely from the definition for Density.</p>
<pre class="haskell">&nbsp;
<span style="color: #06c; font-weight: bold;">instance</span> <a href="http://haskell.org/ghc/docs/latest/html/libraries/base/Prelude.html#t:Functor"><span style="background-color: #efefbf; font-weight: bold;">Functor</span></a> w =&gt; <a href="http://haskell.org/ghc/docs/latest/html/libraries/base/Prelude.html#t:Functor"><span style="background-color: #efefbf; font-weight: bold;">Functor</span></a> <span style="color: green;">&#40;</span>L w<span style="color: green;">&#41;</span> <span style="color: #06c; font-weight: bold;">where</span>
  <a href="http://haskell.org/ghc/docs/latest/html/libraries/base/Prelude.html#v:fmap"><span style="font-weight: bold;">fmap</span></a> f <span style="color: green;">&#40;</span>L w r<span style="color: green;">&#41;</span> = L <span style="color: green;">&#40;</span><a href="http://haskell.org/ghc/docs/latest/html/libraries/base/Prelude.html#v:fmap"><span style="font-weight: bold;">fmap</span></a> <span style="color: green;">&#40;</span>f .<span style="color: green;">&#41;</span> w<span style="color: green;">&#41;</span> r
&nbsp;
<span style="color: #06c; font-weight: bold;">instance</span> ComonadTrans L <span style="color: #06c; font-weight: bold;">where</span>
  lower <span style="color: green;">&#40;</span>L w r<span style="color: green;">&#41;</span> = <a href="http://haskell.org/ghc/docs/latest/html/libraries/base/Prelude.html#v:fmap"><span style="font-weight: bold;">fmap</span></a> <span style="color: green;">&#40;</span>$r<span style="color: green;">&#41;</span> w
&nbsp;
<span style="color: #06c; font-weight: bold;">instance</span> Extend w =&gt; Extend <span style="color: green;">&#40;</span>L w<span style="color: green;">&#41;</span> <span style="color: #06c; font-weight: bold;">where</span>
  <a href="../../../../haskell/category-extras/dist/doc/html/category-extras/Control-Comonad.html#v:duplicate"><span style="font-weight: bold;">duplicate</span></a> <span style="color: green;">&#40;</span>L w s<span style="color: green;">&#41;</span> = L <span style="color: green;">&#40;</span><a href="../../../../haskell/category-extras/dist/doc/html/category-extras/Control-Comonad.html#v:extend"><span style="font-weight: bold;">extend</span></a> L w<span style="color: green;">&#41;</span> s
&nbsp;
<span style="color: #06c; font-weight: bold;">instance</span> <a href="../../../../haskell/category-extras/dist/doc/html/category-extras/Control-Comonad.html#t:Comonad"><span style="background-color: #efefbf; font-weight: bold;">Comonad</span></a> w =&gt; <a href="../../../../haskell/category-extras/dist/doc/html/category-extras/Control-Comonad.html#t:Comonad"><span style="background-color: #efefbf; font-weight: bold;">Comonad</span></a> <span style="color: green;">&#40;</span>L w<span style="color: green;">&#41;</span> <span style="color: #06c; font-weight: bold;">where</span>
  <a href="../../../../haskell/category-extras/dist/doc/html/category-extras/Control-Comonad.html#v:extract"><span style="font-weight: bold;">extract</span></a> <span style="color: green;">&#40;</span>L w r<span style="color: green;">&#41;</span> = <a href="../../../../haskell/category-extras/dist/doc/html/category-extras/Control-Comonad.html#v:extract"><span style="font-weight: bold;">extract</span></a> w r
&nbsp;</pre>
<p>Reasoning as before about <code>w</code> as if it were composed of an adjunction <code>f -| g : Hask -> Hask</code> to build some intuition, we can see:</p>
<pre class="haskell">&nbsp;
L w a ~ exists r. <span style="color: green;">&#40;</span>w <span style="color: green;">&#40;</span>r -&gt; a<span style="color: green;">&#41;</span>, r<span style="color: green;">&#41;</span>
      ~ exists r. <span style="color: green;">&#40;</span>f <span style="color: green;">&#40;</span>g <span style="color: green;">&#40;</span>r -&gt; a<span style="color: green;">&#41;</span><span style="color: green;">&#41;</span>, r<span style="color: green;">&#41;</span>
      ~ exists r. <span style="color: green;">&#40;</span>f <span style="color: green;">&#40;</span><span style="color: green;">&#41;</span>, g <span style="color: green;">&#40;</span>r -&gt; a<span style="color: green;">&#41;</span>, r<span style="color: green;">&#41;</span>
      ~ exists r. <span style="color: green;">&#40;</span>f <span style="color: green;">&#40;</span><span style="color: green;">&#41;</span>, f <span style="color: green;">&#40;</span><span style="color: green;">&#41;</span> -&gt; r -&gt; a, r<span style="color: green;">&#41;</span>
      ~ exists r. <span style="color: green;">&#40;</span>f <span style="color: green;">&#40;</span><span style="color: green;">&#41;</span> -&gt; r -&gt; a, f r<span style="color: green;">&#41;</span>
      ~ exists r. <span style="color: green;">&#40;</span>f r -&gt; a, f r<span style="color: green;">&#41;</span>
      ~ Density f a
      ~ <a href="../../../../haskell/category-extras/dist/doc/html/category-extras/Control-Functor-KanExtension.html#t:Lan"><span style="background-color: #efefbf; font-weight: bold;">Lan</span></a> f f a
      ~ <span style="color: green;">&#40;</span>f . <a href="../../../../haskell/category-extras/dist/doc/html/category-extras/Control-Functor-KanExtension.html#t:Lan"><span style="background-color: #efefbf; font-weight: bold;">Lan</span></a> f Id<span style="color: green;">&#41;</span> a
      ~ <span style="color: green;">&#40;</span>f . g<span style="color: green;">&#41;</span> a
      ~ w a
&nbsp;</pre>
<p>The latter few steps require identities established in my <a href="../../../2008/kan-extensions-ii/index.html">second post on Kan extensions</a>.</p>
<p>With that we obtain the "remarkable" insight that <code>L ~ IdentityT</code>, which I suppose is much more obvious when just looking at the type</p>
<pre class="haskell">&nbsp;
<span style="color: #06c; font-weight: bold;">data</span> L w a <span style="color: #06c; font-weight: bold;">where</span>
  L :: w <span style="color: green;">&#40;</span>r -&gt; a<span style="color: green;">&#41;</span> -&gt; r -&gt; L w a
&nbsp;</pre>
<p>and seeing the existentially quantified <code>r</code> as a piece of the environment, being used to build an <code>a</code>, since there is nothing else we can do with it, except pass it in to each function wrapped by <code>w</code>! So at first blush, we've gained nothing.</p>
<p>The key observation is that in one case we would up with something isomorphic to the codensity monad of our right adjoint, while in the other case we would up with the density comonad of our left adjoint. The former is isomorphic to the monad given by our adjunction, while the latter is isomorphic to the comonad, which is, unfortunately, right where we started!</p>
<p><strong>In The Future All Comonads are Comonad Transformers!</strong></p>
<p>Of course, we don't have to just modify a trivial left Kan extension. Let's tweak the <code>Density</code> comonad of another comonad!</p>
<pre class="haskell">&nbsp;
<span style="color: #06c; font-weight: bold;">data</span> D f w a <span style="color: #06c; font-weight: bold;">where</span>
  D :: w <span style="color: green;">&#40;</span>f r -&gt; a<span style="color: green;">&#41;</span> -&gt; f r -&gt; D f w a
&nbsp;</pre>
<p>Since both arguments will be comonads, and I want this to be a comonad transformer, I'm going to swap the roles of the arguments relative to the definition of <code>CoT w m</code>. The reason is that <code>D f w</code> is a Comonad, regardless of the properties of f, so long as <code>w</code> is a <code>Comonad</code> This is similar to how <code>Density f</code> is a Comonad regardless of what <code>f</code> is, as long as it has kind <code>* -> *</code>.</p>
<p>The implementation of <code>D</code> is identical to <code>L</code> above, just as <code>CoT</code> and <code>Co</code> share implementations and <code>ContT</code> and <code>Cont</code> do.</p>
<pre class="haskell">&nbsp;
<span style="color: #06c; font-weight: bold;">instance</span> <a href="http://haskell.org/ghc/docs/latest/html/libraries/base/Prelude.html#t:Functor"><span style="background-color: #efefbf; font-weight: bold;">Functor</span></a> w =&gt; <a href="http://haskell.org/ghc/docs/latest/html/libraries/base/Prelude.html#t:Functor"><span style="background-color: #efefbf; font-weight: bold;">Functor</span></a> <span style="color: green;">&#40;</span>D f w<span style="color: green;">&#41;</span> <span style="color: #06c; font-weight: bold;">where</span>
  <a href="http://haskell.org/ghc/docs/latest/html/libraries/base/Prelude.html#v:fmap"><span style="font-weight: bold;">fmap</span></a> f <span style="color: green;">&#40;</span>D w r<span style="color: green;">&#41;</span> = D <span style="color: green;">&#40;</span><a href="http://haskell.org/ghc/docs/latest/html/libraries/base/Prelude.html#v:fmap"><span style="font-weight: bold;">fmap</span></a> <span style="color: green;">&#40;</span>f .<span style="color: green;">&#41;</span> w<span style="color: green;">&#41;</span> r
&nbsp;
<span style="color: #06c; font-weight: bold;">instance</span> Extend w =&gt; Extend <span style="color: green;">&#40;</span>D f w<span style="color: green;">&#41;</span> <span style="color: #06c; font-weight: bold;">where</span>
  <a href="../../../../haskell/category-extras/dist/doc/html/category-extras/Control-Comonad.html#v:duplicate"><span style="font-weight: bold;">duplicate</span></a> <span style="color: green;">&#40;</span>D w s<span style="color: green;">&#41;</span> = D <span style="color: green;">&#40;</span><a href="../../../../haskell/category-extras/dist/doc/html/category-extras/Control-Comonad.html#v:extend"><span style="font-weight: bold;">extend</span></a> D w<span style="color: green;">&#41;</span> s
&nbsp;
<span style="color: #06c; font-weight: bold;">instance</span> <a href="../../../../haskell/category-extras/dist/doc/html/category-extras/Control-Comonad.html#t:Comonad"><span style="background-color: #efefbf; font-weight: bold;">Comonad</span></a> w =&gt; <a href="../../../../haskell/category-extras/dist/doc/html/category-extras/Control-Comonad.html#t:Comonad"><span style="background-color: #efefbf; font-weight: bold;">Comonad</span></a> <span style="color: green;">&#40;</span>D f w<span style="color: green;">&#41;</span> <span style="color: #06c; font-weight: bold;">where</span>
  <a href="../../../../haskell/category-extras/dist/doc/html/category-extras/Control-Comonad.html#v:extract"><span style="font-weight: bold;">extract</span></a> <span style="color: green;">&#40;</span>D w r<span style="color: green;">&#41;</span> = <a href="../../../../haskell/category-extras/dist/doc/html/category-extras/Control-Comonad.html#v:extract"><span style="font-weight: bold;">extract</span></a> w r
&nbsp;
<span style="color: #06c; font-weight: bold;">instance</span> ComonadTrans <span style="color: green;">&#40;</span>D f<span style="color: green;">&#41;</span> <span style="color: #06c; font-weight: bold;">where</span>
  lower <span style="color: green;">&#40;</span>D w r<span style="color: green;">&#41;</span> = <a href="http://haskell.org/ghc/docs/latest/html/libraries/base/Prelude.html#v:fmap"><span style="font-weight: bold;">fmap</span></a> <span style="color: green;">&#40;</span>$r<span style="color: green;">&#41;</span> w
&nbsp;</pre>
<p>But in addition to being able to <code>lower :: D f w a -> w a</code>, we can also lower to the other comonad!</p>
<pre class="haskell">&nbsp;
fstD :: <span style="color: green;">&#40;</span>Extend f, <a href="../../../../haskell/category-extras/dist/doc/html/category-extras/Control-Comonad.html#t:Comonad"><span style="background-color: #efefbf; font-weight: bold;">Comonad</span></a> w<span style="color: green;">&#41;</span> =&gt; D f w a -&gt; f a
fstD <span style="color: green;">&#40;</span>D w r<span style="color: green;">&#41;</span> = <a href="../../../../haskell/category-extras/dist/doc/html/category-extras/Control-Comonad.html#v:extend"><span style="font-weight: bold;">extend</span></a> <span style="color: green;">&#40;</span><a href="../../../../haskell/category-extras/dist/doc/html/category-extras/Control-Comonad.html#v:extract"><span style="font-weight: bold;">extract</span></a> w<span style="color: green;">&#41;</span> r
&nbsp;
sndD :: <a href="../../../../haskell/category-extras/dist/doc/html/category-extras/Control-Comonad.html#t:Comonad"><span style="background-color: #efefbf; font-weight: bold;">Comonad</span></a> w =&gt; D f w a -&gt; w a
sndD = lower
&nbsp;</pre>
<p>This means that if either comonad provides us with a piece of functionality we can exploit it.</p>
<p><strong>Selling Products</strong></p>
<p>In general Monad products always exist:</p>
<pre>
newtype Product m n a = Pair { runFst :: m a, runSnd :: n a }

instance (Monad m, Monad n) => Monad (Product m n) where
   return a = Pair (return a) (return a)
   Pair ma na >>= f = Pair (ma >>= runFst . f) (na >>= runSnd . f)
</pre>
<p>and Comonad coproducts always exist:</p>
<pre class="haskell">&nbsp;
<span style="color: #06c; font-weight: bold;">newtype</span> Coproduct f g a = Coproduct <span style="color: green;">&#123;</span> getCoproduct :: <a href="http://haskell.org/ghc/docs/latest/html/libraries/base/Prelude.html#t:Either"><span style="background-color: #efefbf; font-weight: bold;">Either</span></a> <span style="color: green;">&#40;</span>f a<span style="color: green;">&#41;</span> <span style="color: green;">&#40;</span>g a<span style="color: green;">&#41;</span> <span style="color: green;">&#125;</span>
&nbsp;
left :: f a -&gt; Coproduct f g a
left = Coproduct . <a href="http://haskell.org/ghc/docs/latest/html/libraries/base/Prelude.html#v:Left"><span style="font-weight: bold;">Left</span></a>
&nbsp;
right :: g a -&gt; Coproduct f g a
right = Coproduct . <a href="http://haskell.org/ghc/docs/latest/html/libraries/base/Prelude.html#v:Right"><span style="font-weight: bold;">Right</span></a>
&nbsp;
coproduct :: <span style="color: green;">&#40;</span>f a -&gt; b<span style="color: green;">&#41;</span> -&gt; <span style="color: green;">&#40;</span>g a -&gt; b<span style="color: green;">&#41;</span> -&gt; Coproduct f g a -&gt; b
coproduct f g = <a href="http://haskell.org/ghc/docs/latest/html/libraries/base/Prelude.html#v:either"><span style="font-weight: bold;">either</span></a> f g . getCoproduct
&nbsp;
<span style="color: #06c; font-weight: bold;">instance</span> <span style="color: green;">&#40;</span>Extend f, Extend g<span style="color: green;">&#41;</span> =&gt; Extend <span style="color: green;">&#40;</span>Coproduct f g<span style="color: green;">&#41;</span> <span style="color: #06c; font-weight: bold;">where</span>
  <a href="../../../../haskell/category-extras/dist/doc/html/category-extras/Control-Comonad.html#v:extend"><span style="font-weight: bold;">extend</span></a> f = Coproduct . coproduct
    <span style="color: green;">&#40;</span><a href="http://haskell.org/ghc/docs/latest/html/libraries/base/Prelude.html#v:Left"><span style="font-weight: bold;">Left</span></a> . <a href="../../../../haskell/category-extras/dist/doc/html/category-extras/Control-Comonad.html#v:extend"><span style="font-weight: bold;">extend</span></a> <span style="color: green;">&#40;</span>f . Coproduct . <a href="http://haskell.org/ghc/docs/latest/html/libraries/base/Prelude.html#v:Left"><span style="font-weight: bold;">Left</span></a><span style="color: green;">&#41;</span><span style="color: green;">&#41;</span>
    <span style="color: green;">&#40;</span><a href="http://haskell.org/ghc/docs/latest/html/libraries/base/Prelude.html#v:Right"><span style="font-weight: bold;">Right</span></a> . <a href="../../../../haskell/category-extras/dist/doc/html/category-extras/Control-Comonad.html#v:extend"><span style="font-weight: bold;">extend</span></a> <span style="color: green;">&#40;</span>f . Coproduct . <a href="http://haskell.org/ghc/docs/latest/html/libraries/base/Prelude.html#v:Right"><span style="font-weight: bold;">Right</span></a><span style="color: green;">&#41;</span><span style="color: green;">&#41;</span>
&nbsp;
<span style="color: #06c; font-weight: bold;">instance</span> <span style="color: green;">&#40;</span><a href="../../../../haskell/category-extras/dist/doc/html/category-extras/Control-Comonad.html#t:Comonad"><span style="background-color: #efefbf; font-weight: bold;">Comonad</span></a> f, <a href="../../../../haskell/category-extras/dist/doc/html/category-extras/Control-Comonad.html#t:Comonad"><span style="background-color: #efefbf; font-weight: bold;">Comonad</span></a> g<span style="color: green;">&#41;</span> =&gt; <a href="../../../../haskell/category-extras/dist/doc/html/category-extras/Control-Comonad.html#t:Comonad"><span style="background-color: #efefbf; font-weight: bold;">Comonad</span></a> <span style="color: green;">&#40;</span>Coproduct f g<span style="color: green;">&#41;</span> <span style="color: #06c; font-weight: bold;">where</span>
  <a href="../../../../haskell/category-extras/dist/doc/html/category-extras/Control-Comonad.html#v:extract"><span style="font-weight: bold;">extract</span></a> = coproduct <a href="../../../../haskell/category-extras/dist/doc/html/category-extras/Control-Comonad.html#v:extract"><span style="font-weight: bold;">extract</span></a> <a href="../../../../haskell/category-extras/dist/doc/html/category-extras/Control-Comonad.html#v:extract"><span style="font-weight: bold;">extract</span></a>
&nbsp;</pre>
<p>but Christoph Lüth and Neil Ghani showed that <a href="http://citeseerx.ist.psu.edu/viewdoc/summary?doi=10.1.1.8.3581">monad coproducts don't always exist</a>!</p>
<p>On the other hand what we built up above looks a lot like a comonad product!</p>
<p>Too see that, first we'll note some of the product-like things we can do:</p>
<p><code>fstD</code> and <code>sndD</code> act a lot like <code>fst</code> and <code>snd</code>, projecting our parts of our product and it turns out we can "braid" our almost-products, interchanging the left and right hand side. </p>
<pre class="haskell">&nbsp;
braid :: <span style="color: green;">&#40;</span>Extend f, <a href="../../../../haskell/category-extras/dist/doc/html/category-extras/Control-Comonad.html#t:Comonad"><span style="background-color: #efefbf; font-weight: bold;">Comonad</span></a> w<span style="color: green;">&#41;</span> =&gt; D f w a -&gt; D w f a
braid <span style="color: green;">&#40;</span>D w r<span style="color: green;">&#41;</span> = D <span style="color: green;">&#40;</span><a href="../../../../haskell/category-extras/dist/doc/html/category-extras/Control-Comonad.html#v:extend"><span style="font-weight: bold;">extend</span></a> <span style="color: green;">&#40;</span><a href="http://haskell.org/ghc/docs/latest/html/libraries/base/Prelude.html#v:flip"><span style="font-weight: bold;">flip</span></a> <a href="../../../../haskell/category-extras/dist/doc/html/category-extras/Control-Comonad.html#v:extract"><span style="font-weight: bold;">extract</span></a><span style="color: green;">&#41;</span> r<span style="color: green;">&#41;</span> w
&nbsp;</pre>
<p>(I use scary air-quotes around braid, because it doesn't let us braid them in a categorical sense, as we'll see.)</p>
<p>After braiding, one of our projections swaps places as we'd expect:</p>
<pre class="haskell">&nbsp;
sndD <span style="color: green;">&#40;</span>braid <span style="color: green;">&#40;</span>D w r<span style="color: green;">&#41;</span><span style="color: green;">&#41;</span> = <span style="color: #5d478b; font-style: italic;">-- by braid def</span>
sndD <span style="color: green;">&#40;</span>D <span style="color: green;">&#40;</span><a href="../../../../haskell/category-extras/dist/doc/html/category-extras/Control-Comonad.html#v:extend"><span style="font-weight: bold;">extend</span></a> <span style="color: green;">&#40;</span><a href="http://haskell.org/ghc/docs/latest/html/libraries/base/Prelude.html#v:flip"><span style="font-weight: bold;">flip</span></a> <a href="../../../../haskell/category-extras/dist/doc/html/category-extras/Control-Comonad.html#v:extract"><span style="font-weight: bold;">extract</span></a><span style="color: green;">&#41;</span> r<span style="color: green;">&#41;</span> w<span style="color: green;">&#41;</span> = <span style="color: #5d478b; font-style: italic;">-- by sndD (and lower) def</span>
<a href="http://haskell.org/ghc/docs/latest/html/libraries/base/Prelude.html#v:fmap"><span style="font-weight: bold;">fmap</span></a> <span style="color: green;">&#40;</span>$w<span style="color: green;">&#41;</span> <span style="color: green;">&#40;</span><a href="../../../../haskell/category-extras/dist/doc/html/category-extras/Control-Comonad.html#v:extend"><span style="font-weight: bold;">extend</span></a> <span style="color: green;">&#40;</span><a href="http://haskell.org/ghc/docs/latest/html/libraries/base/Prelude.html#v:flip"><span style="font-weight: bold;">flip</span></a> <a href="../../../../haskell/category-extras/dist/doc/html/category-extras/Control-Comonad.html#v:extract"><span style="font-weight: bold;">extract</span></a><span style="color: green;">&#41;</span> r<span style="color: green;">&#41;</span> = <span style="color: #5d478b; font-style: italic;">-- extend fmap fusion</span>
<a href="../../../../haskell/category-extras/dist/doc/html/category-extras/Control-Comonad.html#v:extend"><span style="font-weight: bold;">extend</span></a> <span style="color: green;">&#40;</span><span style="color: green;">&#40;</span>$w<span style="color: green;">&#41;</span> . <a href="http://haskell.org/ghc/docs/latest/html/libraries/base/Prelude.html#v:flip"><span style="font-weight: bold;">flip</span></a> <a href="../../../../haskell/category-extras/dist/doc/html/category-extras/Control-Comonad.html#v:extract"><span style="font-weight: bold;">extract</span></a><span style="color: green;">&#41;</span> r = <span style="color: #5d478b; font-style: italic;">-- @unpl</span>
<a href="../../../../haskell/category-extras/dist/doc/html/category-extras/Control-Comonad.html#v:extend"><span style="font-weight: bold;">extend</span></a> <span style="color: green;">&#40;</span>\t -&gt; <a href="http://haskell.org/ghc/docs/latest/html/libraries/base/Prelude.html#v:flip"><span style="font-weight: bold;">flip</span></a> <a href="../../../../haskell/category-extras/dist/doc/html/category-extras/Control-Comonad.html#v:extract"><span style="font-weight: bold;">extract</span></a> t w<span style="color: green;">&#41;</span> r = <span style="color: #5d478b; font-style: italic;">-- flip . flip = id</span>
<a href="../../../../haskell/category-extras/dist/doc/html/category-extras/Control-Comonad.html#v:extend"><span style="font-weight: bold;">extend</span></a> <span style="color: green;">&#40;</span><a href="../../../../haskell/category-extras/dist/doc/html/category-extras/Control-Comonad.html#v:extract"><span style="font-weight: bold;">extract</span></a> w<span style="color: green;">&#41;</span> r = <span style="color: #5d478b; font-style: italic;">-- by fstD def</span>
fstD <span style="color: green;">&#40;</span>D w r<span style="color: green;">&#41;</span>
&nbsp;</pre>
<p>But we stall when we try to show <code>fstD . braid = sndD</code>.</p>
<p>Why is that?</p>
<p><strong>A Product of an Imperfect Union</strong></p>
<p><a href="../../../2011/more-on-comonads-as-monad-transformers/index.html">Last time</a>, when we inspected <code>CoT w m a</code> we demonstrated that on one hand given a suitable adjunction <code>f -| g</code>, such that <code>w = f . g</code>, <code>Co w ~ Co (f . g) ~ (g . f)</code>, but on the other <code>CoT w m a</code> was bigger than <code>g . m . f</code>, and that if n -| m, then <code>CoT w m a ~ g . m . n . f</code>. </p>
<p>Of course, these two results agree, if you view <code>Co w</code> as <code>CoT w Identity</code>, where <code>Identity -| Identity</code>, since <code>Identity ~ Identity . Identity</code></p>
<p>Therefore it should come as no surprise that given <code>w = f . g</code>, for a suitable adjunction <code>f -| g</code>, then <code>D w j a</code> is bigger than <code>f . j . g</code>. In fact if, <code>j -| k</code>, then <code>D w j ~ f . j . k . g</code>.</p>
<p>So what is happening is that we have only managed to "break one of our comonads in half", and <code>D w j a</code> lets you do 'too much stuff' with the <code>j</code> portion of the comonad. This keeps us from being symmetric.</p>
<p>Moreover it turns out to be a bit trickier to build one than to just hand in a <code>w (f a)</code> or <code>w a</code> and an <code>f a</code> to build our product-like construction.</p>
<p>Even so, exploiting Density <em>was</em> enough to transform any comonad into a comonad-transformer and to enable us to access the properties of either the comonad we are transforming with, or the comonad that we are transforming.</p>
]]></content:encoded>
			<wfw:commentRss>http://comonad.com/reader/2011/a-product-of-an-imperfect-union/feed/</wfw:commentRss>
		<slash:comments>0</slash:comments>
		</item>
		<item>
		<title>More on Comonads as Monad Transformers</title>
		<link>http://comonad.com/reader/2011/more-on-comonads-as-monad-transformers/</link>
		<comments>http://comonad.com/reader/2011/more-on-comonads-as-monad-transformers/#comments</comments>
		<pubDate>Thu, 30 Jun 2011 19:15:22 +0000</pubDate>
		<dc:creator>Edward Kmett</dc:creator>
				<category><![CDATA[Category Theory]]></category>
		<category><![CDATA[Comonads]]></category>
		<category><![CDATA[Haskell]]></category>
		<category><![CDATA[Kan Extensions]]></category>
		<category><![CDATA[Monads]]></category>

		<guid isPermaLink="false">http://comonad.com/reader/?p=328</guid>
		<description><![CDATA[Last time in Monad Transformers from Comonads I showed that given any comonad we can derive the monad-transformer
&#160;
newtype CoT w m a = CoT &#123; runCoT :: w &#40;a -&#62; m r&#41; -&#62; m r
&#160;
and so demonstrated that there are fewer comonads than monads in Haskell, because while every Comonad gives rise to a Monad [...]]]></description>
			<content:encoded><![CDATA[<p>Last time in <a href="../../../2011/monad-transformers-from-comonads/index.html">Monad Transformers from Comonads</a> I showed that given any comonad we can derive the monad-transformer</p>
<pre class="haskell">&nbsp;
<span style="color: #06c; font-weight: bold;">newtype</span> CoT w m a = CoT <span style="color: green;">&#123;</span> runCoT :: w <span style="color: green;">&#40;</span>a -&gt; m r<span style="color: green;">&#41;</span> -&gt; m r
&nbsp;</pre>
<p>and so demonstrated that there are fewer comonads than monads in Haskell, because while every Comonad gives rise to a Monad transformer, there are Monads that do not like <code>IO</code>, <code>ST s</code>, and <code>STM</code>.</p>
<p>I want to elaborate a bit more on this topic.</p>
<p><span id="more-328"></span></p>
<p>In <a href="../../../2011/monads-from-comonads/index.html">Monads from Comonads</a> we observed that for non-transformer version of <code>CoT</code></p>
<pre class="haskell">&nbsp;
<span style="color: #06c; font-weight: bold;">type</span> Co w = CoT w Identity
&nbsp;</pre>
<p>under the assumption that <code>w = f . g</code> for <code>f -| g : Hask -> Hask</code>, then </p>
<pre class="haskell">&nbsp;
Co w ~ Co <span style="color: green;">&#40;</span>f . g<span style="color: green;">&#41;</span> ~ g . f
&nbsp;</pre>
<p>This demonstrated that the <code>Co w</code> is isomorphic to the monad we obtain by composing the adjunction that gave rise to our comonad the other way around.</p>
<p>But what about <code>CoT</code>?</p>
<p>Sadly <code>CoT</code> is a bit bigger.</p>
<p>We can see by first starting to apply the same treatment that we gave <code>Co</code>.</p>
<pre class="haskell">&nbsp;
CoT w m a ~ <span style="color: #06c; font-weight: bold;">forall</span> r. w <span style="color: green;">&#40;</span>a -&gt; m r<span style="color: green;">&#41;</span> -&gt; m r
          ~ <span style="color: #06c; font-weight: bold;">forall</span> r. f <span style="color: green;">&#40;</span>g <span style="color: green;">&#40;</span>a -&gt; m r<span style="color: green;">&#41;</span><span style="color: green;">&#41;</span> -&gt; m r
          ~ <span style="color: #06c; font-weight: bold;">forall</span> r. f <span style="color: green;">&#40;</span>f<span style="color: green;">&#40;</span><span style="color: green;">&#41;</span> -&gt; a -&gt; m r<span style="color: green;">&#41;</span> -&gt; m r
          ~ <span style="color: #06c; font-weight: bold;">forall</span> r. f <span style="color: green;">&#40;</span>a -&gt; f <span style="color: green;">&#40;</span><span style="color: green;">&#41;</span> -&gt; m r<span style="color: green;">&#41;</span> -&gt; m r
          ~ <span style="color: #06c; font-weight: bold;">forall</span> r. <span style="color: green;">&#40;</span>a -&gt; f <span style="color: green;">&#40;</span><span style="color: green;">&#41;</span> -&gt; m r, f <span style="color: green;">&#40;</span><span style="color: green;">&#41;</span><span style="color: green;">&#41;</span> -&gt; m r
          ~ <span style="color: #06c; font-weight: bold;">forall</span> r. <span style="color: green;">&#40;</span>a -&gt; f <span style="color: green;">&#40;</span><span style="color: green;">&#41;</span> -&gt; m r<span style="color: green;">&#41;</span> -&gt; f <span style="color: green;">&#40;</span><span style="color: green;">&#41;</span> -&gt; m r
          ~ <span style="color: #06c; font-weight: bold;">forall</span> r. <span style="color: green;">&#40;</span>a -&gt; g <span style="color: green;">&#40;</span>m r<span style="color: green;">&#41;</span><span style="color: green;">&#41;</span> -&gt; g <span style="color: green;">&#40;</span>m r<span style="color: green;">&#41;</span>
          ~ Codensity <span style="color: green;">&#40;</span>g . m<span style="color: green;">&#41;</span> a
&nbsp;</pre>
<p>(I'm using <code>.</code> to represent <code>Compose</code> for readability.)</p>
<p>But we've seen before that <code>Codensity g a</code> is in a sense bigger than <code>g a</code>, since given an Adjunction <code>f -| g</code>, <code>Codensity g a ~ (g . f) a</code>, <strong>not</strong> <code>g a</code>.</p>
<p>Moreover can compose adjunctions:</p>
<pre class="haskell">&nbsp;
<span style="color: #06c; font-weight: bold;">instance</span>
    <span style="color: green;">&#40;</span><a href="../../../../haskell/category-extras/dist/doc/html/category-extras/Control-Functor-Adjunction.html#t:Adjunction"><span style="background-color: #efefbf; font-weight: bold;">Adjunction</span></a> f g, <a href="../../../../haskell/category-extras/dist/doc/html/category-extras/Control-Functor-Adjunction.html#t:Adjunction"><span style="background-color: #efefbf; font-weight: bold;">Adjunction</span></a> f' g'<span style="color: green;">&#41;</span> =&gt;
    <a href="../../../../haskell/category-extras/dist/doc/html/category-extras/Control-Functor-Adjunction.html#t:Adjunction"><span style="background-color: #efefbf; font-weight: bold;">Adjunction</span></a> <span style="color: green;">&#40;</span>Compose f' f<span style="color: green;">&#41;</span> <span style="color: green;">&#40;</span>Compose g g'<span style="color: green;">&#41;</span> <span style="color: #06c; font-weight: bold;">where</span>
  <a href="../../../../haskell/category-extras/dist/doc/html/category-extras/Control-Functor-Adjunction.html#v:unit"><span style="font-weight: bold;">unit</span></a>   = Compose . <a href="../../../../haskell/category-extras/dist/doc/html/category-extras/Control-Functor-Adjunction.html#v:leftAdjunct"><span style="font-weight: bold;">leftAdjunct</span></a> <span style="color: green;">&#40;</span><a href="../../../../haskell/category-extras/dist/doc/html/category-extras/Control-Functor-Adjunction.html#v:leftAdjunct"><span style="font-weight: bold;">leftAdjunct</span></a> Compose<span style="color: green;">&#41;</span>
  <a href="../../../../haskell/category-extras/dist/doc/html/category-extras/Control-Functor-Adjunction.html#v:counit"><span style="font-weight: bold;">counit</span></a> = <a href="../../../../haskell/category-extras/dist/doc/html/category-extras/Control-Functor-Adjunction.html#v:rightAdjunct"><span style="font-weight: bold;">rightAdjunct</span></a> <span style="color: green;">&#40;</span><a href="../../../../haskell/category-extras/dist/doc/html/category-extras/Control-Functor-Adjunction.html#v:rightAdjunct"><span style="font-weight: bold;">rightAdjunct</span></a> getCompose<span style="color: green;">&#41;</span> . getCompose
&nbsp;</pre>
<p>So if <code>n -| m</code>, then we can see that <code>Codensity (g . m) a ~ g . m . n . f</code>, rather than the smaller <code>g . m . f</code>, which we can obtain using  <code>AdjointT f g m</code> from <a href="http://hackage.haskell.org/packages/archive/adjunctions/1.8.0/doc/html/Control-Monad-Trans-Adjoint.html">Control.Monad.Trans.Adjoint</a> in <a href="http://hackage.haskell.org/package/adjunctions">adjunctions</a>.</p>
<p>So <code>CoT</code> isn't the smallest monad transformer that would be given by an adjunction. </p>
<p>In fact, it is isomorphic to <code>AdjointT f g (Codensity m) a</code> instead of <code>AdjointT f g m a</code>.</p>
<p>Sadly, there doesn't appear to be a general purpose construction of the smaller transformer just given an unseparated <code>w = f . g</code>.</p>
]]></content:encoded>
			<wfw:commentRss>http://comonad.com/reader/2011/more-on-comonads-as-monad-transformers/feed/</wfw:commentRss>
		<slash:comments>3</slash:comments>
		</item>
		<item>
		<title>Monad Transformers from Comonads</title>
		<link>http://comonad.com/reader/2011/monad-transformers-from-comonads/</link>
		<comments>http://comonad.com/reader/2011/monad-transformers-from-comonads/#comments</comments>
		<pubDate>Wed, 29 Jun 2011 01:51:43 +0000</pubDate>
		<dc:creator>Edward Kmett</dc:creator>
				<category><![CDATA[Category Theory]]></category>
		<category><![CDATA[Comonads]]></category>
		<category><![CDATA[Data Structures]]></category>
		<category><![CDATA[Haskell]]></category>
		<category><![CDATA[Kan Extensions]]></category>
		<category><![CDATA[Monads]]></category>

		<guid isPermaLink="false">http://comonad.com/reader/?p=321</guid>
		<description><![CDATA[Last time, I showed that we can transform any Comonad in Haskell into a Monad in Haskell.
Today, I'll show that we can go one step further and derive a monad transformer from any comonad! 

A Comonad to Monad-Transformer Transformer
Given
&#160;
newtype CoT w m a = CoT &#123; runCoT :: forall r. w &#40;a -&#62; m r&#41; [...]]]></description>
			<content:encoded><![CDATA[<p><a href="../../../2011/monads-from-comonads/index.html">Last time</a>, I showed that we can transform any Comonad in Haskell into a Monad in Haskell.</p>
<p>Today, I'll show that we can go one step further and derive a monad transformer from any comonad! </p>
<p><span id="more-321"></span></p>
<p><strong>A Comonad to Monad-Transformer Transformer</strong></p>
<p>Given</p>
<pre class="haskell">&nbsp;
<span style="color: #06c; font-weight: bold;">newtype</span> CoT w m a = CoT <span style="color: green;">&#123;</span> runCoT :: <span style="color: #06c; font-weight: bold;">forall</span> r. w <span style="color: green;">&#40;</span>a -&gt; m r<span style="color: green;">&#41;</span> -&gt; m r <span style="color: green;">&#125;</span>
&nbsp;</pre>
<p>we can easily embed the type of the previous <code>Co</code> and create a smart constructor and deconstructor in the style of the MTL.</p>
<pre class="haskell">&nbsp;
<span style="color: #06c; font-weight: bold;">type</span> Co w = CoT w Identity
&nbsp;
co :: <a href="http://haskell.org/ghc/docs/latest/html/libraries/base/Prelude.html#t:Functor"><span style="background-color: #efefbf; font-weight: bold;">Functor</span></a> w =&gt; <span style="color: green;">&#40;</span><span style="color: #06c; font-weight: bold;">forall</span> r. w <span style="color: green;">&#40;</span>a -&gt; r<span style="color: green;">&#41;</span> -&gt; r<span style="color: green;">&#41;</span> -&gt; Co w a
co f = CoT <span style="color: green;">&#40;</span>Identity . f . <a href="http://haskell.org/ghc/docs/latest/html/libraries/base/Prelude.html#v:fmap"><span style="font-weight: bold;">fmap</span></a> <span style="color: green;">&#40;</span><a href="http://haskell.org/ghc/docs/latest/html/libraries/base/Prelude.html#v:fmap"><span style="font-weight: bold;">fmap</span></a> runIdentity<span style="color: green;">&#41;</span><span style="color: green;">&#41;</span>
&nbsp;
runCo :: <a href="http://haskell.org/ghc/docs/latest/html/libraries/base/Prelude.html#t:Functor"><span style="background-color: #efefbf; font-weight: bold;">Functor</span></a> w =&gt; Co w a -&gt; w <span style="color: green;">&#40;</span>a -&gt; r<span style="color: green;">&#41;</span> -&gt; r
runCo m = runIdentity . runCoT m . <a href="http://haskell.org/ghc/docs/latest/html/libraries/base/Prelude.html#v:fmap"><span style="font-weight: bold;">fmap</span></a> <span style="color: green;">&#40;</span><a href="http://haskell.org/ghc/docs/latest/html/libraries/base/Prelude.html#v:fmap"><span style="font-weight: bold;">fmap</span></a> Identity<span style="color: green;">&#41;</span>
&nbsp;</pre>
<p>In fact, as with between Cont and ContT, none of the major instances even change!</p>
<pre class="haskell">&nbsp;
<span style="color: #06c; font-weight: bold;">instance</span> <a href="http://haskell.org/ghc/docs/latest/html/libraries/base/Prelude.html#t:Functor"><span style="background-color: #efefbf; font-weight: bold;">Functor</span></a> w =&gt; <a href="http://haskell.org/ghc/docs/latest/html/libraries/base/Prelude.html#t:Functor"><span style="background-color: #efefbf; font-weight: bold;">Functor</span></a> <span style="color: green;">&#40;</span>CoT w m<span style="color: green;">&#41;</span> <span style="color: #06c; font-weight: bold;">where</span>
  <a href="http://haskell.org/ghc/docs/latest/html/libraries/base/Prelude.html#v:fmap"><span style="font-weight: bold;">fmap</span></a> f <span style="color: green;">&#40;</span>CoT w<span style="color: green;">&#41;</span> = CoT <span style="color: green;">&#40;</span>w . <a href="http://haskell.org/ghc/docs/latest/html/libraries/base/Prelude.html#v:fmap"><span style="font-weight: bold;">fmap</span></a> <span style="color: green;">&#40;</span>. f<span style="color: green;">&#41;</span><span style="color: green;">&#41;</span>
&nbsp;
<span style="color: #06c; font-weight: bold;">instance</span> Extend w =&gt; Apply <span style="color: green;">&#40;</span>CoT w m<span style="color: green;">&#41;</span> <span style="color: #06c; font-weight: bold;">where</span>
  mf &lt; .&gt; ma = mf &gt;&gt;- \f -&gt; <a href="http://haskell.org/ghc/docs/latest/html/libraries/base/Prelude.html#v:fmap"><span style="font-weight: bold;">fmap</span></a> f ma
&nbsp;
<span style="color: #06c; font-weight: bold;">instance</span> Extend w =&gt; Bind <span style="color: green;">&#40;</span>CoT w m<span style="color: green;">&#41;</span> <span style="color: #06c; font-weight: bold;">where</span>
  CoT k &gt;&gt;- f = CoT <span style="color: green;">&#40;</span>k . <a href="../../../../haskell/category-extras/dist/doc/html/category-extras/Control-Comonad.html#v:extend"><span style="font-weight: bold;">extend</span></a> <span style="color: green;">&#40;</span>\wa a -&gt; runCoT <span style="color: green;">&#40;</span>f a<span style="color: green;">&#41;</span> wa<span style="color: green;">&#41;</span><span style="color: green;">&#41;</span>
&nbsp;
<span style="color: #06c; font-weight: bold;">instance</span> <a href="../../../../haskell/category-extras/dist/doc/html/category-extras/Control-Comonad.html#t:Comonad"><span style="background-color: #efefbf; font-weight: bold;">Comonad</span></a> w =&gt; Applicative <span style="color: green;">&#40;</span>CoT w m<span style="color: green;">&#41;</span> <span style="color: #06c; font-weight: bold;">where</span>
  pure a = CoT <span style="color: green;">&#40;</span>`<a href="../../../../haskell/category-extras/dist/doc/html/category-extras/Control-Comonad.html#v:extract"><span style="font-weight: bold;">extract</span></a>` a<span style="color: green;">&#41;</span>
  mf &lt; *&gt; ma = mf &gt;&gt;= \f -&gt; <a href="http://haskell.org/ghc/docs/latest/html/libraries/base/Prelude.html#v:fmap"><span style="font-weight: bold;">fmap</span></a> f ma
&nbsp;
<span style="color: #06c; font-weight: bold;">instance</span> <a href="../../../../haskell/category-extras/dist/doc/html/category-extras/Control-Comonad.html#t:Comonad"><span style="background-color: #efefbf; font-weight: bold;">Comonad</span></a> w =&gt; <a href="http://haskell.org/ghc/docs/latest/html/libraries/base/Prelude.html#t:Monad"><span style="background-color: #efefbf; font-weight: bold;">Monad</span></a> <span style="color: green;">&#40;</span>CoT w m<span style="color: green;">&#41;</span> <span style="color: #06c; font-weight: bold;">where</span>
  <a href="http://haskell.org/ghc/docs/latest/html/libraries/base/Prelude.html#v:return"><span style="font-weight: bold;">return</span></a> a = CoT <span style="color: green;">&#40;</span>`<a href="../../../../haskell/category-extras/dist/doc/html/category-extras/Control-Comonad.html#v:extract"><span style="font-weight: bold;">extract</span></a>` a<span style="color: green;">&#41;</span>
  CoT k &gt;&gt;= f = CoT <span style="color: green;">&#40;</span>k . <a href="../../../../haskell/category-extras/dist/doc/html/category-extras/Control-Comonad.html#v:extend"><span style="font-weight: bold;">extend</span></a> <span style="color: green;">&#40;</span>\wa a -&gt; runCoT <span style="color: green;">&#40;</span>f a<span style="color: green;">&#41;</span> wa<span style="color: green;">&#41;</span><span style="color: green;">&#41;</span>
&nbsp;</pre>
<p>We can use CoT as a Monad transformer, or lift IO actions:</p>
<pre class="haskell">&nbsp;
<span style="color: #06c; font-weight: bold;">instance</span> <a href="../../../../haskell/category-extras/dist/doc/html/category-extras/Control-Comonad.html#t:Comonad"><span style="background-color: #efefbf; font-weight: bold;">Comonad</span></a> w =&gt; MonadTrans <span style="color: green;">&#40;</span>CoT w<span style="color: green;">&#41;</span> <span style="color: #06c; font-weight: bold;">where</span>
  lift m = CoT <span style="color: green;">&#40;</span><a href="../../../../haskell/category-extras/dist/doc/html/category-extras/Control-Comonad.html#v:extract"><span style="font-weight: bold;">extract</span></a> . <a href="http://haskell.org/ghc/docs/latest/html/libraries/base/Prelude.html#v:fmap"><span style="font-weight: bold;">fmap</span></a> <span style="color: green;">&#40;</span>m &gt;&gt;=<span style="color: green;">&#41;</span><span style="color: green;">&#41;</span>
&nbsp;
<span style="color: #06c; font-weight: bold;">instance</span> <span style="color: green;">&#40;</span><a href="../../../../haskell/category-extras/dist/doc/html/category-extras/Control-Comonad.html#t:Comonad"><span style="background-color: #efefbf; font-weight: bold;">Comonad</span></a> w, MonadIO m<span style="color: green;">&#41;</span> =&gt; MonadIO <span style="color: green;">&#40;</span>CoT w m<span style="color: green;">&#41;</span> <span style="color: #06c; font-weight: bold;">where</span>
  liftIO = lift . liftIO
&nbsp;</pre>
<p>(This monad transformer is available in my <a href="http://hackage.haskell.org/package/kan-extensions">kan-extensions</a> package as of 1.9.0 on hackage.)</p>
<p>And as before we can lift and lower CoKleisli arrows, although the results are monadic when lowered.</p>
<pre class="haskell">&nbsp;
liftCoT0 :: <a href="../../../../haskell/category-extras/dist/doc/html/category-extras/Control-Comonad.html#t:Comonad"><span style="background-color: #efefbf; font-weight: bold;">Comonad</span></a> w =&gt; <span style="color: green;">&#40;</span><span style="color: #06c; font-weight: bold;">forall</span> a. w a -&gt; s<span style="color: green;">&#41;</span> -&gt; CoT w m s
liftCoT0 f = CoT <span style="color: green;">&#40;</span><a href="../../../../haskell/category-extras/dist/doc/html/category-extras/Control-Comonad.html#v:extract"><span style="font-weight: bold;">extract</span></a> &lt; *&gt; f<span style="color: green;">&#41;</span>
&nbsp;
lowerCoT0 :: <span style="color: green;">&#40;</span><a href="http://haskell.org/ghc/docs/latest/html/libraries/base/Prelude.html#t:Functor"><span style="background-color: #efefbf; font-weight: bold;">Functor</span></a> w, <a href="http://haskell.org/ghc/docs/latest/html/libraries/base/Prelude.html#t:Monad"><span style="background-color: #efefbf; font-weight: bold;">Monad</span></a> m<span style="color: green;">&#41;</span> =&gt; CoT w m s -&gt; w a -&gt; m s
lowerCoT0 m = runCoT m . <span style="color: green;">&#40;</span><a href="http://haskell.org/ghc/docs/latest/html/libraries/base/Prelude.html#v:return"><span style="font-weight: bold;">return</span></a> &lt; $<span style="color: green;">&#41;</span>
&nbsp;
lowerCo0 :: <a href="http://haskell.org/ghc/docs/latest/html/libraries/base/Prelude.html#t:Functor"><span style="background-color: #efefbf; font-weight: bold;">Functor</span></a> w =&gt; Co w s -&gt; w a -&gt; s
lowerCo0 m = runIdentity . runCoT m . <span style="color: green;">&#40;</span><a href="http://haskell.org/ghc/docs/latest/html/libraries/base/Prelude.html#v:return"><span style="font-weight: bold;">return</span></a> &lt; $<span style="color: green;">&#41;</span>
&nbsp;
liftCoT1 :: <span style="color: green;">&#40;</span><span style="color: #06c; font-weight: bold;">forall</span> a. w a -&gt; a<span style="color: green;">&#41;</span> -&gt; CoT w m <span style="color: green;">&#40;</span><span style="color: green;">&#41;</span>
liftCoT1 f = CoT <span style="color: green;">&#40;</span>`f` <span style="color: green;">&#40;</span><span style="color: green;">&#41;</span><span style="color: green;">&#41;</span>
&nbsp;
lowerCoT1 :: <span style="color: green;">&#40;</span><a href="http://haskell.org/ghc/docs/latest/html/libraries/base/Prelude.html#t:Functor"><span style="background-color: #efefbf; font-weight: bold;">Functor</span></a> w, <a href="http://haskell.org/ghc/docs/latest/html/libraries/base/Prelude.html#t:Monad"><span style="background-color: #efefbf; font-weight: bold;">Monad</span></a> m<span style="color: green;">&#41;</span> =&gt; CoT w m <span style="color: green;">&#40;</span><span style="color: green;">&#41;</span> -&gt; w a -&gt; m a
lowerCoT1 m = runCoT m . <a href="http://haskell.org/ghc/docs/latest/html/libraries/base/Prelude.html#v:fmap"><span style="font-weight: bold;">fmap</span></a> <span style="color: green;">&#40;</span><a href="http://haskell.org/ghc/docs/latest/html/libraries/base/Prelude.html#v:const"><span style="font-weight: bold;">const</span></a> . <a href="http://haskell.org/ghc/docs/latest/html/libraries/base/Prelude.html#v:return"><span style="font-weight: bold;">return</span></a><span style="color: green;">&#41;</span>
&nbsp;
lowerCo1 :: <a href="http://haskell.org/ghc/docs/latest/html/libraries/base/Prelude.html#t:Functor"><span style="background-color: #efefbf; font-weight: bold;">Functor</span></a> w =&gt; Co w <span style="color: green;">&#40;</span><span style="color: green;">&#41;</span> -&gt; w a -&gt; a
lowerCo1 m = runIdentity . runCoT m . <a href="http://haskell.org/ghc/docs/latest/html/libraries/base/Prelude.html#v:fmap"><span style="font-weight: bold;">fmap</span></a> <span style="color: green;">&#40;</span><a href="http://haskell.org/ghc/docs/latest/html/libraries/base/Prelude.html#v:const"><span style="font-weight: bold;">const</span></a> . <a href="http://haskell.org/ghc/docs/latest/html/libraries/base/Prelude.html#v:return"><span style="font-weight: bold;">return</span></a><span style="color: green;">&#41;</span>
&nbsp;</pre>
<p>Since we could mean the MonadFoo instance derived from its comonadic equivalent or from the one we wrap as a monad transformer, we choose to default to the one from the monad, but we can still provide the lifted comonadic actions:</p>
<pre class="haskell">&nbsp;
posW :: <span style="color: green;">&#40;</span>ComonadStore s w, <a href="http://haskell.org/ghc/docs/latest/html/libraries/base/Prelude.html#t:Monad"><span style="background-color: #efefbf; font-weight: bold;">Monad</span></a> m<span style="color: green;">&#41;</span> =&gt; CoT w m s
posW = liftCoT0 pos
&nbsp;
peekW :: <span style="color: green;">&#40;</span>ComonadStore s w, <a href="http://haskell.org/ghc/docs/latest/html/libraries/base/Prelude.html#t:Monad"><span style="background-color: #efefbf; font-weight: bold;">Monad</span></a> m<span style="color: green;">&#41;</span> =&gt; s -&gt; CoT w m <span style="color: green;">&#40;</span><span style="color: green;">&#41;</span>
peekW s = liftCoT1 <span style="color: green;">&#40;</span>peek s<span style="color: green;">&#41;</span>
&nbsp;
peeksW :: <span style="color: green;">&#40;</span>ComonadStore s w, <a href="http://haskell.org/ghc/docs/latest/html/libraries/base/Prelude.html#t:Monad"><span style="background-color: #efefbf; font-weight: bold;">Monad</span></a> m<span style="color: green;">&#41;</span> =&gt; <span style="color: green;">&#40;</span>s -&gt; s<span style="color: green;">&#41;</span> -&gt; CoT w m <span style="color: green;">&#40;</span><span style="color: green;">&#41;</span>
peeksW f = liftCoT1 <span style="color: green;">&#40;</span>peeks f<span style="color: green;">&#41;</span>
&nbsp;
askW :: <span style="color: green;">&#40;</span>ComonadEnv e w, <a href="http://haskell.org/ghc/docs/latest/html/libraries/base/Prelude.html#t:Monad"><span style="background-color: #efefbf; font-weight: bold;">Monad</span></a> m<span style="color: green;">&#41;</span> =&gt; CoT w m e
askW = liftCoT0 <span style="color: green;">&#40;</span>Env.ask<span style="color: green;">&#41;</span>
&nbsp;
asksW :: <span style="color: green;">&#40;</span>ComonadEnv e w, <a href="http://haskell.org/ghc/docs/latest/html/libraries/base/Prelude.html#t:Monad"><span style="background-color: #efefbf; font-weight: bold;">Monad</span></a> m<span style="color: green;">&#41;</span> =&gt; <span style="color: green;">&#40;</span>e -&gt; a<span style="color: green;">&#41;</span> -&gt; CoT w m a
asksW f = liftCoT0 <span style="color: green;">&#40;</span>Env.asks f<span style="color: green;">&#41;</span>
&nbsp;
traceW :: <span style="color: green;">&#40;</span>ComonadTraced e w, <a href="http://haskell.org/ghc/docs/latest/html/libraries/base/Prelude.html#t:Monad"><span style="background-color: #efefbf; font-weight: bold;">Monad</span></a> m<span style="color: green;">&#41;</span> =&gt; e -&gt; CoT w m <span style="color: green;">&#40;</span><span style="color: green;">&#41;</span>
traceW e = liftCoT1 <span style="color: green;">&#40;</span>Traced.trace e<span style="color: green;">&#41;</span>
&nbsp;</pre>
<p>and we just lift the monadic actions as usual:</p>
<pre class="haskell">&nbsp;
<span style="color: #06c; font-weight: bold;">instance</span> <span style="color: green;">&#40;</span><a href="../../../../haskell/category-extras/dist/doc/html/category-extras/Control-Comonad.html#t:Comonad"><span style="background-color: #efefbf; font-weight: bold;">Comonad</span></a> w, MonadReader e m<span style="color: green;">&#41;</span> =&gt; MonadReader e <span style="color: green;">&#40;</span>CoT w m<span style="color: green;">&#41;</span> <span style="color: #06c; font-weight: bold;">where</span>
  ask = lift Reader.ask
  local f m = CoT <span style="color: green;">&#40;</span>local f . runCoT m<span style="color: green;">&#41;</span>
&nbsp;
<span style="color: #06c; font-weight: bold;">instance</span> <span style="color: green;">&#40;</span><a href="../../../../haskell/category-extras/dist/doc/html/category-extras/Control-Comonad.html#t:Comonad"><span style="background-color: #efefbf; font-weight: bold;">Comonad</span></a> w, MonadState s m<span style="color: green;">&#41;</span> =&gt; MonadState s <span style="color: green;">&#40;</span>CoT w m<span style="color: green;">&#41;</span> <span style="color: #06c; font-weight: bold;">where</span>
  get = lift get
  put = lift . put
&nbsp;
<span style="color: #06c; font-weight: bold;">instance</span> <span style="color: green;">&#40;</span><a href="../../../../haskell/category-extras/dist/doc/html/category-extras/Control-Comonad.html#t:Comonad"><span style="background-color: #efefbf; font-weight: bold;">Comonad</span></a> w, MonadWriter e m<span style="color: green;">&#41;</span> =&gt; MonadWriter e <span style="color: green;">&#40;</span>CoT w m<span style="color: green;">&#41;</span> <span style="color: #06c; font-weight: bold;">where</span>
  tell = lift . tell
  pass m = CoT <span style="color: green;">&#40;</span>pass . runCoT m . <a href="http://haskell.org/ghc/docs/latest/html/libraries/base/Prelude.html#v:fmap"><span style="font-weight: bold;">fmap</span></a> aug<span style="color: green;">&#41;</span> <span style="color: #06c; font-weight: bold;">where</span>
    aug f <span style="color: green;">&#40;</span>a,e<span style="color: green;">&#41;</span> = liftM <span style="color: green;">&#40;</span>\r -&gt; <span style="color: green;">&#40;</span>r,e<span style="color: green;">&#41;</span><span style="color: green;">&#41;</span> <span style="color: green;">&#40;</span>f a<span style="color: green;">&#41;</span>
  listen = <a href="http://haskell.org/ghc/docs/latest/html/libraries/base/Prelude.html#v:error"><span style="font-weight: bold;">error</span></a> <span style="color: #3c7331;">&quot;Control.Monad.Co.listen: TODO&quot;</span>
&nbsp;
<span style="color: #06c; font-weight: bold;">instance</span> <span style="color: green;">&#40;</span><a href="../../../../haskell/category-extras/dist/doc/html/category-extras/Control-Comonad.html#t:Comonad"><span style="background-color: #efefbf; font-weight: bold;">Comonad</span></a> w, MonadError e m<span style="color: green;">&#41;</span> =&gt; MonadError e <span style="color: green;">&#40;</span>CoT w m<span style="color: green;">&#41;</span> <span style="color: #06c; font-weight: bold;">where</span>
  throwError = lift . throwError
  catchError = <a href="http://haskell.org/ghc/docs/latest/html/libraries/base/Prelude.html#v:error"><span style="font-weight: bold;">error</span></a> <span style="color: #3c7331;">&quot;Control.Monad.Co.catchError: TODO&quot;</span>
&nbsp;
<span style="color: #06c; font-weight: bold;">instance</span> <span style="color: green;">&#40;</span><a href="../../../../haskell/category-extras/dist/doc/html/category-extras/Control-Comonad.html#t:Comonad"><span style="background-color: #efefbf; font-weight: bold;">Comonad</span></a> w, MonadCont m<span style="color: green;">&#41;</span> =&gt; MonadCont <span style="color: green;">&#40;</span>CoT w m<span style="color: green;">&#41;</span> <span style="color: #06c; font-weight: bold;">where</span>
  callCC = <a href="http://haskell.org/ghc/docs/latest/html/libraries/base/Prelude.html#v:error"><span style="font-weight: bold;">error</span></a> <span style="color: #3c7331;">&quot;Control.Monad.Co.callCC: TODO&quot;</span>
&nbsp;</pre>
<p>I welcome help working through the missing methods above.</p>
<p>This should go a long way towards showing the fact that there are strictly fewer comonads than monads in Haskell, and of course that there are no analogues to IO, STM and ST s in the world of Haskell comonads!</p>
<p>Every comonad gives you a monad-transformer, but not every monad is a monad transformer.</p>
]]></content:encoded>
			<wfw:commentRss>http://comonad.com/reader/2011/monad-transformers-from-comonads/feed/</wfw:commentRss>
		<slash:comments>1</slash:comments>
		</item>
		<item>
		<title>Monads from Comonads</title>
		<link>http://comonad.com/reader/2011/monads-from-comonads/</link>
		<comments>http://comonad.com/reader/2011/monads-from-comonads/#comments</comments>
		<pubDate>Mon, 27 Jun 2011 20:50:32 +0000</pubDate>
		<dc:creator>Edward Kmett</dc:creator>
				<category><![CDATA[Category Theory]]></category>
		<category><![CDATA[Comonads]]></category>
		<category><![CDATA[Haskell]]></category>
		<category><![CDATA[Kan Extensions]]></category>
		<category><![CDATA[Mathematics]]></category>
		<category><![CDATA[Monads]]></category>

		<guid isPermaLink="false">http://comonad.com/reader/?p=291</guid>
		<description><![CDATA[Today I'll show that you can derive a Monad from any old Comonad you have lying around.

But first, we'll need to take a bit of a bit of a detour.
A Monad Sandwich
We'll need the definition of an adjunction on the category of Haskell types, which we can strip down and borrow from my adjunctions package.
&#160;
class [...]]]></description>
			<content:encoded><![CDATA[<p>Today I'll show that you can derive a <code>Monad</code> from any old <code>Comonad</code> you have lying around.</p>
<p><span id="more-291"></span></p>
<p>But first, we'll need to take a bit of a bit of a detour.</p>
<p><strong>A Monad Sandwich</strong></p>
<p>We'll need the definition of an <a href="http://en.wikipedia.org/wiki/Adjoint_functors">adjunction</a> on the category of Haskell types, which we can strip down and borrow from my <a href="http://hackage.haskell.org/package/adjunctions">adjunctions</a> package.</p>
<pre class="haskell">&nbsp;
<span style="color: #06c; font-weight: bold;">class</span> <span style="color: green;">&#40;</span><a href="http://haskell.org/ghc/docs/latest/html/libraries/base/Prelude.html#t:Functor"><span style="background-color: #efefbf; font-weight: bold;">Functor</span></a> f, Representable u<span style="color: green;">&#41;</span> =&gt;
         <a href="../../../../haskell/category-extras/dist/doc/html/category-extras/Control-Functor-Adjunction.html#t:Adjunction"><span style="background-color: #efefbf; font-weight: bold;">Adjunction</span></a> f u | f -&gt; u, u -&gt; f <span style="color: #06c; font-weight: bold;">where</span>
    <a href="../../../../haskell/category-extras/dist/doc/html/category-extras/Control-Functor-Adjunction.html#v:leftAdjunct"><span style="font-weight: bold;">leftAdjunct</span></a> :: <span style="color: green;">&#40;</span>f a -&gt; b<span style="color: green;">&#41;</span> -&gt; a -&gt; u b
    <a href="../../../../haskell/category-extras/dist/doc/html/category-extras/Control-Functor-Adjunction.html#v:rightAdjunct"><span style="font-weight: bold;">rightAdjunct</span></a> :: <span style="color: green;">&#40;</span>a -&gt; u b<span style="color: green;">&#41;</span> -&gt; f a -&gt; b
&nbsp;</pre>
<p>Here we can define our Adjunction by defining leftAdjunct and rightAdjunct, such that they witness an isomorphism from <code>(f a -> b)</code> to <code>(a -> u b)</code></p>
<p>Every <a href="http://hackage.haskell.org/packages/archive/adjunctions/1.0.0/doc/html/Data-Functor-Adjunction.html">Adjunction</a> <code>F -| G : C -> D</code>, gives rise to a monad GF on D and a Comonad FG on C.</p>
<p>In addition to this, you can sandwich an additional monad M on C in between GF to give a monad GMF on D:</p>
<p><a href="http://hackage.haskell.org/packages/archive/adjunctions/1.0.0/doc/html/Control-Monad-Trans-Adjoint.html">Control.Monad.Trans.Adjoint</a></p>
<p>and you can sandwich a comonad W on D in between F and G to yield the comonad FWG on C:</p>
<p><a href="http://hackage.haskell.org/packages/archive/adjunctions/1.0.0/doc/html/Control-Comonad-Trans-Adjoint.html">Control.Comonad.Trans.Adjoint</a></p>
<p><strong>A Contravariant Comonad Sandwich</strong></p>
<p>As was first shown to me me by Derek Elkins, this construction works even when you C is not the category of Haskell types!</p>
<p>Consider the <a href="http://hackage.haskell.org/packages/archive/contravariant/0.1.2/doc/html/Data-Functor-Contravariant.html">Contravariant</a> functor <code>Op r</code>:</p>
<pre class="haskell">&nbsp;
<span style="color: #06c; font-weight: bold;">newtype</span> Op a b = Op <span style="color: green;">&#123;</span> getOp :: b -&gt; a <span style="color: green;">&#125;</span> 
&nbsp;
<span style="color: #06c; font-weight: bold;">instance</span> Contravariant <span style="color: green;">&#40;</span>Op a<span style="color: green;">&#41;</span> <span style="color: #06c; font-weight: bold;">where</span>
  contramap f g = Op <span style="color: green;">&#40;</span>getOp g . f<span style="color: green;">&#41;</span>
&nbsp;</pre>
<p>We can view <code>Op r</code> as a functor from <code>Hask^op -> Hask</code> or as one from <code>Hask -> Hask^op</code>.</p>
<p>We can define a notion of a contravariant adjunction <code>F -| G : Hask^op -> Hask</code>.</p>
<p><a href="http://hackage.haskell.org/packages/archive/adjunctions/1.0.0/doc/html/Data-Functor-Contravariant-Adjunction.html">Data.Functor.Contravariant.Adjunction</a></p>
<pre class="haskell">&nbsp;
<span style="color: #06c; font-weight: bold;">class</span> <span style="color: green;">&#40;</span>Contravariant f, Corepresentable g<span style="color: green;">&#41;</span> =&gt;
       <a href="../../../../haskell/category-extras/dist/doc/html/category-extras/Control-Functor-Adjunction.html#t:Adjunction"><span style="background-color: #efefbf; font-weight: bold;">Adjunction</span></a> f g | f -&gt; g, g -&gt; f <span style="color: #06c; font-weight: bold;">where</span>
    <a href="../../../../haskell/category-extras/dist/doc/html/category-extras/Control-Functor-Adjunction.html#v:leftAdjunct"><span style="font-weight: bold;">leftAdjunct</span></a> :: <span style="color: green;">&#40;</span>b -&gt; f a<span style="color: green;">&#41;</span> -&gt; a -&gt; g b
    <a href="../../../../haskell/category-extras/dist/doc/html/category-extras/Control-Functor-Adjunction.html#v:rightAdjunct"><span style="font-weight: bold;">rightAdjunct</span></a> :: <span style="color: green;">&#40;</span>a -&gt; g b<span style="color: green;">&#41;</span> -&gt; b -&gt; f a
&nbsp;</pre>
<p>Where, now, <code>leftAdjunct</code> and <code>rightAdjunct</code> witness the isomorphism from <code>(f a < - b)</code> to </code><code>(a -> g b)</code>, which means once you flip the arrow around both seem to be going the same way. Ultimately any contravariant adjunction on Hask is comprised of two isomorphic functors, each self-adjoint.</p>
<p>This gives rise to one notion of a comonad-to-monad transformer!</p>
<p><a href="http://hackage.haskell.org/packages/archive/adjunctions/1.0.0/doc/html/Control-Monad-Trans-Contravariant-Adjoint.html">Control.Monad.Trans.Contravariant.Adjoint</a></p>
<p>But we can we do better?</p>
<p><strong>An End as the Means</strong></p>
<p>First, some boilerplate.</p>
<pre class="haskell">&nbsp;
<span style="color: #5d478b; font-style: italic;">{-# LANGUAGE Rank2Types, FlexibleInstances, FlexibleContexts, MultiParamTypeClasses, UndecidableInstances #-}</span>
&nbsp;
<span style="color: #06c; font-weight: bold;">import</span> Data.Monoid
<span style="color: #06c; font-weight: bold;">import</span> Control.<a href="../../../../haskell/category-extras/dist/doc/html/category-extras/Control-Comonad.html#t:Comonad"><span style="background-color: #efefbf; font-weight: bold;">Comonad</span></a>
<span style="color: #06c; font-weight: bold;">import</span> Control.Applicative
<span style="color: #06c; font-weight: bold;">import</span> Control.<a href="../../../../haskell/category-extras/dist/doc/html/category-extras/Control-Comonad.html#t:Comonad"><span style="background-color: #efefbf; font-weight: bold;">Comonad</span></a>.Store.Class
<span style="color: #06c; font-weight: bold;">import</span> Control.<a href="../../../../haskell/category-extras/dist/doc/html/category-extras/Control-Comonad.html#t:Comonad"><span style="background-color: #efefbf; font-weight: bold;">Comonad</span></a>.Env.Class <span style="color: #06c; font-weight: bold;">as</span> Env
<span style="color: #06c; font-weight: bold;">import</span> Control.<a href="../../../../haskell/category-extras/dist/doc/html/category-extras/Control-Comonad.html#t:Comonad"><span style="background-color: #efefbf; font-weight: bold;">Comonad</span></a>.Traced.Class <span style="color: #06c; font-weight: bold;">as</span> Traced
<span style="color: #06c; font-weight: bold;">import</span> Control.<a href="http://haskell.org/ghc/docs/latest/html/libraries/base/Prelude.html#t:Monad"><span style="background-color: #efefbf; font-weight: bold;">Monad</span></a>.Reader.Class
<span style="color: #06c; font-weight: bold;">import</span> Control.<a href="http://haskell.org/ghc/docs/latest/html/libraries/base/Prelude.html#t:Monad"><span style="background-color: #efefbf; font-weight: bold;">Monad</span></a>.Writer.Class
<span style="color: #06c; font-weight: bold;">import</span> Control.<a href="http://haskell.org/ghc/docs/latest/html/libraries/base/Prelude.html#t:Monad"><span style="background-color: #efefbf; font-weight: bold;">Monad</span></a>.State.Class
<span style="color: #06c; font-weight: bold;">import</span> Data.<a href="http://haskell.org/ghc/docs/latest/html/libraries/base/Prelude.html#t:Functor"><span style="background-color: #efefbf; font-weight: bold;">Functor</span></a>.Bind
&nbsp;</pre>
<p>Our new comonad to monad transformer is given by</p>
<pre class="haskell">&nbsp;
<span style="color: #06c; font-weight: bold;">newtype</span> Co w a = Co <span style="color: green;">&#123;</span> runCo :: <span style="color: #06c; font-weight: bold;">forall</span> r. w <span style="color: green;">&#40;</span>a -&gt; r<span style="color: green;">&#41;</span> -&gt; r <span style="color: green;">&#125;</span>
&nbsp;</pre>
<p>What we've done is added a quantifier to prevent the use of the type <em>r</em>, as we did when describing <a href="http://hackage.haskell.org/packages/archive/kan-extensions/0.5.1/doc/html/Control-Monad-Codensity.html"><code>Codensity</code></a> and <a href="http://hackage.haskell.org/packages/archive/kan-extensions/0.5.1/doc/html/Data-Functor-KanExtension.html"><code>Ran</code></a>, categorically we've taken some kind of <a href="http://en.wikipedia.org/wiki/End_(category_theory)">end</a>. This idea came to me after an observation was made by Russell O'Connor that <code>Conts (Store s) a</code> was pretty close to a continuation passing style version of <code>State s</code>.</p>
<p>Now, we can start spitting out instances for this type. </p>
<pre class="haskell">&nbsp;
<span style="color: #06c; font-weight: bold;">instance</span> <a href="http://haskell.org/ghc/docs/latest/html/libraries/base/Prelude.html#t:Functor"><span style="background-color: #efefbf; font-weight: bold;">Functor</span></a> w =&gt; <a href="http://haskell.org/ghc/docs/latest/html/libraries/base/Prelude.html#t:Functor"><span style="background-color: #efefbf; font-weight: bold;">Functor</span></a> <span style="color: green;">&#40;</span>Co w<span style="color: green;">&#41;</span> <span style="color: #06c; font-weight: bold;">where</span>
   <a href="http://haskell.org/ghc/docs/latest/html/libraries/base/Prelude.html#v:fmap"><span style="font-weight: bold;">fmap</span></a> f <span style="color: green;">&#40;</span>Co w<span style="color: green;">&#41;</span> = Co <span style="color: green;">&#40;</span>w . <a href="http://haskell.org/ghc/docs/latest/html/libraries/base/Prelude.html#v:fmap"><span style="font-weight: bold;">fmap</span></a> <span style="color: green;">&#40;</span>. f<span style="color: green;">&#41;</span><span style="color: green;">&#41;</span>
&nbsp;
<span style="color: #06c; font-weight: bold;">instance</span> <a href="../../../../haskell/category-extras/dist/doc/html/category-extras/Control-Comonad.html#t:Comonad"><span style="background-color: #efefbf; font-weight: bold;">Comonad</span></a> w =&gt; <a href="http://haskell.org/ghc/docs/latest/html/libraries/base/Prelude.html#t:Monad"><span style="background-color: #efefbf; font-weight: bold;">Monad</span></a> <span style="color: green;">&#40;</span>Co w<span style="color: green;">&#41;</span> <span style="color: #06c; font-weight: bold;">where</span>
   <a href="http://haskell.org/ghc/docs/latest/html/libraries/base/Prelude.html#v:return"><span style="font-weight: bold;">return</span></a> a = Co <span style="color: green;">&#40;</span>`<a href="../../../../haskell/category-extras/dist/doc/html/category-extras/Control-Comonad.html#v:extract"><span style="font-weight: bold;">extract</span></a>` a<span style="color: green;">&#41;</span>
   Co k &gt;&gt;= f = Co <span style="color: green;">&#40;</span>k .<a href="../../../../haskell/category-extras/dist/doc/html/category-extras/Control-Comonad.html#v:extend"><span style="font-weight: bold;">extend</span></a> <span style="color: green;">&#40;</span>\wa a -&gt; runCo <span style="color: green;">&#40;</span>f a<span style="color: green;">&#41;</span> wa<span style="color: green;">&#41;</span><span style="color: green;">&#41;</span>
&nbsp;
<span style="color: #06c; font-weight: bold;">instance</span> <a href="../../../../haskell/category-extras/dist/doc/html/category-extras/Control-Comonad.html#t:Comonad"><span style="background-color: #efefbf; font-weight: bold;">Comonad</span></a> w =&gt; Applicative <span style="color: green;">&#40;</span>Co w<span style="color: green;">&#41;</span> <span style="color: #06c; font-weight: bold;">where</span>
   mf &lt; *&gt; ma = mf &gt;&gt;= \f -&gt; <a href="http://haskell.org/ghc/docs/latest/html/libraries/base/Prelude.html#v:fmap"><span style="font-weight: bold;">fmap</span></a> f ma
   pure a = Co <span style="color: green;">&#40;</span>`<a href="../../../../haskell/category-extras/dist/doc/html/category-extras/Control-Comonad.html#v:extract"><span style="font-weight: bold;">extract</span></a>` a<span style="color: green;">&#41;</span>
&nbsp;</pre>
<p>In my break-out of category-extras, I've split off the semigroupoid structure of Kleisli-, co-Kleisli-, and static- arrow composition as <code>Bind</code>, <code>Extend</code> and <code>Apply</code> respectively, so we can make use of slightly less structure and get slightly less structure in turn:</p>
<pre class="haskell">&nbsp;
<span style="color: #06c; font-weight: bold;">instance</span> Extend w =&gt; Bind <span style="color: green;">&#40;</span>Co w<span style="color: green;">&#41;</span> <span style="color: #06c; font-weight: bold;">where</span>
   Co k &gt;&gt;- f = Co <span style="color: green;">&#40;</span>k .<a href="../../../../haskell/category-extras/dist/doc/html/category-extras/Control-Comonad.html#v:extend"><span style="font-weight: bold;">extend</span></a> <span style="color: green;">&#40;</span>\wa a -&gt; runCo <span style="color: green;">&#40;</span>f a<span style="color: green;">&#41;</span> wa<span style="color: green;">&#41;</span><span style="color: green;">&#41;</span>
&nbsp;
<span style="color: #06c; font-weight: bold;">instance</span> Extend w =&gt; Apply <span style="color: green;">&#40;</span>Co w<span style="color: green;">&#41;</span> <span style="color: #06c; font-weight: bold;">where</span>
   mf &lt; .&gt; ma = mf &gt;&gt;- \f -&gt; <a href="http://haskell.org/ghc/docs/latest/html/libraries/base/Prelude.html#v:fmap"><span style="font-weight: bold;">fmap</span></a> f ma
&nbsp;</pre>
<p><strong>From comonad-transformers to the mtl</strong></p>
<p>We can look at how this transforms some particular comonads. </p>
<p>The comonadic version of <a href="http://hackage.haskell.org/packages/archive/mtl/2.0.1.0/doc/html/Control-Monad-State-Lazy.html"><code>State</code></a> is <a href="http://hackage.haskell.org/packages/archive/comonad-transformers/1.7/doc/html/Control-Comonad-Trans-Store-Lazy.html"><code>Store</code></a>. Looking at <code>Co (Store s) a</code></p>
<pre class="haskell">&nbsp;
Co <span style="color: green;">&#40;</span>Store s<span style="color: green;">&#41;</span> a ~ <span style="color: #06c; font-weight: bold;">forall</span> r. <span style="color: green;">&#40;</span><span style="color: green;">&#40;</span>s -&gt; a -&gt; r, s<span style="color: green;">&#41;</span> -&gt; r<span style="color: green;">&#41;</span>
               ~ <span style="color: #06c; font-weight: bold;">forall</span> r. <span style="color: green;">&#40;</span>s -&gt; a -&gt; r<span style="color: green;">&#41;</span> -&gt; s -&gt; r
               ~ <span style="color: #06c; font-weight: bold;">forall</span> r. <span style="color: green;">&#40;</span>a -&gt; s -&gt; r<span style="color: green;">&#41;</span> -&gt; s -&gt; r
               ~ Codensity <span style="color: green;">&#40;</span><span style="color: green;">&#40;</span>-&gt;<span style="color: green;">&#41;</span>s<span style="color: green;">&#41;</span> a
               ~ State s a
&nbsp;</pre>
<p>This gives rise to a leap of intuition that we'll motivate further below:</p>
<pre class="haskell">&nbsp;
<span style="color: #06c; font-weight: bold;">instance</span> ComonadStore s m =&gt; MonadState s <span style="color: green;">&#40;</span>Co m<span style="color: green;">&#41;</span> <span style="color: #06c; font-weight: bold;">where</span>
   get = Co <span style="color: green;">&#40;</span>\w -&gt; <a href="../../../../haskell/category-extras/dist/doc/html/category-extras/Control-Comonad.html#v:extract"><span style="font-weight: bold;">extract</span></a> w <span style="color: green;">&#40;</span>pos w<span style="color: green;">&#41;</span><span style="color: green;">&#41;</span>
   put s = Co <span style="color: green;">&#40;</span>\w -&gt; peek s w <span style="color: green;">&#40;</span><span style="color: green;">&#41;</span><span style="color: green;">&#41;</span>
&nbsp;</pre>
<p>Sadly this breaks down a little for <code>Writer</code> and <code>Reader</code> as the <code>mtl</code> unfortunately has historically included a bunch of extra baggage in these classes. In particular, in reader, the notion of <code>local</code> isn't always available, blocking some otherwise perfectly good <code>MonadReader</code> instances, and I've chosen not to repeat this mistake in <code>comonad-transformers</code>.</p>
<pre class="haskell">&nbsp;
<span style="color: #06c; font-weight: bold;">instance</span> ComonadEnv e m =&gt; MonadReader e <span style="color: green;">&#40;</span>Co m<span style="color: green;">&#41;</span> <span style="color: #06c; font-weight: bold;">where</span>
   ask = Co <span style="color: green;">&#40;</span>\w -&gt; <a href="../../../../haskell/category-extras/dist/doc/html/category-extras/Control-Comonad.html#v:extract"><span style="font-weight: bold;">extract</span></a> w <span style="color: green;">&#40;</span>Env.ask w<span style="color: green;">&#41;</span><span style="color: green;">&#41;</span>
   local = <a href="http://haskell.org/ghc/docs/latest/html/libraries/base/Prelude.html#v:error"><span style="font-weight: bold;">error</span></a> <span style="color: #3c7331;">&quot;local&quot;</span>
&nbsp;</pre>
<p>Ideally, local belongs in a subclass of <code>MonadReader</code>.</p>
<pre class="haskell">&nbsp;
<span style="color: #06c; font-weight: bold;">class</span> <a href="http://haskell.org/ghc/docs/latest/html/libraries/base/Prelude.html#t:Monad"><span style="background-color: #efefbf; font-weight: bold;">Monad</span></a> m =&gt; MonadReader e m | m -&gt; e <span style="color: #06c; font-weight: bold;">where</span>
   ask :: m a -&gt; e
&nbsp;
<span style="color: #06c; font-weight: bold;">class</span> MonadReader e m =&gt; MonadLocal e m | m -&gt; e <span style="color: #06c; font-weight: bold;">where</span>
   local :: <span style="color: green;">&#40;</span>e -&gt; e<span style="color: green;">&#41;</span> -&gt; m a -&gt; m a
&nbsp;</pre>
<p>Similarly there is a lot of baggage in the <code>MonadWriter</code>. The <code>Monoid</code> constraint isnt necessary for the class itself, just for most instances, and the <code>listen</code> and <code>pass</code> members should be a member of a more restricted subclass as well to admit some missing <code>MonadWriter</code> instances, but we can at least provide the notion of tell that is critical to <code>Writer</code>.</p>
<pre class="haskell">&nbsp;
<span style="color: #06c; font-weight: bold;">instance</span> <span style="color: green;">&#40;</span>Monoid e, ComonadTraced e m<span style="color: green;">&#41;</span> =&gt; MonadWriter e <span style="color: green;">&#40;</span>Co m<span style="color: green;">&#41;</span> <span style="color: #06c; font-weight: bold;">where</span>
   tell m = Co <span style="color: green;">&#40;</span>\w -&gt; Traced.trace m w <span style="color: green;">&#40;</span><span style="color: green;">&#41;</span><span style="color: green;">&#41;</span>
   listen = <a href="http://haskell.org/ghc/docs/latest/html/libraries/base/Prelude.html#v:error"><span style="font-weight: bold;">error</span></a> <span style="color: #3c7331;">&quot;listen&quot;</span>
   pass = <a href="http://haskell.org/ghc/docs/latest/html/libraries/base/Prelude.html#v:error"><span style="font-weight: bold;">error</span></a> <span style="color: #3c7331;">&quot;pass&quot;</span>
&nbsp;</pre>
<p>But given the split out</p>
<pre class="haskell">&nbsp;
<span style="color: #06c; font-weight: bold;">instance</span> <a href="http://haskell.org/ghc/docs/latest/html/libraries/base/Prelude.html#t:Monad"><span style="background-color: #efefbf; font-weight: bold;">Monad</span></a> m =&gt; MonadWriter e m | m -&gt; e <span style="color: #06c; font-weight: bold;">where</span>
    tell :: e -&gt; m <span style="color: green;">&#40;</span><span style="color: green;">&#41;</span>
&nbsp;
<span style="color: #06c; font-weight: bold;">instance</span> MonadWriter e m =&gt; MonadListen e m | m -&gt; e
    listen :: m a -&gt; m <span style="color: green;">&#40;</span>a, w<span style="color: green;">&#41;</span>
    pass :: m <span style="color: green;">&#40;</span>a, w -&gt; w<span style="color: green;">&#41;</span> -&gt; m a
&nbsp;</pre>
<p>We could provide this functionality more robustly. (There is a similar subset of <code>Comonad</code>s that can provide listen and pass analogues.)</p>
<p>While I am now the maintainer of the mtl, I can't really justify making the above corrections to the class hierarchy at this time. They would theoretically break a lot of code. I would be curious to see how much code would break in practice though.</p>
<p><strong>Combinators Please!</strong></p>
<p>There is a recurring pattern in the above code, so we can also improve this construction by providing some automatic lifting combinators that take certain cokleisli arrows and give us monadic values</p>
<pre class="haskell">&nbsp;
lift0 :: <a href="../../../../haskell/category-extras/dist/doc/html/category-extras/Control-Comonad.html#t:Comonad"><span style="background-color: #efefbf; font-weight: bold;">Comonad</span></a> w =&gt; <span style="color: green;">&#40;</span><span style="color: #06c; font-weight: bold;">forall</span> a. w a -&gt; s<span style="color: green;">&#41;</span> -&gt; Co w s
lift0 f = Co <span style="color: green;">&#40;</span><a href="../../../../haskell/category-extras/dist/doc/html/category-extras/Control-Comonad.html#v:extract"><span style="font-weight: bold;">extract</span></a> &lt; *&gt; f<span style="color: green;">&#41;</span>
&nbsp;
lift1 :: <span style="color: green;">&#40;</span><span style="color: #06c; font-weight: bold;">forall</span> a. w a -&gt; a<span style="color: green;">&#41;</span> -&gt; Co w <span style="color: green;">&#40;</span><span style="color: green;">&#41;</span>
lift1 f = Co <span style="color: green;">&#40;</span>`f` <span style="color: green;">&#40;</span><span style="color: green;">&#41;</span><span style="color: green;">&#41;</span>
&nbsp;</pre>
<p>along with their inverses</p>
<pre class="haskell">&nbsp;
lower0 :: <a href="http://haskell.org/ghc/docs/latest/html/libraries/base/Prelude.html#t:Functor"><span style="background-color: #efefbf; font-weight: bold;">Functor</span></a> w =&gt; Co w s -&gt; w a -&gt; s
lower0 <span style="color: green;">&#40;</span>Co f<span style="color: green;">&#41;</span> w = f <span style="color: green;">&#40;</span><a href="http://haskell.org/ghc/docs/latest/html/libraries/base/Prelude.html#v:id"><span style="font-weight: bold;">id</span></a> &lt; $ w<span style="color: green;">&#41;</span>
&nbsp;
lower1 :: <a href="http://haskell.org/ghc/docs/latest/html/libraries/base/Prelude.html#t:Functor"><span style="background-color: #efefbf; font-weight: bold;">Functor</span></a> w =&gt; Co w <span style="color: green;">&#40;</span><span style="color: green;">&#41;</span> -&gt; w a -&gt; a
lower1 <span style="color: green;">&#40;</span>Co f<span style="color: green;">&#41;</span> w = f <span style="color: green;">&#40;</span><a href="http://haskell.org/ghc/docs/latest/html/libraries/base/Prelude.html#v:fmap"><span style="font-weight: bold;">fmap</span></a> <a href="http://haskell.org/ghc/docs/latest/html/libraries/base/Prelude.html#v:const"><span style="font-weight: bold;">const</span></a> w<span style="color: green;">&#41;</span>
&nbsp;</pre>
<p>(The proofs that these are inverses are quite hairy, and lean heavily on parametricity.)</p>
<p>Then in the above, the code simplifies to:</p>
<pre class="haskell">&nbsp;
get = lift0 pos
put s = lift1 <span style="color: green;">&#40;</span>peek s<span style="color: green;">&#41;</span>
ask = lift0 Env.ask
tell s = lift1 <span style="color: green;">&#40;</span>tell s<span style="color: green;">&#41;</span>
&nbsp;</pre>
<p><strong>Co-Density?</strong></p>
<p>Co and Codensity are closely related.</p>
<p>Given any Comonad W, it is given rise to by the composition FG for some adjunction <code>F -| G : Hask -> C</code>.</p>
<p>Considering only the case where <code>C = Hask</code> for now, we can find that</p>
<pre class="haskell">&nbsp;
Co w a ~ <span style="color: #06c; font-weight: bold;">forall</span> r. <span style="color: green;">&#40;</span>f <span style="color: green;">&#40;</span>g <span style="color: green;">&#40;</span>a -&gt; r<span style="color: green;">&#41;</span><span style="color: green;">&#41;</span> -&gt; r<span style="color: green;">&#41;</span>.
&nbsp;</pre>
<p>Since <code>f -| g</code>, we know that <code>g</code> is <code>Representable</code> by <code>f ()</code>, as witnessed by:</p>
<pre class="haskell">&nbsp;
tabulateAdjunction :: <a href="../../../../haskell/category-extras/dist/doc/html/category-extras/Control-Functor-Adjunction.html#t:Adjunction"><span style="background-color: #efefbf; font-weight: bold;">Adjunction</span></a> f u =&gt; <span style="color: green;">&#40;</span>f <span style="color: green;">&#40;</span><span style="color: green;">&#41;</span> -&gt; b<span style="color: green;">&#41;</span> -&gt; u b
tabulateAdjunction f = <a href="../../../../haskell/category-extras/dist/doc/html/category-extras/Control-Functor-Adjunction.html#v:leftAdjunct"><span style="font-weight: bold;">leftAdjunct</span></a> f <span style="color: green;">&#40;</span><span style="color: green;">&#41;</span>
&nbsp;
indexAdjunction :: <a href="../../../../haskell/category-extras/dist/doc/html/category-extras/Control-Functor-Adjunction.html#t:Adjunction"><span style="background-color: #efefbf; font-weight: bold;">Adjunction</span></a> f u =&gt; u b -&gt; f a -&gt; b
indexAdjunction = <a href="../../../../haskell/category-extras/dist/doc/html/category-extras/Control-Functor-Adjunction.html#v:rightAdjunct"><span style="font-weight: bold;">rightAdjunct</span></a> . <a href="http://haskell.org/ghc/docs/latest/html/libraries/base/Prelude.html#v:const"><span style="font-weight: bold;">const</span></a>
&nbsp;</pre>
<p>therefore</p>
<pre class="haskell">&nbsp;
Co w a ~ f <span style="color: green;">&#40;</span>g <span style="color: green;">&#40;</span>a -&gt; r<span style="color: green;">&#41;</span><span style="color: green;">&#41;</span> -&gt; r ~ f <span style="color: green;">&#40;</span>f <span style="color: green;">&#40;</span><span style="color: green;">&#41;</span> -&gt; a -&gt; r<span style="color: green;">&#41;</span> -&gt; r
&nbsp;</pre>
<p>Since <em>f</em> is a left adjoint functor, <code>f a ~ (a, f ())</code> by Sjoerd Visscher's elegant little <code>split</code> combinator:</p>
<pre class="haskell">&nbsp;
split :: <a href="../../../../haskell/category-extras/dist/doc/html/category-extras/Control-Functor-Adjunction.html#t:Adjunction"><span style="background-color: #efefbf; font-weight: bold;">Adjunction</span></a> f u =&gt; f a -&gt; <span style="color: green;">&#40;</span>a, f <span style="color: green;">&#40;</span><span style="color: green;">&#41;</span><span style="color: green;">&#41;</span>
split = <a href="../../../../haskell/category-extras/dist/doc/html/category-extras/Control-Functor-Adjunction.html#v:rightAdjunct"><span style="font-weight: bold;">rightAdjunct</span></a> <span style="color: green;">&#40;</span><a href="http://haskell.org/ghc/docs/latest/html/libraries/base/Prelude.html#v:flip"><span style="font-weight: bold;">flip</span></a> <a href="../../../../haskell/category-extras/dist/doc/html/category-extras/Control-Functor-Adjunction.html#v:leftAdjunct"><span style="font-weight: bold;">leftAdjunct</span></a> <span style="color: green;">&#40;</span><span style="color: green;">&#41;</span> . <span style="color: green;">&#40;</span>,<span style="color: green;">&#41;</span><span style="color: green;">&#41;</span>
&nbsp;</pre>
<p>which has the simple inverse</p>
<pre class="haskell">&nbsp;
unsplit :: <a href="../../../../haskell/category-extras/dist/doc/html/category-extras/Control-Functor-Adjunction.html#t:Adjunction"><span style="background-color: #efefbf; font-weight: bold;">Adjunction</span></a> f g =&gt; a -&gt; f <span style="color: green;">&#40;</span><span style="color: green;">&#41;</span> -&gt; f a
unsplit a = <a href="http://haskell.org/ghc/docs/latest/html/libraries/base/Prelude.html#v:fmap"><span style="font-weight: bold;">fmap</span></a> <span style="color: green;">&#40;</span><a href="http://haskell.org/ghc/docs/latest/html/libraries/base/Prelude.html#v:const"><span style="font-weight: bold;">const</span></a> a<span style="color: green;">&#41;</span>
&nbsp;</pre>
<p>so we can apply that to our argument:</p>
<pre class="haskell">&nbsp;
Co w a ~ <span style="color: #06c; font-weight: bold;">forall</span> r. f <span style="color: green;">&#40;</span>f <span style="color: green;">&#40;</span><span style="color: green;">&#41;</span> -&gt; a -&gt; r<span style="color: green;">&#41;</span> -&gt; r ~
         <span style="color: #06c; font-weight: bold;">forall</span> r. <span style="color: green;">&#40;</span>f <span style="color: green;">&#40;</span><span style="color: green;">&#41;</span> -&gt; a -&gt; r, f <span style="color: green;">&#40;</span><span style="color: green;">&#41;</span><span style="color: green;">&#41;</span> -&gt; r
&nbsp;</pre>
<p>and curry to obtain</p>
<pre class="haskell">&nbsp;
Co w a ~ <span style="color: #06c; font-weight: bold;">forall</span> r. <span style="color: green;">&#40;</span>f <span style="color: green;">&#40;</span><span style="color: green;">&#41;</span> -&gt; a -&gt; r<span style="color: green;">&#41;</span> -&gt; f <span style="color: green;">&#40;</span><span style="color: green;">&#41;</span> -&gt; r
&nbsp;</pre>
<p>and swap the arguments</p>
<pre class="haskell">&nbsp;
Co w a ~ <span style="color: #06c; font-weight: bold;">forall</span> r. <span style="color: green;">&#40;</span>a -&gt; f <span style="color: green;">&#40;</span><span style="color: green;">&#41;</span> -&gt; r<span style="color: green;">&#41;</span> -&gt; f <span style="color: green;">&#40;</span><span style="color: green;">&#41;</span> -&gt; r
&nbsp;</pre>
<p>then we can tabulate the two subtypes of the form (f () -> r)</p>
<pre class="haskell">&nbsp;
Co w a ~ <span style="color: #06c; font-weight: bold;">forall</span> r. <span style="color: green;">&#40;</span>a -&gt; g r<span style="color: green;">&#41;</span> -&gt; g r
&nbsp;</pre>
<p>and so we find that</p>
<pre class="haskell">&nbsp;
Co w a ~ Codensity g a
&nbsp;</pre>
<p>Finally, </p>
<pre class="haskell">&nbsp;
Codensity g a ~ <a href="../../../../haskell/category-extras/dist/doc/html/category-extras/Control-Functor-KanExtension.html#t:Ran"><span style="background-color: #efefbf; font-weight: bold;">Ran</span></a> g g a
&nbsp;</pre>
<p>but we showed back in my second article on Kan extensions that given f -| g that</p>
<pre class="haskell">&nbsp;
<a href="../../../../haskell/category-extras/dist/doc/html/category-extras/Control-Functor-KanExtension.html#t:Ran"><span style="background-color: #efefbf; font-weight: bold;">Ran</span></a> g g a ~ g <span style="color: green;">&#40;</span>f a<span style="color: green;">&#41;</span>
&nbsp;</pre>
<p>So <code>Co w ~ Co (f . g) ~ (g . f)</code>, the monad given rise to by composing our adjunction the other way!</p>
<p><strong>Comonads from Monads?</strong></p>
<p>Now, given all this you might ask </p>
<blockquote><p>Is there is a similar construction that lets you build a comonad out of a monad?</p></blockquote>
<p>Sadly, it seems the answer <strong>in Haskell</strong> is no.</p>
<p>Any adjunction from <code>Hask -> Hask^op</code> would require two functions</p>
<pre class="haskell">&nbsp;
<span style="color: #06c; font-weight: bold;">class</span> <span style="color: green;">&#40;</span>Contravariant f, Contravariant g<span style="color: green;">&#41;</span> =&gt; DualContravariantAdjunction f g <span style="color: #06c; font-weight: bold;">where</span>
    <a href="../../../../haskell/category-extras/dist/doc/html/category-extras/Control-Functor-Adjunction.html#v:leftAdjunct"><span style="font-weight: bold;">leftAdjunct</span></a> :: <span style="color: green;">&#40;</span>f a -&gt; b<span style="color: green;">&#41;</span> -&gt; g b -&gt; a
    <a href="../../../../haskell/category-extras/dist/doc/html/category-extras/Control-Functor-Adjunction.html#v:rightAdjunct"><span style="font-weight: bold;">rightAdjunct</span></a> :: <span style="color: green;">&#40;</span>g b -&gt; a<span style="color: green;">&#41;</span> -&gt; f a -&gt; b
&nbsp;</pre>
<p>where <strong>both functors are contravariant</strong>. </p>
<p>Surmounting the intuitionistic impossibility of this, then given any such adjunction, there would be a nice coend we could take, letting us sandwich any <code>Monad</code> in the middle as we did above.</p>
<p>There does exist one such very boring Contravariant Functor.</p>
<pre class="haskell">&nbsp;
<span style="color: #06c; font-weight: bold;">newtype</span> Absurd a = Absurd <span style="color: green;">&#40;</span>Absurd a<span style="color: green;">&#41;</span>
&nbsp;
absurdity :: Absurd a -&gt; b
absurdity <span style="color: green;">&#40;</span>Absurd a<span style="color: green;">&#41;</span> = absurdity a
&nbsp;
<span style="color: #06c; font-weight: bold;">instance</span> Contravariant Absurd <span style="color: #06c; font-weight: bold;">where</span>
   contramap f <span style="color: green;">&#40;</span>Absurd <span style="color: #06c; font-weight: bold;">as</span><span style="color: green;">&#41;</span> = Absurd <span style="color: green;">&#40;</span>contramap f <span style="color: #06c; font-weight: bold;">as</span><span style="color: green;">&#41;</span>
&nbsp;
<span style="color: #06c; font-weight: bold;">instance</span> DualContravariantAdjunction Absurd Absurd <span style="color: #06c; font-weight: bold;">where</span>
    <a href="../../../../haskell/category-extras/dist/doc/html/category-extras/Control-Functor-Adjunction.html#v:leftAdjunct"><span style="font-weight: bold;">leftAdjunct</span></a> _ = absurdity
    <a href="../../../../haskell/category-extras/dist/doc/html/category-extras/Control-Functor-Adjunction.html#v:rightAdjunct"><span style="font-weight: bold;">rightAdjunct</span></a> _ = absurdity
&nbsp;</pre>
<p>We can safely sandwich IO within this adjunction from <code>Hask -> Hask^op</code> to obtain a comonad.</p>
<pre class="haskell">&nbsp;
<span style="color: #06c; font-weight: bold;">newtype</span> Silly m a = Silly <span style="color: green;">&#123;</span> runSilly :: Absurd <span style="color: green;">&#40;</span>m <span style="color: green;">&#40;</span>Absurd a<span style="color: green;">&#41;</span><span style="color: green;">&#41;</span> <span style="color: green;">&#125;</span>
&nbsp;
<span style="color: #06c; font-weight: bold;">instance</span> <a href="http://haskell.org/ghc/docs/latest/html/libraries/base/Prelude.html#t:Monad"><span style="background-color: #efefbf; font-weight: bold;">Monad</span></a> m =&gt; Extend <span style="color: green;">&#40;</span>Silly m<span style="color: green;">&#41;</span> <span style="color: #06c; font-weight: bold;">where</span>
    <a href="../../../../haskell/category-extras/dist/doc/html/category-extras/Control-Comonad.html#v:extend"><span style="font-weight: bold;">extend</span></a> f <span style="color: green;">&#40;</span>Silly m<span style="color: green;">&#41;</span> = absurdity m
&nbsp;
<span style="color: #06c; font-weight: bold;">instance</span> <a href="http://haskell.org/ghc/docs/latest/html/libraries/base/Prelude.html#t:Monad"><span style="background-color: #efefbf; font-weight: bold;">Monad</span></a> m =&gt; <a href="../../../../haskell/category-extras/dist/doc/html/category-extras/Control-Comonad.html#t:Comonad"><span style="background-color: #efefbf; font-weight: bold;">Comonad</span></a> <span style="color: green;">&#40;</span>Silly m<span style="color: green;">&#41;</span> <span style="color: #06c; font-weight: bold;">where</span>
    <a href="../../../../haskell/category-extras/dist/doc/html/category-extras/Control-Comonad.html#v:extract"><span style="font-weight: bold;">extract</span></a> <span style="color: green;">&#40;</span>Silly m<span style="color: green;">&#41;</span> = absurdity m
&nbsp;</pre>
<p>But for any more interesting such type that actually lets us get at its contents, we would be able to derive a circuitous path to <code>unsafePerformIO</code>!</p>
<p>Since <code>unsafePerformIO</code> should not be constructible without knowing <code>IO</code> specifics, no <strong>useful</strong> <code>DualContravariantAdjunction</code>s should exist.</p>
]]></content:encoded>
			<wfw:commentRss>http://comonad.com/reader/2011/monads-from-comonads/feed/</wfw:commentRss>
		<slash:comments>9</slash:comments>
		</item>
		<item>
		<title>Free Monads for Less (Part 3 of 3): Yielding IO</title>
		<link>http://comonad.com/reader/2011/free-monads-for-less-3/</link>
		<comments>http://comonad.com/reader/2011/free-monads-for-less-3/#comments</comments>
		<pubDate>Fri, 24 Jun 2011 06:41:06 +0000</pubDate>
		<dc:creator>Edward Kmett</dc:creator>
				<category><![CDATA[Algorithms]]></category>
		<category><![CDATA[Category Theory]]></category>
		<category><![CDATA[Comonads]]></category>
		<category><![CDATA[Data Structures]]></category>
		<category><![CDATA[Haskell]]></category>
		<category><![CDATA[Kan Extensions]]></category>
		<category><![CDATA[Monads]]></category>

		<guid isPermaLink="false">http://comonad.com/reader/?p=251</guid>
		<description><![CDATA[<a href="http://comonad.com/reader/2011/free-monads-for-less-2/">Last time</a>, I said that I was going to put our cheap new free monad to work, so let's give it a shot. ]]></description>
			<content:encoded><![CDATA[<p><a href="../../../2011/free-monads-for-less-2/index.html">Last time</a>, I said that I was going to put our cheap new free monad to work, so let's give it a shot. </p>
<p><span id="more-251"></span></p>
<p><strong>Yield for Less</strong></p>
<p>Last month at <a href="http://www.pps.jussieu.fr/~saurin/tpdc2011/">TPDC 2011</a>, Roshan James and Amr Sabry presented <a href="http://parametricity.net/dropbox/yield.subc.pdf">Yield: Mainstream Delimited Continuations</a>.</p>
<p>Without calling it such they worked with the free monad of the indexed store comonad. Ignoring the comonad, and just looking at the functor we can see that</p>
<pre class="haskell">&nbsp;
<span style="color: #06c; font-weight: bold;">data</span> Store i o r = Store <span style="color: green;">&#40;</span>i -&gt; r<span style="color: green;">&#41;</span> o
    <span style="color: #06c; font-weight: bold;">deriving</span> <span style="color: green;">&#40;</span><a href="http://haskell.org/ghc/docs/latest/html/libraries/base/Prelude.html#t:Functor"><span style="background-color: #efefbf; font-weight: bold;">Functor</span></a><span style="color: green;">&#41;</span>
&nbsp;</pre>
<p>admits the operation</p>
<pre class="haskell">&nbsp;
<span style="color: #06c; font-weight: bold;">class</span> <a href="http://haskell.org/ghc/docs/latest/html/libraries/base/Prelude.html#t:Functor"><span style="background-color: #efefbf; font-weight: bold;">Functor</span></a> y =&gt; Yieldable y i o | y -&gt; i o <span style="color: #06c; font-weight: bold;">where</span>
   yield :: o -&gt; y i
&nbsp;
<span style="color: #06c; font-weight: bold;">instance</span> Yieldable <span style="color: green;">&#40;</span>Store i o<span style="color: green;">&#41;</span> i o <span style="color: #06c; font-weight: bold;">where</span>
   yield = Store <a href="http://haskell.org/ghc/docs/latest/html/libraries/base/Prelude.html#v:id"><span style="font-weight: bold;">id</span></a>
&nbsp;</pre>
<p>The free monad of <code>Store i o</code> is a nice model for asymmetric coroutines.</p>
<pre class="haskell">&nbsp;
<span style="color: #06c; font-weight: bold;">type</span> Yield i o = Free <span style="color: green;">&#40;</span>Store i o<span style="color: green;">&#41;</span>
&nbsp;
liftFree :: <a href="http://haskell.org/ghc/docs/latest/html/libraries/base/Prelude.html#t:Functor"><span style="background-color: #efefbf; font-weight: bold;">Functor</span></a> f =&gt; f a -&gt; Free f a
liftFree = Free . <a href="http://haskell.org/ghc/docs/latest/html/libraries/base/Prelude.html#v:fmap"><span style="font-weight: bold;">fmap</span></a> Pure
&nbsp;
<span style="color: #06c; font-weight: bold;">instance</span> Yieldable y i o =&gt; Yieldable <span style="color: green;">&#40;</span>Free y<span style="color: green;">&#41;</span> i o <span style="color: #06c; font-weight: bold;">where</span>
   yield = liftFree . yield
&nbsp;</pre>
<p>With its <code>Monad</code>, you can write computations like:</p>
<pre class="haskell">&nbsp;
foo :: <a href="http://haskell.org/ghc/docs/latest/html/libraries/base/Prelude.html#t:Num"><span style="background-color: #efefbf; font-weight: bold;">Num</span></a> o =&gt; Yield <span style="color: green;">&#40;</span><span style="color: green;">&#41;</span> o <span style="color: green;">&#40;</span><span style="color: green;">&#41;</span>
foo = <span style="color: #06c; font-weight: bold;">do</span>
   yield <span style="color: red;">1</span>
   yield <span style="color: red;">2</span>
   yield <span style="color: red;">3</span>
&nbsp;</pre>
<p>or to streamline one of James and Sabry's examples</p>
<pre class="haskell">&nbsp;
walk :: Traversable f =&gt; f o -&gt; Yield i o <span style="color: green;">&#40;</span>f i<span style="color: green;">&#41;</span>
walk = traverse yield
&nbsp;</pre>
<p>is an asymmetric coroutine that yields each of the elements in a traversable container in turn, replacing them with the responses from whatever is driving the coroutine.</p>
<p>James and Sabry called this the naive frame grabbing implementation. It is inefficient for the same reasons that we discussed before about retraversing the common trunk in free monads in general. Note that the unchanging trunk here isn't the data structure that we're traversing, but instead the chain of <code>Store i o</code> actions we took to get to the current instruction.</p>
<p>James and Sabry then proceeded to optimize it by hitting it with <a href="http://hackage.haskell.org/packages/archive/kan-extensions/0.5.0/doc/html/Control-Monad-Codensity.html">Codensity</a>.</p>
<pre class="haskell">&nbsp;
<span style="color: #06c; font-weight: bold;">type</span> Iterator i o = Codensity <span style="color: green;">&#40;</span>Yield i o<span style="color: green;">&#41;</span>
&nbsp;
<span style="color: #06c; font-weight: bold;">instance</span> <span style="color: green;">&#40;</span><a href="http://haskell.org/ghc/docs/latest/html/libraries/base/Prelude.html#t:Monad"><span style="background-color: #efefbf; font-weight: bold;">Monad</span></a> y, Yieldable y i o<span style="color: green;">&#41;</span> =&gt; Yieldable <span style="color: green;">&#40;</span>Codensity y<span style="color: green;">&#41;</span> i o <span style="color: #06c; font-weight: bold;">where</span>
   yield = liftCodensity . yield
&nbsp;</pre>
<p>But we've now seen that we can get away with something smaller and get the same benefits.</p>
<pre class="haskell">&nbsp;
liftF :: <a href="http://haskell.org/ghc/docs/latest/html/libraries/base/Prelude.html#t:Functor"><span style="background-color: #efefbf; font-weight: bold;">Functor</span></a> f =&gt; f a -&gt; F f a
liftF f = F <span style="color: green;">&#40;</span>\kp kf -&gt; kf <span style="color: green;">&#40;</span><a href="http://haskell.org/ghc/docs/latest/html/libraries/base/Prelude.html#v:fmap"><span style="font-weight: bold;">fmap</span></a> kp f<span style="color: green;">&#41;</span><span style="color: green;">&#41;</span>
&nbsp;
<span style="color: #06c; font-weight: bold;">instance</span> Yieldable y i o =&gt; Yieldable <span style="color: green;">&#40;</span>F y<span style="color: green;">&#41;</span> i o <span style="color: #06c; font-weight: bold;">where</span>
   yield = liftF . yield
&nbsp;</pre>
<p>Flattened, and with the store untupled the new optimized representation looks like:</p>
<pre class="haskell">&nbsp;
<span style="color: #06c; font-weight: bold;">newtype</span> Iterator i o a = Iterator
  <span style="color: green;">&#123;</span> runIterator ::
    <span style="color: #06c; font-weight: bold;">forall</span> r. <span style="color: green;">&#40;</span>a -&gt; r<span style="color: green;">&#41;</span> -&gt; <span style="color: green;">&#40;</span>o -&gt; <span style="color: green;">&#40;</span>i -&gt; r<span style="color: green;">&#41;</span> -&gt; r<span style="color: green;">&#41;</span> -&gt; r<span style="color: green;">&#41;</span>
  <span style="color: green;">&#125;</span>
&nbsp;</pre>
<p>and provides the same performance improvements for asymmetric coroutines as the <code>Codensity</code> version, used by James and Sabry, which would flatten to the much larger and less satisfying:</p>
<pre class="haskell">&nbsp;
<span style="color: #06c; font-weight: bold;">newtype</span> RSIterator i o a = RSIterator
    <span style="color: green;">&#123;</span> runRSIterator :: <span style="color: #06c; font-weight: bold;">forall</span> r.
          <span style="color: green;">&#40;</span>a -&gt; <span style="color: green;">&#40;</span>o -&gt; <span style="color: green;">&#40;</span>i -&gt; r<span style="color: green;">&#41;</span> -&gt; r<span style="color: green;">&#41;</span> -&gt; r<span style="color: green;">&#41;</span>
             -&gt; <span style="color: green;">&#40;</span>o -&gt; <span style="color: green;">&#40;</span>i -&gt; r<span style="color: green;">&#41;</span> -&gt; r<span style="color: green;">&#41;</span> -&gt; r
    <span style="color: green;">&#125;</span>
&nbsp;</pre>
<p>They proceed to give an encoding of delimited continuations into this type and vice versa, but the rest of their material is of no further use to us here.</p>
<p>As an aside the performance benefits of encoding Oleg's <a href="http://okmij.org/ftp/Streams.html">iteratees</a> in <a href="http://hackage.haskell.org/packages/archive/iteratee/0.8.5.0/doc/html/Data-Iteratee-Base.html">continuation passing style</a> arise for much the same reason. The resuting encoding is a right Kan extension!</p>
<p><strong>Who Needs the RealWorld?</strong></p>
<p>As <a href="http://twitter.com/#!/runarorama/status/83570792704638976">Runar recently tweeted</a>, we have put this to good use here at <a href="https://www.capitaliq.com/home/what-we-offer/how-you-can-get-it/clarifi.aspx">ClariFI</a>. (<strong>Yes</strong>, we are hiring! If the contents of my blog make sense to you then <a href="mailto:ekmett@gmail.com">email me</a> and let's talk.)</p>
<p>At ClariFI have a strongly typed functional language that bears a strong resemblance to Haskell with <a href="http://www.haskell.org/haskellwiki/Rank-N_types">rank-n types</a> and a number of other interesting type system features that are particularly suited to our problem domain.</p>
<p>However, as with Haskell, we needed a story for how to deal with <code>IO</code>. </p>
<p>Now, <a href="http://www.haskell.org/ghc/">GHC</a> models <a href="http://www.haskell.org/ghc/docs/6.2/html/libraries/base/GHC.IOBase.html">IO</a> with the type</p>
<pre class="haskell">&nbsp;
<span style="color: #06c; font-weight: bold;">newtype</span> <a href="http://haskell.org/ghc/docs/latest/html/libraries/base/Prelude.html#t:IO"><span style="background-color: #efefbf; font-weight: bold;">IO</span></a> a =
   <a href="http://haskell.org/ghc/docs/latest/html/libraries/base/Prelude.html#t:IO"><span style="background-color: #efefbf; font-weight: bold;">IO</span></a> <span style="color: green;">&#40;</span>State# RealWorld -&gt; <span style="color: green;">&#40;</span># a, State# RealWorld #<span style="color: green;">&#41;</span><span style="color: green;">&#41;</span>
&nbsp;</pre>
<p>where they model <code>IO</code> by working in a strict state monad, passing around a real world that they promise not to mutate or copy. (In practice, the world is passed around as a 0-byte token.</p>
<p>This is somewhat problematic semantically, for a number of reasons.</p>
<p>First, There is always the risk of copying it or plumbing it through backwards, so we carefully hide the <code>State# RealWorld</code> from the end user. So this model really wants some notion of uniqueness or linear typing to render it perfectly safe. Heck, the entire <a href="http://en.wikipedia.org/wiki/Clean_(programming_language)">Clean</a> language arose from just trying to address this concern.</p>
<p>Second, you don't <strong>really</strong> get to pass the real world around!  We have multiple cores working these days. Stuff is happening in the back end, and as much as you might want it to be, your program isn't responsible for everything that happens in the <code>RealWorld</code>!.</p>
<p>Third, if in some sense all bottoms are the same, then <code>forever (putStrLn "Hello World")</code> and <code>undefined</code> are the same in that sense, despite the slew of side-effects that arise from the first one. Now, in Haskell you are allowed to catch some bottoms in the IO monad, and thereby escape from certain doom, but it is still a reasonable objection.</p>
<p>One alternate model for talking about <code>IO</code> is to view it as a free monad of some set of operations. This approach was taken by Wouter Swierstra's Functional Pearl: <a href="http://www.cs.nott.ac.uk/~wss/Publications/DataTypesALaCarte.pdf">Data Types a la Carte</a>.</p>
<p>You can then supply some sort of external interpreter that pumps that tree structure, performing the individual actions.</p>
<p>This is unsatisfying because of two things:</p>
<p>First, the performance is abysmal using the common ADT encoding of a free monad. Janis Voigtländer of course showed, that this can be rectified by using the <code>Codensity</code> monad.</p>
<p>Second, the set of <code>FFI</code> operations is closed.</p>
<p>What we've done instead is to define our primitive <code>IO</code> actions externally as some <code>FFI</code> type:</p>
<pre class="haskell">&nbsp;
<span style="color: #06c; font-weight: bold;">type</span> FFI o i <span style="color: #5d478b; font-style: italic;">-- external, side-effecting computation taking o, returning i</span>
&nbsp;</pre>
<p>In practice, these are obtained by reflection by our <code>foreign import</code> statements since we run in the JVM.</p>
<p>Then we looked at the free monad of</p>
<pre class="haskell">&nbsp;
<span style="color: #06c; font-weight: bold;">newtype</span> OI a = <span style="color: #06c; font-weight: bold;">forall</span> o i. OI <span style="color: green;">&#40;</span>FFI o i<span style="color: green;">&#41;</span> o <span style="color: green;">&#40;</span>i -&gt; a<span style="color: green;">&#41;</span> <span style="color: #06c; font-weight: bold;">deriving</span> <a href="http://haskell.org/ghc/docs/latest/html/libraries/base/Prelude.html#t:Functor"><span style="background-color: #efefbf; font-weight: bold;">Functor</span></a>
&nbsp;</pre>
<p>where <code>OI</code> is the indexed store comonad used as the building block above, yielding arguments to <code>FFI</code> of type <em>o</em>, and representing a computation that would resume with a value of type <em>i</em> to obtain a result of type <em>a</em>.<code></p>
<p>In some sense this yields a more useful notion than Richard Kieburtz's novel, but largely unimplementable, </code><code>OI</code> comonad from <a href="http://citeseerx.ist.psu.edu/viewdoc/download?doi=10.1.1.45.4741&rep=rep1&type=ps">Codata and Comonads in Haskell</a>.</p>
<p>Flattening <code>Free OI</code> would yield the naive</p>
<pre class="haskell">&nbsp;
<span style="color: #5d478b; font-style: italic;">-- data FIO a where</span>
<span style="color: #5d478b; font-style: italic;">--    Return :: a -&gt; FIO a</span>
<span style="color: #5d478b; font-style: italic;">--    FIO :: FFI o i -&gt; o -&gt; (i -&gt; FIO a) -&gt; FIO a</span>
&nbsp;</pre>
<p>which would be interpreted by the runtime system.</p>
<p>But once we've converted to our Church-encoded Free monad and flattened we obtain:</p>
<pre class="haskell">&nbsp;
<span style="color: #06c; font-weight: bold;">newtype</span> <a href="http://haskell.org/ghc/docs/latest/html/libraries/base/Prelude.html#t:IO"><span style="background-color: #efefbf; font-weight: bold;">IO</span></a> a = <a href="http://haskell.org/ghc/docs/latest/html/libraries/base/Prelude.html#t:IO"><span style="background-color: #efefbf; font-weight: bold;">IO</span></a>
    <span style="color: green;">&#40;</span><span style="color: #06c; font-weight: bold;">forall</span> r. <span style="color: green;">&#40;</span>a -&gt; r<span style="color: green;">&#41;</span> -&gt;
                 <span style="color: green;">&#40;</span><span style="color: #06c; font-weight: bold;">forall</span> i o. FFI o i -&gt; o -&gt; <span style="color: green;">&#40;</span>i -&gt; r<span style="color: green;">&#41;</span> -&gt; r<span style="color: green;">&#41;</span> -&gt;
                 r<span style="color: green;">&#41;</span>
&nbsp;</pre>
<p>with the <code>Functor</code> and <code>Monad</code> instances defined above.</p>
<p>This then gives us a number of choices on how we implement the runtime system:</p>
<p>We can use the machinery described earlier to convert from <code>IO a</code> to <code>Free OI a</code> or <code>FIO a</code>, and then have the runtime system pattern match on that structure on our main method, taking the <code>FFI</code> actions and their arguments and passing the results in to the language, or we can invert control, and implement things more directly by just defining </p>
<pre class="haskell">&nbsp;
FFI = <span style="color: green;">&#40;</span>-&gt;<span style="color: green;">&#41;</span>
&nbsp;</pre>
<p>while letting the <code>FFI</code>'d methods have side-effects, and then defining</p>
<pre class="haskell">&nbsp;
unsafePerformIO :: <a href="http://haskell.org/ghc/docs/latest/html/libraries/base/Prelude.html#t:IO"><span style="background-color: #efefbf; font-weight: bold;">IO</span></a> a -&gt; a
unsafePerformIO <span style="color: green;">&#40;</span><a href="http://haskell.org/ghc/docs/latest/html/libraries/base/Prelude.html#t:IO"><span style="background-color: #efefbf; font-weight: bold;">IO</span></a> m<span style="color: green;">&#41;</span> = m <a href="http://haskell.org/ghc/docs/latest/html/libraries/base/Prelude.html#v:id"><span style="font-weight: bold;">id</span></a> <span style="color: green;">&#40;</span>\ oi o ir -&gt; ir <span style="color: green;">&#40;</span>oi o<span style="color: green;">&#41;</span><span style="color: green;">&#41;</span>
&nbsp;</pre>
<p>But regardless of how <code>FFI</code> is implemented,  this model provides a clear structural difference between <code>forever (putStrLn "Hello")</code> and <code>undefined</code> and does not require us to believe the pleasant fiction that we can get our hands on the real world and pass it around.</p>
<p>Our actual <code>IO</code> representation is only slightly more complicated than the one presented here in order to deal with the plumbing of an extra continuation to deal with Java exceptions, but the substance of this approach isn't changed by this addition.</p>
<p>[Edit: incorporated a minor typographical fix into Iterator from Max Bolingbroke]<br />
[Edit: fixed Store to be data, an liftM that should have been an fmap and added the missing Functor constraint that was present in my actual implementation but didn't make it to the web, and a couple of typos in the implementation of RSIterator, all noted by Clumsy.]</p>
]]></content:encoded>
			<wfw:commentRss>http://comonad.com/reader/2011/free-monads-for-less-3/feed/</wfw:commentRss>
		<slash:comments>9</slash:comments>
		</item>
	</channel>
</rss>

<!-- Localized -->