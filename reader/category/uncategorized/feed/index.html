<?xml version="1.0" encoding="UTF-8"?>
<rss version="2.0"
	xmlns:content="http://purl.org/rss/1.0/modules/content/"
	xmlns:wfw="http://wellformedweb.org/CommentAPI/"
	xmlns:dc="http://purl.org/dc/elements/1.1/"
	xmlns:atom="http://www.w3.org/2005/Atom"
	xmlns:sy="http://purl.org/rss/1.0/modules/syndication/"
	xmlns:slash="http://purl.org/rss/1.0/modules/slash/"
	>

<channel>
	<title>The Comonad.Reader &#187; Uncategorized</title>
	<atom:link href="http://comonad.com/reader/category/uncategorized/feed/" rel="self" type="application/rss+xml" />
	<link>http://comonad.com/reader</link>
	<description>types, (co)monads, substructural logic</description>
	<lastBuildDate>Sun, 23 Sep 2012 03:43:13 +0000</lastBuildDate>
	<generator>http://wordpress.org/?v=2.8.4</generator>
	<language>en</language>
	<sy:updatePeriod>hourly</sy:updatePeriod>
	<sy:updateFrequency>1</sy:updateFrequency>
			<item>
		<title>What Constraints Entail: Part 2</title>
		<link>http://comonad.com/reader/2011/what-constraints-entail-part-2/</link>
		<comments>http://comonad.com/reader/2011/what-constraints-entail-part-2/#comments</comments>
		<pubDate>Thu, 03 Nov 2011 07:23:53 +0000</pubDate>
		<dc:creator>Edward Kmett</dc:creator>
				<category><![CDATA[Constraint Kinds]]></category>
		<category><![CDATA[Haskell]]></category>
		<category><![CDATA[Logic]]></category>
		<category><![CDATA[Monads]]></category>
		<category><![CDATA[Type Hackery]]></category>
		<category><![CDATA[Uncategorized]]></category>

		<guid isPermaLink="false">http://comonad.com/reader/?p=461</guid>
		<description><![CDATA[Last time we derived an entailment relation for constraints, now let's get some use out of it.
Reflecting Classes and Instances
Most of the implications we use on a day to day basis come from our class and instance declarations, but last time we only really dealt with constraint products.

For example given: 
&#160;
#if 0
class Eq a =&#62; [...]]]></description>
			<content:encoded><![CDATA[<p><a href="../../../2011/what-constraints-entail-part-1/index.html">Last time</a> we derived an entailment relation for constraints, now let's get some use out of it.</p>
<h2>Reflecting Classes and Instances</h2>
<p>Most of the implications we use on a day to day basis come from our class and instance declarations, but last time we only really dealt with constraint products.</p>
<p><span id="more-461"></span></p>
<p>For example given: </p>
<pre class="haskell">&nbsp;
#if <span style="color: red;">0</span>
<span style="color: #06c; font-weight: bold;">class</span> <a href="http://haskell.org/ghc/docs/latest/html/libraries/base/Prelude.html#t:Eq"><span style="background-color: #efefbf; font-weight: bold;">Eq</span></a> a =&gt; <a href="http://haskell.org/ghc/docs/latest/html/libraries/base/Prelude.html#t:Ord"><span style="background-color: #efefbf; font-weight: bold;">Ord</span></a> a
<span style="color: #06c; font-weight: bold;">instance</span> <a href="http://haskell.org/ghc/docs/latest/html/libraries/base/Prelude.html#t:Eq"><span style="background-color: #efefbf; font-weight: bold;">Eq</span></a> a =&gt; <a href="http://haskell.org/ghc/docs/latest/html/libraries/base/Prelude.html#t:Eq"><span style="background-color: #efefbf; font-weight: bold;">Eq</span></a> <span style="color: green;">&#91;</span>a<span style="color: green;">&#93;</span>
#endif
&nbsp;</pre>
<p>we could provide the following witnesses</p>
<pre class="haskell">&nbsp;
ordEq :: <a href="http://haskell.org/ghc/docs/latest/html/libraries/base/Prelude.html#t:Ord"><span style="background-color: #efefbf; font-weight: bold;">Ord</span></a> a :- <a href="http://haskell.org/ghc/docs/latest/html/libraries/base/Prelude.html#t:Eq"><span style="background-color: #efefbf; font-weight: bold;">Eq</span></a> a
ordEq = Sub Dict
&nbsp;
eqList :: <a href="http://haskell.org/ghc/docs/latest/html/libraries/base/Prelude.html#t:Eq"><span style="background-color: #efefbf; font-weight: bold;">Eq</span></a> a :- <a href="http://haskell.org/ghc/docs/latest/html/libraries/base/Prelude.html#t:Eq"><span style="background-color: #efefbf; font-weight: bold;">Eq</span></a> <span style="color: green;">&#91;</span>a<span style="color: green;">&#93;</span>
eqList = Sub Dict
&nbsp;</pre>
<p>But this would require a lot of names and become remarkably tedious.</p>
<p>So lets define classes to reflect the entailment provided by class definitions and instance declarations and then use them to reflect themselves.</p>
<pre class="haskell">&nbsp;
<span style="color: #06c; font-weight: bold;">class</span> Class b h | h -&gt; b <span style="color: #06c; font-weight: bold;">where</span>
  cls :: h :- b
&nbsp;
<span style="color: #06c; font-weight: bold;">infixr</span> <span style="color: red;">9</span> :=&gt;
<span style="color: #06c; font-weight: bold;">class</span> b :=&gt; h | h -&gt; b <span style="color: #06c; font-weight: bold;">where</span>
  ins :: b :- h
&nbsp;
<span style="color: #06c; font-weight: bold;">instance</span> Class <span style="color: green;">&#40;</span><span style="color: green;">&#41;</span> <span style="color: green;">&#40;</span>Class b a<span style="color: green;">&#41;</span> <span style="color: #06c; font-weight: bold;">where</span> cls = Sub Dict
<span style="color: #06c; font-weight: bold;">instance</span> Class <span style="color: green;">&#40;</span><span style="color: green;">&#41;</span> <span style="color: green;">&#40;</span>b :=&gt; a<span style="color: green;">&#41;</span> <span style="color: #06c; font-weight: bold;">where</span> cls = Sub Dict
&nbsp;</pre>
<p>Now we can reflect classes and instances as instances of Class and (:=>) respectively with:</p>
<pre class="haskell">&nbsp;
<span style="color: #5d478b; font-style: italic;">-- class Eq a =&gt; Ord a where ...</span>
<span style="color: #06c; font-weight: bold;">instance</span> Class <span style="color: green;">&#40;</span><a href="http://haskell.org/ghc/docs/latest/html/libraries/base/Prelude.html#t:Eq"><span style="background-color: #efefbf; font-weight: bold;">Eq</span></a> a<span style="color: green;">&#41;</span> <span style="color: green;">&#40;</span><a href="http://haskell.org/ghc/docs/latest/html/libraries/base/Prelude.html#t:Ord"><span style="background-color: #efefbf; font-weight: bold;">Ord</span></a> a<span style="color: green;">&#41;</span> <span style="color: #06c; font-weight: bold;">where</span> cls = Sub Dict
<span style="color: #5d478b; font-style: italic;">-- instance Eq a =&gt; Eq [a] where ...</span>
<span style="color: #06c; font-weight: bold;">instance</span> <a href="http://haskell.org/ghc/docs/latest/html/libraries/base/Prelude.html#t:Eq"><span style="background-color: #efefbf; font-weight: bold;">Eq</span></a> a :=&gt; <a href="http://haskell.org/ghc/docs/latest/html/libraries/base/Prelude.html#t:Eq"><span style="background-color: #efefbf; font-weight: bold;">Eq</span></a> <span style="color: green;">&#91;</span>a<span style="color: green;">&#93;</span> <span style="color: #06c; font-weight: bold;">where</span> ins = Sub Dict
&nbsp;</pre>
<p>That said, instances of Class and Instance should never require a context themselves, because the modules that the class and instance declarations live in can't taken one, so we can define the following instances which bootstrap the instances of (:=>) for Class and (:=>) once and for all.</p>
<pre class="haskell">&nbsp;
#ifdef UNDECIDABLE
<span style="color: #06c; font-weight: bold;">instance</span> Class b a =&gt; <span style="color: green;">&#40;</span><span style="color: green;">&#41;</span> :=&gt; Class b a <span style="color: #06c; font-weight: bold;">where</span> ins = Sub Dict
<span style="color: #06c; font-weight: bold;">instance</span> <span style="color: green;">&#40;</span>b :=&gt; a<span style="color: green;">&#41;</span> =&gt; <span style="color: green;">&#40;</span><span style="color: green;">&#41;</span> :=&gt; b :=&gt; a <span style="color: #06c; font-weight: bold;">where</span> ins = Sub Dict
#endif
&nbsp;</pre>
<p>These two instances are both decidable, and following a recent bug fix, the current version of GHC HEAD supports them, but my local version isn't that recent, hence the #ifdef.</p>
<p>We can also give admissable-if-not-ever-stated instances of Class and (:=>) for () as well.</p>
<pre class="haskell">&nbsp;
<span style="color: #06c; font-weight: bold;">instance</span> Class <span style="color: green;">&#40;</span><span style="color: green;">&#41;</span> <span style="color: green;">&#40;</span><span style="color: green;">&#41;</span> <span style="color: #06c; font-weight: bold;">where</span> cls = Sub Dict
<span style="color: #06c; font-weight: bold;">instance</span> <span style="color: green;">&#40;</span><span style="color: green;">&#41;</span> :=&gt; <span style="color: green;">&#40;</span><span style="color: green;">&#41;</span> <span style="color: #06c; font-weight: bold;">where</span> ins = Sub Dict
&nbsp;</pre>
<h2>Reflecting the Prelude</h2>
<p>So now that we've written a handful of instances, lets take the plunge and just reflect the entire Prelude, and (most of) the instances for the other modules we've loaded.</p>
<pre class="haskell">&nbsp;
<span style="color: #06c; font-weight: bold;">instance</span> Class <span style="color: green;">&#40;</span><span style="color: green;">&#41;</span> <span style="color: green;">&#40;</span><a href="http://haskell.org/ghc/docs/latest/html/libraries/base/Prelude.html#t:Eq"><span style="background-color: #efefbf; font-weight: bold;">Eq</span></a> a<span style="color: green;">&#41;</span> <span style="color: #06c; font-weight: bold;">where</span> cls = Sub Dict
<span style="color: #06c; font-weight: bold;">instance</span> <span style="color: green;">&#40;</span><span style="color: green;">&#41;</span> :=&gt; <a href="http://haskell.org/ghc/docs/latest/html/libraries/base/Prelude.html#t:Eq"><span style="background-color: #efefbf; font-weight: bold;">Eq</span></a> <span style="color: green;">&#40;</span><span style="color: green;">&#41;</span> <span style="color: #06c; font-weight: bold;">where</span> ins = Sub Dict
<span style="color: #06c; font-weight: bold;">instance</span> <span style="color: green;">&#40;</span><span style="color: green;">&#41;</span> :=&gt; <a href="http://haskell.org/ghc/docs/latest/html/libraries/base/Prelude.html#t:Eq"><span style="background-color: #efefbf; font-weight: bold;">Eq</span></a> <a href="http://haskell.org/ghc/docs/latest/html/libraries/base/Prelude.html#t:Int"><span style="background-color: #efefbf; font-weight: bold;">Int</span></a> <span style="color: #06c; font-weight: bold;">where</span> ins = Sub Dict
<span style="color: #06c; font-weight: bold;">instance</span> <span style="color: green;">&#40;</span><span style="color: green;">&#41;</span> :=&gt; <a href="http://haskell.org/ghc/docs/latest/html/libraries/base/Prelude.html#t:Eq"><span style="background-color: #efefbf; font-weight: bold;">Eq</span></a> <a href="http://haskell.org/ghc/docs/latest/html/libraries/base/Prelude.html#t:Bool"><span style="background-color: #efefbf; font-weight: bold;">Bool</span></a> <span style="color: #06c; font-weight: bold;">where</span> ins = Sub Dict
<span style="color: #06c; font-weight: bold;">instance</span> <span style="color: green;">&#40;</span><span style="color: green;">&#41;</span> :=&gt; <a href="http://haskell.org/ghc/docs/latest/html/libraries/base/Prelude.html#t:Eq"><span style="background-color: #efefbf; font-weight: bold;">Eq</span></a> <a href="http://haskell.org/ghc/docs/latest/html/libraries/base/Prelude.html#t:Integer"><span style="background-color: #efefbf; font-weight: bold;">Integer</span></a> <span style="color: #06c; font-weight: bold;">where</span> ins = Sub Dict
<span style="color: #06c; font-weight: bold;">instance</span> <span style="color: green;">&#40;</span><span style="color: green;">&#41;</span> :=&gt; <a href="http://haskell.org/ghc/docs/latest/html/libraries/base/Prelude.html#t:Eq"><span style="background-color: #efefbf; font-weight: bold;">Eq</span></a> <a href="http://haskell.org/ghc/docs/latest/html/libraries/base/Prelude.html#t:Float"><span style="background-color: #efefbf; font-weight: bold;">Float</span></a> <span style="color: #06c; font-weight: bold;">where</span> ins = Sub Dict
<span style="color: #06c; font-weight: bold;">instance</span> <span style="color: green;">&#40;</span><span style="color: green;">&#41;</span> :=&gt; <a href="http://haskell.org/ghc/docs/latest/html/libraries/base/Prelude.html#t:Eq"><span style="background-color: #efefbf; font-weight: bold;">Eq</span></a> <a href="http://haskell.org/ghc/docs/latest/html/libraries/base/Prelude.html#t:Double"><span style="background-color: #efefbf; font-weight: bold;">Double</span></a> <span style="color: #06c; font-weight: bold;">where</span> ins = Sub Dict
<span style="color: #06c; font-weight: bold;">instance</span> <a href="http://haskell.org/ghc/docs/latest/html/libraries/base/Prelude.html#t:Eq"><span style="background-color: #efefbf; font-weight: bold;">Eq</span></a> a :=&gt; <a href="http://haskell.org/ghc/docs/latest/html/libraries/base/Prelude.html#t:Eq"><span style="background-color: #efefbf; font-weight: bold;">Eq</span></a> <span style="color: green;">&#91;</span>a<span style="color: green;">&#93;</span> <span style="color: #06c; font-weight: bold;">where</span> ins = Sub Dict
<span style="color: #06c; font-weight: bold;">instance</span> <a href="http://haskell.org/ghc/docs/latest/html/libraries/base/Prelude.html#t:Eq"><span style="background-color: #efefbf; font-weight: bold;">Eq</span></a> a :=&gt; <a href="http://haskell.org/ghc/docs/latest/html/libraries/base/Prelude.html#t:Eq"><span style="background-color: #efefbf; font-weight: bold;">Eq</span></a> <span style="color: green;">&#40;</span><a href="http://haskell.org/ghc/docs/latest/html/libraries/base/Prelude.html#t:Maybe"><span style="background-color: #efefbf; font-weight: bold;">Maybe</span></a> a<span style="color: green;">&#41;</span> <span style="color: #06c; font-weight: bold;">where</span> ins = Sub Dict
<span style="color: #06c; font-weight: bold;">instance</span> <a href="http://haskell.org/ghc/docs/latest/html/libraries/base/Prelude.html#t:Eq"><span style="background-color: #efefbf; font-weight: bold;">Eq</span></a> a :=&gt; <a href="http://haskell.org/ghc/docs/latest/html/libraries/base/Prelude.html#t:Eq"><span style="background-color: #efefbf; font-weight: bold;">Eq</span></a> <span style="color: green;">&#40;</span>Complex a<span style="color: green;">&#41;</span> <span style="color: #06c; font-weight: bold;">where</span> ins = Sub Dict
<span style="color: #06c; font-weight: bold;">instance</span> <a href="http://haskell.org/ghc/docs/latest/html/libraries/base/Prelude.html#t:Eq"><span style="background-color: #efefbf; font-weight: bold;">Eq</span></a> a :=&gt; <a href="http://haskell.org/ghc/docs/latest/html/libraries/base/Prelude.html#t:Eq"><span style="background-color: #efefbf; font-weight: bold;">Eq</span></a> <span style="color: green;">&#40;</span>Ratio a<span style="color: green;">&#41;</span> <span style="color: #06c; font-weight: bold;">where</span> ins = Sub Dict
<span style="color: #06c; font-weight: bold;">instance</span> <span style="color: green;">&#40;</span><a href="http://haskell.org/ghc/docs/latest/html/libraries/base/Prelude.html#t:Eq"><span style="background-color: #efefbf; font-weight: bold;">Eq</span></a> a, <a href="http://haskell.org/ghc/docs/latest/html/libraries/base/Prelude.html#t:Eq"><span style="background-color: #efefbf; font-weight: bold;">Eq</span></a> b<span style="color: green;">&#41;</span> :=&gt; <a href="http://haskell.org/ghc/docs/latest/html/libraries/base/Prelude.html#t:Eq"><span style="background-color: #efefbf; font-weight: bold;">Eq</span></a> <span style="color: green;">&#40;</span>a, b<span style="color: green;">&#41;</span> <span style="color: #06c; font-weight: bold;">where</span> ins = Sub Dict
<span style="color: #06c; font-weight: bold;">instance</span> <span style="color: green;">&#40;</span><a href="http://haskell.org/ghc/docs/latest/html/libraries/base/Prelude.html#t:Eq"><span style="background-color: #efefbf; font-weight: bold;">Eq</span></a> a, <a href="http://haskell.org/ghc/docs/latest/html/libraries/base/Prelude.html#t:Eq"><span style="background-color: #efefbf; font-weight: bold;">Eq</span></a> b<span style="color: green;">&#41;</span> :=&gt; <a href="http://haskell.org/ghc/docs/latest/html/libraries/base/Prelude.html#t:Eq"><span style="background-color: #efefbf; font-weight: bold;">Eq</span></a> <span style="color: green;">&#40;</span><a href="http://haskell.org/ghc/docs/latest/html/libraries/base/Prelude.html#t:Either"><span style="background-color: #efefbf; font-weight: bold;">Either</span></a> a b<span style="color: green;">&#41;</span> <span style="color: #06c; font-weight: bold;">where</span> ins = Sub Dict
<span style="color: #06c; font-weight: bold;">instance</span> <span style="color: green;">&#40;</span><span style="color: green;">&#41;</span> :=&gt; <a href="http://haskell.org/ghc/docs/latest/html/libraries/base/Prelude.html#t:Eq"><span style="background-color: #efefbf; font-weight: bold;">Eq</span></a> <span style="color: green;">&#40;</span>Dict a<span style="color: green;">&#41;</span> <span style="color: #06c; font-weight: bold;">where</span> ins = Sub Dict
<span style="color: #06c; font-weight: bold;">instance</span> <span style="color: green;">&#40;</span><span style="color: green;">&#41;</span> :=&gt; <a href="http://haskell.org/ghc/docs/latest/html/libraries/base/Prelude.html#t:Eq"><span style="background-color: #efefbf; font-weight: bold;">Eq</span></a> <span style="color: green;">&#40;</span>a :- b<span style="color: green;">&#41;</span> <span style="color: #06c; font-weight: bold;">where</span> ins = Sub Dict
&nbsp;</pre>
<pre class="haskell">&nbsp;
<span style="color: #06c; font-weight: bold;">instance</span> Class <span style="color: green;">&#40;</span><a href="http://haskell.org/ghc/docs/latest/html/libraries/base/Prelude.html#t:Eq"><span style="background-color: #efefbf; font-weight: bold;">Eq</span></a> a<span style="color: green;">&#41;</span> <span style="color: green;">&#40;</span><a href="http://haskell.org/ghc/docs/latest/html/libraries/base/Prelude.html#t:Ord"><span style="background-color: #efefbf; font-weight: bold;">Ord</span></a> a<span style="color: green;">&#41;</span> <span style="color: #06c; font-weight: bold;">where</span> cls = Sub Dict
<span style="color: #06c; font-weight: bold;">instance</span> <span style="color: green;">&#40;</span><span style="color: green;">&#41;</span> :=&gt; <a href="http://haskell.org/ghc/docs/latest/html/libraries/base/Prelude.html#t:Ord"><span style="background-color: #efefbf; font-weight: bold;">Ord</span></a> <span style="color: green;">&#40;</span><span style="color: green;">&#41;</span> <span style="color: #06c; font-weight: bold;">where</span> ins = Sub Dict
<span style="color: #06c; font-weight: bold;">instance</span> <span style="color: green;">&#40;</span><span style="color: green;">&#41;</span> :=&gt; <a href="http://haskell.org/ghc/docs/latest/html/libraries/base/Prelude.html#t:Ord"><span style="background-color: #efefbf; font-weight: bold;">Ord</span></a> <a href="http://haskell.org/ghc/docs/latest/html/libraries/base/Prelude.html#t:Bool"><span style="background-color: #efefbf; font-weight: bold;">Bool</span></a> <span style="color: #06c; font-weight: bold;">where</span> ins = Sub Dict
<span style="color: #06c; font-weight: bold;">instance</span> <span style="color: green;">&#40;</span><span style="color: green;">&#41;</span> :=&gt; <a href="http://haskell.org/ghc/docs/latest/html/libraries/base/Prelude.html#t:Ord"><span style="background-color: #efefbf; font-weight: bold;">Ord</span></a> <a href="http://haskell.org/ghc/docs/latest/html/libraries/base/Prelude.html#t:Int"><span style="background-color: #efefbf; font-weight: bold;">Int</span></a> <span style="color: #06c; font-weight: bold;">where</span> ins = Sub Dict
<span style="color: #06c; font-weight: bold;">instance</span> <span style="color: green;">&#40;</span><span style="color: green;">&#41;</span>:=&gt; <a href="http://haskell.org/ghc/docs/latest/html/libraries/base/Prelude.html#t:Ord"><span style="background-color: #efefbf; font-weight: bold;">Ord</span></a> <a href="http://haskell.org/ghc/docs/latest/html/libraries/base/Prelude.html#t:Integer"><span style="background-color: #efefbf; font-weight: bold;">Integer</span></a> <span style="color: #06c; font-weight: bold;">where</span> ins = Sub Dict
<span style="color: #06c; font-weight: bold;">instance</span> <span style="color: green;">&#40;</span><span style="color: green;">&#41;</span> :=&gt; <a href="http://haskell.org/ghc/docs/latest/html/libraries/base/Prelude.html#t:Ord"><span style="background-color: #efefbf; font-weight: bold;">Ord</span></a> <a href="http://haskell.org/ghc/docs/latest/html/libraries/base/Prelude.html#t:Float"><span style="background-color: #efefbf; font-weight: bold;">Float</span></a> <span style="color: #06c; font-weight: bold;">where</span> ins = Sub Dict
<span style="color: #06c; font-weight: bold;">instance</span> <span style="color: green;">&#40;</span><span style="color: green;">&#41;</span>:=&gt; <a href="http://haskell.org/ghc/docs/latest/html/libraries/base/Prelude.html#t:Ord"><span style="background-color: #efefbf; font-weight: bold;">Ord</span></a> <a href="http://haskell.org/ghc/docs/latest/html/libraries/base/Prelude.html#t:Double"><span style="background-color: #efefbf; font-weight: bold;">Double</span></a> <span style="color: #06c; font-weight: bold;">where</span> ins = Sub Dict
<span style="color: #06c; font-weight: bold;">instance</span> <span style="color: green;">&#40;</span><span style="color: green;">&#41;</span> :=&gt; <a href="http://haskell.org/ghc/docs/latest/html/libraries/base/Prelude.html#t:Ord"><span style="background-color: #efefbf; font-weight: bold;">Ord</span></a> <a href="http://haskell.org/ghc/docs/latest/html/libraries/base/Prelude.html#t:Char"><span style="background-color: #efefbf; font-weight: bold;">Char</span></a> <span style="color: #06c; font-weight: bold;">where</span> ins = Sub Dict
<span style="color: #06c; font-weight: bold;">instance</span> <a href="http://haskell.org/ghc/docs/latest/html/libraries/base/Prelude.html#t:Ord"><span style="background-color: #efefbf; font-weight: bold;">Ord</span></a> a :=&gt; <a href="http://haskell.org/ghc/docs/latest/html/libraries/base/Prelude.html#t:Ord"><span style="background-color: #efefbf; font-weight: bold;">Ord</span></a> <span style="color: green;">&#40;</span><a href="http://haskell.org/ghc/docs/latest/html/libraries/base/Prelude.html#t:Maybe"><span style="background-color: #efefbf; font-weight: bold;">Maybe</span></a> a<span style="color: green;">&#41;</span> <span style="color: #06c; font-weight: bold;">where</span> ins = Sub Dict
<span style="color: #06c; font-weight: bold;">instance</span> <a href="http://haskell.org/ghc/docs/latest/html/libraries/base/Prelude.html#t:Ord"><span style="background-color: #efefbf; font-weight: bold;">Ord</span></a> a :=&gt; <a href="http://haskell.org/ghc/docs/latest/html/libraries/base/Prelude.html#t:Ord"><span style="background-color: #efefbf; font-weight: bold;">Ord</span></a> <span style="color: green;">&#91;</span>a<span style="color: green;">&#93;</span> <span style="color: #06c; font-weight: bold;">where</span> ins = Sub Dict
<span style="color: #06c; font-weight: bold;">instance</span> <span style="color: green;">&#40;</span><a href="http://haskell.org/ghc/docs/latest/html/libraries/base/Prelude.html#t:Ord"><span style="background-color: #efefbf; font-weight: bold;">Ord</span></a> a, <a href="http://haskell.org/ghc/docs/latest/html/libraries/base/Prelude.html#t:Ord"><span style="background-color: #efefbf; font-weight: bold;">Ord</span></a> b<span style="color: green;">&#41;</span> :=&gt; <a href="http://haskell.org/ghc/docs/latest/html/libraries/base/Prelude.html#t:Ord"><span style="background-color: #efefbf; font-weight: bold;">Ord</span></a> <span style="color: green;">&#40;</span>a, b<span style="color: green;">&#41;</span> <span style="color: #06c; font-weight: bold;">where</span> ins = Sub Dict
<span style="color: #06c; font-weight: bold;">instance</span> <span style="color: green;">&#40;</span><a href="http://haskell.org/ghc/docs/latest/html/libraries/base/Prelude.html#t:Ord"><span style="background-color: #efefbf; font-weight: bold;">Ord</span></a> a, <a href="http://haskell.org/ghc/docs/latest/html/libraries/base/Prelude.html#t:Ord"><span style="background-color: #efefbf; font-weight: bold;">Ord</span></a> b<span style="color: green;">&#41;</span> :=&gt; <a href="http://haskell.org/ghc/docs/latest/html/libraries/base/Prelude.html#t:Ord"><span style="background-color: #efefbf; font-weight: bold;">Ord</span></a> <span style="color: green;">&#40;</span><a href="http://haskell.org/ghc/docs/latest/html/libraries/base/Prelude.html#t:Either"><span style="background-color: #efefbf; font-weight: bold;">Either</span></a> a b<span style="color: green;">&#41;</span> <span style="color: #06c; font-weight: bold;">where</span> ins = Sub Dict
<span style="color: #06c; font-weight: bold;">instance</span> <a href="http://haskell.org/ghc/docs/latest/html/libraries/base/Prelude.html#t:Integral"><span style="background-color: #efefbf; font-weight: bold;">Integral</span></a> a :=&gt; <a href="http://haskell.org/ghc/docs/latest/html/libraries/base/Prelude.html#t:Ord"><span style="background-color: #efefbf; font-weight: bold;">Ord</span></a> <span style="color: green;">&#40;</span>Ratio a<span style="color: green;">&#41;</span> <span style="color: #06c; font-weight: bold;">where</span> ins = Sub Dict
<span style="color: #06c; font-weight: bold;">instance</span> <span style="color: green;">&#40;</span><span style="color: green;">&#41;</span> :=&gt; <a href="http://haskell.org/ghc/docs/latest/html/libraries/base/Prelude.html#t:Ord"><span style="background-color: #efefbf; font-weight: bold;">Ord</span></a> <span style="color: green;">&#40;</span>Dict a<span style="color: green;">&#41;</span> <span style="color: #06c; font-weight: bold;">where</span> ins = Sub Dict
<span style="color: #06c; font-weight: bold;">instance</span> <span style="color: green;">&#40;</span><span style="color: green;">&#41;</span> :=&gt; <a href="http://haskell.org/ghc/docs/latest/html/libraries/base/Prelude.html#t:Ord"><span style="background-color: #efefbf; font-weight: bold;">Ord</span></a> <span style="color: green;">&#40;</span>a :- b<span style="color: green;">&#41;</span> <span style="color: #06c; font-weight: bold;">where</span> ins = Sub Dict
&nbsp;</pre>
<pre class="haskell">&nbsp;
<span style="color: #06c; font-weight: bold;">instance</span> Class <span style="color: green;">&#40;</span><span style="color: green;">&#41;</span> <span style="color: green;">&#40;</span><a href="http://haskell.org/ghc/docs/latest/html/libraries/base/Prelude.html#t:Show"><span style="background-color: #efefbf; font-weight: bold;">Show</span></a> a<span style="color: green;">&#41;</span> <span style="color: #06c; font-weight: bold;">where</span> cls = Sub Dict
<span style="color: #06c; font-weight: bold;">instance</span> <span style="color: green;">&#40;</span><span style="color: green;">&#41;</span> :=&gt; <a href="http://haskell.org/ghc/docs/latest/html/libraries/base/Prelude.html#t:Show"><span style="background-color: #efefbf; font-weight: bold;">Show</span></a> <span style="color: green;">&#40;</span><span style="color: green;">&#41;</span> <span style="color: #06c; font-weight: bold;">where</span> ins = Sub Dict
<span style="color: #06c; font-weight: bold;">instance</span> <span style="color: green;">&#40;</span><span style="color: green;">&#41;</span> :=&gt; <a href="http://haskell.org/ghc/docs/latest/html/libraries/base/Prelude.html#t:Show"><span style="background-color: #efefbf; font-weight: bold;">Show</span></a> <a href="http://haskell.org/ghc/docs/latest/html/libraries/base/Prelude.html#t:Bool"><span style="background-color: #efefbf; font-weight: bold;">Bool</span></a> <span style="color: #06c; font-weight: bold;">where</span> ins = Sub Dict
<span style="color: #06c; font-weight: bold;">instance</span> <span style="color: green;">&#40;</span><span style="color: green;">&#41;</span> :=&gt; <a href="http://haskell.org/ghc/docs/latest/html/libraries/base/Prelude.html#t:Show"><span style="background-color: #efefbf; font-weight: bold;">Show</span></a> <a href="http://haskell.org/ghc/docs/latest/html/libraries/base/Prelude.html#t:Ordering"><span style="background-color: #efefbf; font-weight: bold;">Ordering</span></a> <span style="color: #06c; font-weight: bold;">where</span> ins = Sub Dict
<span style="color: #06c; font-weight: bold;">instance</span> <span style="color: green;">&#40;</span><span style="color: green;">&#41;</span> :=&gt; <a href="http://haskell.org/ghc/docs/latest/html/libraries/base/Prelude.html#t:Show"><span style="background-color: #efefbf; font-weight: bold;">Show</span></a> <a href="http://haskell.org/ghc/docs/latest/html/libraries/base/Prelude.html#t:Char"><span style="background-color: #efefbf; font-weight: bold;">Char</span></a> <span style="color: #06c; font-weight: bold;">where</span> ins = Sub Dict
<span style="color: #06c; font-weight: bold;">instance</span> <a href="http://haskell.org/ghc/docs/latest/html/libraries/base/Prelude.html#t:Show"><span style="background-color: #efefbf; font-weight: bold;">Show</span></a> a :=&gt; <a href="http://haskell.org/ghc/docs/latest/html/libraries/base/Prelude.html#t:Show"><span style="background-color: #efefbf; font-weight: bold;">Show</span></a> <span style="color: green;">&#40;</span>Complex a<span style="color: green;">&#41;</span> <span style="color: #06c; font-weight: bold;">where</span> ins = Sub Dict
<span style="color: #06c; font-weight: bold;">instance</span> <a href="http://haskell.org/ghc/docs/latest/html/libraries/base/Prelude.html#t:Show"><span style="background-color: #efefbf; font-weight: bold;">Show</span></a> a :=&gt; <a href="http://haskell.org/ghc/docs/latest/html/libraries/base/Prelude.html#t:Show"><span style="background-color: #efefbf; font-weight: bold;">Show</span></a> <span style="color: green;">&#91;</span>a<span style="color: green;">&#93;</span> <span style="color: #06c; font-weight: bold;">where</span> ins = Sub Dict
<span style="color: #06c; font-weight: bold;">instance</span> <a href="http://haskell.org/ghc/docs/latest/html/libraries/base/Prelude.html#t:Show"><span style="background-color: #efefbf; font-weight: bold;">Show</span></a> a :=&gt; <a href="http://haskell.org/ghc/docs/latest/html/libraries/base/Prelude.html#t:Show"><span style="background-color: #efefbf; font-weight: bold;">Show</span></a> <span style="color: green;">&#40;</span><a href="http://haskell.org/ghc/docs/latest/html/libraries/base/Prelude.html#t:Maybe"><span style="background-color: #efefbf; font-weight: bold;">Maybe</span></a> a<span style="color: green;">&#41;</span> <span style="color: #06c; font-weight: bold;">where</span> ins = Sub Dict
<span style="color: #06c; font-weight: bold;">instance</span> <span style="color: green;">&#40;</span><a href="http://haskell.org/ghc/docs/latest/html/libraries/base/Prelude.html#t:Show"><span style="background-color: #efefbf; font-weight: bold;">Show</span></a> a, <a href="http://haskell.org/ghc/docs/latest/html/libraries/base/Prelude.html#t:Show"><span style="background-color: #efefbf; font-weight: bold;">Show</span></a> b<span style="color: green;">&#41;</span> :=&gt; <a href="http://haskell.org/ghc/docs/latest/html/libraries/base/Prelude.html#t:Show"><span style="background-color: #efefbf; font-weight: bold;">Show</span></a> <span style="color: green;">&#40;</span>a, b<span style="color: green;">&#41;</span> <span style="color: #06c; font-weight: bold;">where</span> ins = Sub Dict
<span style="color: #06c; font-weight: bold;">instance</span> <span style="color: green;">&#40;</span><a href="http://haskell.org/ghc/docs/latest/html/libraries/base/Prelude.html#t:Show"><span style="background-color: #efefbf; font-weight: bold;">Show</span></a> a, <a href="http://haskell.org/ghc/docs/latest/html/libraries/base/Prelude.html#t:Show"><span style="background-color: #efefbf; font-weight: bold;">Show</span></a> b<span style="color: green;">&#41;</span> :=&gt; <a href="http://haskell.org/ghc/docs/latest/html/libraries/base/Prelude.html#t:Show"><span style="background-color: #efefbf; font-weight: bold;">Show</span></a> <span style="color: green;">&#40;</span><a href="http://haskell.org/ghc/docs/latest/html/libraries/base/Prelude.html#t:Either"><span style="background-color: #efefbf; font-weight: bold;">Either</span></a> a b<span style="color: green;">&#41;</span> <span style="color: #06c; font-weight: bold;">where</span> ins = Sub Dict
<span style="color: #06c; font-weight: bold;">instance</span> <span style="color: green;">&#40;</span><a href="http://haskell.org/ghc/docs/latest/html/libraries/base/Prelude.html#t:Integral"><span style="background-color: #efefbf; font-weight: bold;">Integral</span></a> a, <a href="http://haskell.org/ghc/docs/latest/html/libraries/base/Prelude.html#t:Show"><span style="background-color: #efefbf; font-weight: bold;">Show</span></a> a<span style="color: green;">&#41;</span> :=&gt; <a href="http://haskell.org/ghc/docs/latest/html/libraries/base/Prelude.html#t:Show"><span style="background-color: #efefbf; font-weight: bold;">Show</span></a> <span style="color: green;">&#40;</span>Ratio a<span style="color: green;">&#41;</span> <span style="color: #06c; font-weight: bold;">where</span> ins = Sub Dict
<span style="color: #06c; font-weight: bold;">instance</span> <span style="color: green;">&#40;</span><span style="color: green;">&#41;</span> :=&gt; <a href="http://haskell.org/ghc/docs/latest/html/libraries/base/Prelude.html#t:Show"><span style="background-color: #efefbf; font-weight: bold;">Show</span></a> <span style="color: green;">&#40;</span>Dict a<span style="color: green;">&#41;</span> <span style="color: #06c; font-weight: bold;">where</span> ins = Sub Dict
<span style="color: #06c; font-weight: bold;">instance</span> <span style="color: green;">&#40;</span><span style="color: green;">&#41;</span> :=&gt; <a href="http://haskell.org/ghc/docs/latest/html/libraries/base/Prelude.html#t:Show"><span style="background-color: #efefbf; font-weight: bold;">Show</span></a> <span style="color: green;">&#40;</span>a :- b<span style="color: green;">&#41;</span> <span style="color: #06c; font-weight: bold;">where</span> ins = Sub Dict
&nbsp;</pre>
<pre class="haskell">&nbsp;
<span style="color: #06c; font-weight: bold;">instance</span> Class <span style="color: green;">&#40;</span><span style="color: green;">&#41;</span> <span style="color: green;">&#40;</span><a href="http://haskell.org/ghc/docs/latest/html/libraries/base/Prelude.html#t:Read"><span style="background-color: #efefbf; font-weight: bold;">Read</span></a> a<span style="color: green;">&#41;</span> <span style="color: #06c; font-weight: bold;">where</span> cls = Sub Dict
<span style="color: #06c; font-weight: bold;">instance</span> <span style="color: green;">&#40;</span><span style="color: green;">&#41;</span> :=&gt; <a href="http://haskell.org/ghc/docs/latest/html/libraries/base/Prelude.html#t:Read"><span style="background-color: #efefbf; font-weight: bold;">Read</span></a> <span style="color: green;">&#40;</span><span style="color: green;">&#41;</span> <span style="color: #06c; font-weight: bold;">where</span> ins = Sub Dict
<span style="color: #06c; font-weight: bold;">instance</span> <span style="color: green;">&#40;</span><span style="color: green;">&#41;</span> :=&gt; <a href="http://haskell.org/ghc/docs/latest/html/libraries/base/Prelude.html#t:Read"><span style="background-color: #efefbf; font-weight: bold;">Read</span></a> <a href="http://haskell.org/ghc/docs/latest/html/libraries/base/Prelude.html#t:Bool"><span style="background-color: #efefbf; font-weight: bold;">Bool</span></a> <span style="color: #06c; font-weight: bold;">where</span> ins = Sub Dict
<span style="color: #06c; font-weight: bold;">instance</span> <span style="color: green;">&#40;</span><span style="color: green;">&#41;</span> :=&gt; <a href="http://haskell.org/ghc/docs/latest/html/libraries/base/Prelude.html#t:Read"><span style="background-color: #efefbf; font-weight: bold;">Read</span></a> <a href="http://haskell.org/ghc/docs/latest/html/libraries/base/Prelude.html#t:Ordering"><span style="background-color: #efefbf; font-weight: bold;">Ordering</span></a> <span style="color: #06c; font-weight: bold;">where</span> ins = Sub Dict
<span style="color: #06c; font-weight: bold;">instance</span> <span style="color: green;">&#40;</span><span style="color: green;">&#41;</span> :=&gt; <a href="http://haskell.org/ghc/docs/latest/html/libraries/base/Prelude.html#t:Read"><span style="background-color: #efefbf; font-weight: bold;">Read</span></a> <a href="http://haskell.org/ghc/docs/latest/html/libraries/base/Prelude.html#t:Char"><span style="background-color: #efefbf; font-weight: bold;">Char</span></a> <span style="color: #06c; font-weight: bold;">where</span> ins = Sub Dict
<span style="color: #06c; font-weight: bold;">instance</span> <a href="http://haskell.org/ghc/docs/latest/html/libraries/base/Prelude.html#t:Read"><span style="background-color: #efefbf; font-weight: bold;">Read</span></a> a :=&gt; <a href="http://haskell.org/ghc/docs/latest/html/libraries/base/Prelude.html#t:Read"><span style="background-color: #efefbf; font-weight: bold;">Read</span></a> <span style="color: green;">&#40;</span>Complex a<span style="color: green;">&#41;</span> <span style="color: #06c; font-weight: bold;">where</span> ins = Sub Dict
<span style="color: #06c; font-weight: bold;">instance</span> <a href="http://haskell.org/ghc/docs/latest/html/libraries/base/Prelude.html#t:Read"><span style="background-color: #efefbf; font-weight: bold;">Read</span></a> a :=&gt; <a href="http://haskell.org/ghc/docs/latest/html/libraries/base/Prelude.html#t:Read"><span style="background-color: #efefbf; font-weight: bold;">Read</span></a> <span style="color: green;">&#91;</span>a<span style="color: green;">&#93;</span> <span style="color: #06c; font-weight: bold;">where</span> ins = Sub Dict
<span style="color: #06c; font-weight: bold;">instance</span> <a href="http://haskell.org/ghc/docs/latest/html/libraries/base/Prelude.html#t:Read"><span style="background-color: #efefbf; font-weight: bold;">Read</span></a> a :=&gt; <a href="http://haskell.org/ghc/docs/latest/html/libraries/base/Prelude.html#t:Read"><span style="background-color: #efefbf; font-weight: bold;">Read</span></a> <span style="color: green;">&#40;</span><a href="http://haskell.org/ghc/docs/latest/html/libraries/base/Prelude.html#t:Maybe"><span style="background-color: #efefbf; font-weight: bold;">Maybe</span></a> a<span style="color: green;">&#41;</span> <span style="color: #06c; font-weight: bold;">where</span> ins = Sub Dict
<span style="color: #06c; font-weight: bold;">instance</span> <span style="color: green;">&#40;</span><a href="http://haskell.org/ghc/docs/latest/html/libraries/base/Prelude.html#t:Read"><span style="background-color: #efefbf; font-weight: bold;">Read</span></a> a, <a href="http://haskell.org/ghc/docs/latest/html/libraries/base/Prelude.html#t:Read"><span style="background-color: #efefbf; font-weight: bold;">Read</span></a> b<span style="color: green;">&#41;</span> :=&gt; <a href="http://haskell.org/ghc/docs/latest/html/libraries/base/Prelude.html#t:Read"><span style="background-color: #efefbf; font-weight: bold;">Read</span></a> <span style="color: green;">&#40;</span>a, b<span style="color: green;">&#41;</span> <span style="color: #06c; font-weight: bold;">where</span> ins = Sub Dict
<span style="color: #06c; font-weight: bold;">instance</span> <span style="color: green;">&#40;</span><a href="http://haskell.org/ghc/docs/latest/html/libraries/base/Prelude.html#t:Read"><span style="background-color: #efefbf; font-weight: bold;">Read</span></a> a, <a href="http://haskell.org/ghc/docs/latest/html/libraries/base/Prelude.html#t:Read"><span style="background-color: #efefbf; font-weight: bold;">Read</span></a> b<span style="color: green;">&#41;</span> :=&gt; <a href="http://haskell.org/ghc/docs/latest/html/libraries/base/Prelude.html#t:Read"><span style="background-color: #efefbf; font-weight: bold;">Read</span></a> <span style="color: green;">&#40;</span><a href="http://haskell.org/ghc/docs/latest/html/libraries/base/Prelude.html#t:Either"><span style="background-color: #efefbf; font-weight: bold;">Either</span></a> a b<span style="color: green;">&#41;</span> <span style="color: #06c; font-weight: bold;">where</span> ins = Sub Dict
<span style="color: #06c; font-weight: bold;">instance</span> <span style="color: green;">&#40;</span><a href="http://haskell.org/ghc/docs/latest/html/libraries/base/Prelude.html#t:Integral"><span style="background-color: #efefbf; font-weight: bold;">Integral</span></a> a, <a href="http://haskell.org/ghc/docs/latest/html/libraries/base/Prelude.html#t:Read"><span style="background-color: #efefbf; font-weight: bold;">Read</span></a> a<span style="color: green;">&#41;</span> :=&gt; <a href="http://haskell.org/ghc/docs/latest/html/libraries/base/Prelude.html#t:Read"><span style="background-color: #efefbf; font-weight: bold;">Read</span></a> <span style="color: green;">&#40;</span>Ratio a<span style="color: green;">&#41;</span> <span style="color: #06c; font-weight: bold;">where</span> ins = Sub Dict
&nbsp;</pre>
<pre class="haskell">&nbsp;
<span style="color: #06c; font-weight: bold;">instance</span> Class <span style="color: green;">&#40;</span><span style="color: green;">&#41;</span> <span style="color: green;">&#40;</span><a href="http://haskell.org/ghc/docs/latest/html/libraries/base/Prelude.html#t:Enum"><span style="background-color: #efefbf; font-weight: bold;">Enum</span></a> a<span style="color: green;">&#41;</span> <span style="color: #06c; font-weight: bold;">where</span> cls = Sub Dict
<span style="color: #06c; font-weight: bold;">instance</span> <span style="color: green;">&#40;</span><span style="color: green;">&#41;</span> :=&gt; <a href="http://haskell.org/ghc/docs/latest/html/libraries/base/Prelude.html#t:Enum"><span style="background-color: #efefbf; font-weight: bold;">Enum</span></a> <span style="color: green;">&#40;</span><span style="color: green;">&#41;</span> <span style="color: #06c; font-weight: bold;">where</span> ins = Sub Dict
<span style="color: #06c; font-weight: bold;">instance</span> <span style="color: green;">&#40;</span><span style="color: green;">&#41;</span> :=&gt; <a href="http://haskell.org/ghc/docs/latest/html/libraries/base/Prelude.html#t:Enum"><span style="background-color: #efefbf; font-weight: bold;">Enum</span></a> <a href="http://haskell.org/ghc/docs/latest/html/libraries/base/Prelude.html#t:Bool"><span style="background-color: #efefbf; font-weight: bold;">Bool</span></a> <span style="color: #06c; font-weight: bold;">where</span> ins = Sub Dict
<span style="color: #06c; font-weight: bold;">instance</span> <span style="color: green;">&#40;</span><span style="color: green;">&#41;</span> :=&gt; <a href="http://haskell.org/ghc/docs/latest/html/libraries/base/Prelude.html#t:Enum"><span style="background-color: #efefbf; font-weight: bold;">Enum</span></a> <a href="http://haskell.org/ghc/docs/latest/html/libraries/base/Prelude.html#t:Ordering"><span style="background-color: #efefbf; font-weight: bold;">Ordering</span></a> <span style="color: #06c; font-weight: bold;">where</span> ins = Sub Dict
<span style="color: #06c; font-weight: bold;">instance</span> <span style="color: green;">&#40;</span><span style="color: green;">&#41;</span> :=&gt; <a href="http://haskell.org/ghc/docs/latest/html/libraries/base/Prelude.html#t:Enum"><span style="background-color: #efefbf; font-weight: bold;">Enum</span></a> <a href="http://haskell.org/ghc/docs/latest/html/libraries/base/Prelude.html#t:Char"><span style="background-color: #efefbf; font-weight: bold;">Char</span></a> <span style="color: #06c; font-weight: bold;">where</span> ins = Sub Dict
<span style="color: #06c; font-weight: bold;">instance</span> <span style="color: green;">&#40;</span><span style="color: green;">&#41;</span> :=&gt; <a href="http://haskell.org/ghc/docs/latest/html/libraries/base/Prelude.html#t:Enum"><span style="background-color: #efefbf; font-weight: bold;">Enum</span></a> <a href="http://haskell.org/ghc/docs/latest/html/libraries/base/Prelude.html#t:Int"><span style="background-color: #efefbf; font-weight: bold;">Int</span></a> <span style="color: #06c; font-weight: bold;">where</span> ins = Sub Dict
<span style="color: #06c; font-weight: bold;">instance</span> <span style="color: green;">&#40;</span><span style="color: green;">&#41;</span> :=&gt; <a href="http://haskell.org/ghc/docs/latest/html/libraries/base/Prelude.html#t:Enum"><span style="background-color: #efefbf; font-weight: bold;">Enum</span></a> <a href="http://haskell.org/ghc/docs/latest/html/libraries/base/Prelude.html#t:Integer"><span style="background-color: #efefbf; font-weight: bold;">Integer</span></a> <span style="color: #06c; font-weight: bold;">where</span> ins = Sub Dict
<span style="color: #06c; font-weight: bold;">instance</span> <span style="color: green;">&#40;</span><span style="color: green;">&#41;</span> :=&gt; <a href="http://haskell.org/ghc/docs/latest/html/libraries/base/Prelude.html#t:Enum"><span style="background-color: #efefbf; font-weight: bold;">Enum</span></a> <a href="http://haskell.org/ghc/docs/latest/html/libraries/base/Prelude.html#t:Float"><span style="background-color: #efefbf; font-weight: bold;">Float</span></a> <span style="color: #06c; font-weight: bold;">where</span> ins = Sub Dict
<span style="color: #06c; font-weight: bold;">instance</span> <span style="color: green;">&#40;</span><span style="color: green;">&#41;</span> :=&gt; <a href="http://haskell.org/ghc/docs/latest/html/libraries/base/Prelude.html#t:Enum"><span style="background-color: #efefbf; font-weight: bold;">Enum</span></a> <a href="http://haskell.org/ghc/docs/latest/html/libraries/base/Prelude.html#t:Double"><span style="background-color: #efefbf; font-weight: bold;">Double</span></a> <span style="color: #06c; font-weight: bold;">where</span> ins = Sub Dict
<span style="color: #06c; font-weight: bold;">instance</span> <a href="http://haskell.org/ghc/docs/latest/html/libraries/base/Prelude.html#t:Integral"><span style="background-color: #efefbf; font-weight: bold;">Integral</span></a> a :=&gt; <a href="http://haskell.org/ghc/docs/latest/html/libraries/base/Prelude.html#t:Enum"><span style="background-color: #efefbf; font-weight: bold;">Enum</span></a> <span style="color: green;">&#40;</span>Ratio a<span style="color: green;">&#41;</span> <span style="color: #06c; font-weight: bold;">where</span> ins = Sub Dict
&nbsp;</pre>
<pre class="haskell">&nbsp;
<span style="color: #06c; font-weight: bold;">instance</span> Class <span style="color: green;">&#40;</span><span style="color: green;">&#41;</span> <span style="color: green;">&#40;</span><a href="http://haskell.org/ghc/docs/latest/html/libraries/base/Prelude.html#t:Bounded"><span style="background-color: #efefbf; font-weight: bold;">Bounded</span></a> a<span style="color: green;">&#41;</span> <span style="color: #06c; font-weight: bold;">where</span> cls = Sub Dict
<span style="color: #06c; font-weight: bold;">instance</span> <span style="color: green;">&#40;</span><span style="color: green;">&#41;</span> :=&gt; <a href="http://haskell.org/ghc/docs/latest/html/libraries/base/Prelude.html#t:Bounded"><span style="background-color: #efefbf; font-weight: bold;">Bounded</span></a> <span style="color: green;">&#40;</span><span style="color: green;">&#41;</span> <span style="color: #06c; font-weight: bold;">where</span> ins = Sub Dict
<span style="color: #06c; font-weight: bold;">instance</span> <span style="color: green;">&#40;</span><span style="color: green;">&#41;</span> :=&gt; <a href="http://haskell.org/ghc/docs/latest/html/libraries/base/Prelude.html#t:Bounded"><span style="background-color: #efefbf; font-weight: bold;">Bounded</span></a> <a href="http://haskell.org/ghc/docs/latest/html/libraries/base/Prelude.html#t:Ordering"><span style="background-color: #efefbf; font-weight: bold;">Ordering</span></a> <span style="color: #06c; font-weight: bold;">where</span> ins = Sub Dict
<span style="color: #06c; font-weight: bold;">instance</span> <span style="color: green;">&#40;</span><span style="color: green;">&#41;</span> :=&gt; <a href="http://haskell.org/ghc/docs/latest/html/libraries/base/Prelude.html#t:Bounded"><span style="background-color: #efefbf; font-weight: bold;">Bounded</span></a> <a href="http://haskell.org/ghc/docs/latest/html/libraries/base/Prelude.html#t:Bool"><span style="background-color: #efefbf; font-weight: bold;">Bool</span></a> <span style="color: #06c; font-weight: bold;">where</span> ins = Sub Dict
<span style="color: #06c; font-weight: bold;">instance</span> <span style="color: green;">&#40;</span><span style="color: green;">&#41;</span> :=&gt; <a href="http://haskell.org/ghc/docs/latest/html/libraries/base/Prelude.html#t:Bounded"><span style="background-color: #efefbf; font-weight: bold;">Bounded</span></a> <a href="http://haskell.org/ghc/docs/latest/html/libraries/base/Prelude.html#t:Int"><span style="background-color: #efefbf; font-weight: bold;">Int</span></a> <span style="color: #06c; font-weight: bold;">where</span> ins = Sub Dict
<span style="color: #06c; font-weight: bold;">instance</span> <span style="color: green;">&#40;</span><span style="color: green;">&#41;</span> :=&gt; <a href="http://haskell.org/ghc/docs/latest/html/libraries/base/Prelude.html#t:Bounded"><span style="background-color: #efefbf; font-weight: bold;">Bounded</span></a> <a href="http://haskell.org/ghc/docs/latest/html/libraries/base/Prelude.html#t:Char"><span style="background-color: #efefbf; font-weight: bold;">Char</span></a> <span style="color: #06c; font-weight: bold;">where</span> ins = Sub Dict
<span style="color: #06c; font-weight: bold;">instance</span> <span style="color: green;">&#40;</span><a href="http://haskell.org/ghc/docs/latest/html/libraries/base/Prelude.html#t:Bounded"><span style="background-color: #efefbf; font-weight: bold;">Bounded</span></a> a, <a href="http://haskell.org/ghc/docs/latest/html/libraries/base/Prelude.html#t:Bounded"><span style="background-color: #efefbf; font-weight: bold;">Bounded</span></a> b<span style="color: green;">&#41;</span> :=&gt; <a href="http://haskell.org/ghc/docs/latest/html/libraries/base/Prelude.html#t:Bounded"><span style="background-color: #efefbf; font-weight: bold;">Bounded</span></a> <span style="color: green;">&#40;</span>a,b<span style="color: green;">&#41;</span> <span style="color: #06c; font-weight: bold;">where</span> ins = Sub Dict
&nbsp;</pre>
<pre class="haskell">&nbsp;
<span style="color: #06c; font-weight: bold;">instance</span> Class <span style="color: green;">&#40;</span><span style="color: green;">&#41;</span> <span style="color: green;">&#40;</span><a href="http://haskell.org/ghc/docs/latest/html/libraries/base/Prelude.html#t:Num"><span style="background-color: #efefbf; font-weight: bold;">Num</span></a> a<span style="color: green;">&#41;</span> <span style="color: #06c; font-weight: bold;">where</span> cls = Sub Dict
<span style="color: #06c; font-weight: bold;">instance</span> <span style="color: green;">&#40;</span><span style="color: green;">&#41;</span> :=&gt; <a href="http://haskell.org/ghc/docs/latest/html/libraries/base/Prelude.html#t:Num"><span style="background-color: #efefbf; font-weight: bold;">Num</span></a> <a href="http://haskell.org/ghc/docs/latest/html/libraries/base/Prelude.html#t:Int"><span style="background-color: #efefbf; font-weight: bold;">Int</span></a> <span style="color: #06c; font-weight: bold;">where</span> ins = Sub Dict
<span style="color: #06c; font-weight: bold;">instance</span> <span style="color: green;">&#40;</span><span style="color: green;">&#41;</span> :=&gt; <a href="http://haskell.org/ghc/docs/latest/html/libraries/base/Prelude.html#t:Num"><span style="background-color: #efefbf; font-weight: bold;">Num</span></a> <a href="http://haskell.org/ghc/docs/latest/html/libraries/base/Prelude.html#t:Integer"><span style="background-color: #efefbf; font-weight: bold;">Integer</span></a> <span style="color: #06c; font-weight: bold;">where</span> ins = Sub Dict
<span style="color: #06c; font-weight: bold;">instance</span> <span style="color: green;">&#40;</span><span style="color: green;">&#41;</span> :=&gt; <a href="http://haskell.org/ghc/docs/latest/html/libraries/base/Prelude.html#t:Num"><span style="background-color: #efefbf; font-weight: bold;">Num</span></a> <a href="http://haskell.org/ghc/docs/latest/html/libraries/base/Prelude.html#t:Float"><span style="background-color: #efefbf; font-weight: bold;">Float</span></a> <span style="color: #06c; font-weight: bold;">where</span> ins = Sub Dict
<span style="color: #06c; font-weight: bold;">instance</span> <span style="color: green;">&#40;</span><span style="color: green;">&#41;</span> :=&gt; <a href="http://haskell.org/ghc/docs/latest/html/libraries/base/Prelude.html#t:Num"><span style="background-color: #efefbf; font-weight: bold;">Num</span></a> <a href="http://haskell.org/ghc/docs/latest/html/libraries/base/Prelude.html#t:Double"><span style="background-color: #efefbf; font-weight: bold;">Double</span></a> <span style="color: #06c; font-weight: bold;">where</span> ins = Sub Dict
<span style="color: #06c; font-weight: bold;">instance</span> <a href="http://haskell.org/ghc/docs/latest/html/libraries/base/Prelude.html#t:RealFloat"><span style="background-color: #efefbf; font-weight: bold;">RealFloat</span></a> a :=&gt; <a href="http://haskell.org/ghc/docs/latest/html/libraries/base/Prelude.html#t:Num"><span style="background-color: #efefbf; font-weight: bold;">Num</span></a> <span style="color: green;">&#40;</span>Complex a<span style="color: green;">&#41;</span> <span style="color: #06c; font-weight: bold;">where</span> ins = Sub Dict
<span style="color: #06c; font-weight: bold;">instance</span> <a href="http://haskell.org/ghc/docs/latest/html/libraries/base/Prelude.html#t:Integral"><span style="background-color: #efefbf; font-weight: bold;">Integral</span></a> a :=&gt; <a href="http://haskell.org/ghc/docs/latest/html/libraries/base/Prelude.html#t:Num"><span style="background-color: #efefbf; font-weight: bold;">Num</span></a> <span style="color: green;">&#40;</span>Ratio a<span style="color: green;">&#41;</span> <span style="color: #06c; font-weight: bold;">where</span> ins = Sub Dict
&nbsp;</pre>
<pre class="haskell">&nbsp;
<span style="color: #06c; font-weight: bold;">instance</span> Class <span style="color: green;">&#40;</span><a href="http://haskell.org/ghc/docs/latest/html/libraries/base/Prelude.html#t:Num"><span style="background-color: #efefbf; font-weight: bold;">Num</span></a> a, <a href="http://haskell.org/ghc/docs/latest/html/libraries/base/Prelude.html#t:Ord"><span style="background-color: #efefbf; font-weight: bold;">Ord</span></a> a<span style="color: green;">&#41;</span> <span style="color: green;">&#40;</span><a href="http://haskell.org/ghc/docs/latest/html/libraries/base/Prelude.html#t:Real"><span style="background-color: #efefbf; font-weight: bold;">Real</span></a> a<span style="color: green;">&#41;</span> <span style="color: #06c; font-weight: bold;">where</span> cls = Sub Dict
<span style="color: #06c; font-weight: bold;">instance</span> <span style="color: green;">&#40;</span><span style="color: green;">&#41;</span> :=&gt; <a href="http://haskell.org/ghc/docs/latest/html/libraries/base/Prelude.html#t:Real"><span style="background-color: #efefbf; font-weight: bold;">Real</span></a> <a href="http://haskell.org/ghc/docs/latest/html/libraries/base/Prelude.html#t:Int"><span style="background-color: #efefbf; font-weight: bold;">Int</span></a> <span style="color: #06c; font-weight: bold;">where</span> ins = Sub Dict
<span style="color: #06c; font-weight: bold;">instance</span> <span style="color: green;">&#40;</span><span style="color: green;">&#41;</span> :=&gt; <a href="http://haskell.org/ghc/docs/latest/html/libraries/base/Prelude.html#t:Real"><span style="background-color: #efefbf; font-weight: bold;">Real</span></a> <a href="http://haskell.org/ghc/docs/latest/html/libraries/base/Prelude.html#t:Integer"><span style="background-color: #efefbf; font-weight: bold;">Integer</span></a> <span style="color: #06c; font-weight: bold;">where</span> ins = Sub Dict
<span style="color: #06c; font-weight: bold;">instance</span> <span style="color: green;">&#40;</span><span style="color: green;">&#41;</span> :=&gt; <a href="http://haskell.org/ghc/docs/latest/html/libraries/base/Prelude.html#t:Real"><span style="background-color: #efefbf; font-weight: bold;">Real</span></a> <a href="http://haskell.org/ghc/docs/latest/html/libraries/base/Prelude.html#t:Float"><span style="background-color: #efefbf; font-weight: bold;">Float</span></a> <span style="color: #06c; font-weight: bold;">where</span> ins = Sub Dict
<span style="color: #06c; font-weight: bold;">instance</span> <span style="color: green;">&#40;</span><span style="color: green;">&#41;</span> :=&gt; <a href="http://haskell.org/ghc/docs/latest/html/libraries/base/Prelude.html#t:Real"><span style="background-color: #efefbf; font-weight: bold;">Real</span></a> <a href="http://haskell.org/ghc/docs/latest/html/libraries/base/Prelude.html#t:Double"><span style="background-color: #efefbf; font-weight: bold;">Double</span></a> <span style="color: #06c; font-weight: bold;">where</span> ins = Sub Dict
<span style="color: #06c; font-weight: bold;">instance</span> <a href="http://haskell.org/ghc/docs/latest/html/libraries/base/Prelude.html#t:Integral"><span style="background-color: #efefbf; font-weight: bold;">Integral</span></a> a :=&gt; <a href="http://haskell.org/ghc/docs/latest/html/libraries/base/Prelude.html#t:Real"><span style="background-color: #efefbf; font-weight: bold;">Real</span></a> <span style="color: green;">&#40;</span>Ratio a<span style="color: green;">&#41;</span> <span style="color: #06c; font-weight: bold;">where</span> ins = Sub Dict
&nbsp;</pre>
<pre class="haskell">&nbsp;
<span style="color: #06c; font-weight: bold;">instance</span> Class <span style="color: green;">&#40;</span><a href="http://haskell.org/ghc/docs/latest/html/libraries/base/Prelude.html#t:Real"><span style="background-color: #efefbf; font-weight: bold;">Real</span></a> a, <a href="http://haskell.org/ghc/docs/latest/html/libraries/base/Prelude.html#t:Enum"><span style="background-color: #efefbf; font-weight: bold;">Enum</span></a> a<span style="color: green;">&#41;</span> <span style="color: green;">&#40;</span><a href="http://haskell.org/ghc/docs/latest/html/libraries/base/Prelude.html#t:Integral"><span style="background-color: #efefbf; font-weight: bold;">Integral</span></a> a<span style="color: green;">&#41;</span> <span style="color: #06c; font-weight: bold;">where</span> cls = Sub Dict
<span style="color: #06c; font-weight: bold;">instance</span> <span style="color: green;">&#40;</span><span style="color: green;">&#41;</span> :=&gt; <a href="http://haskell.org/ghc/docs/latest/html/libraries/base/Prelude.html#t:Integral"><span style="background-color: #efefbf; font-weight: bold;">Integral</span></a> <a href="http://haskell.org/ghc/docs/latest/html/libraries/base/Prelude.html#t:Int"><span style="background-color: #efefbf; font-weight: bold;">Int</span></a> <span style="color: #06c; font-weight: bold;">where</span> ins = Sub Dict
<span style="color: #06c; font-weight: bold;">instance</span> <span style="color: green;">&#40;</span><span style="color: green;">&#41;</span> :=&gt; <a href="http://haskell.org/ghc/docs/latest/html/libraries/base/Prelude.html#t:Integral"><span style="background-color: #efefbf; font-weight: bold;">Integral</span></a> <a href="http://haskell.org/ghc/docs/latest/html/libraries/base/Prelude.html#t:Integer"><span style="background-color: #efefbf; font-weight: bold;">Integer</span></a> <span style="color: #06c; font-weight: bold;">where</span> ins = Sub Dict
&nbsp;</pre>
<pre class="haskell">&nbsp;
<span style="color: #06c; font-weight: bold;">instance</span> Class <span style="color: green;">&#40;</span><a href="http://haskell.org/ghc/docs/latest/html/libraries/base/Prelude.html#t:Num"><span style="background-color: #efefbf; font-weight: bold;">Num</span></a> a<span style="color: green;">&#41;</span> <span style="color: green;">&#40;</span><a href="http://haskell.org/ghc/docs/latest/html/libraries/base/Prelude.html#t:Fractional"><span style="background-color: #efefbf; font-weight: bold;">Fractional</span></a> a<span style="color: green;">&#41;</span> <span style="color: #06c; font-weight: bold;">where</span> cls = Sub Dict
<span style="color: #06c; font-weight: bold;">instance</span> <span style="color: green;">&#40;</span><span style="color: green;">&#41;</span> :=&gt; <a href="http://haskell.org/ghc/docs/latest/html/libraries/base/Prelude.html#t:Fractional"><span style="background-color: #efefbf; font-weight: bold;">Fractional</span></a> <a href="http://haskell.org/ghc/docs/latest/html/libraries/base/Prelude.html#t:Float"><span style="background-color: #efefbf; font-weight: bold;">Float</span></a> <span style="color: #06c; font-weight: bold;">where</span> ins = Sub Dict
<span style="color: #06c; font-weight: bold;">instance</span> <span style="color: green;">&#40;</span><span style="color: green;">&#41;</span> :=&gt; <a href="http://haskell.org/ghc/docs/latest/html/libraries/base/Prelude.html#t:Fractional"><span style="background-color: #efefbf; font-weight: bold;">Fractional</span></a> <a href="http://haskell.org/ghc/docs/latest/html/libraries/base/Prelude.html#t:Double"><span style="background-color: #efefbf; font-weight: bold;">Double</span></a> <span style="color: #06c; font-weight: bold;">where</span> ins = Sub Dict
<span style="color: #06c; font-weight: bold;">instance</span> <a href="http://haskell.org/ghc/docs/latest/html/libraries/base/Prelude.html#t:RealFloat"><span style="background-color: #efefbf; font-weight: bold;">RealFloat</span></a> a :=&gt; <a href="http://haskell.org/ghc/docs/latest/html/libraries/base/Prelude.html#t:Fractional"><span style="background-color: #efefbf; font-weight: bold;">Fractional</span></a> <span style="color: green;">&#40;</span>Complex a<span style="color: green;">&#41;</span> <span style="color: #06c; font-weight: bold;">where</span> ins = Sub Dict
<span style="color: #06c; font-weight: bold;">instance</span> <a href="http://haskell.org/ghc/docs/latest/html/libraries/base/Prelude.html#t:Integral"><span style="background-color: #efefbf; font-weight: bold;">Integral</span></a> a :=&gt; <a href="http://haskell.org/ghc/docs/latest/html/libraries/base/Prelude.html#t:Fractional"><span style="background-color: #efefbf; font-weight: bold;">Fractional</span></a> <span style="color: green;">&#40;</span>Ratio a<span style="color: green;">&#41;</span> <span style="color: #06c; font-weight: bold;">where</span> ins = Sub Dict
&nbsp;</pre>
<pre class="haskell">&nbsp;
<span style="color: #06c; font-weight: bold;">instance</span> Class <span style="color: green;">&#40;</span><a href="http://haskell.org/ghc/docs/latest/html/libraries/base/Prelude.html#t:Fractional"><span style="background-color: #efefbf; font-weight: bold;">Fractional</span></a> a<span style="color: green;">&#41;</span> <span style="color: green;">&#40;</span><a href="http://haskell.org/ghc/docs/latest/html/libraries/base/Prelude.html#t:Floating"><span style="background-color: #efefbf; font-weight: bold;">Floating</span></a> a<span style="color: green;">&#41;</span> <span style="color: #06c; font-weight: bold;">where</span> cls = Sub Dict
<span style="color: #06c; font-weight: bold;">instance</span> <span style="color: green;">&#40;</span><span style="color: green;">&#41;</span> :=&gt; <a href="http://haskell.org/ghc/docs/latest/html/libraries/base/Prelude.html#t:Floating"><span style="background-color: #efefbf; font-weight: bold;">Floating</span></a> <a href="http://haskell.org/ghc/docs/latest/html/libraries/base/Prelude.html#t:Float"><span style="background-color: #efefbf; font-weight: bold;">Float</span></a> <span style="color: #06c; font-weight: bold;">where</span> ins = Sub Dict
<span style="color: #06c; font-weight: bold;">instance</span> <span style="color: green;">&#40;</span><span style="color: green;">&#41;</span> :=&gt; <a href="http://haskell.org/ghc/docs/latest/html/libraries/base/Prelude.html#t:Floating"><span style="background-color: #efefbf; font-weight: bold;">Floating</span></a> <a href="http://haskell.org/ghc/docs/latest/html/libraries/base/Prelude.html#t:Double"><span style="background-color: #efefbf; font-weight: bold;">Double</span></a> <span style="color: #06c; font-weight: bold;">where</span> ins = Sub Dict
<span style="color: #06c; font-weight: bold;">instance</span> <a href="http://haskell.org/ghc/docs/latest/html/libraries/base/Prelude.html#t:RealFloat"><span style="background-color: #efefbf; font-weight: bold;">RealFloat</span></a> a :=&gt; <a href="http://haskell.org/ghc/docs/latest/html/libraries/base/Prelude.html#t:Floating"><span style="background-color: #efefbf; font-weight: bold;">Floating</span></a> <span style="color: green;">&#40;</span>Complex a<span style="color: green;">&#41;</span> <span style="color: #06c; font-weight: bold;">where</span> ins = Sub Dict
&nbsp;</pre>
<pre class="haskell">&nbsp;
<span style="color: #06c; font-weight: bold;">instance</span> Class <span style="color: green;">&#40;</span><a href="http://haskell.org/ghc/docs/latest/html/libraries/base/Prelude.html#t:Real"><span style="background-color: #efefbf; font-weight: bold;">Real</span></a> a, <a href="http://haskell.org/ghc/docs/latest/html/libraries/base/Prelude.html#t:Fractional"><span style="background-color: #efefbf; font-weight: bold;">Fractional</span></a> a<span style="color: green;">&#41;</span> <span style="color: green;">&#40;</span><a href="http://haskell.org/ghc/docs/latest/html/libraries/base/Prelude.html#t:RealFrac"><span style="background-color: #efefbf; font-weight: bold;">RealFrac</span></a> a<span style="color: green;">&#41;</span> <span style="color: #06c; font-weight: bold;">where</span> cls = Sub Dict
<span style="color: #06c; font-weight: bold;">instance</span> <span style="color: green;">&#40;</span><span style="color: green;">&#41;</span> :=&gt; <a href="http://haskell.org/ghc/docs/latest/html/libraries/base/Prelude.html#t:RealFrac"><span style="background-color: #efefbf; font-weight: bold;">RealFrac</span></a> <a href="http://haskell.org/ghc/docs/latest/html/libraries/base/Prelude.html#t:Float"><span style="background-color: #efefbf; font-weight: bold;">Float</span></a> <span style="color: #06c; font-weight: bold;">where</span> ins = Sub Dict
<span style="color: #06c; font-weight: bold;">instance</span> <span style="color: green;">&#40;</span><span style="color: green;">&#41;</span> :=&gt; <a href="http://haskell.org/ghc/docs/latest/html/libraries/base/Prelude.html#t:RealFrac"><span style="background-color: #efefbf; font-weight: bold;">RealFrac</span></a> <a href="http://haskell.org/ghc/docs/latest/html/libraries/base/Prelude.html#t:Double"><span style="background-color: #efefbf; font-weight: bold;">Double</span></a> <span style="color: #06c; font-weight: bold;">where</span> ins = Sub Dict
<span style="color: #06c; font-weight: bold;">instance</span> <a href="http://haskell.org/ghc/docs/latest/html/libraries/base/Prelude.html#t:Integral"><span style="background-color: #efefbf; font-weight: bold;">Integral</span></a> a :=&gt; <a href="http://haskell.org/ghc/docs/latest/html/libraries/base/Prelude.html#t:RealFrac"><span style="background-color: #efefbf; font-weight: bold;">RealFrac</span></a> <span style="color: green;">&#40;</span>Ratio a<span style="color: green;">&#41;</span> <span style="color: #06c; font-weight: bold;">where</span> ins = Sub Dict
&nbsp;</pre>
<pre class="haskell">&nbsp;
<span style="color: #06c; font-weight: bold;">instance</span> Class <span style="color: green;">&#40;</span><a href="http://haskell.org/ghc/docs/latest/html/libraries/base/Prelude.html#t:RealFrac"><span style="background-color: #efefbf; font-weight: bold;">RealFrac</span></a> a, <a href="http://haskell.org/ghc/docs/latest/html/libraries/base/Prelude.html#t:Floating"><span style="background-color: #efefbf; font-weight: bold;">Floating</span></a> a<span style="color: green;">&#41;</span> <span style="color: green;">&#40;</span><a href="http://haskell.org/ghc/docs/latest/html/libraries/base/Prelude.html#t:RealFloat"><span style="background-color: #efefbf; font-weight: bold;">RealFloat</span></a> a<span style="color: green;">&#41;</span> <span style="color: #06c; font-weight: bold;">where</span> cls = Sub Dict
<span style="color: #06c; font-weight: bold;">instance</span> <span style="color: green;">&#40;</span><span style="color: green;">&#41;</span> :=&gt; <a href="http://haskell.org/ghc/docs/latest/html/libraries/base/Prelude.html#t:RealFloat"><span style="background-color: #efefbf; font-weight: bold;">RealFloat</span></a> <a href="http://haskell.org/ghc/docs/latest/html/libraries/base/Prelude.html#t:Float"><span style="background-color: #efefbf; font-weight: bold;">Float</span></a> <span style="color: #06c; font-weight: bold;">where</span> ins = Sub Dict
<span style="color: #06c; font-weight: bold;">instance</span> <span style="color: green;">&#40;</span><span style="color: green;">&#41;</span> :=&gt; <a href="http://haskell.org/ghc/docs/latest/html/libraries/base/Prelude.html#t:RealFloat"><span style="background-color: #efefbf; font-weight: bold;">RealFloat</span></a> <a href="http://haskell.org/ghc/docs/latest/html/libraries/base/Prelude.html#t:Double"><span style="background-color: #efefbf; font-weight: bold;">Double</span></a> <span style="color: #06c; font-weight: bold;">where</span> ins = Sub Dict
&nbsp;</pre>
<pre class="haskell">&nbsp;
<span style="color: #06c; font-weight: bold;">instance</span> Class <span style="color: green;">&#40;</span><span style="color: green;">&#41;</span> <span style="color: green;">&#40;</span>Monoid a<span style="color: green;">&#41;</span> <span style="color: #06c; font-weight: bold;">where</span> cls = Sub Dict
<span style="color: #06c; font-weight: bold;">instance</span> <span style="color: green;">&#40;</span><span style="color: green;">&#41;</span> :=&gt; Monoid <span style="color: green;">&#40;</span><span style="color: green;">&#41;</span> <span style="color: #06c; font-weight: bold;">where</span> ins = Sub Dict
<span style="color: #06c; font-weight: bold;">instance</span> <span style="color: green;">&#40;</span><span style="color: green;">&#41;</span> :=&gt; Monoid <a href="http://haskell.org/ghc/docs/latest/html/libraries/base/Prelude.html#t:Ordering"><span style="background-color: #efefbf; font-weight: bold;">Ordering</span></a> <span style="color: #06c; font-weight: bold;">where</span> ins = Sub Dict
<span style="color: #06c; font-weight: bold;">instance</span> <span style="color: green;">&#40;</span><span style="color: green;">&#41;</span> :=&gt; Monoid <span style="color: green;">&#91;</span>a<span style="color: green;">&#93;</span> <span style="color: #06c; font-weight: bold;">where</span> ins = Sub Dict
<span style="color: #06c; font-weight: bold;">instance</span> Monoid a :=&gt; Monoid <span style="color: green;">&#40;</span><a href="http://haskell.org/ghc/docs/latest/html/libraries/base/Prelude.html#t:Maybe"><span style="background-color: #efefbf; font-weight: bold;">Maybe</span></a> a<span style="color: green;">&#41;</span> <span style="color: #06c; font-weight: bold;">where</span> ins = Sub Dict
<span style="color: #06c; font-weight: bold;">instance</span> <span style="color: green;">&#40;</span>Monoid a, Monoid b<span style="color: green;">&#41;</span> :=&gt; Monoid <span style="color: green;">&#40;</span>a, b<span style="color: green;">&#41;</span> <span style="color: #06c; font-weight: bold;">where</span> ins = Sub Dict
&nbsp;</pre>
<pre class="haskell">&nbsp;
<span style="color: #06c; font-weight: bold;">instance</span> Class <span style="color: green;">&#40;</span><span style="color: green;">&#41;</span> <span style="color: green;">&#40;</span><a href="http://haskell.org/ghc/docs/latest/html/libraries/base/Prelude.html#t:Functor"><span style="background-color: #efefbf; font-weight: bold;">Functor</span></a> f<span style="color: green;">&#41;</span> <span style="color: #06c; font-weight: bold;">where</span> cls = Sub Dict
<span style="color: #06c; font-weight: bold;">instance</span> <span style="color: green;">&#40;</span><span style="color: green;">&#41;</span> :=&gt; <a href="http://haskell.org/ghc/docs/latest/html/libraries/base/Prelude.html#t:Functor"><span style="background-color: #efefbf; font-weight: bold;">Functor</span></a> <span style="color: green;">&#91;</span><span style="color: green;">&#93;</span> <span style="color: #06c; font-weight: bold;">where</span> ins = Sub Dict
<span style="color: #06c; font-weight: bold;">instance</span> <span style="color: green;">&#40;</span><span style="color: green;">&#41;</span> :=&gt; <a href="http://haskell.org/ghc/docs/latest/html/libraries/base/Prelude.html#t:Functor"><span style="background-color: #efefbf; font-weight: bold;">Functor</span></a> <a href="http://haskell.org/ghc/docs/latest/html/libraries/base/Prelude.html#t:Maybe"><span style="background-color: #efefbf; font-weight: bold;">Maybe</span></a> <span style="color: #06c; font-weight: bold;">where</span> ins = Sub Dict
<span style="color: #06c; font-weight: bold;">instance</span> <span style="color: green;">&#40;</span><span style="color: green;">&#41;</span> :=&gt; <a href="http://haskell.org/ghc/docs/latest/html/libraries/base/Prelude.html#t:Functor"><span style="background-color: #efefbf; font-weight: bold;">Functor</span></a> <span style="color: green;">&#40;</span><a href="http://haskell.org/ghc/docs/latest/html/libraries/base/Prelude.html#t:Either"><span style="background-color: #efefbf; font-weight: bold;">Either</span></a> a<span style="color: green;">&#41;</span> <span style="color: #06c; font-weight: bold;">where</span> ins = Sub Dict
<span style="color: #06c; font-weight: bold;">instance</span> <span style="color: green;">&#40;</span><span style="color: green;">&#41;</span> :=&gt; <a href="http://haskell.org/ghc/docs/latest/html/libraries/base/Prelude.html#t:Functor"><span style="background-color: #efefbf; font-weight: bold;">Functor</span></a> <span style="color: green;">&#40;</span><span style="color: green;">&#40;</span>-&gt;<span style="color: green;">&#41;</span> a<span style="color: green;">&#41;</span> <span style="color: #06c; font-weight: bold;">where</span> ins = Sub Dict
<span style="color: #06c; font-weight: bold;">instance</span> <span style="color: green;">&#40;</span><span style="color: green;">&#41;</span> :=&gt; <a href="http://haskell.org/ghc/docs/latest/html/libraries/base/Prelude.html#t:Functor"><span style="background-color: #efefbf; font-weight: bold;">Functor</span></a> <span style="color: green;">&#40;</span><span style="color: green;">&#40;</span>,<span style="color: green;">&#41;</span> a<span style="color: green;">&#41;</span> <span style="color: #06c; font-weight: bold;">where</span> ins = Sub Dict
<span style="color: #06c; font-weight: bold;">instance</span> <span style="color: green;">&#40;</span><span style="color: green;">&#41;</span> :=&gt; <a href="http://haskell.org/ghc/docs/latest/html/libraries/base/Prelude.html#t:Functor"><span style="background-color: #efefbf; font-weight: bold;">Functor</span></a> <a href="http://haskell.org/ghc/docs/latest/html/libraries/base/Prelude.html#t:IO"><span style="background-color: #efefbf; font-weight: bold;">IO</span></a> <span style="color: #06c; font-weight: bold;">where</span> ins = Sub Dict
&nbsp;</pre>
<pre class="haskell">&nbsp;
<span style="color: #06c; font-weight: bold;">instance</span> Class <span style="color: green;">&#40;</span><a href="http://haskell.org/ghc/docs/latest/html/libraries/base/Prelude.html#t:Functor"><span style="background-color: #efefbf; font-weight: bold;">Functor</span></a> f<span style="color: green;">&#41;</span> <span style="color: green;">&#40;</span>Applicative f<span style="color: green;">&#41;</span> <span style="color: #06c; font-weight: bold;">where</span> cls = Sub Dict
<span style="color: #06c; font-weight: bold;">instance</span> <span style="color: green;">&#40;</span><span style="color: green;">&#41;</span> :=&gt; Applicative <span style="color: green;">&#91;</span><span style="color: green;">&#93;</span> <span style="color: #06c; font-weight: bold;">where</span> ins = Sub Dict
<span style="color: #06c; font-weight: bold;">instance</span> <span style="color: green;">&#40;</span><span style="color: green;">&#41;</span> :=&gt; Applicative <a href="http://haskell.org/ghc/docs/latest/html/libraries/base/Prelude.html#t:Maybe"><span style="background-color: #efefbf; font-weight: bold;">Maybe</span></a> <span style="color: #06c; font-weight: bold;">where</span> ins = Sub Dict
<span style="color: #06c; font-weight: bold;">instance</span> <span style="color: green;">&#40;</span><span style="color: green;">&#41;</span> :=&gt; Applicative <span style="color: green;">&#40;</span><a href="http://haskell.org/ghc/docs/latest/html/libraries/base/Prelude.html#t:Either"><span style="background-color: #efefbf; font-weight: bold;">Either</span></a> a<span style="color: green;">&#41;</span> <span style="color: #06c; font-weight: bold;">where</span> ins = Sub Dict
<span style="color: #06c; font-weight: bold;">instance</span> <span style="color: green;">&#40;</span><span style="color: green;">&#41;</span> :=&gt; Applicative <span style="color: green;">&#40;</span><span style="color: green;">&#40;</span>-&gt;<span style="color: green;">&#41;</span>a<span style="color: green;">&#41;</span> <span style="color: #06c; font-weight: bold;">where</span> ins = Sub Dict
<span style="color: #06c; font-weight: bold;">instance</span> <span style="color: green;">&#40;</span><span style="color: green;">&#41;</span> :=&gt; Applicative <a href="http://haskell.org/ghc/docs/latest/html/libraries/base/Prelude.html#t:IO"><span style="background-color: #efefbf; font-weight: bold;">IO</span></a> <span style="color: #06c; font-weight: bold;">where</span> ins = Sub Dict
<span style="color: #06c; font-weight: bold;">instance</span> Monoid a :=&gt; Applicative <span style="color: green;">&#40;</span><span style="color: green;">&#40;</span>,<span style="color: green;">&#41;</span>a<span style="color: green;">&#41;</span> <span style="color: #06c; font-weight: bold;">where</span> ins = Sub Dict
&nbsp;</pre>
<pre class="haskell">&nbsp;
<span style="color: #06c; font-weight: bold;">instance</span> Class <span style="color: green;">&#40;</span>Applicative f<span style="color: green;">&#41;</span> <span style="color: green;">&#40;</span>Alternative f<span style="color: green;">&#41;</span> <span style="color: #06c; font-weight: bold;">where</span> cls = Sub Dict
<span style="color: #06c; font-weight: bold;">instance</span> <span style="color: green;">&#40;</span><span style="color: green;">&#41;</span> :=&gt; Alternative <span style="color: green;">&#91;</span><span style="color: green;">&#93;</span> <span style="color: #06c; font-weight: bold;">where</span> ins = Sub Dict
<span style="color: #06c; font-weight: bold;">instance</span> <span style="color: green;">&#40;</span><span style="color: green;">&#41;</span> :=&gt; Alternative <a href="http://haskell.org/ghc/docs/latest/html/libraries/base/Prelude.html#t:Maybe"><span style="background-color: #efefbf; font-weight: bold;">Maybe</span></a> <span style="color: #06c; font-weight: bold;">where</span> ins = Sub Dict
&nbsp;</pre>
<pre class="haskell">&nbsp;
<span style="color: #06c; font-weight: bold;">instance</span> Class <span style="color: green;">&#40;</span><span style="color: green;">&#41;</span> <span style="color: green;">&#40;</span><a href="http://haskell.org/ghc/docs/latest/html/libraries/base/Prelude.html#t:Monad"><span style="background-color: #efefbf; font-weight: bold;">Monad</span></a> f<span style="color: green;">&#41;</span> <span style="color: #06c; font-weight: bold;">where</span> cls = Sub Dict
<span style="color: #06c; font-weight: bold;">instance</span> <span style="color: green;">&#40;</span><span style="color: green;">&#41;</span> :=&gt; <a href="http://haskell.org/ghc/docs/latest/html/libraries/base/Prelude.html#t:Monad"><span style="background-color: #efefbf; font-weight: bold;">Monad</span></a> <span style="color: green;">&#91;</span><span style="color: green;">&#93;</span> <span style="color: #06c; font-weight: bold;">where</span> ins = Sub Dict
<span style="color: #06c; font-weight: bold;">instance</span> <span style="color: green;">&#40;</span><span style="color: green;">&#41;</span> :=&gt; <a href="http://haskell.org/ghc/docs/latest/html/libraries/base/Prelude.html#t:Monad"><span style="background-color: #efefbf; font-weight: bold;">Monad</span></a> <span style="color: green;">&#40;</span><span style="color: green;">&#40;</span>-&gt;<span style="color: green;">&#41;</span> a<span style="color: green;">&#41;</span> <span style="color: #06c; font-weight: bold;">where</span> ins = Sub Dict
<span style="color: #06c; font-weight: bold;">instance</span> <span style="color: green;">&#40;</span><span style="color: green;">&#41;</span> :=&gt; <a href="http://haskell.org/ghc/docs/latest/html/libraries/base/Prelude.html#t:Monad"><span style="background-color: #efefbf; font-weight: bold;">Monad</span></a> <span style="color: green;">&#40;</span><a href="http://haskell.org/ghc/docs/latest/html/libraries/base/Prelude.html#t:Either"><span style="background-color: #efefbf; font-weight: bold;">Either</span></a> a<span style="color: green;">&#41;</span> <span style="color: #06c; font-weight: bold;">where</span> ins = Sub Dict
<span style="color: #06c; font-weight: bold;">instance</span> <span style="color: green;">&#40;</span><span style="color: green;">&#41;</span> :=&gt; <a href="http://haskell.org/ghc/docs/latest/html/libraries/base/Prelude.html#t:Monad"><span style="background-color: #efefbf; font-weight: bold;">Monad</span></a> <a href="http://haskell.org/ghc/docs/latest/html/libraries/base/Prelude.html#t:IO"><span style="background-color: #efefbf; font-weight: bold;">IO</span></a> <span style="color: #06c; font-weight: bold;">where</span> ins = Sub Dict
&nbsp;</pre>
<pre class="haskell">&nbsp;
<span style="color: #06c; font-weight: bold;">instance</span> Class <span style="color: green;">&#40;</span><a href="http://haskell.org/ghc/docs/latest/html/libraries/base/Prelude.html#t:Monad"><span style="background-color: #efefbf; font-weight: bold;">Monad</span></a> f<span style="color: green;">&#41;</span> <span style="color: green;">&#40;</span>MonadPlus f<span style="color: green;">&#41;</span> <span style="color: #06c; font-weight: bold;">where</span> cls = Sub Dict
<span style="color: #06c; font-weight: bold;">instance</span> <span style="color: green;">&#40;</span><span style="color: green;">&#41;</span> :=&gt; MonadPlus <span style="color: green;">&#91;</span><span style="color: green;">&#93;</span> <span style="color: #06c; font-weight: bold;">where</span> ins = Sub Dict
<span style="color: #06c; font-weight: bold;">instance</span> <span style="color: green;">&#40;</span><span style="color: green;">&#41;</span> :=&gt; MonadPlus <a href="http://haskell.org/ghc/docs/latest/html/libraries/base/Prelude.html#t:Maybe"><span style="background-color: #efefbf; font-weight: bold;">Maybe</span></a> <span style="color: #06c; font-weight: bold;">where</span> ins = Sub Dict
&nbsp;</pre>
<p>Of course, the structure of these definitions is extremely formulaic, so when template-haskell builds against HEAD again, they should be able to be generated automatically using splicing and reify, which would reduce this from a wall of text to a handful of lines with better coverage!</p>
<h2>An alternative using Default Signatures and Type Families</h2>
<p>Many of the above definitions could have been streamlined by using default definitions. However, MPTCs do not currently support default signatures. We can however, define Class and (:=>) using type families rather than functional dependencies. This enables us to use defaulting, whenever the superclass or context was ().</p>
<pre class="haskell">&nbsp;
#if <span style="color: red;">0</span>
<span style="color: #06c; font-weight: bold;">class</span> Class h <span style="color: #06c; font-weight: bold;">where</span>
  <span style="color: #06c; font-weight: bold;">type</span> Sup h :: Constraint
  <span style="color: #06c; font-weight: bold;">type</span> Sup h = <span style="color: green;">&#40;</span><span style="color: green;">&#41;</span>
  cls :: h :- Sup h
  <span style="color: #06c; font-weight: bold;">default</span> cls :: h :- <span style="color: green;">&#40;</span><span style="color: green;">&#41;</span>
  cls = Sub Dict
&nbsp;
<span style="color: #06c; font-weight: bold;">class</span> Instance h <span style="color: #06c; font-weight: bold;">where</span>
  <span style="color: #06c; font-weight: bold;">type</span> Ctx h :: Constraint
  <span style="color: #06c; font-weight: bold;">type</span> Ctx h = <span style="color: green;">&#40;</span><span style="color: green;">&#41;</span>
  ins :: Ctx h :- h
  <span style="color: #06c; font-weight: bold;">default</span> ins :: h =&gt; Ctx h :- h
  ins = Sub Dict
&nbsp;
<span style="color: #06c; font-weight: bold;">instance</span> Class <span style="color: green;">&#40;</span>Class a<span style="color: green;">&#41;</span>
<span style="color: #06c; font-weight: bold;">instance</span> Class <span style="color: green;">&#40;</span>Instance a<span style="color: green;">&#41;</span>
&nbsp;
#ifdef UNDECIDABLE
<span style="color: #06c; font-weight: bold;">instance</span> Class a =&gt; Instance <span style="color: green;">&#40;</span>Class a<span style="color: green;">&#41;</span>
<span style="color: #06c; font-weight: bold;">instance</span> Instance a =&gt; Instance <span style="color: green;">&#40;</span>Instance a<span style="color: green;">&#41;</span>
#endif
&nbsp;
<span style="color: #06c; font-weight: bold;">instance</span> Class <span style="color: green;">&#40;</span><span style="color: green;">&#41;</span>
<span style="color: #06c; font-weight: bold;">instance</span> Instance <span style="color: green;">&#40;</span><span style="color: green;">&#41;</span>
#endif
&nbsp;</pre>
<p>This seems at first to be a promising approach. Many instances are quite small:</p>
<pre class="haskell">&nbsp;
#if <span style="color: red;">0</span>
<span style="color: #06c; font-weight: bold;">instance</span> Class <span style="color: green;">&#40;</span><a href="http://haskell.org/ghc/docs/latest/html/libraries/base/Prelude.html#t:Eq"><span style="background-color: #efefbf; font-weight: bold;">Eq</span></a> a<span style="color: green;">&#41;</span>
<span style="color: #06c; font-weight: bold;">instance</span> Instance <span style="color: green;">&#40;</span><a href="http://haskell.org/ghc/docs/latest/html/libraries/base/Prelude.html#t:Eq"><span style="background-color: #efefbf; font-weight: bold;">Eq</span></a> <span style="color: green;">&#40;</span><span style="color: green;">&#41;</span><span style="color: green;">&#41;</span>
<span style="color: #06c; font-weight: bold;">instance</span> Instance <span style="color: green;">&#40;</span><a href="http://haskell.org/ghc/docs/latest/html/libraries/base/Prelude.html#t:Eq"><span style="background-color: #efefbf; font-weight: bold;">Eq</span></a> <a href="http://haskell.org/ghc/docs/latest/html/libraries/base/Prelude.html#t:Int"><span style="background-color: #efefbf; font-weight: bold;">Int</span></a><span style="color: green;">&#41;</span>
<span style="color: #06c; font-weight: bold;">instance</span> Instance <span style="color: green;">&#40;</span><a href="http://haskell.org/ghc/docs/latest/html/libraries/base/Prelude.html#t:Eq"><span style="background-color: #efefbf; font-weight: bold;">Eq</span></a> <a href="http://haskell.org/ghc/docs/latest/html/libraries/base/Prelude.html#t:Bool"><span style="background-color: #efefbf; font-weight: bold;">Bool</span></a><span style="color: green;">&#41;</span>
<span style="color: #06c; font-weight: bold;">instance</span> Instance <span style="color: green;">&#40;</span><a href="http://haskell.org/ghc/docs/latest/html/libraries/base/Prelude.html#t:Eq"><span style="background-color: #efefbf; font-weight: bold;">Eq</span></a> <a href="http://haskell.org/ghc/docs/latest/html/libraries/base/Prelude.html#t:Integer"><span style="background-color: #efefbf; font-weight: bold;">Integer</span></a><span style="color: green;">&#41;</span>
<span style="color: #06c; font-weight: bold;">instance</span> Instance <span style="color: green;">&#40;</span><a href="http://haskell.org/ghc/docs/latest/html/libraries/base/Prelude.html#t:Eq"><span style="background-color: #efefbf; font-weight: bold;">Eq</span></a> <a href="http://haskell.org/ghc/docs/latest/html/libraries/base/Prelude.html#t:Float"><span style="background-color: #efefbf; font-weight: bold;">Float</span></a><span style="color: green;">&#41;</span>
<span style="color: #06c; font-weight: bold;">instance</span> Instance <span style="color: green;">&#40;</span><a href="http://haskell.org/ghc/docs/latest/html/libraries/base/Prelude.html#t:Eq"><span style="background-color: #efefbf; font-weight: bold;">Eq</span></a> <a href="http://haskell.org/ghc/docs/latest/html/libraries/base/Prelude.html#t:Double"><span style="background-color: #efefbf; font-weight: bold;">Double</span></a><span style="color: green;">&#41;</span>
#endif
&nbsp;</pre>
<p>But those that aren't are considerably more verbose and are much harder to read off than the definitions using the MPTC based Class and (:=>).</p>
<pre class="haskell">&nbsp;
#if <span style="color: red;">0</span>
<span style="color: #06c; font-weight: bold;">instance</span> Instance <span style="color: green;">&#40;</span><a href="http://haskell.org/ghc/docs/latest/html/libraries/base/Prelude.html#t:Eq"><span style="background-color: #efefbf; font-weight: bold;">Eq</span></a> <span style="color: green;">&#91;</span>a<span style="color: green;">&#93;</span><span style="color: green;">&#41;</span> <span style="color: #06c; font-weight: bold;">where</span>
  <span style="color: #06c; font-weight: bold;">type</span> Ctx <span style="color: green;">&#40;</span><a href="http://haskell.org/ghc/docs/latest/html/libraries/base/Prelude.html#t:Eq"><span style="background-color: #efefbf; font-weight: bold;">Eq</span></a> <span style="color: green;">&#91;</span>a<span style="color: green;">&#93;</span><span style="color: green;">&#41;</span> = <a href="http://haskell.org/ghc/docs/latest/html/libraries/base/Prelude.html#t:Eq"><span style="background-color: #efefbf; font-weight: bold;">Eq</span></a> a
  ins = Sub Dict
<span style="color: #06c; font-weight: bold;">instance</span> Instance <span style="color: green;">&#40;</span><a href="http://haskell.org/ghc/docs/latest/html/libraries/base/Prelude.html#t:Eq"><span style="background-color: #efefbf; font-weight: bold;">Eq</span></a> <span style="color: green;">&#40;</span><a href="http://haskell.org/ghc/docs/latest/html/libraries/base/Prelude.html#t:Maybe"><span style="background-color: #efefbf; font-weight: bold;">Maybe</span></a> a<span style="color: green;">&#41;</span><span style="color: green;">&#41;</span> <span style="color: #06c; font-weight: bold;">where</span>
  <span style="color: #06c; font-weight: bold;">type</span> Ctx <span style="color: green;">&#40;</span><a href="http://haskell.org/ghc/docs/latest/html/libraries/base/Prelude.html#t:Eq"><span style="background-color: #efefbf; font-weight: bold;">Eq</span></a> <span style="color: green;">&#40;</span><a href="http://haskell.org/ghc/docs/latest/html/libraries/base/Prelude.html#t:Maybe"><span style="background-color: #efefbf; font-weight: bold;">Maybe</span></a> a<span style="color: green;">&#41;</span><span style="color: green;">&#41;</span> = <a href="http://haskell.org/ghc/docs/latest/html/libraries/base/Prelude.html#t:Eq"><span style="background-color: #efefbf; font-weight: bold;">Eq</span></a> a
  ins = Sub Dict
<span style="color: #06c; font-weight: bold;">instance</span> Instance <span style="color: green;">&#40;</span><a href="http://haskell.org/ghc/docs/latest/html/libraries/base/Prelude.html#t:Eq"><span style="background-color: #efefbf; font-weight: bold;">Eq</span></a> <span style="color: green;">&#40;</span>Complex a<span style="color: green;">&#41;</span><span style="color: green;">&#41;</span> <span style="color: #06c; font-weight: bold;">where</span>
  <span style="color: #06c; font-weight: bold;">type</span> Ctx <span style="color: green;">&#40;</span><a href="http://haskell.org/ghc/docs/latest/html/libraries/base/Prelude.html#t:Eq"><span style="background-color: #efefbf; font-weight: bold;">Eq</span></a> <span style="color: green;">&#40;</span>Complex a<span style="color: green;">&#41;</span><span style="color: green;">&#41;</span> = <a href="http://haskell.org/ghc/docs/latest/html/libraries/base/Prelude.html#t:Eq"><span style="background-color: #efefbf; font-weight: bold;">Eq</span></a> a
  ins = Sub Dict
<span style="color: #06c; font-weight: bold;">instance</span> Instance <span style="color: green;">&#40;</span><a href="http://haskell.org/ghc/docs/latest/html/libraries/base/Prelude.html#t:Eq"><span style="background-color: #efefbf; font-weight: bold;">Eq</span></a> <span style="color: green;">&#40;</span>Ratio a<span style="color: green;">&#41;</span><span style="color: green;">&#41;</span> <span style="color: #06c; font-weight: bold;">where</span>
  <span style="color: #06c; font-weight: bold;">type</span> Ctx <span style="color: green;">&#40;</span><a href="http://haskell.org/ghc/docs/latest/html/libraries/base/Prelude.html#t:Eq"><span style="background-color: #efefbf; font-weight: bold;">Eq</span></a> <span style="color: green;">&#40;</span>Ratio a<span style="color: green;">&#41;</span><span style="color: green;">&#41;</span> = <a href="http://haskell.org/ghc/docs/latest/html/libraries/base/Prelude.html#t:Eq"><span style="background-color: #efefbf; font-weight: bold;">Eq</span></a> a
  ins = Sub Dict
<span style="color: #06c; font-weight: bold;">instance</span> Instance <span style="color: green;">&#40;</span><a href="http://haskell.org/ghc/docs/latest/html/libraries/base/Prelude.html#t:Eq"><span style="background-color: #efefbf; font-weight: bold;">Eq</span></a> <span style="color: green;">&#40;</span>a, b<span style="color: green;">&#41;</span><span style="color: green;">&#41;</span> <span style="color: #06c; font-weight: bold;">where</span>
  <span style="color: #06c; font-weight: bold;">type</span> Ctx <span style="color: green;">&#40;</span><a href="http://haskell.org/ghc/docs/latest/html/libraries/base/Prelude.html#t:Eq"><span style="background-color: #efefbf; font-weight: bold;">Eq</span></a> <span style="color: green;">&#40;</span>a,b<span style="color: green;">&#41;</span><span style="color: green;">&#41;</span> = <span style="color: green;">&#40;</span><a href="http://haskell.org/ghc/docs/latest/html/libraries/base/Prelude.html#t:Eq"><span style="background-color: #efefbf; font-weight: bold;">Eq</span></a> a, <a href="http://haskell.org/ghc/docs/latest/html/libraries/base/Prelude.html#t:Eq"><span style="background-color: #efefbf; font-weight: bold;">Eq</span></a> b<span style="color: green;">&#41;</span>
  ins = Sub Dict
<span style="color: #06c; font-weight: bold;">instance</span> Instance <span style="color: green;">&#40;</span><a href="http://haskell.org/ghc/docs/latest/html/libraries/base/Prelude.html#t:Eq"><span style="background-color: #efefbf; font-weight: bold;">Eq</span></a> <span style="color: green;">&#40;</span><a href="http://haskell.org/ghc/docs/latest/html/libraries/base/Prelude.html#t:Either"><span style="background-color: #efefbf; font-weight: bold;">Either</span></a> a b<span style="color: green;">&#41;</span><span style="color: green;">&#41;</span> <span style="color: #06c; font-weight: bold;">where</span>
  <span style="color: #06c; font-weight: bold;">type</span> Ctx <span style="color: green;">&#40;</span><a href="http://haskell.org/ghc/docs/latest/html/libraries/base/Prelude.html#t:Eq"><span style="background-color: #efefbf; font-weight: bold;">Eq</span></a> <span style="color: green;">&#40;</span><a href="http://haskell.org/ghc/docs/latest/html/libraries/base/Prelude.html#t:Either"><span style="background-color: #efefbf; font-weight: bold;">Either</span></a> a b<span style="color: green;">&#41;</span><span style="color: green;">&#41;</span> = <span style="color: green;">&#40;</span><a href="http://haskell.org/ghc/docs/latest/html/libraries/base/Prelude.html#t:Eq"><span style="background-color: #efefbf; font-weight: bold;">Eq</span></a> a, <a href="http://haskell.org/ghc/docs/latest/html/libraries/base/Prelude.html#t:Eq"><span style="background-color: #efefbf; font-weight: bold;">Eq</span></a> b<span style="color: green;">&#41;</span>
  ins = Sub Dict
#endif
&nbsp;</pre>
<p>Having tested both approaches, the type family approach led to a ~10% larger file size, and was harder to read, so I remained with MPTCs even though it meant repeating "where ins = Sub Dict" over and over.</p>
<p>In a perfect world, we'd gain the ability to use default signatures with multiparameter type classes, and the result would be considerably shorter and easier to read!</p>
<h2>Fake Superclasses</h2>
<p>Now, that we have all this machinery, it'd be nice to get something useful out of it. Even if we could derive it by other means, it'd let us know we weren't completely wasting our time.</p>
<p>Let's define a rather horrid helper, which we'll only use where a and b are the same constraint being applied to a newtype wrapper of the same type, so we can rely on the fact that the dictionaries have the same representation.</p>
<pre class="haskell">&nbsp;
evil :: a :- b
evil = unsafeCoerce refl
&nbsp;</pre>
<p>We often bemoan the fact that we can't use Applicative sugar given just a Monad, since Applicative wasn't made a superclass of Monad due to the inability of the Haskell 98 report to foresee the future invention of Applicative.</p>
<p>There are rather verbose options to get Applicative sugar for your Monad, or to pass it to something that expects an Applicative. For instance you can use WrappedMonad from Applicative. We reflect the relevant instance here.</p>
<pre class="haskell">&nbsp;
<span style="color: #06c; font-weight: bold;">instance</span> <a href="http://haskell.org/ghc/docs/latest/html/libraries/base/Prelude.html#t:Monad"><span style="background-color: #efefbf; font-weight: bold;">Monad</span></a> m :=&gt; Applicative <span style="color: green;">&#40;</span>WrappedMonad m<span style="color: green;">&#41;</span> <span style="color: #06c; font-weight: bold;">where</span> ins = Sub Dict
&nbsp;</pre>
<p>Using that instance and the combinators defined previously, we can obtain the following </p>
<pre class="haskell">&nbsp;
applicative :: <span style="color: #06c; font-weight: bold;">forall</span> m a. <a href="http://haskell.org/ghc/docs/latest/html/libraries/base/Prelude.html#t:Monad"><span style="background-color: #efefbf; font-weight: bold;">Monad</span></a> m =&gt; <span style="color: green;">&#40;</span>Applicative m =&gt; m a<span style="color: green;">&#41;</span> -&gt; m a
applicative m =
  m \\ trans <span style="color: green;">&#40;</span>evil :: Applicative <span style="color: green;">&#40;</span>WrappedMonad m<span style="color: green;">&#41;</span> :- Applicative m<span style="color: green;">&#41;</span> ins
&nbsp;</pre>
<p>Here ins is instantiated to the instance of (:=>) above, so we use trans to compose <code>ins :: Monad m :- Applicative (WrappedMonad m)</code> with <code>evil :: Applicative (WrappedMonad m) :- Applicative m</code> to obtain an entailment of type <code>Monad m :- Applicative m</code> in local scope, and then apply that transformation to discharge the Applicative obligation on m.</p>
<p>Now, we can use this to write definitions. [Note: Frustratingly, my blog software inserts spaces after &lt;'s in code]</p>
<pre class="haskell">&nbsp;
<span style="color: green;">&#40;</span>&lt; &amp;&gt;<span style="color: green;">&#41;</span> :: <a href="http://haskell.org/ghc/docs/latest/html/libraries/base/Prelude.html#t:Monad"><span style="background-color: #efefbf; font-weight: bold;">Monad</span></a> m =&gt; m a -&gt; m b -&gt; m <span style="color: green;">&#40;</span>a, b<span style="color: green;">&#41;</span>
m &lt; &amp;&gt; n = applicative $ <span style="color: green;">&#40;</span>,<span style="color: green;">&#41;</span> &lt; $&gt; m &lt; *&gt; n
&nbsp;</pre>
<p>Which compares rather favorably to the more correct</p>
<pre class="haskell">&nbsp;
<span style="color: green;">&#40;</span>&lt; &amp;&gt;<span style="color: green;">&#41;</span> :: <a href="http://haskell.org/ghc/docs/latest/html/libraries/base/Prelude.html#t:Monad"><span style="background-color: #efefbf; font-weight: bold;">Monad</span></a> m =&gt; m a -&gt; m b -&gt; m <span style="color: green;">&#40;</span>a, b<span style="color: green;">&#41;</span>
m &lt; &amp;&gt; n = unwrapMonad $ <span style="color: green;">&#40;</span>,<span style="color: green;">&#41;</span> &lt; $&gt; WrapMonad m &lt; *&gt; WrapMonad n
&nbsp;</pre>
<p>especially considering you still have access to any other instances on m you might want to bring into scope without having to use deriving to lift them onto the newtype!</p>
<p>Similarly you can borrow <code>< |></code> and empty locally for use by your <code>MonadPlus</code> with:</p>
<pre class="haskell">&nbsp;
<span style="color: #06c; font-weight: bold;">instance</span> MonadPlus m :=&gt; Alternative <span style="color: green;">&#40;</span>WrappedMonad m<span style="color: green;">&#41;</span> <span style="color: #06c; font-weight: bold;">where</span> ins = Sub Dict
&nbsp;
alternative :: <span style="color: #06c; font-weight: bold;">forall</span> m a. MonadPlus m =&gt; <span style="color: green;">&#40;</span>Alternative m =&gt; m a<span style="color: green;">&#41;</span> -&gt; m a
alternative m =
  m \\ trans <span style="color: green;">&#40;</span>evil :: Alternative <span style="color: green;">&#40;</span>WrappedMonad m<span style="color: green;">&#41;</span> :- Alternative m<span style="color: green;">&#41;</span> ins
&nbsp;</pre>
<p>The correctness of this of course relies upon the convention that any <code>Applicative</code> and <code>Alternative</code> your <code>Monad</code> may have should agree with its <code>Monad</code> instance, so even if you use <code>Alternative</code> or <code>Applicative</code> in a context where the actual <code>Applicative</code> or <code>Alternative</code> instance for your particular type m is in scope, it shouldn't matter beyond a little bit of efficiency which instance the compiler picks to discharge the <code>Applicative</code> or <code>Alternative</code> obligation.</p>
<p>Note: It isn't that the <code>Constraint</code> kind is invalid, but rather that using <code>unsafeCoerce</code> judiciously we can bring into scope instances that don't exist for a given type by substituting those from a different type which have the right representation.</p>
<p>[<a href="https://github.com/ekmett/constraints/blob/master/Data/Constraint.hs">Source</a>]</p>
]]></content:encoded>
			<wfw:commentRss>http://comonad.com/reader/2011/what-constraints-entail-part-2/feed/</wfw:commentRss>
		<slash:comments>13</slash:comments>
		</item>
		<item>
		<title>What Constraints Entail: Part 1</title>
		<link>http://comonad.com/reader/2011/what-constraints-entail-part-1/</link>
		<comments>http://comonad.com/reader/2011/what-constraints-entail-part-1/#comments</comments>
		<pubDate>Thu, 03 Nov 2011 05:46:11 +0000</pubDate>
		<dc:creator>Edward Kmett</dc:creator>
				<category><![CDATA[Category Theory]]></category>
		<category><![CDATA[Constraint Kinds]]></category>
		<category><![CDATA[Haskell]]></category>
		<category><![CDATA[Logic]]></category>
		<category><![CDATA[Monads]]></category>
		<category><![CDATA[Type Hackery]]></category>
		<category><![CDATA[Uncategorized]]></category>

		<guid isPermaLink="false">http://comonad.com/reader/?p=430</guid>
		<description><![CDATA[Max Bolingbroke has done a wonderful job on adding Constraint kinds to GHC.
Constraint Kinds adds a new kind Constraint, such that Eq :: * -> Constraint, Monad :: (* -> *) -> Constraint, but since it is a kind, we can make type families for constraints, and even parameterize constraints on constraints. 
So, let's play [...]]]></description>
			<content:encoded><![CDATA[<p>Max Bolingbroke has done a wonderful job on adding Constraint kinds to GHC.</p>
<p>Constraint Kinds adds a new kind <code>Constraint</code>, such that <code>Eq :: * -> Constraint</code>, <code>Monad :: (* -> *) -> Constraint</code>, but since it is a kind, we can make type families for constraints, and even parameterize constraints <em>on</em> constraints. </p>
<p>So, let's play with them and see what we can come up with!</p>
<p><span id="more-430"></span></p>
<h2>A Few Extensions</h2>
<p>First, we'll need a few language features:</p>
<pre class="haskell">&nbsp;
<span style="color: #5d478b; font-style: italic;">{-# LANGUAGE
  CPP,
  ScopedTypeVariables,
  FlexibleInstances,
  FlexibleContexts,
  ConstraintKinds,
  KindSignatures,
  TypeOperators,
  FunctionalDependencies,
  Rank2Types,
  StandaloneDeriving,
  GADTs
  #-}</span>
&nbsp;</pre>
<p>Because of the particular version of GHC I'm using I'll also need</p>
<pre class="haskell">&nbsp;
<span style="color: #5d478b; font-style: italic;">{-# LANGUAGE UndecidableInstances #-}</span>
#define UNDECIDABLE
&nbsp;</pre>
<p>but this bug has been fixed in the current version of GHC Head. I'll be explicit about any instances that need UndecidableInstances by surrounding them in an <code>#ifdef UNDECIDABLE</code> block.</p>
<h2>Explicit Dictionaries</h2>
<p>So with that out of the way, let's import some definitions</p>
<pre class="haskell">&nbsp;
<span style="color: #06c; font-weight: bold;">import</span> Control.<a href="http://haskell.org/ghc/docs/latest/html/libraries/base/Prelude.html#t:Monad"><span style="background-color: #efefbf; font-weight: bold;">Monad</span></a>
<span style="color: #06c; font-weight: bold;">import</span> Control.<a href="http://haskell.org/ghc/docs/latest/html/libraries/base/Prelude.html#t:Monad"><span style="background-color: #efefbf; font-weight: bold;">Monad</span></a>.Instances
<span style="color: #06c; font-weight: bold;">import</span> Control.Applicative
<span style="color: #06c; font-weight: bold;">import</span> Data.Monoid
<span style="color: #06c; font-weight: bold;">import</span> Data.Complex
<span style="color: #06c; font-weight: bold;">import</span> Data.Ratio
<span style="color: #06c; font-weight: bold;">import</span> Unsafe.Coerce
&nbsp;</pre>
<p>and make one of our own that shows what we get out of making Constraints into a kind we can manipulate like any other.</p>
<pre class="haskell">&nbsp;
<span style="color: #06c; font-weight: bold;">data</span> Dict a <span style="color: #06c; font-weight: bold;">where</span>
  Dict :: a =&gt; Dict a
&nbsp;</pre>
<p>Previously, we coud make a Dict like data type for any one particular class constraint that we wanted to capture, but now we can write this type once and for all. The act of pattern matching on the Dict constructor will bring the constraint 'a' into scope.</p>
<p>Of course, in the absence of incoherent and overlapping instances there is at most one dictionary of a given type, so we could make instances, like we can for any other data type, but standalone deriving is smart enough to figure these out for me. (Thanks copumpkin!)</p>
<pre class="haskell">&nbsp;
<span style="color: #06c; font-weight: bold;">deriving</span> <span style="color: #06c; font-weight: bold;">instance</span> <a href="http://haskell.org/ghc/docs/latest/html/libraries/base/Prelude.html#t:Eq"><span style="background-color: #efefbf; font-weight: bold;">Eq</span></a> <span style="color: green;">&#40;</span>Dict a<span style="color: green;">&#41;</span>
<span style="color: #06c; font-weight: bold;">deriving</span> <span style="color: #06c; font-weight: bold;">instance</span> <a href="http://haskell.org/ghc/docs/latest/html/libraries/base/Prelude.html#t:Ord"><span style="background-color: #efefbf; font-weight: bold;">Ord</span></a> <span style="color: green;">&#40;</span>Dict a<span style="color: green;">&#41;</span>
<span style="color: #06c; font-weight: bold;">deriving</span> <span style="color: #06c; font-weight: bold;">instance</span> <a href="http://haskell.org/ghc/docs/latest/html/libraries/base/Prelude.html#t:Show"><span style="background-color: #efefbf; font-weight: bold;">Show</span></a> <span style="color: green;">&#40;</span>Dict a<span style="color: green;">&#41;</span>
&nbsp;</pre>
<p>If we're willing to turn on UndecidableInstances to enable the polymorphic constraint we can even add:</p>
<pre class="haskell">&nbsp;
#ifdef UNDECIDABLE
<span style="color: #06c; font-weight: bold;">deriving</span> <span style="color: #06c; font-weight: bold;">instance</span> a =&gt; <a href="http://haskell.org/ghc/docs/latest/html/libraries/base/Prelude.html#t:Read"><span style="background-color: #efefbf; font-weight: bold;">Read</span></a> <span style="color: green;">&#40;</span>Dict a<span style="color: green;">&#41;</span>
<span style="color: #06c; font-weight: bold;">instance</span> a =&gt; Monoid <span style="color: green;">&#40;</span>Dict a<span style="color: green;">&#41;</span> <span style="color: #06c; font-weight: bold;">where</span>
  mappend Dict Dict = Dict
  mempty = Dict
#endif
&nbsp;</pre>
<p>and similar polymorphically constrained instances for <code>Enum</code>, <code>Bounded</code>, etc.</p>
<h2>Entailment</h2>
<p>For that we'll need a notion of entailment.</p>
<pre class="haskell">&nbsp;
<span style="color: #06c; font-weight: bold;">infixr</span> <span style="color: red;">9</span> :-
<span style="color: #06c; font-weight: bold;">newtype</span> a :- b = Sub <span style="color: green;">&#40;</span>a =&gt; Dict b<span style="color: green;">&#41;</span>
&nbsp;
<span style="color: #06c; font-weight: bold;">instance</span> <a href="http://haskell.org/ghc/docs/latest/html/libraries/base/Prelude.html#t:Eq"><span style="background-color: #efefbf; font-weight: bold;">Eq</span></a> <span style="color: green;">&#40;</span>a :- b<span style="color: green;">&#41;</span> <span style="color: #06c; font-weight: bold;">where</span>
  _ == _ = <a href="http://haskell.org/ghc/docs/latest/html/libraries/base/Prelude.html#v:True"><span style="font-weight: bold;">True</span></a>
&nbsp;
<span style="color: #06c; font-weight: bold;">instance</span> <a href="http://haskell.org/ghc/docs/latest/html/libraries/base/Prelude.html#t:Ord"><span style="background-color: #efefbf; font-weight: bold;">Ord</span></a> <span style="color: green;">&#40;</span>a :- b<span style="color: green;">&#41;</span> <span style="color: #06c; font-weight: bold;">where</span>
  <a href="http://haskell.org/ghc/docs/latest/html/libraries/base/Prelude.html#v:compare"><span style="font-weight: bold;">compare</span></a> _ _ = EQ
&nbsp;
<span style="color: #06c; font-weight: bold;">instance</span> <a href="http://haskell.org/ghc/docs/latest/html/libraries/base/Prelude.html#t:Show"><span style="background-color: #efefbf; font-weight: bold;">Show</span></a> <span style="color: green;">&#40;</span>a :- b<span style="color: green;">&#41;</span> <span style="color: #06c; font-weight: bold;">where</span>
  showsPrec d _ = <a href="http://haskell.org/ghc/docs/latest/html/libraries/base/Prelude.html#v:showParen"><span style="font-weight: bold;">showParen</span></a> <span style="color: green;">&#40;</span>d &gt; <span style="color: red;">10</span><span style="color: green;">&#41;</span> $
    <a href="http://haskell.org/ghc/docs/latest/html/libraries/base/Prelude.html#v:showString"><span style="font-weight: bold;">showString</span></a> <span style="color: #3c7331;">&quot;Sub Dict&quot;</span>
&nbsp;</pre>
<p>Here we're saying that <code>Sub</code> takes one argument, which is a computation that when implicitly given a constraint of type <em>a</em>, can give me back a dictionary for the type <em>b</em>. Moreover, as a newtype it adds no overhead that isn't aleady present in manipulating terms of type (a => Dict b) directly.</p>
<p>The simplest thing we can define with this is that entailment is reflexive.</p>
<pre class="haskell">&nbsp;
refl :: a :- a
refl = Sub Dict
&nbsp;</pre>
<p>Max has already written up a nice restricted monad example using these, but what I want to play with today is the category of substitutability of constraints, but there are a few observations I need to make, first.</p>
<p>ConstraintKinds overloads <code>()</code> and <code>(a,b)</code> to represent the trivial constraint and the product of two constraints respectively. </p>
<p>The latter is done with a bit of a hack, which we'll talk about in a minute, but we can use the former as a terminal object for our category of entailments.</p>
<pre lang="haskell>
top :: a :- ()
top = Sub Dict
</pre>
<p>We can weaken the constraint, in a manner similar to fst or snd:</p>
<pre class="haskell">&nbsp;
weaken1 :: <span style="color: green;">&#40;</span>a, b<span style="color: green;">&#41;</span> :- a
weaken1 = Sub Dict
&nbsp;
weaken2 :: <span style="color: green;">&#40;</span>a, b<span style="color: green;">&#41;</span> :- b
weaken2 = Sub Dict
&nbsp;</pre>
<p>Constraints are idempotent, so we can duplicate one, perhaps as a prelude to transforming one of them into something else.</p>
<pre class="haskell">&nbsp;
contract :: a :- <span style="color: green;">&#40;</span>a, a<span style="color: green;">&#41;</span>
contract = Sub Dict
&nbsp;</pre>
<p>But to do much more complicated, we're going to need a notion of substitution, letting us use our entailment relation to satisfy obligations.</p>
<pre class="haskell">&nbsp;
<span style="color: #06c; font-weight: bold;">infixl</span> <span style="color: red;">1</span> \\ <span style="color: #5d478b; font-style: italic;">-- required comment</span>
<span style="color: green;">&#40;</span>\\<span style="color: green;">&#41;</span> :: a =&gt; <span style="color: green;">&#40;</span>b =&gt; r<span style="color: green;">&#41;</span> -&gt; <span style="color: green;">&#40;</span>a :- b<span style="color: green;">&#41;</span> -&gt; r
r \\ Sub Dict = r
&nbsp;</pre>
<p>The type says that given that a constraint <em>a</em> can be satisfied, a computation that needs a constraint of type <em>b</em> to be satisfied in order to obtain a result, and the fact that <em>a</em> entails <em>b</em>, we can compute the result. </p>
<p>The constraint <em>a</em> is satisfied by the type signature, and the fact that we get quietly passed whatever dictionary is needed. Pattern matching on Sub brings into scope a computation of type <code>(a => Dict b)</code>, and we are able to discharge the <em>a</em> obligation, using the dictionary we were passed, Pattern matching on <code>Dict</code> forces that computation to happen and brings b into scope, allowing us to meet the obligation of the computation of r. All of this happens for us behind the scenes just by pattern matching.</p>
<p>So what can we do with this?</p>
<p>We can use \\ to compose constraints.</p>
<pre class="haskell">&nbsp;
trans :: <span style="color: green;">&#40;</span>b :- c<span style="color: green;">&#41;</span> -&gt; <span style="color: green;">&#40;</span>a :- b<span style="color: green;">&#41;</span> -&gt; a :- c
trans f g = Sub $ Dict \\ f \\ g
&nbsp;</pre>
<p>In fact, the way the dictionaries get plumbed around inside the argument to Sub is rather nice, because we can give that same definition different type signatures, letting us make (,) more product-like, giving us the canonical product morphism to go with the weakenings/projections we defined above.</p>
<pre class="haskell">&nbsp;
<span style="color: green;">&#40;</span>&amp;&amp;&amp;<span style="color: green;">&#41;</span> :: <span style="color: green;">&#40;</span>a :- b<span style="color: green;">&#41;</span> -&gt; <span style="color: green;">&#40;</span>a :- c<span style="color: green;">&#41;</span> -&gt; a :- <span style="color: green;">&#40;</span>b, c<span style="color: green;">&#41;</span>
f &amp;&amp;&amp; g = Sub $ Dict \\ f \\ g
&nbsp;</pre>
<p>And since we're using it as a product, we can make it act like a bifunctor also using the same definition.</p>
<pre class="haskell">&nbsp;
<span style="color: green;">&#40;</span>***<span style="color: green;">&#41;</span> :: <span style="color: green;">&#40;</span>a :- b<span style="color: green;">&#41;</span> -&gt; <span style="color: green;">&#40;</span>c :- d<span style="color: green;">&#41;</span> -&gt; <span style="color: green;">&#40;</span>a, c<span style="color: green;">&#41;</span> :- <span style="color: green;">&#40;</span>b, d<span style="color: green;">&#41;</span>
f *** g = Sub $ Dict \\ f \\ g
&nbsp;</pre>
<h2>Limited Sub-Superkinding?</h2>
<p>Ideally we'd be able to capture something like that bifunctoriality using a type like</p>
<pre class="haskell">&nbsp;
#if <span style="color: red;">0</span>
<span style="color: #06c; font-weight: bold;">class</span> BifunctorS <span style="color: green;">&#40;</span>p :: Constraint -&gt; Constraint -&gt; Constraint<span style="color: green;">&#41;</span> <span style="color: #06c; font-weight: bold;">where</span>
  bimapS :: <span style="color: green;">&#40;</span>a :- b<span style="color: green;">&#41;</span> -&gt; <span style="color: green;">&#40;</span>c :- d<span style="color: green;">&#41;</span> -&gt; p a c :- p b d
#endif
&nbsp;</pre>
<p>In an even more ideal world, it would be enriched using something like</p>
<pre class="haskell">&nbsp;
#ifdef POLYMORPHIC_KINDS
<span style="color: #06c; font-weight: bold;">class</span> Category <span style="color: green;">&#40;</span>k :: x -&gt; x -&gt; *<span style="color: green;">&#41;</span> <span style="color: #06c; font-weight: bold;">where</span>
  <a href="http://haskell.org/ghc/docs/latest/html/libraries/base/Prelude.html#v:id"><span style="font-weight: bold;">id</span></a> :: k a a
  <span style="color: green;">&#40;</span>.<span style="color: green;">&#41;</span> :: k b c -&gt; k a b -&gt; k a c
<span style="color: #06c; font-weight: bold;">instance</span> Category <span style="color: green;">&#40;</span>:-<span style="color: green;">&#41;</span> <span style="color: #06c; font-weight: bold;">where</span>
  <a href="http://haskell.org/ghc/docs/latest/html/libraries/base/Prelude.html#v:id"><span style="font-weight: bold;">id</span></a> = refl
  <span style="color: green;">&#40;</span>.<span style="color: green;">&#41;</span> = trans
#endif
&nbsp;</pre>
<p>where x is a <strong>kind variable</strong>, then we could obtain a more baroque and admittedly far less thought-out bifunctor class like:</p>
<pre class="haskell">&nbsp;
#if <span style="color: red;">0</span>
<span style="color: #06c; font-weight: bold;">class</span> Bifunctor <span style="color: green;">&#40;</span>p :: x -&gt; y -&gt; z<span style="color: green;">&#41;</span> <span style="color: #06c; font-weight: bold;">where</span>
  <span style="color: #06c; font-weight: bold;">type</span> <a href="http://haskell.org/ghc/docs/latest/html/libraries/base/Prelude.html#v:Left"><span style="font-weight: bold;">Left</span></a> p :: x -&gt; x -&gt; *
  <span style="color: #06c; font-weight: bold;">type</span> <a href="http://haskell.org/ghc/docs/latest/html/libraries/base/Prelude.html#v:Left"><span style="font-weight: bold;">Left</span></a> p = <span style="color: green;">&#40;</span>-&gt;<span style="color: green;">&#41;</span>
  <span style="color: #06c; font-weight: bold;">type</span> <a href="http://haskell.org/ghc/docs/latest/html/libraries/base/Prelude.html#v:Right"><span style="font-weight: bold;">Right</span></a> p :: y -&gt; y -&gt; *
  <span style="color: #06c; font-weight: bold;">type</span> <a href="http://haskell.org/ghc/docs/latest/html/libraries/base/Prelude.html#v:Right"><span style="font-weight: bold;">Right</span></a> p = <span style="color: green;">&#40;</span>-&gt;<span style="color: green;">&#41;</span>
  <span style="color: #06c; font-weight: bold;">type</span> Cod p :: z -&gt; z -&gt; *
  <span style="color: #06c; font-weight: bold;">type</span> Cod p = <span style="color: green;">&#40;</span>-&gt;<span style="color: green;">&#41;</span>
  bimap :: <a href="http://haskell.org/ghc/docs/latest/html/libraries/base/Prelude.html#v:Left"><span style="font-weight: bold;">Left</span></a> p a b -&gt; <a href="http://haskell.org/ghc/docs/latest/html/libraries/base/Prelude.html#v:Right"><span style="font-weight: bold;">Right</span></a> p c d -&gt; Cod p <span style="color: green;">&#40;</span>p a c<span style="color: green;">&#41;</span> <span style="color: green;">&#40;</span>p b d<span style="color: green;">&#41;</span>
#endif
&nbsp;</pre>
<p>Or even more more ideally, you could use the fact that we can directly define product categories!</p>
<p>Since they are talking about kind-indexing for classes and type families, we could have separate bifunctors for (,) for both kinds * and Constraint.</p>
<p>The current constraint kind code uses a hack to let (a,b) be used as a type inhabiting * and as the syntax for constraints. This hack is limited however. It only works when the type (,) is fully applied to its arguments. Otherwise you'd wind up with the fact that the type (,) needs to have both of these kinds:</p>
<pre class="haskell">&nbsp;
<span style="color: #5d478b; font-style: italic;">-- (,) :: Constraint -&gt; Constraint -&gt; Constraint and</span>
<span style="color: #5d478b; font-style: italic;">-- (,) :: * -&gt; * -&gt; *</span>
&nbsp;</pre>
<p>What is currently done is that the kind magically switches for <code>()</code> and <code>(,)</code> in certain circumstances. GHC already had some support for this because it parses <code>(Foo a, Bar b)</code> as a type in <code>(Foo a, Bar b) => Baz a b</code> before transforming it into a bunch of constraints.</p>
<p>Since we already have a notion of sub-kinding at the kind level, we could solve this for <code>()</code> by making up a new kind, say, <code>???</code> which is the subkind of both <code>*</code> and <code>Constraint</code>, but this would break the nice join lattice properties of the current system.</p>
<p>[Edit: in the initial draft, I had said superkind]</p>
<pre class="haskell">&nbsp;
<span style="color: #5d478b; font-style: italic;">--    ?</span>
<span style="color: #5d478b; font-style: italic;">--   / \</span>
<span style="color: #5d478b; font-style: italic;">-- (#)  ??</span>
<span style="color: #5d478b; font-style: italic;">--     /  \</span>
<span style="color: #5d478b; font-style: italic;">--    #    *  Constraint</span>
<span style="color: #5d478b; font-style: italic;">--          \ /</span>
<span style="color: #5d478b; font-style: italic;">--          ???</span>
&nbsp;</pre>
<p>But this doesn't address the kind of <code>(,)</code> above. With the new polymorphic kinds that Brent Yorgey and company have been working on and a limited notion of sub-superkinding, this could be resolved by making a new super-kind <code>@</code> that is the super-kind of both <code>*</code> and <code>Constraint</code>, and which is a sub-superkind of the usual unnamed Box superkind. </p>
<pre class="haskell">&nbsp;
<span style="color: #5d478b; font-style: italic;">-- Box</span>
<span style="color: #5d478b; font-style: italic;">--  |</span>
<span style="color: #5d478b; font-style: italic;">--  @</span>
&nbsp;</pre>
<p>Then we can have:</p>
<pre class="haskell">&nbsp;
<span style="color: #5d478b; font-style: italic;">-- (,) :: forall (k :: @). k -&gt; k -&gt; k</span>
<span style="color: #5d478b; font-style: italic;">-- () :: forall (k :: @). k</span>
&nbsp;</pre>
<p>and kind checking/inference will do the right thing about keeping the kind ambiguous for types like <code>(,) () :: forall (k :: @). k</code></p>
<p>This would get rid of the hack and let me make a proper bifunctor for <code>(,)</code> in the category of entailments.</p>
<p>The version of GHC head I'm working with right now doesn't support polymorphic kinds, so I've only been playing with these in a toy type checker, but I'm really looking forward to being able to have product categories!</p>
<h2>Stay Tuned</h2>
<p><a href="../../../2011/what-constraints-entail-part-2/index.html">Next</a>, we'll go over how to reflect the class and instance declarations so we can derive entailment of a superclass for a class, and the entailment of instances.</p>
<p>[<a href="https://github.com/ekmett/constraints/blob/master/Data/Constraint.hs">Source</a>]</p>
]]></content:encoded>
			<wfw:commentRss>http://comonad.com/reader/2011/what-constraints-entail-part-1/feed/</wfw:commentRss>
		<slash:comments>4</slash:comments>
		</item>
		<item>
		<title>A Parsec Full of Rats, Part 2</title>
		<link>http://comonad.com/reader/2011/a-parsec-full-of-rats-part-2/</link>
		<comments>http://comonad.com/reader/2011/a-parsec-full-of-rats-part-2/#comments</comments>
		<pubDate>Sat, 24 Sep 2011 03:07:32 +0000</pubDate>
		<dc:creator>Edward Kmett</dc:creator>
				<category><![CDATA[Algorithms]]></category>
		<category><![CDATA[Data Structures]]></category>
		<category><![CDATA[Haskell]]></category>
		<category><![CDATA[Monads]]></category>
		<category><![CDATA[Parsing]]></category>
		<category><![CDATA[Uncategorized]]></category>
		<category><![CDATA[packrat]]></category>
		<category><![CDATA[parsec]]></category>
		<category><![CDATA[trifecta]]></category>

		<guid isPermaLink="false">http://comonad.com/reader/?p=397</guid>
		<description><![CDATA[Last time, I showed that we can build a small parsec clone with packrat support.
This time I intend to implement packrat directly on top of Parsec 3.
One of the main topics of discussion when it comes to packrat parsing since Bryan Ford's initial release of Pappy has been the fact that in general you shouldn't [...]]]></description>
			<content:encoded><![CDATA[<p>Last time, I showed that we can build a small parsec clone with packrat support.</p>
<p>This time I intend to implement packrat directly on top of Parsec 3.</p>
<p>One of the main topics of discussion when it comes to packrat parsing since Bryan Ford's initial release of Pappy has been the fact that in general you shouldn't use packrat to memoize every rule, and that instead you should apply Amdahl's law to look for the cases where the lookup time is paid back in terms of repetitive evaluation, computation time and the hit rate. This is great news for us, since, we only want to memoize a handful of expensive combinators.</p>
<p><span id="more-397"></span></p>
<p>First, we'll need to import enough of Parsec to do something interesting.</p>
<pre class="haskell">&nbsp;
<span style="color: #5d478b; font-style: italic;">{-# LANGUAGE RecordWildCards, ViewPatterns, FlexibleInstances, MultiParamTypeClasses #-}</span>
&nbsp;
<span style="color: #06c; font-weight: bold;">import</span> Text.Parsec
<span style="color: #06c; font-weight: bold;">import</span> <span style="color: #06c; font-weight: bold;">qualified</span> Text.Parsec.Token <span style="color: #06c; font-weight: bold;">as</span> T
<span style="color: #06c; font-weight: bold;">import</span> Text.Parsec.Token
    <span style="color: green;">&#40;</span>GenLanguageDef<span style="color: green;">&#40;</span>..<span style="color: green;">&#41;</span>, GenTokenParser<span style="color: green;">&#40;</span>TokenParser<span style="color: green;">&#41;</span><span style="color: green;">&#41;</span>
<span style="color: #06c; font-weight: bold;">import</span> Text.Parsec.Pos <span style="color: green;">&#40;</span>initialPos, updatePosChar<span style="color: green;">&#41;</span>
<span style="color: #06c; font-weight: bold;">import</span> Data.<a href="http://haskell.org/ghc/docs/latest/html/libraries/base/Prelude.html#t:Functor"><span style="background-color: #efefbf; font-weight: bold;">Functor</span></a>.Identity <span style="color: green;">&#40;</span>Identity<span style="color: green;">&#40;</span>..<span style="color: green;">&#41;</span><span style="color: green;">&#41;</span>
<span style="color: #06c; font-weight: bold;">import</span> Control.Applicative <span style="color: #06c; font-weight: bold;">hiding</span> <span style="color: green;">&#40;</span><span style="color: green;">&#40;</span>&lt; |&gt;<span style="color: green;">&#41;</span><span style="color: green;">&#41;</span>
<span style="color: #06c; font-weight: bold;">import</span> Control.<a href="http://haskell.org/ghc/docs/latest/html/libraries/base/Prelude.html#t:Monad"><span style="background-color: #efefbf; font-weight: bold;">Monad</span></a>.Fix <span style="color: green;">&#40;</span>fix<span style="color: green;">&#41;</span>
&nbsp;</pre>
<p>Then as before, we'll define PEG-style backtracking:</p>
<pre class="haskell">&nbsp;
<span style="color: green;">&#40;</span>&lt; /&gt;<span style="color: green;">&#41;</span> :: <a href="http://haskell.org/ghc/docs/latest/html/libraries/base/Prelude.html#t:Monad"><span style="background-color: #efefbf; font-weight: bold;">Monad</span></a> m =&gt; ParsecT s u m a -&gt; ParsecT s u m a -&gt;
    ParsecT s u m a
p &lt; /&gt; q = try p &lt; |&gt; q
<span style="color: #06c; font-weight: bold;">infixl</span> <span style="color: red;">3</span> &lt; /&gt;
&nbsp;</pre>
<p>Now we need an analogue to our Result type from last time, which recalled whether or not we had consumed input, and what the current cursor location is. Fortunately, we can recycle the definitions from Parsec to this end.</p>
<pre class="haskell">&nbsp;
<span style="color: #06c; font-weight: bold;">type</span> Result d a = Consumed <span style="color: green;">&#40;</span>Reply d <span style="color: green;">&#40;</span><span style="color: green;">&#41;</span> a<span style="color: green;">&#41;</span>
&nbsp;</pre>
<p>We'll define a combinator to build a parser directly from a field accessor. Last time, this was just the use of the "Rat" constructor. Now it is a bit trickier, because we need to turn <code>Consumed (Reply d () a)</code> into <code>m (Consumed (m (Reply d u a)))</code> by wrapping it in the appropriate monad, and giving the user back his state unmolested. </p>
<pre class="haskell">&nbsp;
rat :: <a href="http://haskell.org/ghc/docs/latest/html/libraries/base/Prelude.html#t:Monad"><span style="background-color: #efefbf; font-weight: bold;">Monad</span></a> m =&gt; <span style="color: green;">&#40;</span>d -&gt; Result d a<span style="color: green;">&#41;</span> -&gt; ParsecT d u m a
rat f   = mkPT $ \s0 -&gt; <a href="http://haskell.org/ghc/docs/latest/html/libraries/base/Prelude.html#v:return"><span style="font-weight: bold;">return</span></a> $
    <a href="http://haskell.org/ghc/docs/latest/html/libraries/base/Prelude.html#v:return"><span style="font-weight: bold;">return</span></a> . patch s0 &lt; $&gt; f <span style="color: green;">&#40;</span>stateInput s0<span style="color: green;">&#41;</span> <span style="color: #06c; font-weight: bold;">where</span>
  patch <span style="color: green;">&#40;</span>State _ _ u<span style="color: green;">&#41;</span> <span style="color: green;">&#40;</span>Ok a <span style="color: green;">&#40;</span>State s p _<span style="color: green;">&#41;</span> err<span style="color: green;">&#41;</span> = Ok a <span style="color: green;">&#40;</span>State s p u<span style="color: green;">&#41;</span> err
  patch _             <span style="color: green;">&#40;</span>Error e<span style="color: green;">&#41;</span>                = Error e
&nbsp;</pre>
<p>Last time we could go from a parser to a result just by applying the user stream type, but with parsec we also have to supply their notion of a position. This leads to the following combinator. By running in the Identity monad with no user state it should be obvious that we've duplicated the functionality of the previous 'Rat' parser (with the addition of a source position).</p>
<pre class="haskell">&nbsp;
womp :: d -&gt; SourcePos -&gt; ParsecT d <span style="color: green;">&#40;</span><span style="color: green;">&#41;</span> Identity a -&gt; Result d a
womp d pos p = <a href="http://haskell.org/ghc/docs/latest/html/libraries/base/Prelude.html#v:fmap"><span style="font-weight: bold;">fmap</span></a> runIdentity . runIdentity $
    runParsecT p <span style="color: green;">&#40;</span>State d pos <span style="color: green;">&#40;</span><span style="color: green;">&#41;</span><span style="color: green;">&#41;</span>
&nbsp;</pre>
<p>The combinator is so named because we needed a big space-rat rather than a little pack-rat to keep with the theme.</p>
<blockquote><p>It's not impossible. I used to bullseye womp rats in my T-16 back home, they're not much bigger than two meters.</p></blockquote>
<p>Now we'll write a bit of annoyingly verbose boilerplate to convince <code>Parsec</code> that we really want a <code>LanguageDef</code> for some monad other than Identity. (As an aside, why <code>Text.Parsec.Language</code> doesn't contain GenLanguageDefs that are parametric in their choice of Monad is beyond me.) </p>
<pre class="haskell">&nbsp;
myLanguageDef :: <a href="http://haskell.org/ghc/docs/latest/html/libraries/base/Prelude.html#t:Monad"><span style="background-color: #efefbf; font-weight: bold;">Monad</span></a> m =&gt; T.GenLanguageDef D u m
myLanguageDef = T.LanguageDef
  <span style="color: green;">&#123;</span> commentStart    = <span style="color: #3c7331;">&quot;{-&quot;</span>
  , commentEnd      = <span style="color: #3c7331;">&quot;-}&quot;</span>
  , commentLine     = <span style="color: #3c7331;">&quot;--&quot;</span>
  , nestedComments  = <a href="http://haskell.org/ghc/docs/latest/html/libraries/base/Prelude.html#v:True"><span style="font-weight: bold;">True</span></a>
  , identStart      = letter &lt; |&gt; char '_'
  , identLetter     = alphaNum &lt; |&gt; oneOf <span style="color: #3c7331;">&quot;_'&quot;</span>
  , opStart         = opLetter myLanguageDef
  , opLetter        = oneOf <span style="color: #3c7331;">&quot;:!#$%&amp;*+./&lt; =&gt;?@<span style="">\\</span>^|-~&quot;</span>
  , reservedOpNames = <span style="color: green;">&#91;</span><span style="color: green;">&#93;</span>
  , reservedNames   = <span style="color: green;">&#91;</span><span style="color: green;">&#93;</span>
  , caseSensitive   = <a href="http://haskell.org/ghc/docs/latest/html/libraries/base/Prelude.html#v:True"><span style="font-weight: bold;">True</span></a>
  <span style="color: green;">&#125;</span>
&nbsp;</pre>
<p>As a shameless plug, trifecta offers a particularly nice solution to this problem, breaking up the monolithic Token type into separate concerns and letting you layer parser transformers that enrich the parser to deal with things like Haskell-style layout, literate comments, parsing comments in whitespace, etc. </p>
<p>And as one last bit of boilerplate, we'll abuse RecordWildcards once again to avoid the usual 20 lines of boilerplate that are expected of us, so we can get access to parsec's token parsers.</p>
<pre class="haskell">&nbsp;
TokenParser <span style="color: green;">&#123;</span>..<span style="color: green;">&#125;</span> = T.makeTokenParser myLanguageDef
&nbsp;</pre>
<p>Now we're ready to define our incredibly straightforward stream type:</p>
<pre class="haskell">&nbsp;
<span style="color: #06c; font-weight: bold;">data</span> D = D
  <span style="color: green;">&#123;</span> _add        :: Result D <a href="http://haskell.org/ghc/docs/latest/html/libraries/base/Prelude.html#t:Integer"><span style="background-color: #efefbf; font-weight: bold;">Integer</span></a>
  , _mult       :: Result D <a href="http://haskell.org/ghc/docs/latest/html/libraries/base/Prelude.html#t:Integer"><span style="background-color: #efefbf; font-weight: bold;">Integer</span></a>
  , _primary    :: Result D <a href="http://haskell.org/ghc/docs/latest/html/libraries/base/Prelude.html#t:Integer"><span style="background-color: #efefbf; font-weight: bold;">Integer</span></a>
  , _dec        :: Result D <a href="http://haskell.org/ghc/docs/latest/html/libraries/base/Prelude.html#t:Integer"><span style="background-color: #efefbf; font-weight: bold;">Integer</span></a>
  , _uncons     :: <a href="http://haskell.org/ghc/docs/latest/html/libraries/base/Prelude.html#t:Maybe"><span style="background-color: #efefbf; font-weight: bold;">Maybe</span></a> <span style="color: green;">&#40;</span><a href="http://haskell.org/ghc/docs/latest/html/libraries/base/Prelude.html#t:Char"><span style="background-color: #efefbf; font-weight: bold;">Char</span></a>, D<span style="color: green;">&#41;</span>
  <span style="color: green;">&#125;</span>
&nbsp;
<span style="color: #06c; font-weight: bold;">instance</span> <a href="http://haskell.org/ghc/docs/latest/html/libraries/base/Prelude.html#t:Monad"><span style="background-color: #efefbf; font-weight: bold;">Monad</span></a> m =&gt; Stream D m <a href="http://haskell.org/ghc/docs/latest/html/libraries/base/Prelude.html#t:Char"><span style="background-color: #efefbf; font-weight: bold;">Char</span></a> <span style="color: #06c; font-weight: bold;">where</span>
  uncons = <a href="http://haskell.org/ghc/docs/latest/html/libraries/base/Prelude.html#v:return"><span style="font-weight: bold;">return</span></a> . _uncons
&nbsp;</pre>
<p>And using the general purpose <code>rat</code> combinator from earlier, we can write some memoized parsers:</p>
<pre class="haskell">&nbsp;
add, mult, primary, dec :: Parsec D u <a href="http://haskell.org/ghc/docs/latest/html/libraries/base/Prelude.html#t:Integer"><span style="background-color: #efefbf; font-weight: bold;">Integer</span></a>
add     = rat _add
mult    = rat _mult
primary = rat _primary
dec     = rat _dec
&nbsp;</pre>
<p>And finally, we write the code to tie the knot and build the stream:</p>
<pre class="haskell">&nbsp;
parse :: SourceName -&gt; <a href="http://haskell.org/ghc/docs/latest/html/libraries/base/Prelude.html#t:String"><span style="background-color: #efefbf; font-weight: bold;">String</span></a> -&gt; D
parse n = go <span style="color: green;">&#40;</span>initialPos n<span style="color: green;">&#41;</span> <span style="color: #06c; font-weight: bold;">where</span>
  go p s = fix $ \d -&gt; <span style="color: #06c; font-weight: bold;">let</span>
    <span style="color: green;">&#40;</span>womp d p -&gt; _add<span style="color: green;">&#41;</span> =
            <span style="color: green;">&#40;</span>+<span style="color: green;">&#41;</span> &lt; $&gt; mult &lt; * reservedOp <span style="color: #3c7331;">&quot;+&quot;</span> &lt;*&gt; add
        &lt; /&gt; mult &lt; ?&gt; <span style="color: #3c7331;">&quot;summand&quot;</span>
    <span style="color: green;">&#40;</span>womp d p -&gt; _mult<span style="color: green;">&#41;</span> =
            <span style="color: green;">&#40;</span>*<span style="color: green;">&#41;</span> &lt; $&gt; primary &lt; * reservedOp <span style="color: #3c7331;">&quot;*&quot;</span> &lt;*&gt; mult
        &lt; /&gt; primary &lt; ?&gt; <span style="color: #3c7331;">&quot;factor&quot;</span>
    <span style="color: green;">&#40;</span>womp d p -&gt; _primary<span style="color: green;">&#41;</span> =
            parens add
        &lt; /&gt; dec &lt; ?&gt; <span style="color: #3c7331;">&quot;number&quot;</span>
    <span style="color: green;">&#40;</span>womp d p -&gt; _dec<span style="color: green;">&#41;</span> = natural
    _uncons = <span style="color: #06c; font-weight: bold;">case</span> s <span style="color: #06c; font-weight: bold;">of</span>
      <span style="color: green;">&#40;</span>x:xs<span style="color: green;">&#41;</span> -&gt; <a href="http://haskell.org/ghc/docs/latest/html/libraries/base/Prelude.html#v:Just"><span style="font-weight: bold;">Just</span></a> <span style="color: green;">&#40;</span>x, go <span style="color: green;">&#40;</span>updatePosChar p x<span style="color: green;">&#41;</span> xs<span style="color: green;">&#41;</span>
      <span style="color: green;">&#91;</span><span style="color: green;">&#93;</span>     -&gt; <a href="http://haskell.org/ghc/docs/latest/html/libraries/base/Prelude.html#v:Nothing"><span style="font-weight: bold;">Nothing</span></a>
    <span style="color: #06c; font-weight: bold;">in</span> D <span style="color: green;">&#123;</span> .. <span style="color: green;">&#125;</span>
&nbsp;
runD :: Parsec D u a -&gt; u -&gt; SourceName -&gt; <a href="http://haskell.org/ghc/docs/latest/html/libraries/base/Prelude.html#t:String"><span style="background-color: #efefbf; font-weight: bold;">String</span></a> -&gt; <a href="http://haskell.org/ghc/docs/latest/html/libraries/base/Prelude.html#t:Either"><span style="background-color: #efefbf; font-weight: bold;">Either</span></a> ParseError a
runD p u fn s = runParser p u fn <span style="color: green;">&#40;</span>prep fn s<span style="color: green;">&#41;</span>
&nbsp;</pre>
<p>and finally, let it rip:</p>
<pre class="haskell">&nbsp;
eval :: <a href="http://haskell.org/ghc/docs/latest/html/libraries/base/Prelude.html#t:String"><span style="background-color: #efefbf; font-weight: bold;">String</span></a> -&gt; <a href="http://haskell.org/ghc/docs/latest/html/libraries/base/Prelude.html#t:Integer"><span style="background-color: #efefbf; font-weight: bold;">Integer</span></a>
eval s = <a href="http://haskell.org/ghc/docs/latest/html/libraries/base/Prelude.html#v:either"><span style="font-weight: bold;">either</span></a> <span style="color: green;">&#40;</span><a href="http://haskell.org/ghc/docs/latest/html/libraries/base/Prelude.html#v:error"><span style="font-weight: bold;">error</span></a> . <a href="http://haskell.org/ghc/docs/latest/html/libraries/base/Prelude.html#v:show"><span style="font-weight: bold;">show</span></a><span style="color: green;">&#41;</span> <a href="http://haskell.org/ghc/docs/latest/html/libraries/base/Prelude.html#v:id"><span style="font-weight: bold;">id</span></a> $
    runD <span style="color: green;">&#40;</span>whiteSpace *&gt; add &lt; * eof<span style="color: green;">&#41;</span> <span style="color: green;">&#40;</span><span style="color: green;">&#41;</span> <span style="color: #3c7331;">&quot;-&quot;</span> s
&nbsp;</pre>
<p>While this approach tends to encourage memoizing fewer combinators than libraries such as frisby, this is exactly what <a href="http://www.mercury.csse.unimelb.edu.au/information/papers/packrat.pdf">current research suggests you probably should do</a> with packrat parsing!</p>
<p>The other purported advantage of packrat parsers is that they <a href="http://www.vpri.org/pdf/tr2007002_packrat.pdf">can deal with left recursion in the grammar</a>. However, that is not the case, hidden left recursion in the presence of the algorithm used in the scala parsing combinator libraries leads to incorrect non-left-most parses <a href="http://tratt.net/laurie/research/publications/papers/tratt__direct_left_recursive_parsing_expression_grammars.pdf">as shown by Tratt</a>.</p>
<p>I leave it as an exercise for the reader to extend this material with the parsec+iteratees approach from my original talk on trifecta to get packrat parsing of streaming input. Either that or you can wait until it is integrated into trifecta.</p>
<p>You can download the source to this (without the spurious spaces inserted by wordpress) <a href="https://github.com/ekmett/trifecta/blob/master/wip/Womprat.hs">here</a>.</p>
<p>If I can find the time, I hope to spend some time addressing Scott and Johnstone's GLL parsers, which actually achieve the O(n^3) worst case bounds touted for Tomita's GLR algorithm (which is actually O(n^4) as it was originally defined despite the author's claims), and how to encode them in Haskell with an eye towards building a memoizing parser combinator library that can parse LL(1) fragments in O(1), deal with arbitrary context-free grammars in O(n^3), and degrade reasonably gracefully in the presence of context-sensitivity, while supporting hidden left recursion as long as such recursion passes through at least one memoized rule. This is important because CFGs are closed under extensions to the grammar, which is a nice property to have if you want to have a language where you can add new statement types easily without concerning yourself overmuch with the order in which you insert the rules or load the different extensions.</p>
</pre>
]]></content:encoded>
			<wfw:commentRss>http://comonad.com/reader/2011/a-parsec-full-of-rats-part-2/feed/</wfw:commentRss>
		<slash:comments>0</slash:comments>
		</item>
		<item>
		<title>A Parsec Full of Rats, Part 1</title>
		<link>http://comonad.com/reader/2011/a-parsec-full-of-rats/</link>
		<comments>http://comonad.com/reader/2011/a-parsec-full-of-rats/#comments</comments>
		<pubDate>Sat, 24 Sep 2011 02:10:06 +0000</pubDate>
		<dc:creator>Edward Kmett</dc:creator>
				<category><![CDATA[Algorithms]]></category>
		<category><![CDATA[Data Structures]]></category>
		<category><![CDATA[Haskell]]></category>
		<category><![CDATA[Monads]]></category>
		<category><![CDATA[Parsing]]></category>
		<category><![CDATA[Uncategorized]]></category>
		<category><![CDATA[packrat]]></category>
		<category><![CDATA[trifecta]]></category>

		<guid isPermaLink="false">http://comonad.com/reader/?p=380</guid>
		<description><![CDATA[You never heard of the Millenium Falcon? It's the ship that made the Kessel Run in 12 parsecs.
I've been working on a parser combinator library called trifecta, and so I decided I'd share some thoughts on parsing. 
Packrat parsing (as provided by frisby, pappy, rats! and the Scala parsing combinators) and more traditional recursive descent [...]]]></description>
			<content:encoded><![CDATA[<blockquote><p>You never heard of the Millenium Falcon? It's the ship that made the Kessel Run in 12 parsecs.</p></blockquote>
<p>I've been working on a parser combinator library called <a href="http://hackage.haskell.org/package/trifecta">trifecta</a>, and so I decided I'd share some thoughts on parsing. </p>
<p><a href="http://pdos.csail.mit.edu/~baford/packrat/">Packrat parsing</a> (as provided by <a href="http://hackage.haskell.org/package/frisby">frisby</a>, <a href="http://hackage.haskell.org/package/pappy">pappy</a>, <a href="http://cs.nyu.edu/rgrimm/xtc/">rats!</a> and the Scala parsing combinators) and more traditional recursive descent parsers (like Parsec) are often held up as somehow different. </p>
<p>Today I'll show that you can add monadic parsing to a packrat parser, sacrificing asymptotic guarantees in exchange for the convenient context sensitivity, and conversely how you can easily add packrat parsing to a traditional monadic parser combinator library.</p>
<p><span id="more-380"></span></p>
<p>To keep this post self-contained, I'm going to start by defining a small packrat parsing library by hand, which acts rather like parsec in its backtracking behavior. First, some imports:</p>
<pre class="haskell">&nbsp;
<span style="color: #5d478b; font-style: italic;">{-# LANGUAGE RecordWildCards, ViewPatterns, DeriveFunctor #-}</span>
<span style="color: #06c; font-weight: bold;">import</span> Control.Applicative
<span style="color: #06c; font-weight: bold;">import</span> Control.<a href="http://haskell.org/ghc/docs/latest/html/libraries/base/Prelude.html#t:Monad"><span style="background-color: #efefbf; font-weight: bold;">Monad</span></a> <span style="color: green;">&#40;</span>MonadPlus<span style="color: green;">&#40;</span>..<span style="color: green;">&#41;</span>, guard<span style="color: green;">&#41;</span>
<span style="color: #06c; font-weight: bold;">import</span> Control.<a href="http://haskell.org/ghc/docs/latest/html/libraries/base/Prelude.html#t:Monad"><span style="background-color: #efefbf; font-weight: bold;">Monad</span></a>.Fix <span style="color: green;">&#40;</span>fix<span style="color: green;">&#41;</span>
<span style="color: #06c; font-weight: bold;">import</span> Data.<a href="http://haskell.org/ghc/docs/latest/html/libraries/base/Prelude.html#t:Char"><span style="background-color: #efefbf; font-weight: bold;">Char</span></a> <span style="color: green;">&#40;</span>isDigit, digitToInt, isSpace<span style="color: green;">&#41;</span>
&nbsp;</pre>
<p>Second, we'll define a bog simple parser, which consumes an input stream of type d, yielding a possible answer and telling us whether or not it has actually consumed any input as it went.</p>
<pre class="haskell">&nbsp;
<span style="color: #06c; font-weight: bold;">newtype</span> Rat d a = Rat <span style="color: green;">&#123;</span> runRat :: d -&gt; Result d a <span style="color: green;">&#125;</span>
  <span style="color: #06c; font-weight: bold;">deriving</span> <a href="http://haskell.org/ghc/docs/latest/html/libraries/base/Prelude.html#t:Functor"><span style="background-color: #efefbf; font-weight: bold;">Functor</span></a>
&nbsp;
<span style="color: #06c; font-weight: bold;">data</span> Result d a
  = Pure a             <span style="color: #5d478b; font-style: italic;">-- didn't consume anything, can backtrack</span>
  | Commit d a      <span style="color: #5d478b; font-style: italic;">-- consumed input</span>
  | Fail <a href="http://haskell.org/ghc/docs/latest/html/libraries/base/Prelude.html#t:String"><span style="background-color: #efefbf; font-weight: bold;">String</span></a> <a href="http://haskell.org/ghc/docs/latest/html/libraries/base/Prelude.html#t:Bool"><span style="background-color: #efefbf; font-weight: bold;">Bool</span></a> <span style="color: #5d478b; font-style: italic;">-- failed, flagged if consumed</span>
  <span style="color: #06c; font-weight: bold;">deriving</span> <a href="http://haskell.org/ghc/docs/latest/html/libraries/base/Prelude.html#t:Functor"><span style="background-color: #efefbf; font-weight: bold;">Functor</span></a>
&nbsp;</pre>
<p>Now, we can finally implement some type classes:</p>
<pre class="haskell">&nbsp;
<span style="color: #06c; font-weight: bold;">instance</span> Applicative <span style="color: green;">&#40;</span>Rat d<span style="color: green;">&#41;</span> <span style="color: #06c; font-weight: bold;">where</span>
  pure a = Rat $ \ _ -&gt; Pure a
  Rat mf &lt; *&gt; Rat ma = Rat $ \ d -&gt; <span style="color: #06c; font-weight: bold;">case</span> mf d <span style="color: #06c; font-weight: bold;">of</span>
    Pure f      -&gt; <a href="http://haskell.org/ghc/docs/latest/html/libraries/base/Prelude.html#v:fmap"><span style="font-weight: bold;">fmap</span></a> f <span style="color: green;">&#40;</span>ma d<span style="color: green;">&#41;</span>
    Fail s c    -&gt; Fail s c
    Commit d' f -&gt; <span style="color: #06c; font-weight: bold;">case</span> ma d' <span style="color: #06c; font-weight: bold;">of</span>
      Pure a       -&gt; Commit d' <span style="color: green;">&#40;</span>f a<span style="color: green;">&#41;</span>
      Fail s _     -&gt; Fail s <a href="http://haskell.org/ghc/docs/latest/html/libraries/base/Prelude.html#v:True"><span style="font-weight: bold;">True</span></a>
      Commit d'' a -&gt; Commit d'' <span style="color: green;">&#40;</span>f a<span style="color: green;">&#41;</span>
&nbsp;</pre>
<p>including an instance of Alternative that behaves like parsec, only backtracking on failure if no input was unconsumed.</p>
<pre class="haskell">&nbsp;
<span style="color: #06c; font-weight: bold;">instance</span> Alternative <span style="color: green;">&#40;</span>Rat d<span style="color: green;">&#41;</span> <span style="color: #06c; font-weight: bold;">where</span>
  Rat ma &lt; |&gt; Rat mb = Rat $ \ d -&gt; <span style="color: #06c; font-weight: bold;">case</span> ma d <span style="color: #06c; font-weight: bold;">of</span>
    Fail _ <a href="http://haskell.org/ghc/docs/latest/html/libraries/base/Prelude.html#v:False"><span style="font-weight: bold;">False</span></a> -&gt; mb d
    x            -&gt; x
  empty = Rat $ \ _ -&gt; Fail <span style="color: #3c7331;">&quot;empty&quot;</span> <a href="http://haskell.org/ghc/docs/latest/html/libraries/base/Prelude.html#v:False"><span style="font-weight: bold;">False</span></a>
&nbsp;</pre>
<p>For those willing to forego the asymptotic guarantees of packrat, we'll offer a monad.</p>
<pre class="haskell">&nbsp;
<span style="color: #06c; font-weight: bold;">instance</span> <a href="http://haskell.org/ghc/docs/latest/html/libraries/base/Prelude.html#t:Monad"><span style="background-color: #efefbf; font-weight: bold;">Monad</span></a> <span style="color: green;">&#40;</span>Rat d<span style="color: green;">&#41;</span> <span style="color: #06c; font-weight: bold;">where</span>
  <a href="http://haskell.org/ghc/docs/latest/html/libraries/base/Prelude.html#v:return"><span style="font-weight: bold;">return</span></a> a = Rat $ \_ -&gt; Pure a
  Rat m &gt;&gt;= k = Rat $ \d -&gt; <span style="color: #06c; font-weight: bold;">case</span> m d <span style="color: #06c; font-weight: bold;">of</span>
    Pure a -&gt; runRat <span style="color: green;">&#40;</span>k a<span style="color: green;">&#41;</span> d
    Commit d' a -&gt; <span style="color: #06c; font-weight: bold;">case</span> runRat <span style="color: green;">&#40;</span>k a<span style="color: green;">&#41;</span> d' <span style="color: #06c; font-weight: bold;">of</span>
      Pure b -&gt; Commit d' b
      Fail s _ -&gt; Fail s <a href="http://haskell.org/ghc/docs/latest/html/libraries/base/Prelude.html#v:True"><span style="font-weight: bold;">True</span></a>
      commit -&gt; commit
    Fail s c -&gt; Fail s c
  <a href="http://haskell.org/ghc/docs/latest/html/libraries/base/Prelude.html#v:fail"><span style="font-weight: bold;">fail</span></a> s = Rat $ \ _ -&gt; Fail s <a href="http://haskell.org/ghc/docs/latest/html/libraries/base/Prelude.html#v:False"><span style="font-weight: bold;">False</span></a>
&nbsp;
<span style="color: #06c; font-weight: bold;">instance</span> MonadPlus <span style="color: green;">&#40;</span>Rat d<span style="color: green;">&#41;</span> <span style="color: #06c; font-weight: bold;">where</span>
  mplus = <span style="color: green;">&#40;</span>&lt; |&gt;<span style="color: green;">&#41;</span>
  mzero = empty
&nbsp;</pre>
<p>and a Parsec-style "try", which rewinds on failure, so that < |> can try again.</p>
<pre class="haskell">&nbsp;
try :: Rat d a -&gt; Rat d a
try <span style="color: green;">&#40;</span>Rat m<span style="color: green;">&#41;</span> = Rat $ \d -&gt; <span style="color: #06c; font-weight: bold;">case</span> m d <span style="color: #06c; font-weight: bold;">of</span>
  Fail s _ -&gt; Fail s <a href="http://haskell.org/ghc/docs/latest/html/libraries/base/Prelude.html#v:False"><span style="font-weight: bold;">False</span></a>
  x        -&gt; x
&nbsp;</pre>
<p>Since we've consumed < |> with parsec semantics. Let's give a PEG-style backtracking (< />).</p>
<pre class="haskell">&nbsp;
<span style="color: green;">&#40;</span>&lt; /&gt;<span style="color: green;">&#41;</span> :: Rat d a -&gt; Rat d a -&gt; Rat d a
p &lt; /&gt; q = try p &lt; |&gt; q
<span style="color: #06c; font-weight: bold;">infixl</span> <span style="color: red;">3</span> &lt; /&gt;
&nbsp;</pre>
<p>So far nothing we have done involves packrat at all. These are all general purpose recursive descent combinators.</p>
<p>We can define an input stream and a number of combinators to read input.</p>
<pre class="haskell">&nbsp;
<span style="color: #06c; font-weight: bold;">class</span> Stream d <span style="color: #06c; font-weight: bold;">where</span>
  anyChar :: Rat d <a href="http://haskell.org/ghc/docs/latest/html/libraries/base/Prelude.html#t:Char"><span style="background-color: #efefbf; font-weight: bold;">Char</span></a>
&nbsp;
whiteSpace :: Stream d =&gt; Rat d <span style="color: green;">&#40;</span><span style="color: green;">&#41;</span>
whiteSpace = <span style="color: green;">&#40;</span><span style="color: green;">&#41;</span> &lt; $ many <span style="color: green;">&#40;</span>satisfy isSpace<span style="color: green;">&#41;</span>
phrase :: Stream d =&gt; Rat d a -&gt; Rat d a
phrase m = whiteSpace *&gt; m &lt; * eof
&nbsp;
notFollowedBy :: Rat d a -&gt; Rat d <span style="color: green;">&#40;</span><span style="color: green;">&#41;</span>
notFollowedBy <span style="color: green;">&#40;</span>Rat m<span style="color: green;">&#41;</span> = Rat $ \d -&gt; <span style="color: #06c; font-weight: bold;">case</span> m d <span style="color: #06c; font-weight: bold;">of</span>
  Fail<span style="color: green;">&#123;</span><span style="color: green;">&#125;</span> -&gt; Pure <span style="color: green;">&#40;</span><span style="color: green;">&#41;</span>
  _      -&gt; Fail <span style="color: #3c7331;">&quot;unexpected&quot;</span> <a href="http://haskell.org/ghc/docs/latest/html/libraries/base/Prelude.html#v:False"><span style="font-weight: bold;">False</span></a>
&nbsp;
eof :: Stream d =&gt; Rat d <span style="color: green;">&#40;</span><span style="color: green;">&#41;</span>
eof = notFollowedBy anyChar
&nbsp;
satisfy :: Stream d =&gt; <span style="color: green;">&#40;</span><a href="http://haskell.org/ghc/docs/latest/html/libraries/base/Prelude.html#t:Char"><span style="background-color: #efefbf; font-weight: bold;">Char</span></a> -&gt; <a href="http://haskell.org/ghc/docs/latest/html/libraries/base/Prelude.html#t:Bool"><span style="background-color: #efefbf; font-weight: bold;">Bool</span></a><span style="color: green;">&#41;</span> -&gt; Rat d <a href="http://haskell.org/ghc/docs/latest/html/libraries/base/Prelude.html#t:Char"><span style="background-color: #efefbf; font-weight: bold;">Char</span></a>
satisfy p = try $ <span style="color: #06c; font-weight: bold;">do</span>
  x &lt; - anyChar
  x &lt;$ guard <span style="color: green;">&#40;</span>p x<span style="color: green;">&#41;</span>
&nbsp;
char :: Stream d =&gt; <a href="http://haskell.org/ghc/docs/latest/html/libraries/base/Prelude.html#t:Char"><span style="background-color: #efefbf; font-weight: bold;">Char</span></a> -&gt; Rat d <a href="http://haskell.org/ghc/docs/latest/html/libraries/base/Prelude.html#t:Char"><span style="background-color: #efefbf; font-weight: bold;">Char</span></a>
char c = satisfy <span style="color: green;">&#40;</span>c ==<span style="color: green;">&#41;</span>
&nbsp;
lexeme :: Stream d =&gt; Rat d a -&gt; Rat d a
lexeme m = m &lt; * whiteSpace
&nbsp;
symbol :: Stream d =&gt; <a href="http://haskell.org/ghc/docs/latest/html/libraries/base/Prelude.html#t:Char"><span style="background-color: #efefbf; font-weight: bold;">Char</span></a> -&gt; Rat d <a href="http://haskell.org/ghc/docs/latest/html/libraries/base/Prelude.html#t:Char"><span style="background-color: #efefbf; font-weight: bold;">Char</span></a>
symbol c = lexeme <span style="color: green;">&#40;</span>char c<span style="color: green;">&#41;</span>
&nbsp;
digit :: Stream d =&gt; Rat d <a href="http://haskell.org/ghc/docs/latest/html/libraries/base/Prelude.html#t:Int"><span style="background-color: #efefbf; font-weight: bold;">Int</span></a>
digit = digitToInt &lt; $&gt; satisfy isDigit
&nbsp;</pre>
<p>And we can of course use a string as our input stream:</p>
<pre class="haskell">&nbsp;
<span style="color: #06c; font-weight: bold;">instance</span> Stream <span style="color: green;">&#91;</span><a href="http://haskell.org/ghc/docs/latest/html/libraries/base/Prelude.html#t:Char"><span style="background-color: #efefbf; font-weight: bold;">Char</span></a><span style="color: green;">&#93;</span> <span style="color: #06c; font-weight: bold;">where</span>
  anyChar = Rat $ \s -&gt; <span style="color: #06c; font-weight: bold;">case</span> s <span style="color: #06c; font-weight: bold;">of</span>
    <span style="color: green;">&#40;</span>x:xs<span style="color: green;">&#41;</span> -&gt; Commit xs x
    <span style="color: green;">&#91;</span><span style="color: green;">&#93;</span> -&gt; Fail <span style="color: #3c7331;">&quot;EOF&quot;</span> <a href="http://haskell.org/ghc/docs/latest/html/libraries/base/Prelude.html#v:False"><span style="font-weight: bold;">False</span></a>
&nbsp;</pre>
<p>Now that we've built a poor man's Parsec, let's do something more interesting. Instead of just using String as out input stream, let's include slots for use in memoizing the results from our various parsers at each location. To keep things concrete, we'll memoize the ArithPackrat.hs example that Bryan Ford used in his initial packrat presentation enriched with some whitespace handling.</p>
<pre class="haskell">&nbsp;
<span style="color: #06c; font-weight: bold;">data</span> D = D
  <span style="color: green;">&#123;</span> _add        :: Result D <a href="http://haskell.org/ghc/docs/latest/html/libraries/base/Prelude.html#t:Int"><span style="background-color: #efefbf; font-weight: bold;">Int</span></a>
  , _mult       :: Result D <a href="http://haskell.org/ghc/docs/latest/html/libraries/base/Prelude.html#t:Int"><span style="background-color: #efefbf; font-weight: bold;">Int</span></a>
  , _primary    :: Result D <a href="http://haskell.org/ghc/docs/latest/html/libraries/base/Prelude.html#t:Int"><span style="background-color: #efefbf; font-weight: bold;">Int</span></a>
  , _decimal    :: Result D <a href="http://haskell.org/ghc/docs/latest/html/libraries/base/Prelude.html#t:Int"><span style="background-color: #efefbf; font-weight: bold;">Int</span></a>
  , anyCharD    :: Result D <a href="http://haskell.org/ghc/docs/latest/html/libraries/base/Prelude.html#t:Char"><span style="background-color: #efefbf; font-weight: bold;">Char</span></a>
  <span style="color: green;">&#125;</span>
&nbsp;</pre>
<p>If you look at the type of each of those functions you'll see that <code>_add :: D -> Result D Int</code>, which is exactly our Rat newtype expects as its argument, we we can bundle them directly:</p>
<pre class="haskell">&nbsp;
&nbsp;
add, mult, primary, decimal :: Rat D <a href="http://haskell.org/ghc/docs/latest/html/libraries/base/Prelude.html#t:Int"><span style="background-color: #efefbf; font-weight: bold;">Int</span></a>
add     = Rat _add
mult    = Rat _mult
primary = Rat _primary
decimal = Rat _decimal
&nbsp;</pre>
<p>We can similarly juse use the character parse result.</p>
<pre class="haskell">&nbsp;
<span style="color: #06c; font-weight: bold;">instance</span> Stream D <span style="color: #06c; font-weight: bold;">where</span>
  anyChar = Rat anyCharD
&nbsp;</pre>
<p>Now we just need to build a D from a String. I'm using view patterns and record wildcards to shrink the amount of repetitive naming.</p>
<pre class="haskell">&nbsp;
parse :: <a href="http://haskell.org/ghc/docs/latest/html/libraries/base/Prelude.html#t:String"><span style="background-color: #efefbf; font-weight: bold;">String</span></a> -&gt; D
parse s = fix $ \d -&gt; <span style="color: #06c; font-weight: bold;">let</span>
  Rat <span style="color: green;">&#40;</span>dv d -&gt; _add<span style="color: green;">&#41;</span> =
        <span style="color: green;">&#40;</span>+<span style="color: green;">&#41;</span> &lt; $&gt; mult &lt; * symbol '+' &lt;*&gt; add
     &lt; /&gt; mult
  Rat <span style="color: green;">&#40;</span>dv d -&gt; _mult<span style="color: green;">&#41;</span> =
        <span style="color: green;">&#40;</span>*<span style="color: green;">&#41;</span> &lt; $&gt; primary &lt; * symbol '*' &lt;*&gt; mult
    &lt; /&gt; primary
  Rat <span style="color: green;">&#40;</span>dv d -&gt; _primary<span style="color: green;">&#41;</span> =
        symbol '<span style="color: green;">&#40;</span>' *&gt; add &lt; * symbol '<span style="color: green;">&#41;</span>'
    &lt;/&gt; decimal
  Rat <span style="color: green;">&#40;</span>dv d -&gt; _decimal<span style="color: green;">&#41;</span> =
     <a href="http://haskell.org/ghc/docs/latest/html/libraries/base/Prelude.html#v:foldl"><span style="font-weight: bold;">foldl</span></a>' <span style="color: green;">&#40;</span>\b a -&gt; b * <span style="color: red;">10</span> + a<span style="color: green;">&#41;</span> <span style="color: red;">0</span> &lt; $&gt; lexeme <span style="color: green;">&#40;</span>some digit<span style="color: green;">&#41;</span>
  anyCharD = <span style="color: #06c; font-weight: bold;">case</span> s <span style="color: #06c; font-weight: bold;">of</span>
    <span style="color: green;">&#40;</span>x:xs<span style="color: green;">&#41;</span> -&gt; Commit <span style="color: green;">&#40;</span>parse xs<span style="color: green;">&#41;</span> x
    <span style="color: green;">&#91;</span><span style="color: green;">&#93;</span>     -&gt; Fail <span style="color: #3c7331;">&quot;EOF&quot;</span> <a href="http://haskell.org/ghc/docs/latest/html/libraries/base/Prelude.html#v:False"><span style="font-weight: bold;">False</span></a>
  <span style="color: #06c; font-weight: bold;">in</span> D <span style="color: green;">&#123;</span> .. <span style="color: green;">&#125;</span>
&nbsp;
dv :: d -&gt; <span style="color: green;">&#40;</span>d -&gt; b<span style="color: green;">&#41;</span> -&gt; b
dv d f = f d
&nbsp;</pre>
<p>Note that we didn't really bother factoring the grammar, since packrat will take care of memoizing the redundant calls!</p>
<p>And with that, we can define an evaluator.</p>
<pre class="haskell">&nbsp;
eval :: <a href="http://haskell.org/ghc/docs/latest/html/libraries/base/Prelude.html#t:String"><span style="background-color: #efefbf; font-weight: bold;">String</span></a> -&gt; <a href="http://haskell.org/ghc/docs/latest/html/libraries/base/Prelude.html#t:Int"><span style="background-color: #efefbf; font-weight: bold;">Int</span></a>
eval s = <span style="color: #06c; font-weight: bold;">case</span> runRat <span style="color: green;">&#40;</span>whiteSpace *&gt; add &lt; * eof<span style="color: green;">&#41;</span> <span style="color: green;">&#40;</span>parse s<span style="color: green;">&#41;</span> <span style="color: #06c; font-weight: bold;">of</span>
  Pure a -&gt; a
  Commit _ a -&gt; a
  Fail s _ -&gt; <a href="http://haskell.org/ghc/docs/latest/html/libraries/base/Prelude.html#v:error"><span style="font-weight: bold;">error</span></a> s
&nbsp;</pre>
<p>Note that because the input stream D contains the result directly and parse is the only thing that ever generates a D, and it does so when we start up, it should be obvious that the parse results for each location can't depend on any additional information smuggled in via our monad.</p>
<p>Next time, we'll add a packratted Stream type directly to Parsec, which will necessitate some delicate handling of user state.</p>
<p>The small parser implemented here can be <a href="https://github.com/ekmett/trifecta/blob/master/wip/Rat.hs">found on my github account</a>, where it hasn't been adulterated with unnecessary spaces by my blog software.</p>
<p>P.S. To explain the quote, had I thought of it earlier, I could have named my parsing combinator library "Kessel Run" as by the time I'm done with it "it will contain at least 12 parsecs" between its different parser implementations.</p>
]]></content:encoded>
			<wfw:commentRss>http://comonad.com/reader/2011/a-parsec-full-of-rats/feed/</wfw:commentRss>
		<slash:comments>2</slash:comments>
		</item>
		<item>
		<title>The Pointed-Set Comonad</title>
		<link>http://comonad.com/reader/2008/the-pointed-set-comonad/</link>
		<comments>http://comonad.com/reader/2008/the-pointed-set-comonad/#comments</comments>
		<pubDate>Thu, 04 Dec 2008 18:56:15 +0000</pubDate>
		<dc:creator>Edward Kmett</dc:creator>
				<category><![CDATA[Comonads]]></category>
		<category><![CDATA[Haskell]]></category>
		<category><![CDATA[Uncategorized]]></category>

		<guid isPermaLink="false">http://comonad.com/reader/2008/the-pointed-set-comonad/</guid>
		<description><![CDATA[Last night, Chung-Chieh Shan posted an example of a pointed-set monad on his blog, which happens to be isomorphic to a non-empty stream monad with a different emphasis. 
But, I thought I should point out that the pointed set that he posted also has a comonadic structure, which may be exploited since it is just [...]]]></description>
			<content:encoded><![CDATA[<p>Last night, Chung-Chieh Shan posted an example of a <a href="http://conway.rutgers.edu/~ccshan/wiki/blog/posts/Pointed_set/">pointed-set monad</a> on his blog, which happens to be isomorphic to a non-empty stream monad with a different emphasis. </p>
<p>But, I thought I should point out that the pointed set that he posted also has a comonadic structure, which may be exploited since it is just a variation on the "zipper comonad," a structure that is perhaps more correctly called a "pointing comonad."</p>
<p><span id="more-80"></span></p>
<p>But first, a little background:</p>
<p>With <a href="http://en.wikipedia.org/wiki/Combinatorial_species">combinatorial species</a> you point a data structure by marking a single element in it as special. We can represent that with the product of an element and the <a href="http://en.wikipedia.org/wiki/Derivative_(generalizations)#Set_theory_and_logic">derivative</a> of the original type.</p>
<pre>
F*[A] = A * F'[A]
</pre>
<p>So, then looking at Shan's pointed set, we can ask what combinatorial species has a list as its derivative? </p>
<p>The answer is a cycle, not a set. </p>
<p>This fact doesn't matter to the monad, since the only way a monadic action interacts with that extra structure is safely through bind, but does for the comonad where every comonadic action has access to that structure, but no control over the shape of the result.</p>
<p>However, we don't really have a way to represent an unordered set in Haskell, so if you are treating a list as a set, the derivative of a set is another set then we can also view the a * [a] as a pointed set, so long as we don't depend on the order of the elements in the list in any way in obtaining the result of our comonadic actions.</p>
<p>I've changed the name of his data type to <code>PointedSet</code> to avoid conflicting with the definitions of <code>Pointed</code> and <code>Copointed</code> functors in category extras.</p>
<pre class="haskell">&nbsp;
<span style="color: #06c; font-weight: bold;">module</span> PointedSet <span style="color: #06c; font-weight: bold;">where</span>
&nbsp;
<span style="color: #06c; font-weight: bold;">import</span> Control.<a href="../../../../haskell/category-extras/dist/doc/html/category-extras/Control-Comonad.html#t:Comonad"><span style="background-color: #efefbf; font-weight: bold;">Comonad</span></a> <span style="color: #5d478b; font-style: italic;">-- from my category-extras library</span>
<span style="color: #06c; font-weight: bold;">import</span> Data.List <span style="color: green;">&#40;</span>inits,tails<span style="color: green;">&#41;</span> <span style="color: #5d478b; font-style: italic;">-- used much later below</span>
&nbsp;
<span style="color: #06c; font-weight: bold;">data</span> PointedSet a = PointedSet a <span style="color: green;">&#91;</span>a<span style="color: green;">&#93;</span> <span style="color: #06c; font-weight: bold;">deriving</span> <span style="color: green;">&#40;</span><a href="http://haskell.org/ghc/docs/latest/html/libraries/base/Prelude.html#t:Eq"><span style="background-color: #efefbf; font-weight: bold;">Eq</span></a>, <a href="http://haskell.org/ghc/docs/latest/html/libraries/base/Prelude.html#t:Ord"><span style="background-color: #efefbf; font-weight: bold;">Ord</span></a>, <a href="http://haskell.org/ghc/docs/latest/html/libraries/base/Prelude.html#t:Show"><span style="background-color: #efefbf; font-weight: bold;">Show</span></a>, <a href="http://haskell.org/ghc/docs/latest/html/libraries/base/Prelude.html#t:Read"><span style="background-color: #efefbf; font-weight: bold;">Read</span></a><span style="color: green;">&#41;</span>
&nbsp;
<span style="color: #06c; font-weight: bold;">instance</span> <a href="http://haskell.org/ghc/docs/latest/html/libraries/base/Prelude.html#t:Functor"><span style="background-color: #efefbf; font-weight: bold;">Functor</span></a> PointedSet <span style="color: #06c; font-weight: bold;">where</span>
    <a href="http://haskell.org/ghc/docs/latest/html/libraries/base/Prelude.html#v:fmap"><span style="font-weight: bold;">fmap</span></a> f <span style="color: green;">&#40;</span>PointedSet x xs<span style="color: green;">&#41;</span> = PointedSet <span style="color: green;">&#40;</span>f x<span style="color: green;">&#41;</span> $ <a href="http://haskell.org/ghc/docs/latest/html/libraries/base/Prelude.html#v:fmap"><span style="font-weight: bold;">fmap</span></a> f xs
&nbsp;</pre>
<p>The definition for extract is obvious, since you have already selected a point, just return it. </p>
<pre class="haskell">&nbsp;
<span style="color: #06c; font-weight: bold;">instance</span> Copointed PointedSet <span style="color: #06c; font-weight: bold;">where</span>
    <a href="../../../../haskell/category-extras/dist/doc/html/category-extras/Control-Comonad.html#v:extract"><span style="font-weight: bold;">extract</span></a> <span style="color: green;">&#40;</span>PointedSet x _<span style="color: green;">&#41;</span> = x
&nbsp;</pre>
<p>On the other hand, for duplicate we have a couple of options. An obvious and correct, but boring implementation transforms a value as follows:</p>
<pre class="haskell">&nbsp;
boring_duplicate :: PointedSet a -&gt; PointedSet <span style="color: green;">&#40;</span>PointedSet a<span style="color: green;">&#41;</span>
boring_duplicate xxs@<span style="color: green;">&#40;</span>PointedSet x xs<span style="color: green;">&#41;</span> =
    PointedSet xxs $ <a href="http://haskell.org/ghc/docs/latest/html/libraries/base/Prelude.html#v:fmap"><span style="font-weight: bold;">fmap</span></a> <span style="color: green;">&#40;</span><a href="http://haskell.org/ghc/docs/latest/html/libraries/base/Prelude.html#v:flip"><span style="font-weight: bold;">flip</span></a> PointedSet <span style="color: green;">&#91;</span><span style="color: green;">&#93;</span><span style="color: green;">&#41;</span> xs
&nbsp;</pre>
<pre class="haskell">&nbsp;
*PointedSet&gt; boring_duplicate $ PointedSet <span style="color: red;">0</span> <span style="color: green;">&#91;</span><span style="color: red;">1</span>..<span style="color: red;">3</span><span style="color: green;">&#93;</span>
PointedSet <span style="color: green;">&#40;</span>PointedSet <span style="color: red;">0</span> <span style="color: green;">&#91;</span><span style="color: red;">1</span>..<span style="color: red;">3</span><span style="color: green;">&#93;</span><span style="color: green;">&#41;</span> <span style="color: green;">&#91;</span>
    PointedSet <span style="color: red;">1</span> <span style="color: green;">&#91;</span><span style="color: green;">&#93;</span>,
    PointedSet <span style="color: red;">2</span> <span style="color: green;">&#91;</span><span style="color: green;">&#93;</span>,
    PointedSet <span style="color: red;">3</span> <span style="color: green;">&#91;</span><span style="color: green;">&#93;</span>
<span style="color: green;">&#93;</span>
&nbsp;</pre>
<p>but that just abuses the fact that we can always return an empty list. </p>
<p>Another fairly boring interpretation is to just use the guts of the definition of the Stream comonad, but that doesn't model a set with a single memory singled out.</p>
<p>A more interesting version refocuses on each element of the list in turn, which makes the connection to the zipper comonad much more obvious. Since we want a pointed set and not a pointed cycle, we can focus on an element just by swapping out the element in the list in that position for the focus.</p>
<p>Again, since we can't specify general species in Haskell, this is as close as we can come to the correct comonadic structure for a pointed set. Due to the limitations of our type system, the comonadic action can still see the order of elements in the set, but it shouldn't use that information. </p>
<p>Since we don't care to preserve the order of the miscellaneous set elements, the <code>refocus</code> helper function below can just accumulate preceding elements in an accumulating parameter in reverse order.</p>
<pre class="haskell">&nbsp;
<span style="color: #06c; font-weight: bold;">instance</span> <a href="../../../../haskell/category-extras/dist/doc/html/category-extras/Control-Comonad.html#t:Comonad"><span style="background-color: #efefbf; font-weight: bold;">Comonad</span></a> PointedSet <span style="color: #06c; font-weight: bold;">where</span>
    <a href="../../../../haskell/category-extras/dist/doc/html/category-extras/Control-Comonad.html#v:duplicate"><span style="font-weight: bold;">duplicate</span></a> xxs@<span style="color: green;">&#40;</span>PointedSet x xs<span style="color: green;">&#41;</span> = PointedSet xxs $ refocus <span style="color: green;">&#91;</span><span style="color: green;">&#93;</span> x xs
      <span style="color: #06c; font-weight: bold;">where</span>
        refocus :: <span style="color: green;">&#91;</span>a<span style="color: green;">&#93;</span> -&gt; a -&gt; <span style="color: green;">&#91;</span>a<span style="color: green;">&#93;</span> -&gt; <span style="color: green;">&#91;</span>PointedSet a<span style="color: green;">&#93;</span>
        refocus acc x <span style="color: green;">&#40;</span>y:ys<span style="color: green;">&#41;</span> =
            PointedSet y <span style="color: green;">&#40;</span>acc ++ <span style="color: green;">&#40;</span>x:ys<span style="color: green;">&#41;</span><span style="color: green;">&#41;</span> : refocus <span style="color: green;">&#40;</span>y:acc<span style="color: green;">&#41;</span> x ys
        refocus acc x <span style="color: green;">&#91;</span><span style="color: green;">&#93;</span> = <span style="color: green;">&#91;</span><span style="color: green;">&#93;</span>
&nbsp;</pre>
<p>Now,</p>
<pre class="haskell">&nbsp;
*PointedSet&gt; <a href="../../../../haskell/category-extras/dist/doc/html/category-extras/Control-Comonad.html#v:duplicate"><span style="font-weight: bold;">duplicate</span></a> $ PointedSet <span style="color: red;">0</span> <span style="color: green;">&#91;</span><span style="color: red;">1</span>..<span style="color: red;">3</span><span style="color: green;">&#93;</span> =
PointedSet <span style="color: green;">&#40;</span>PointedSet <span style="color: red;">0</span> <span style="color: green;">&#91;</span><span style="color: red;">1</span>,<span style="color: red;">2</span>,<span style="color: red;">3</span><span style="color: green;">&#93;</span><span style="color: green;">&#41;</span> <span style="color: green;">&#91;</span>
    PointedSet <span style="color: red;">1</span> <span style="color: green;">&#91;</span><span style="color: red;">0</span>,<span style="color: red;">2</span>,<span style="color: red;">3</span><span style="color: green;">&#93;</span>,
    PointedSet <span style="color: red;">2</span> <span style="color: green;">&#91;</span><span style="color: red;">1</span>,<span style="color: red;">0</span>,<span style="color: red;">3</span><span style="color: green;">&#93;</span>,
    PointedSet <span style="color: red;">3</span> <span style="color: green;">&#91;</span><span style="color: red;">2</span>,<span style="color: red;">1</span>,<span style="color: red;">0</span><span style="color: green;">&#93;</span>
<span style="color: green;">&#93;</span>
&nbsp;</pre>
<p>With that in hand we can define comonadic actions that can look at an entire <code>PointedSet</code> and return a value, then extend them comonadically to generate new pointed sets.</p>
<p>For instance, if we had a numerical pointed set and wanted to blur our focus somewhat we could weight an average between the focused and unfocused elements:</p>
<pre>
smooth :: Fractional a => a -> PointedSet a -> a
smooth w (PointedSet a as) =
    w * a +
    (1 - w) * sum as / fromIntegral (length as)
</pre>
<p>Smoothing is a safe pointed-set comonadic operation because it doesn't care about the order of the elements in the list.</p>
<p>And so now we can blur the distinction between the focused element and the rest of the set: </p>
<pre class="haskell">&nbsp;
*PointedSet&gt; <a href="../../../../haskell/category-extras/dist/doc/html/category-extras/Control-Comonad.html#v:extend"><span style="font-weight: bold;">extend</span></a> <span style="color: green;">&#40;</span>smooth <span style="color: red;">0.5</span><span style="color: green;">&#41;</span> $ PointedSet <span style="color: red;">10</span> <span style="color: green;">&#91;</span><span style="color: red;">1</span>..<span style="color: red;">5</span><span style="color: green;">&#93;</span>
PointedSet <span style="color: red;">6.5</span> <span style="color: green;">&#91;</span><span style="color: red;">2.9</span>,<span style="color: red;">3.3</span>,<span style="color: red;">3.7</span>,<span style="color: red;">4.1</span>,<span style="color: red;">4.5</span><span style="color: green;">&#93;</span>
&nbsp;</pre>
<p>A quick pass over the comonad laws shows that they all check out.</p>
<p>As noted above, if your comonadic action uses the order of the elements in the list beyond the selection of the focus, then it isn't really a valid pointed set comonadic operation. This is because we are abusing a list to approximate a (multi)set.</p>
<p><b>The Pointed-Cycle Comonad</b></p>
<p>A slight variation on this theme keeps the order of the elements the same in exchange for a more expensive refocusing operation and just rotates them through the focus. </p>
<pre class="haskell">&nbsp;
<span style="color: #06c; font-weight: bold;">data</span> PointedCycle a = PointedCycle a <span style="color: green;">&#91;</span>a<span style="color: green;">&#93;</span> <span style="color: #06c; font-weight: bold;">deriving</span> <span style="color: green;">&#40;</span><a href="http://haskell.org/ghc/docs/latest/html/libraries/base/Prelude.html#t:Eq"><span style="background-color: #efefbf; font-weight: bold;">Eq</span></a>, <a href="http://haskell.org/ghc/docs/latest/html/libraries/base/Prelude.html#t:Ord"><span style="background-color: #efefbf; font-weight: bold;">Ord</span></a>, <a href="http://haskell.org/ghc/docs/latest/html/libraries/base/Prelude.html#t:Show"><span style="background-color: #efefbf; font-weight: bold;">Show</span></a>,<a href="http://haskell.org/ghc/docs/latest/html/libraries/base/Prelude.html#t:Read"><span style="background-color: #efefbf; font-weight: bold;">Read</span></a><span style="color: green;">&#41;</span>
&nbsp;
<span style="color: #06c; font-weight: bold;">instance</span> <a href="http://haskell.org/ghc/docs/latest/html/libraries/base/Prelude.html#t:Functor"><span style="background-color: #efefbf; font-weight: bold;">Functor</span></a> PointedCycle <span style="color: #06c; font-weight: bold;">where</span>
    <a href="http://haskell.org/ghc/docs/latest/html/libraries/base/Prelude.html#v:fmap"><span style="font-weight: bold;">fmap</span></a> f <span style="color: green;">&#40;</span>PointedCycle x xs<span style="color: green;">&#41;</span> = PointedCycle <span style="color: green;">&#40;</span>f x<span style="color: green;">&#41;</span> $ <a href="http://haskell.org/ghc/docs/latest/html/libraries/base/Prelude.html#v:fmap"><span style="font-weight: bold;">fmap</span></a> f xs
&nbsp;
<span style="color: #06c; font-weight: bold;">instance</span> Copointed PointedCycle <span style="color: #06c; font-weight: bold;">where</span>
    <a href="../../../../haskell/category-extras/dist/doc/html/category-extras/Control-Comonad.html#v:extract"><span style="font-weight: bold;">extract</span></a> <span style="color: green;">&#40;</span>PointedCycle x _<span style="color: green;">&#41;</span> = x
&nbsp;
<span style="color: #06c; font-weight: bold;">instance</span> <a href="../../../../haskell/category-extras/dist/doc/html/category-extras/Control-Comonad.html#t:Comonad"><span style="background-color: #efefbf; font-weight: bold;">Comonad</span></a> PointedCycle <span style="color: #06c; font-weight: bold;">where</span>
   <a href="../../../../haskell/category-extras/dist/doc/html/category-extras/Control-Comonad.html#v:duplicate"><span style="font-weight: bold;">duplicate</span></a> xxs@<span style="color: green;">&#40;</span>PointedCycle x xs<span style="color: green;">&#41;</span> =
        PointedCycle xxs . <a href="http://haskell.org/ghc/docs/latest/html/libraries/base/Prelude.html#v:fmap"><span style="font-weight: bold;">fmap</span></a> listToCycle . <a href="http://haskell.org/ghc/docs/latest/html/libraries/base/Prelude.html#v:tail"><span style="font-weight: bold;">tail</span></a> $ rotations <span style="color: green;">&#40;</span>x:xs<span style="color: green;">&#41;</span>
     <span style="color: #06c; font-weight: bold;">where</span>
        rotations :: <span style="color: green;">&#91;</span>a<span style="color: green;">&#93;</span> -&gt; <span style="color: green;">&#91;</span><span style="color: green;">&#91;</span>a<span style="color: green;">&#93;</span><span style="color: green;">&#93;</span>
        rotations xs = <a href="http://haskell.org/ghc/docs/latest/html/libraries/base/Prelude.html#v:init"><span style="font-weight: bold;">init</span></a> $ <a href="http://haskell.org/ghc/docs/latest/html/libraries/base/Prelude.html#v:zipWith"><span style="font-weight: bold;">zipWith</span></a> <span style="color: green;">&#40;</span>++<span style="color: green;">&#41;</span> <span style="color: green;">&#40;</span>tails xs<span style="color: green;">&#41;</span> <span style="color: green;">&#40;</span>inits xs<span style="color: green;">&#41;</span>
        listToCycle <span style="color: green;">&#40;</span>x:xs<span style="color: green;">&#41;</span> = PointedCycle x xs
&nbsp;</pre>
<p>With that you acknowledge that you really have a pointed cycle and the writer of the comonadic action can safely use the ordering information intrinsic to the list as a natural consequence of having taken the derivative of a cycle.</p>
<pre class="haskell">&nbsp;
*PointedSet&gt; <a href="../../../../haskell/category-extras/dist/doc/html/category-extras/Control-Comonad.html#v:duplicate"><span style="font-weight: bold;">duplicate</span></a> $ PointedCycle <span style="color: red;">0</span> <span style="color: green;">&#91;</span><span style="color: red;">1</span>..<span style="color: red;">3</span><span style="color: green;">&#93;</span>
PointedCycle <span style="color: green;">&#40;</span>PointedCycle <span style="color: red;">0</span> <span style="color: green;">&#91;</span><span style="color: red;">1</span>,<span style="color: red;">2</span>,<span style="color: red;">3</span><span style="color: green;">&#93;</span><span style="color: green;">&#41;</span> <span style="color: green;">&#91;</span>
    PointedCycle <span style="color: red;">1</span> <span style="color: green;">&#91;</span><span style="color: red;">2</span>,<span style="color: red;">3</span>,<span style="color: red;">0</span><span style="color: green;">&#93;</span>,
    PointedCycle <span style="color: red;">2</span> <span style="color: green;">&#91;</span><span style="color: red;">3</span>,<span style="color: red;">0</span>,<span style="color: red;">1</span><span style="color: green;">&#93;</span>,
    PointedCycle <span style="color: red;">3</span> <span style="color: green;">&#91;</span><span style="color: red;">0</span>,<span style="color: red;">1</span>,<span style="color: red;">2</span><span style="color: green;">&#93;</span>
<span style="color: green;">&#93;</span>
&nbsp;</pre>
]]></content:encoded>
			<wfw:commentRss>http://comonad.com/reader/2008/the-pointed-set-comonad/feed/</wfw:commentRss>
		<slash:comments>3</slash:comments>
		</item>
		<item>
		<title>Still Alive</title>
		<link>http://comonad.com/reader/2008/still-alive/</link>
		<comments>http://comonad.com/reader/2008/still-alive/#comments</comments>
		<pubDate>Sat, 08 Nov 2008 14:45:45 +0000</pubDate>
		<dc:creator>Edward Kmett</dc:creator>
				<category><![CDATA[Uncategorized]]></category>

		<guid isPermaLink="false">http://comonad.com/reader/2008/still-alive/</guid>
		<description><![CDATA[To those that have asked, I'm still alive. 
I had to restore the blog database from a backup and so I lost a few posts, including the index for the various recursion schemes entries. Fortunately, before that happened I had replicated the catamorphism post as a knol.
Should I find myself with a copious glut of [...]]]></description>
			<content:encoded><![CDATA[<p>To those that have asked, I'm still alive. </p>
<p>I had to restore the blog database from a backup and so I lost a few posts, including the index for the various recursion schemes entries. Fortunately, before that happened I had replicated the <a href="http://knol.google.com/k/edward-kmett/catamorphisms/">catamorphism post as a knol</a>.</p>
<p>Should I find myself with a copious glut of free time, I shall happily re-scribe and finish the rest, but I've been very busy. </p>
]]></content:encoded>
			<wfw:commentRss>http://comonad.com/reader/2008/still-alive/feed/</wfw:commentRss>
		<slash:comments>6</slash:comments>
		</item>
		<item>
		<title>Forgetful Laziness</title>
		<link>http://comonad.com/reader/2008/forgetful-laziness/</link>
		<comments>http://comonad.com/reader/2008/forgetful-laziness/#comments</comments>
		<pubDate>Fri, 16 May 2008 22:25:06 +0000</pubDate>
		<dc:creator>Edward Kmett</dc:creator>
				<category><![CDATA[Haskell]]></category>
		<category><![CDATA[Uncategorized]]></category>

		<guid isPermaLink="false">http://comonad.com/reader/2008/forgetful-laziness/</guid>
		<description><![CDATA[Does anyone know of any work on "forgetful laziness?"

The basic idea being that for each thunk instead of overwriting it with the answer as usual in call-by-need, you'd just write a forwarding pointer, and allow GC to collect the answers over time. 
This results in recalculation and may be subject to thrashing, so the obvious [...]]]></description>
			<content:encoded><![CDATA[<p>Does anyone know of any work on "forgetful laziness?"</p>
<p><span id="more-59"></span></p>
<p>The basic idea being that for each thunk instead of overwriting it with the answer as usual in call-by-need, you'd just write a forwarding pointer, and allow GC to collect the answers over time. </p>
<p>This results in recalculation and may be subject to thrashing, so the obvious fix would be either</p>
<ol>
<li> a 'forget at most once' policy, which would only mitigate the kind of memory leaks you get from laziness under limited conditions, but which has a worst case payout of doubling the workload or
</li>
<li> an exponential backoff on how often you'll try to recollect a given value, which should preserve for practical purposes the asymptotic behavior of any algorithm, but with a much larger constant for pathological access patterns. [Edit: it may affect asymptotic behavior, because you could lose sharing]
</li>
</ol>
<p>This would allow the recollection of large CAFs, etc. eventually once they had bitrotted long enough. </p>
<p>Not sure if its worth the cost of recalculating and of storing any backoff counter, but most of the horror stories you hear about Haskell center around its occasional horrific memory usage profile.</p>
<p>Tuning points might include studying average thunk lifetimes to construct thunk access profiles rather than use a naive exponential backoff.</p>
<p>It also may exascerbate the opposite problem where naive code often builds up a tower of thunks it needs to evaluate all at once in order to provide an answer (i.e. when working with a lazy accumulating parameter).</p>
]]></content:encoded>
			<wfw:commentRss>http://comonad.com/reader/2008/forgetful-laziness/feed/</wfw:commentRss>
		<slash:comments>6</slash:comments>
		</item>
		<item>
		<title>Unnatural Transformations</title>
		<link>http://comonad.com/reader/2008/unnatural-transformations/</link>
		<comments>http://comonad.com/reader/2008/unnatural-transformations/#comments</comments>
		<pubDate>Sun, 27 Apr 2008 00:43:08 +0000</pubDate>
		<dc:creator>Edward Kmett</dc:creator>
				<category><![CDATA[Category Theory]]></category>
		<category><![CDATA[Comonads]]></category>
		<category><![CDATA[Haskell]]></category>
		<category><![CDATA[Monads]]></category>
		<category><![CDATA[Uncategorized]]></category>

		<guid isPermaLink="false">http://comonad.com/reader/2008/unnatural-transformations/</guid>
		<description><![CDATA[Back in the days of HYLO, it was common to write hylomorphisms with an additional natural transformation in them. Well, I was still coding in evil imperative languages back then, but I have it on reliable, er.. well supposition, that this is probably the case, or at least that they liked to do it back [...]]]></description>
			<content:encoded><![CDATA[<p>Back in the days of <a href="http://citeseer.ist.psu.edu/41091.html">HYLO</a>, it was common to write hylomorphisms with an additional natural transformation in them. Well, I was still coding in evil imperative languages back then, but I have it on reliable, er.. well supposition, that this is probably the case, or at least that they liked to do it back in the HYLO papers anyways.</p>
<p>Transcoding the category theory mumbo-jumbo into Haskell, so I can have a larger audience, we get the following 'frat combinator' -- you can blame Jules Bean from #haskell for that.</p>
<pre class="haskell">&nbsp;
hyloEta :: <a href="http://haskell.org/ghc/docs/latest/html/libraries/base/Prelude.html#t:Functor"><span style="background-color: #efefbf; font-weight: bold;">Functor</span></a> f =&gt;
     <span style="color: green;">&#40;</span>g b -&gt; b<span style="color: green;">&#41;</span> -&gt;
     <span style="color: green;">&#40;</span><span style="color: #06c; font-weight: bold;">forall</span> a. f a -&gt; g a<span style="color: green;">&#41;</span> -&gt;
     <span style="color: green;">&#40;</span>a -&gt; f a<span style="color: green;">&#41;</span>
hyloEta phi eta psi = phi . eta . <a href="http://haskell.org/ghc/docs/latest/html/libraries/base/Prelude.html#v:fmap"><span style="font-weight: bold;">fmap</span></a> <span style="color: green;">&#40;</span>hyloEta phi eta psi<span style="color: green;">&#41;</span> . psi
&nbsp;</pre>
<p>We placed eta in the middle of the argument list because it is evocative of the fact that it occurs between phi and psi, and because that seems to be where everyone else puts it. </p>
<p>Now, clearly, we could roll eta into phi and get the more traditional hylo where f = g. Less obviously we could roll it into psi because it is a <a href="http://en.wikipedia.org/wiki/Natural_transformation">natural transformation</a> and so the following diagram commutes:</p>
<div class="codeblock" align="center">
<img src='../../../../latex/eb518f091c90f6025d7669a9291b6c29.png' title='\bfig \square/&gt;`&gt;`&gt;`&gt;/[F(A)`F(B)`G(A)`G(B);F {[}\hspace{-0.8pt}{[}f, g{]}\hspace{-0.8pt}{]} `\eta_A`\eta_B`G {[}\hspace{-0.8pt}{[}f, g{]}\hspace{-0.8pt}{]}] \efig ' alt='\bfig \square/&gt;`&gt;`&gt;`&gt;/[F(A)`F(B)`G(A)`G(B);F {[}\hspace{-0.8pt}{[}f, g{]}\hspace{-0.8pt}{]} `\eta_A`\eta_B`G {[}\hspace{-0.8pt}{[}f, g{]}\hspace{-0.8pt}{]}] \efig ' align=absmiddle>
</div>
<p>This 'Hylo Shift' property (mentioned in that same paper) allows us to move the 'eta' term into the phi term or into the psi term as we see fit. Since we can move the eta term around and it adds no value to the combinator, it quietly returned to the void from whence it came. hyloEta offers us no more power than hylo, so out it goes.</p>
<p>So, if its dead, why talk about it?</p>
<p><span id="more-50"></span></p>
<p>Well, when we move to a generalized hylomorphism we have a design decision that has some performance effects, and my initial pass at a generalized hylomorphism isn't as general as it could be. When we open up the generalized hylomorphism and look at its guts (check the slightly updated <a href="../../../../haskell/Chronomorphism.hs">source code</a> from yesterday) we see:</p>
<pre class="haskell">&nbsp;
g_hylo' w m f g = liftW f . w . <a href="http://haskell.org/ghc/docs/latest/html/libraries/base/Prelude.html#v:fmap"><span style="font-weight: bold;">fmap</span></a> <a href="../../../../haskell/category-extras/dist/doc/html/category-extras/Control-Comonad.html#v:duplicate"><span style="font-weight: bold;">duplicate</span></a> . <a href="http://haskell.org/ghc/docs/latest/html/libraries/base/Prelude.html#v:fmap"><span style="font-weight: bold;">fmap</span></a> <span style="color: green;">&#40;</span>g_hylo' w m f g<span style="color: green;">&#41;</span> . <a href="http://haskell.org/ghc/docs/latest/html/libraries/base/Prelude.html#v:fmap"><span style="font-weight: bold;">fmap</span></a> join . m . liftM g
&nbsp;</pre>
<p>expanding that to include the eta term gives us 4 candidate locations where we can abuse its status as a natural transformation to slot it in.</p>
<pre class="haskell">&nbsp;
g_hylo'<span style="color: red;">1</span> w m f eta g =
    liftW f .
    w . eta . <a href="http://haskell.org/ghc/docs/latest/html/libraries/base/Prelude.html#v:fmap"><span style="font-weight: bold;">fmap</span></a> <a href="../../../../haskell/category-extras/dist/doc/html/category-extras/Control-Comonad.html#v:duplicate"><span style="font-weight: bold;">duplicate</span></a> . <a href="http://haskell.org/ghc/docs/latest/html/libraries/base/Prelude.html#v:fmap"><span style="font-weight: bold;">fmap</span></a> <span style="color: green;">&#40;</span>g_hylo' w m f g<span style="color: green;">&#41;</span> . <a href="http://haskell.org/ghc/docs/latest/html/libraries/base/Prelude.html#v:fmap"><span style="font-weight: bold;">fmap</span></a> join . m .
    liftM g
g_hylo'<span style="color: red;">2</span> w m f eta g =
    liftW f .
    w . <a href="http://haskell.org/ghc/docs/latest/html/libraries/base/Prelude.html#v:fmap"><span style="font-weight: bold;">fmap</span></a> <a href="../../../../haskell/category-extras/dist/doc/html/category-extras/Control-Comonad.html#v:duplicate"><span style="font-weight: bold;">duplicate</span></a> . eta . <a href="http://haskell.org/ghc/docs/latest/html/libraries/base/Prelude.html#v:fmap"><span style="font-weight: bold;">fmap</span></a> <span style="color: green;">&#40;</span>g_hylo' w m f g<span style="color: green;">&#41;</span> . <a href="http://haskell.org/ghc/docs/latest/html/libraries/base/Prelude.html#v:fmap"><span style="font-weight: bold;">fmap</span></a> join . m .
    liftM g
g_hylo'<span style="color: red;">3</span> w m f eta g =
    liftW f .
    w . <a href="http://haskell.org/ghc/docs/latest/html/libraries/base/Prelude.html#v:fmap"><span style="font-weight: bold;">fmap</span></a> <a href="../../../../haskell/category-extras/dist/doc/html/category-extras/Control-Comonad.html#v:duplicate"><span style="font-weight: bold;">duplicate</span></a> . <a href="http://haskell.org/ghc/docs/latest/html/libraries/base/Prelude.html#v:fmap"><span style="font-weight: bold;">fmap</span></a> <span style="color: green;">&#40;</span>g_hylo' w m f g<span style="color: green;">&#41;</span> . eta . <a href="http://haskell.org/ghc/docs/latest/html/libraries/base/Prelude.html#v:fmap"><span style="font-weight: bold;">fmap</span></a> join . m .
    liftM g
g_hylo'<span style="color: red;">4</span> w m f eta g =
    liftW f .
    w . <a href="http://haskell.org/ghc/docs/latest/html/libraries/base/Prelude.html#v:fmap"><span style="font-weight: bold;">fmap</span></a> <a href="../../../../haskell/category-extras/dist/doc/html/category-extras/Control-Comonad.html#v:duplicate"><span style="font-weight: bold;">duplicate</span></a> . <a href="http://haskell.org/ghc/docs/latest/html/libraries/base/Prelude.html#v:fmap"><span style="font-weight: bold;">fmap</span></a> <span style="color: green;">&#40;</span>g_hylo' w m f g<span style="color: green;">&#41;</span> . <a href="http://haskell.org/ghc/docs/latest/html/libraries/base/Prelude.html#v:fmap"><span style="font-weight: bold;">fmap</span></a> join . eta . m .
    liftM g
&nbsp;</pre>
<p>g-hylo'1 and g_hylo'4 are particularly interesting because we have functions sitting right next to them that we can fuse it into by generalizing the type signatures only slightly and because that leaves a run of 3 fmaps in a row that we can fuse together. If we generalize the signatures of both w and m we get the following definition that allows you to place it on the left or the right, and for g_hylo to not have to care about it. </p>
<pre language="haskell">
-- new and improved!
g_hylo :: (Comonad w, Functor f, Monad m) =>
          (forall a. f (w a) -> w (g a)) ->
          (forall a. m (e a) -> f (m a)) ->
          (g (w b) -> b) ->
          (a -> e (m a)) ->
          (a -> b)
g_hylo w m f g = extract . g_hylo' w m f g . return

-- | the kernel of the generalized hylomorphism
g_hylo' :: (Comonad w, Functor f, Monad m) =>
           (forall a. f (w a) -> w (g a)) ->
           (forall a. m (e a) -> f (m a)) ->
           (g (w b) -> b) ->
           (a -> e (m a)) ->
           (m a -> w b)
g_hylo' w m f g = liftW f . w . fmap (duplicate . g_hylo' w m f g . join) . m . liftM g
</pre>
<p>The slightly generalized signatures for our two distributive laws now allow them to change functors on the way through, but we shed a superfluous argument.</p>
<p>Note that while 3 'Functors' e, f and g are involved, only f needs to be a Functor in Hask because we do the duplication, hylomorphism and join all inside f in either case. And most of the time e = f = g. For instance e or g could be <a href="../../../2008/rotten-bananas/index.html">exponential</a> or <a href="http://mathworld.wolfram.com/ContravariantFunctor.html">contravariant</a>. </p>
<p>So now that we've generalized our generalized hylomorphism we're done right?</p>
<p>Not quite. Unfortunately the same trick doesn't work for the <a href="../../../2008/time-for-chronomorphisms/index.html">generalized chronomorphism</a> defined last night. </p>
<p>To see why, we have open up chrono and peek at its guts.</p>
<pre class="haskell">&nbsp;
chrono = g_chrono <a href="http://haskell.org/ghc/docs/latest/html/libraries/base/Prelude.html#v:id"><span style="font-weight: bold;">id</span></a> <a href="http://haskell.org/ghc/docs/latest/html/libraries/base/Prelude.html#v:id"><span style="font-weight: bold;">id</span></a>
&nbsp;</pre>
<p>Well, that was boring. Digging deeper we find:</p>
<pre class="haskell">&nbsp;
g_chrono :: <span style="color: green;">&#40;</span><a href="http://haskell.org/ghc/docs/latest/html/libraries/base/Prelude.html#t:Functor"><span style="background-color: #efefbf; font-weight: bold;">Functor</span></a> f, <a href="http://haskell.org/ghc/docs/latest/html/libraries/base/Prelude.html#t:Functor"><span style="background-color: #efefbf; font-weight: bold;">Functor</span></a> g, <a href="http://haskell.org/ghc/docs/latest/html/libraries/base/Prelude.html#t:Functor"><span style="background-color: #efefbf; font-weight: bold;">Functor</span></a> m, <a href="http://haskell.org/ghc/docs/latest/html/libraries/base/Prelude.html#t:Functor"><span style="background-color: #efefbf; font-weight: bold;">Functor</span></a> w<span style="color: green;">&#41;</span> =&gt;
            <span style="color: green;">&#40;</span><span style="color: #06c; font-weight: bold;">forall</span> b. f <span style="color: green;">&#40;</span>w b<span style="color: green;">&#41;</span> -&gt; w <span style="color: green;">&#40;</span>f b<span style="color: green;">&#41;</span><span style="color: green;">&#41;</span> -&gt;
            <span style="color: green;">&#40;</span><span style="color: #06c; font-weight: bold;">forall</span> b. m <span style="color: green;">&#40;</span>f b<span style="color: green;">&#41;</span> -&gt; f <span style="color: green;">&#40;</span>m b<span style="color: green;">&#41;</span><span style="color: green;">&#41;</span> -&gt;
            <span style="color: green;">&#40;</span>f <span style="color: green;">&#40;</span>Cofree w b<span style="color: green;">&#41;</span> -&gt; b<span style="color: green;">&#41;</span> -&gt;
            <span style="color: green;">&#40;</span>a -&gt; f <span style="color: green;">&#40;</span>Free m a<span style="color: green;">&#41;</span><span style="color: green;">&#41;</span> -&gt;
            a -&gt; b
g_chrono w m = g_hylo <span style="color: green;">&#40;</span>distCofree w<span style="color: green;">&#41;</span> <span style="color: green;">&#40;</span>distFree m<span style="color: green;">&#41;</span>
&nbsp;</pre>
<p>Sticking in hylo's vestigial natural transformation, we get:</p>
<pre class="haskell">&nbsp;
g_chronoEta :: <span style="color: green;">&#40;</span><a href="http://haskell.org/ghc/docs/latest/html/libraries/base/Prelude.html#t:Functor"><span style="background-color: #efefbf; font-weight: bold;">Functor</span></a> f, <a href="http://haskell.org/ghc/docs/latest/html/libraries/base/Prelude.html#t:Functor"><span style="background-color: #efefbf; font-weight: bold;">Functor</span></a> g, <a href="http://haskell.org/ghc/docs/latest/html/libraries/base/Prelude.html#t:Functor"><span style="background-color: #efefbf; font-weight: bold;">Functor</span></a> m, <a href="http://haskell.org/ghc/docs/latest/html/libraries/base/Prelude.html#t:Functor"><span style="background-color: #efefbf; font-weight: bold;">Functor</span></a> w<span style="color: green;">&#41;</span> =&gt;
            <span style="color: green;">&#40;</span><span style="color: #06c; font-weight: bold;">forall</span> b. g <span style="color: green;">&#40;</span>w b<span style="color: green;">&#41;</span> -&gt; w <span style="color: green;">&#40;</span>g b<span style="color: green;">&#41;</span><span style="color: green;">&#41;</span> -&gt;
            <span style="color: green;">&#40;</span><span style="color: #06c; font-weight: bold;">forall</span> b. m <span style="color: green;">&#40;</span>f b<span style="color: green;">&#41;</span> -&gt; f <span style="color: green;">&#40;</span>m b<span style="color: green;">&#41;</span><span style="color: green;">&#41;</span> -&gt;
            <span style="color: green;">&#40;</span>g <span style="color: green;">&#40;</span>Cofree w b<span style="color: green;">&#41;</span> -&gt; b<span style="color: green;">&#41;</span> -&gt;
            <span style="color: green;">&#40;</span><span style="color: #06c; font-weight: bold;">forall</span> c. f a -&gt; g a<span style="color: green;">&#41;</span> -&gt;
            <span style="color: green;">&#40;</span>a -&gt; f <span style="color: green;">&#40;</span>Free m a<span style="color: green;">&#41;</span><span style="color: green;">&#41;</span> -&gt;
            a -&gt; b
g_chronoEta w m f eta g = g_hylo <span style="color: green;">&#40;</span>distCofree w . eta<span style="color: green;">&#41;</span> <span style="color: green;">&#40;</span>distFree m<span style="color: green;">&#41;</span> f g
<span style="color: #5d478b; font-style: italic;">-- g_chronoEta w m f eta g = g_hylo (distCofree w) (eta . distFree m) f g</span>
&nbsp;</pre>
<p>And so, we roll up our sleeves ready to merge it into something, be it f, g, w, m, anything, but it seems the only places eta can go is to merge into one of the distributive laws, because f and g are executed lifted.</p>
<p>Unfortunately, the user passed us rules for distributing the base functor of the cofree comonad and free monad, not for distributing the whole cofree comonad. And my efforts to generalize distFree and distCofree have thus far met with some frustration, there isn't much to grab onto there to write the more general signature.</p>
<p>Ideally, I'd just be able to merge it into one of the distributive laws. Since the HYLO guys liked to put it on the left of the recursive call to the hylomorphism, we'll look at distCofree. The desired signature for distCofree' would be:</p>
<pre class="haskell">&nbsp;
distCofree' ::   <span style="color: green;">&#40;</span><a href="http://haskell.org/ghc/docs/latest/html/libraries/base/Prelude.html#t:Functor"><span style="background-color: #efefbf; font-weight: bold;">Functor</span></a> f, <a href="http://haskell.org/ghc/docs/latest/html/libraries/base/Prelude.html#t:Functor"><span style="background-color: #efefbf; font-weight: bold;">Functor</span></a> g, <a href="http://haskell.org/ghc/docs/latest/html/libraries/base/Prelude.html#t:Functor"><span style="background-color: #efefbf; font-weight: bold;">Functor</span></a> h<span style="color: green;">&#41;</span> =&gt;
                <span style="color: green;">&#40;</span><span style="color: #06c; font-weight: bold;">forall</span> a. f <span style="color: green;">&#40;</span>h a<span style="color: green;">&#41;</span> -&gt; h <span style="color: green;">&#40;</span>g a<span style="color: green;">&#41;</span><span style="color: green;">&#41;</span> -&gt;
                f <span style="color: green;">&#40;</span>Cofree h a<span style="color: green;">&#41;</span> -&gt; Cofree h <span style="color: green;">&#40;</span>g a<span style="color: green;">&#41;</span>
&nbsp;</pre>
<p>and it should have the property that:</p>
<pre class="haskell">&nbsp;
distCofree' <span style="color: green;">&#40;</span>f . eta<span style="color: green;">&#41;</span> == distCofree' f . eta
&nbsp;</pre>
<p>Without that, g_chronoEta is more powerful than g_chrono. Naturally.</p>
<p><a href="../../../../haskell/Chronomorphism.hs">Source Code</a></p>
]]></content:encoded>
			<wfw:commentRss>http://comonad.com/reader/2008/unnatural-transformations/feed/</wfw:commentRss>
		<slash:comments>1</slash:comments>
		</item>
		<item>
		<title>Elgot Algebras</title>
		<link>http://comonad.com/reader/2008/elgot-algebras/</link>
		<comments>http://comonad.com/reader/2008/elgot-algebras/#comments</comments>
		<pubDate>Tue, 01 Jan 2008 17:05:14 +0000</pubDate>
		<dc:creator>Edward Kmett</dc:creator>
				<category><![CDATA[Uncategorized]]></category>

		<guid isPermaLink="false">http://comonad.com/reader/1970/elgot-algebras/</guid>
		<description><![CDATA[Wordpress changed the slug of this post, but Planet Haskell has the old link.
Here is the actual content.
]]></description>
			<content:encoded><![CDATA[<p>Wordpress changed the slug of this post, but Planet Haskell has the old link.</p>
<p><a href="../../../2008/elgot-coalgebras/index.html">Here is the actual content</a>.</p>
]]></content:encoded>
			<wfw:commentRss>http://comonad.com/reader/2008/elgot-algebras/feed/</wfw:commentRss>
		<slash:comments>0</slash:comments>
		</item>
		<item>
		<title>Updated Data.Type.*</title>
		<link>http://comonad.com/reader/2007/updated-datatype/</link>
		<comments>http://comonad.com/reader/2007/updated-datatype/#comments</comments>
		<pubDate>Sat, 14 Jul 2007 02:57:14 +0000</pubDate>
		<dc:creator>Edward Kmett</dc:creator>
				<category><![CDATA[Haskell]]></category>
		<category><![CDATA[Type Hackery]]></category>
		<category><![CDATA[Uncategorized]]></category>

		<guid isPermaLink="false">http://comonad.com/reader/2007/updated-datatype/</guid>
		<description><![CDATA[Updated my little type-level 2s and 16s complement integer library to be ghc 6.6 friendly and uploaded it to hackage based on popular (er.. ok, well, singular) demand. 
O.K. it was more of a polite request, but I did update it.
]]></description>
			<content:encoded><![CDATA[<p>Updated my little <a href="../../../../haskell/type-int/index.html">type-level 2s and 16s complement integer library</a> to be ghc 6.6 friendly and uploaded it to <a href="http://hackage.haskell.org/cgi-bin/hackage-scripts/package/type-int-0.4">hackage</a> based on popular (er.. ok, well, singular) demand. </p>
<p>O.K. it was more of a polite request, but I did update it.</p>
]]></content:encoded>
			<wfw:commentRss>http://comonad.com/reader/2007/updated-datatype/feed/</wfw:commentRss>
		<slash:comments>0</slash:comments>
		</item>
	</channel>
</rss>

<!-- Localized -->