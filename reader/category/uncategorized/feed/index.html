<?xml version="1.0" encoding="UTF-8"?>
<rss version="2.0"
	xmlns:content="http://purl.org/rss/1.0/modules/content/"
	xmlns:wfw="http://wellformedweb.org/CommentAPI/"
	xmlns:dc="http://purl.org/dc/elements/1.1/"
	xmlns:atom="http://www.w3.org/2005/Atom"
	xmlns:sy="http://purl.org/rss/1.0/modules/syndication/"
	xmlns:slash="http://purl.org/rss/1.0/modules/slash/"
	>

<channel>
	<title>The Comonad.Reader &#187; Uncategorized</title>
	<atom:link href="http://comonad.com/reader/category/uncategorized/feed/" rel="self" type="application/rss+xml" />
	<link>http://comonad.com/reader</link>
	<description>types, (co)monads, substructural logic</description>
	<lastBuildDate>Thu, 02 May 2013 14:19:12 +0000</lastBuildDate>
	<generator>http://wordpress.org/?v=2.8.4</generator>
	<language>en</language>
	<sy:updatePeriod>hourly</sy:updatePeriod>
	<sy:updateFrequency>1</sy:updateFrequency>
			<item>
		<title>Representing Applicatives</title>
		<link>http://comonad.com/reader/2013/representing-applicatives/</link>
		<comments>http://comonad.com/reader/2013/representing-applicatives/#comments</comments>
		<pubDate>Thu, 02 May 2013 14:19:12 +0000</pubDate>
		<dc:creator>Gershom Bazerman</dc:creator>
				<category><![CDATA[Uncategorized]]></category>

		<guid isPermaLink="false">http://comonad.com/reader/?p=907</guid>
		<description><![CDATA[In the previous two posts, we've built up a whole range of applicatives, out of Const, Identity, Reader, Compose, Product, Sum, and Fix (and some higher-order analogues). Sum has given us the most trouble, but in some sense has been the most powerful, letting us write things like possibly eventually terminating lists, or trees, or [...]]]></description>
			<content:encoded><![CDATA[<p>In the <a href="http://comonad.com/reader/2012/abstracting-with-applicatives/">previous</a> <a href="http://comonad.com/reader/2013/algebras-of-applicatives/">two</a> posts, we've built up a whole range of applicatives, out of Const, Identity, Reader, Compose, Product, Sum, and Fix (and some higher-order analogues). Sum has given us the most trouble, but in some sense has been the most powerful, letting us write things like possibly eventually terminating lists, or trees, or in fact any sort of structure with branching alternatives. In this post, I want to think a bit more about why it is that Sum is the trickiest of the bunch, and more generally, what we can say about when two applicative structures are the "same". In the process of doing so, we'll invent something a lot like Traversable en passant.</p>
<p>Let's do some counting exercises. <code>Product Identity Identity</code> holds exactly two things. It is therefore isomorphic to <code>((->) Bool)</code>, or if we prefer, <code>((->) Either () ())</code>. That is to say that a pair that <i>holds</i> two values of type <code>a</code> is the same as a function that <i>takes a two-valued type</i> and <i>yields</i> a value of type <code>a</code>. A product of more functors in turn is isomorphic to the reader of the sum of each of the datatypes that "represent" them. E.g. <code>Product (Product Identity Identity) (Product (Const ()) Identity)</code> is iso to <code>((->) (Either (Either () ()) ())</code>, i.e. a data type with three possible inhabitants. In making this move we took Product to Either -- multiplication to sum. We can pull a similar trick with Compose. <code>Compose (Product Identity Identity) (Product Identity Identity)</code> goes to ((->) (Either () (),Either () ())). So again we took Product to a sum type, but now we took Compose to a pair -- a product type! The intuition is that composition <i>multiplies</i> the possibilities of spaces in each nested functor.</p>
<p>Hmm.. products go to sums, composition goes to multiplication, etc. This should remind us of something -- these rules are exactly the rules for working with exponentials. x^n * x^m = x^(n + m). (x^n)^m = x^(n*m). x^0 = 1, x^1 = x.</p>
<p>Seen from the right standpoint, this isn't surprising at all, but almost inevitable. The functors we're describing are known as "representable," a term which derives from category theory. (See appendix on representable functors below).</p>
<p>In Haskell-land, a "representable functor" is just any functor isomorphic to the reader functor <code>((->) a)</code> for some appropriate a. Now if we think back to our algebraic representations of data types, we call the arrow type constructor an exponential. We can "count" <code>a -> x</code> as x^a, since e.g. there are 3^2 distinct functions that inhabit the type 2 -> 3. The intuition for this is that for each input we pick one of the possible results, so as the number of inputs goes up by one, the number of functions goes up by multiplying through by the set of possible results. 1 -> 3 = 3, 2 -> 3 = 3 * 3, (n + 1) -> 3 = 3 * (n -> 3).</p>
<p>Hence, if we "represent" our functors by exponentials, then we can work with them directly as exponentials as well, with all the usual rules. Edward Kmett has a <a href="http://hackage.haskell.org/packages/archive/representable-functors/3.0.0.1/doc/html/Data-Functor-Representable.html">library encoding representable functors in Haskell</a>.</p>
<p>Meanwhile, Peter Hancock prefers to call such functors <a href="http://sneezy.cs.nott.ac.uk/containers/blog/?p=14">"Naperian"</a> after John Napier, inventor of the logarithm (See also <a href="http://stackoverflow.com/a/13100857/371753">here</a>). Why Naperian? Because if our functors are isomorphic to exponentials, then we can take their logs! And that brings us back to the initial discussion of type mathematics. We have some functor F, and claim that it is isomorphic to -^R for some concrete data type R. Well, this means that R is the logarithm of F. E.g. <code>(R -> a, S -> a) =~ Either R S -> a</code>, which is to say that if log F = R and log G =~ S, then log (F * G) = log F + log G. Similarly, for any other data type n, again with log F = R, we have  <code>n -> F a =~ n -> R -> a =~ (n * R) -> a</code>, which is to say that log (F^n) =~ n * log F.</p>
<p>This gives us one intuition for why the sum functor is not generally representable -- it is very difficult to decompose log (F + G) into some simpler compound expression of logs.</p>
<p>So what functors are Representable? Anything that can be seen as a fixed shape with some index. Pairs, fixed-size vectors, fixed-size matrices, any nesting of fixed vectors and matricies. But also infinite structures of regular shape! However, not things whose shape can vary -- not lists, not sums. Trees of fixed depth or infinite binary trees therefore, but not trees of arbitrary depth or with ragged structure, etc.</p>
<p>Representable functors turn out to be extremely powerful tools. Once we know a functor is representable, we know exactly what its applicative instance must be, and that its applicative instance will be "zippy" -- i.e. acting pointwise across the structure. We also know that it has a monad instance! And, unfortunately, that this monad instance is typically fairly useless (in that it is also "zippy" -- i.e. the monad instance on a pair just acts on the two elements pointwise, without ever allowing anything in the first slot to affect anything in the second slot, etc.). But we know more than that. We know that a representable functor, by virtue of being a reader in disguise, cannot have effects that migrate outwards. So any two actions in a representable functor are commutative. And more than that, they are entirely independent.</p>
<p>This means that all representable functors are "<a href="http://hackage.haskell.org/packages/archive/distributive/0.3.1/doc/html/Data-Distributive.html">distributive</a>"! Given any functor f, and any data type r, then we have </p>
<pre class="haskell">&nbsp;
distributeReader :: <a href="http://haskell.org/ghc/docs/latest/html/libraries/base/Prelude.html#t:Functor"><span style="background-color: #efefbf; font-weight: bold;">Functor</span></a> f =&gt; f <span style="color: green;">&#40;</span>r -&gt; a<span style="color: green;">&#41;</span> -&gt; <span style="color: green;">&#40;</span>r -&gt; f a<span style="color: green;">&#41;</span>
distributeReader fra = \r -&gt; <a href="http://haskell.org/ghc/docs/latest/html/libraries/base/Prelude.html#v:fmap"><span style="font-weight: bold;">fmap</span></a> <span style="color: green;">&#40;</span>$r<span style="color: green;">&#41;</span> fra
&nbsp;</pre>
<p>That is to say, given an arrow "inside" a functor, we can always pull the arrow out, and "distribute" application across the contents of the functor. A list of functions from <code>Int -> Int</code> becomes a single function from <code>Int</code> to a list of <code>Int</code>, etc. More generally, since all representable functors are isomorphic to reader, given g representable, and f any functor, then we have: <code>distribute :: (Functor f, Representable g) => f (g a) -> g (f a).</code></p>
<p>This is pretty powerful sauce! And if f and g are <i>both</i> representable, then we get the transposition isomorphism, witnessed by <code>flip</code>! That's just the beginning of the good stuff. If we take functions and "unrepresent" them back to functors (i.e. take their logs), then we can do things like move from <code>((->) Bool)</code> to pairs, etc. Since we're in a pervasively lazy language, we've just created a library for <a href="http://hackage.haskell.org/packages/archive/representable-tries/3.0.2/doc/html/Data-Functor-Representable-Trie.html">memoization</a>! This is because we've gone from a function to a data structure we can index into, representing each possible argument to this function as a "slot" in the structure. And the laziness pays off because we only need to evaluate the contents of each slot on demand (otherwise we'd have a precomputed lookup table rather than a dynamically-evaluated memo table). </p>
<p>And now suppose we take our representable functor in the form <code>s -> a</code> and paired it with an "index" into that function, in the form of a concrete <code>s</code>. Then we'd be able to step that <code>s</code> forward or backwards and navigate around our structure of <code>a</code>s. And this is precisely the <a href="http://hackage.haskell.org/packages/archive/comonads-fd/3.0.1/doc/html/Control-Comonad-Store.html">Store Comonad</a>! And this in turn gives a <a href="http://patternsinfp.wordpress.com/2011/01/31/lenses-are-the-coalgebras-for-the-costate-comonad/">characterization of the lens laws</a>.</p>
<p>What this all gives us a tiny taste of, in fact, is the tremendous power of the <a href="http://blog.sigfpe.com/2006/11/yoneda-lemma.html">Yoneda lemma</a>, which, in Haskell, is all about going between values and functions, and in fact captures the important universality and uniqueness properties that make working with representable functors tractable. A further tiny taste of Yoneda comes from a nice <a href="http://conal.net/blog/posts/memoizing-polymorphic-functions-via-unmemoization">blog post</a> by Conal Elliott on memoization.</p>
<p><strong>Extra Credit on Sum Functors</strong></p>
<p>There in fact is a log identity on sums. It goes like this:</p>
<pre>
log(a + c) = log a + log (1 + c/a)
</pre>
<p>Do you have a useful computational interpretation of this? I've got the inklings of one, but not much else.</p>
<p><strong>Appendix: Notes on Representable Functors in Hask.</strong></p>
<p>The way to think about this is to take some arbitrary category C, and some category that's basically Set (in our case, Hask. In fact, in our case, C is Hask too, and we're just talking about endofunctors on Hask). Now, we take some functor F : C -> Set, and some A which is an element of C. The set of morphisms originating at A (denoted by Hom(A,-)) constitutes a functor called the "hom functor." For any object X in C, we can "plug it in" to Hom(A,-), to then get the set of all arrows from A to X. And for any morphism X -> Y in C, we can derive a morphism from Hom(A,X) to Hom(A,Y), by composition. This is equivalent to, in Haskell-land, using a function <code>f :: x -> y</code> to send <code>g :: a -> x</code> to <code>a -> y</code> by writing "functionAToY = f . g".</p>
<p>So, for any A in C, we have a hom functor on C, which is C -> Set, where the elements of the resultant Set are homomorphisms in C. Now, we have this other arbitrary functor F, which is also C -> Set. Now, if there is an isomorphism of functors between F, and Hom(A,_), then we say F is "representable". A representable functor is thus one that can be worked with entirely as an appropriate hom-functor.</p>
]]></content:encoded>
			<wfw:commentRss>http://comonad.com/reader/2013/representing-applicatives/feed/</wfw:commentRss>
		<slash:comments>0</slash:comments>
		</item>
		<item>
		<title>Algebras of Applicatives</title>
		<link>http://comonad.com/reader/2013/algebras-of-applicatives/</link>
		<comments>http://comonad.com/reader/2013/algebras-of-applicatives/#comments</comments>
		<pubDate>Fri, 11 Jan 2013 17:03:58 +0000</pubDate>
		<dc:creator>Gershom Bazerman</dc:creator>
				<category><![CDATA[Uncategorized]]></category>

		<guid isPermaLink="false">http://comonad.com/reader/?p=811</guid>
		<description><![CDATA[While the previous post in this series was relatively immediately applicable, this one has constructions I definitely wouldn't recommend in production code. However, they do take us further in exploring the universe of applicative functors, and, more broadly, exploring which data types provide which properties by construcion.
It's well known that if you have any Functor [...]]]></description>
			<content:encoded><![CDATA[<p>While the <a href="http://comonad.com/reader/2012/abstracting-with-applicatives">previous post</a> in this series was relatively immediately applicable, this one has constructions I definitely wouldn't recommend in production code. However, they do take us further in exploring the universe of applicative functors, and, more broadly, exploring which data types provide which properties by construcion.</p>
<p>It's well known that if you have any Functor <code>F a</code>, you can take its "fixpoint", creating a structure of infinitely nested Fs, like so. <code>F (F (F (...) ) )</code> Since we can't have infinite types directly in Haskell, we introduce the Fix newtype:</p>
<pre class="haskell">&nbsp;
<span style="color: #06c; font-weight: bold;">newtype</span> Fix f = Fix <span style="color: green;">&#40;</span>f <span style="color: green;">&#40;</span>Fix f<span style="color: green;">&#41;</span><span style="color: green;">&#41;</span></pre>
<p>This "wraps up" the recursion so that GHC accepts the type. <code>Fix f</code> is a <code>Fix</code> constructor, containing an "f" of <code>Fix f</code> inside. Each in turn expands out, and soforth. Fixpoints of functors have fixedpoints of functors inside 'em. And so on, and so on, ad infinitum.</p>
<p>(Digression: We speak of "algebraic data types" in Haskell. The "algebra" in question is an "F-algebra", and we can build up structures with fixpoints of functors, taking those functors as initial or terminal objects and generating either initial algebras or terminal coalgebras. These latter two concepts coincide in Haskell in the Fix description given above, as greatest and least fixpoints of data types in Haskell turn out to be the same thing. For more background, one can go to Wadler's "<a href="http://homepages.inf.ed.ac.uk/wadler/papers/free-rectypes/free-rectypes.txt">Recursive Types for Free</a>,"  or Jacobs and Rutten's "<a href="http://citeseerx.ist.psu.edu/viewdoc/summary?doi=10.1.1.37.1418">Tutorial on (Co)Algebras and (Co)Induction</a>" for starters.)</p>
<p>The family of functors built from our friends Const, Sum, Product, and Reader (exponentiation) are known as Polynomial Functors. If we take closure of these with a proper fixpoint construct (that lets us build infinite structures), we get things that are variously known as Containers, Shapely Types, and Strictly Positive types.</p>
<p>One irritating thing is that the fixpoint of a functor as we've written it is no longer itself a functor. The type constructor Fix is of kind <code>(* -> *) -> *</code>, which says it takes an "f" which takes one argument (e.g. "Maybe" or "Identity" or etc.) and returns a proper type (i.e. a value at the type level of kind *).</p>
<p>We want a fixpoint construction that gives back something of kind <code>* -> *</code> — i.e. something that is a type constructor representing a functor, and not just a plain old type. The following does the trick.</p>
<pre class="haskell">&nbsp;
<span style="color: #06c; font-weight: bold;">newtype</span> FixF f a = FixF <span style="color: green;">&#40;</span>f <span style="color: green;">&#40;</span>FixF f<span style="color: green;">&#41;</span> a<span style="color: green;">&#41;</span>
<span style="color: #06c; font-weight: bold;">deriving</span> <span style="color: #06c; font-weight: bold;">instance</span> <span style="color: green;">&#40;</span><a href="http://haskell.org/ghc/docs/latest/html/libraries/base/Prelude.html#t:Show"><span style="background-color: #efefbf; font-weight: bold;">Show</span></a> <span style="color: green;">&#40;</span>f <span style="color: green;">&#40;</span>FixF f<span style="color: green;">&#41;</span> a<span style="color: green;">&#41;</span><span style="color: green;">&#41;</span> =&gt; <a href="http://haskell.org/ghc/docs/latest/html/libraries/base/Prelude.html#t:Show"><span style="background-color: #efefbf; font-weight: bold;">Show</span></a> <span style="color: green;">&#40;</span>FixF f a<span style="color: green;">&#41;</span></pre>
<p>(I learned about FixF from <a href="http://www.cs.ox.ac.uk/ralf.hinze/SSGIP10/AdjointFolds.pdf">a paper by Ralf Hinze</a>, but I'm sure the origins go back much further).</p>
<p>FixF is of kind <code>((* -> *) -> * -> *) -> * -> *</code>. It takes the fixpoint of a "second-order Functor" (a Functor that sends a Functor to another Functor, i.e. an endofunctor on the functor category of hask), to recover a standard "first order Functor" back out. This sounds scary, but it isn't once you load it up in ghci and start playing with it. In fact, we've encountered second order functors just recently. Product, Sum, and Compose are all of kind <code>(* -> *) -> (* -> *) -> * -> *</code>. So they all send two functors to a third functor. That means that <code>Product Const</code>, <code>Sum Identity</code> and <code>Compose Maybe</code> are all second-order functors, and things appropriate to take our "second-order fixpoint" of.</p>
<p>Conceptually, "Fix f" took a value with one hole, and we filled that hole with "Fix f" so there was no room for a type parameter. Now we've got an "f" with two holes, the first of which takes a functor, and the second of which is the hole of the resulting functor.</p>
<p>Unlike boring old "Fix", we can write Functor and Applicative instances for "FixF", and they're about as simple and compositional as we could possibly hope.</p>
<pre class="haskell"><span style="color: #06c; font-weight: bold;">instance</span> <a href="http://haskell.org/ghc/docs/latest/html/libraries/base/Prelude.html#t:Functor"><span style="background-color: #efefbf; font-weight: bold;">Functor</span></a> <span style="color: green;">&#40;</span>f <span style="color: green;">&#40;</span>FixF f<span style="color: green;">&#41;</span><span style="color: green;">&#41;</span> =&gt; <a href="http://haskell.org/ghc/docs/latest/html/libraries/base/Prelude.html#t:Functor"><span style="background-color: #efefbf; font-weight: bold;">Functor</span></a> <span style="color: green;">&#40;</span>FixF f<span style="color: green;">&#41;</span> <span style="color: #06c; font-weight: bold;">where</span>
    <a href="http://haskell.org/ghc/docs/latest/html/libraries/base/Prelude.html#v:fmap"><span style="font-weight: bold;">fmap</span></a> f <span style="color: green;">&#40;</span>FixF x<span style="color: green;">&#41;</span> = FixF $ <a href="http://haskell.org/ghc/docs/latest/html/libraries/base/Prelude.html#v:fmap"><span style="font-weight: bold;">fmap</span></a> f x
&nbsp;
<span style="color: #06c; font-weight: bold;">instance</span> Applicative <span style="color: green;">&#40;</span>f <span style="color: green;">&#40;</span>FixF f<span style="color: green;">&#41;</span><span style="color: green;">&#41;</span> =&gt; Applicative <span style="color: green;">&#40;</span>FixF f<span style="color: green;">&#41;</span> <span style="color: #06c; font-weight: bold;">where</span>
    pure x = FixF $ pure x
    <span style="color: green;">&#40;</span>FixF f<span style="color: green;">&#41;</span> &lt; *&gt; <span style="color: green;">&#40;</span>FixF x<span style="color: green;">&#41;</span> = FixF <span style="color: green;">&#40;</span>f &lt; *&gt; x<span style="color: green;">&#41;</span></pre>
<p>But now we run into a new problem! It seems like this "a" parameter is just hanging out there, doing basically nothing. We take our classic functors and embed them in there, and they still only have "one hole" at the value level, so don't actually have any place to put the "a" type we now introduced. For example, we can write the following:</p>
<pre class="haskell"><span style="color: #5d478b; font-style: italic;">-- FixF . Compose . Just . FixF . Compose $ Nothing</span>
<span style="color: #5d478b; font-style: italic;">-- &gt; FixF (Compose (Just (FixF (Compose Nothing))))</span>
<span style="color: #5d478b; font-style: italic;">-- :t FixF (Compose (Just (FixF (Compose Nothing))))</span>
<span style="color: #5d478b; font-style: italic;">-- &gt; FixF (Compose Maybe) a</span></pre>
<p>We now introduce one new member of our basic constructions — a second order functor that acts like "const" on the type level, taking any functor and returning Identity.</p>
<pre class="haskell">&nbsp;
<span style="color: #06c; font-weight: bold;">newtype</span> Embed <span style="color: green;">&#40;</span>f :: * -&gt; *<span style="color: green;">&#41;</span> a = Embed a <span style="color: #06c; font-weight: bold;">deriving</span> <span style="color: green;">&#40;</span><a href="http://haskell.org/ghc/docs/latest/html/libraries/base/Prelude.html#t:Show"><span style="background-color: #efefbf; font-weight: bold;">Show</span></a><span style="color: green;">&#41;</span>
&nbsp;
<span style="color: #06c; font-weight: bold;">instance</span> <a href="http://haskell.org/ghc/docs/latest/html/libraries/base/Prelude.html#t:Functor"><span style="background-color: #efefbf; font-weight: bold;">Functor</span></a> <span style="color: green;">&#40;</span>Embed f<span style="color: green;">&#41;</span> <span style="color: #06c; font-weight: bold;">where</span>
    <a href="http://haskell.org/ghc/docs/latest/html/libraries/base/Prelude.html#v:fmap"><span style="font-weight: bold;">fmap</span></a> f <span style="color: green;">&#40;</span>Embed x<span style="color: green;">&#41;</span> = Embed $ f x
&nbsp;
<span style="color: #06c; font-weight: bold;">instance</span> Applicative <span style="color: green;">&#40;</span>Embed f<span style="color: green;">&#41;</span> <span style="color: #06c; font-weight: bold;">where</span>
    pure x = Embed x
    <span style="color: green;">&#40;</span>Embed f<span style="color: green;">&#41;</span> &lt; *&gt; <span style="color: green;">&#40;</span>Embed x<span style="color: green;">&#41;</span> = Embed <span style="color: green;">&#40;</span>f x<span style="color: green;">&#41;</span></pre>
<p>Now we can actually stick functorial values into our fixpoints:</p>
<pre class="haskell"><span style="color: #5d478b; font-style: italic;">-- FixF $ Embed &quot;hi&quot;</span>
<span style="color: #5d478b; font-style: italic;">-- &gt; FixF (Embed &quot;hi&quot;)</span>
&nbsp;
<span style="color: #5d478b; font-style: italic;">-- fmap (++ &quot; world&quot;) $ FixF (Embed &quot;hi&quot;)</span>
<span style="color: #5d478b; font-style: italic;">-- &gt; FixF (Embed &quot;hi world&quot;)</span>
&nbsp;
<span style="color: #5d478b; font-style: italic;">-- FixF . Product (Embed &quot;hi&quot;) .</span>
<span style="color: #5d478b; font-style: italic;">--        FixF . Product (Embed &quot;there&quot;) . FixF $ undefined</span>
<span style="color: #5d478b; font-style: italic;">-- &gt; FixF (Product (Embed &quot;hi&quot;)</span>
<span style="color: #5d478b; font-style: italic;">--   (FixF (Product (Embed &quot;there&quot;)</span>
<span style="color: #5d478b; font-style: italic;">--   (FixF *** Exception: Prelude.undefined</span></pre>
<p>You may have noticed that we seem to be able to use "product" to begin a chain of nested fixpoints, but we don't seem able to stick a "Maybe" in there to <strong>stop</strong> the chain. And it seems like we're not even "fixing" where we intend to be:</p>
<pre class="haskell"><span style="color: #5d478b; font-style: italic;">-- :t FixF . Product (Embed &quot;hi&quot;) . FixF . Product (Embed &quot;there&quot;) . FixF $ undefined</span>
<span style="color: #5d478b; font-style: italic;">-- &gt; FixF (Product (Embed f)) [Char]</span></pre>
<p>That's because we're applying Product, takes and yields arguments of kind <code>* -> *</code> in a context where we really want to take and yield second-order functors as arguments — things of kind <code>(* -> *) -> * -> *</code>. If we had proper kind polymorphism, "Product" and "ProductF" would be able to collapse (and maybe, soon, they will). But at least in the ghc 7.4.1 that I'm working with, we have to write the same darn thing, but "up a kind".</p>
<pre class="haskell"><span style="color: #06c; font-weight: bold;">data</span> ProductF f g <span style="color: green;">&#40;</span>b :: * -&gt; *<span style="color: green;">&#41;</span> a =
      ProductF <span style="color: green;">&#40;</span>f b a<span style="color: green;">&#41;</span> <span style="color: green;">&#40;</span>g b a<span style="color: green;">&#41;</span> <span style="color: #06c; font-weight: bold;">deriving</span> <a href="http://haskell.org/ghc/docs/latest/html/libraries/base/Prelude.html#t:Show"><span style="background-color: #efefbf; font-weight: bold;">Show</span></a>
&nbsp;
<span style="color: #06c; font-weight: bold;">instance</span> <span style="color: green;">&#40;</span><a href="http://haskell.org/ghc/docs/latest/html/libraries/base/Prelude.html#t:Functor"><span style="background-color: #efefbf; font-weight: bold;">Functor</span></a> <span style="color: green;">&#40;</span>f b<span style="color: green;">&#41;</span>, <a href="http://haskell.org/ghc/docs/latest/html/libraries/base/Prelude.html#t:Functor"><span style="background-color: #efefbf; font-weight: bold;">Functor</span></a> <span style="color: green;">&#40;</span>g b<span style="color: green;">&#41;</span><span style="color: green;">&#41;</span> =&gt;
         <a href="http://haskell.org/ghc/docs/latest/html/libraries/base/Prelude.html#t:Functor"><span style="background-color: #efefbf; font-weight: bold;">Functor</span></a> <span style="color: green;">&#40;</span>ProductF f g b<span style="color: green;">&#41;</span> <span style="color: #06c; font-weight: bold;">where</span>
                <a href="http://haskell.org/ghc/docs/latest/html/libraries/base/Prelude.html#v:fmap"><span style="font-weight: bold;">fmap</span></a> f <span style="color: green;">&#40;</span>ProductF x y<span style="color: green;">&#41;</span> = ProductF <span style="color: green;">&#40;</span><a href="http://haskell.org/ghc/docs/latest/html/libraries/base/Prelude.html#v:fmap"><span style="font-weight: bold;">fmap</span></a> f x<span style="color: green;">&#41;</span> <span style="color: green;">&#40;</span><a href="http://haskell.org/ghc/docs/latest/html/libraries/base/Prelude.html#v:fmap"><span style="font-weight: bold;">fmap</span></a> f y<span style="color: green;">&#41;</span>
&nbsp;
<span style="color: #06c; font-weight: bold;">instance</span> <span style="color: green;">&#40;</span>Applicative <span style="color: green;">&#40;</span>f b<span style="color: green;">&#41;</span>, Applicative <span style="color: green;">&#40;</span>g b<span style="color: green;">&#41;</span><span style="color: green;">&#41;</span> =&gt;
         Applicative <span style="color: green;">&#40;</span>ProductF f g b<span style="color: green;">&#41;</span> <span style="color: #06c; font-weight: bold;">where</span>
               pure x = ProductF <span style="color: green;">&#40;</span>pure x<span style="color: green;">&#41;</span> <span style="color: green;">&#40;</span>pure x<span style="color: green;">&#41;</span>
              <span style="color: green;">&#40;</span>ProductF f g<span style="color: green;">&#41;</span> &lt; *&gt; <span style="color: green;">&#40;</span>ProductF x y<span style="color: green;">&#41;</span> = ProductF <span style="color: green;">&#40;</span>f &lt; *&gt; x<span style="color: green;">&#41;</span> <span style="color: green;">&#40;</span>g &lt; *&gt; y<span style="color: green;">&#41;</span></pre>
<p>We can now do the following properly.</p>
<pre class="haskell">yy = FixF . ProductF <span style="color: green;">&#40;</span>Embed <span style="color: #3c7331;">&quot;foo&quot;</span><span style="color: green;">&#41;</span> $ InL $ Const <span style="color: green;">&#40;</span><span style="color: green;">&#41;</span>
xx = FixF . ProductF <span style="color: green;">&#40;</span>Embed <span style="color: #3c7331;">&quot;bar&quot;</span><span style="color: green;">&#41;</span> . InR .
        FixF . ProductF <span style="color: green;">&#40;</span>Embed <span style="color: #3c7331;">&quot;baz&quot;</span><span style="color: green;">&#41;</span> . InL $ Const <span style="color: green;">&#40;</span><span style="color: green;">&#41;</span></pre>
<p>So we've recovered proper lists in Haskell, as the "second-order fixpoint" of polynomial functors. And the types look right too:</p>
<pre class="haskell"><span style="color: #5d478b; font-style: italic;">-- :t yy</span>
<span style="color: #5d478b; font-style: italic;">-- &gt; FixF (ProductF Embed (Sum (Const ()))) [Char]</span></pre>
<p>Because we've built our Applicative instances compositionally, we have an applicative for our list list construction automatically:</p>
<pre class="haskell"><span style="color: #5d478b; font-style: italic;">-- (++) &lt; $&gt; yy &lt; *&gt; xx</span>
<span style="color: #5d478b; font-style: italic;">-- &gt; FixF (ProductF (Embed &quot;foobar&quot;) (InL (Const ())))</span></pre>
<p>This is precisely the "ZipList" applicative instance. In fact, our applicative instances from this "functor toolkit" are all "zippy" — matching up structure where possible, and "smashing it down" where not. This is because Sum, with its associated natural transformation logic, is the only way to introduce a disjoint choice of shape. Here are some simple examples with Sum to demonstrate:</p>
<pre class="haskell"><span style="color: #5d478b; font-style: italic;">-- liftA2 (++) (InL (Identity &quot;hi&quot;)) $</span>
<span style="color: #5d478b; font-style: italic;">--      InR (Product (Identity &quot; there&quot;) (Const ([12::Int])))</span>
<span style="color: #5d478b; font-style: italic;">-- &gt; InL (Identity &quot;hi there&quot;)</span>
<span style="color: #5d478b; font-style: italic;">-- liftA2 (++) (InR (Identity &quot;hi&quot;)) $ InL (Product (Identity &quot; there&quot;) (Const ([12::Int])))</span>
<span style="color: #5d478b; font-style: italic;">-- &gt; InL (Product (Identity &quot;hi there&quot;) (Const [12]))</span></pre>
<p>We're always "smashing" towards the left. So in the first case, that means throwing away half of the pair. In the second case, it means injecting Const mempty into a pair, and then operating with that.</p>
<p>In any case, we now have infinite and possibly infinite branching structures. And not only are they Functors, but they're also Applicatives, and in a way that's uniform and straightforward to reason about.</p>
<p>In the next post, we'll stop building out our vocabulary of "base" Functors (though it's not quite complete) and instead push forward on what else these functors can provide "beyond" Applicative.</p>
]]></content:encoded>
			<wfw:commentRss>http://comonad.com/reader/2013/algebras-of-applicatives/feed/</wfw:commentRss>
		<slash:comments>0</slash:comments>
		</item>
		<item>
		<title>Natural Deduction, Sequent Calculus and Type Classes</title>
		<link>http://comonad.com/reader/2012/natural-deduction-sequent-calculus-and-type-classes/</link>
		<comments>http://comonad.com/reader/2012/natural-deduction-sequent-calculus-and-type-classes/#comments</comments>
		<pubDate>Fri, 07 Dec 2012 19:09:09 +0000</pubDate>
		<dc:creator>Dan Doel</dc:creator>
				<category><![CDATA[Uncategorized]]></category>

		<guid isPermaLink="false">http://comonad.com/reader/?p=720</guid>
		<description><![CDATA[By and large, there are two sorts of proof systems that people use (these days) when studying logic: natural deduction, and sequent calculus. I know of at least one other---Hilbert style---but it is older, and the above systems were invented due to dissatisfaction with Hilbert systems (for a programming analogy, Hilbert systems are like programming [...]]]></description>
			<content:encoded><![CDATA[<p>By and large, there are two sorts of proof systems that people use (these days) when studying logic: natural deduction, and sequent calculus. I know of at least one other---Hilbert style---but it is older, and the above systems were invented due to dissatisfaction with Hilbert systems (for a programming analogy, Hilbert systems are like programming entirely with combinators (S, K, etc.), rather than a lambda calculus).</p>
<h2>Natural Deduction</h2>
<p>Probably the best way to categorize the difference, for the purpose of where we're eventually going, is that natural deduction focuses on the ways to build proof terms up from their constituent parts. This comes in the form of introduction and elimination rules for the various propositions. For instance, the rules for conjunction are:</p>
<div class="codeblock">
<p align="center"> <img src='http://comonad.com/latex/783ccc760a775c36798d4f43a6b1d7f0.png' title=' \inference{A \,\,\,\,\,\,\,\,\, B}{A \wedge B}[$\wedge$-I]' alt=' \inference{A \,\,\,\,\,\,\,\,\, B}{A \wedge B}[$\wedge$-I]' align=absmiddle> </p>
<p align="center"> <img src='http://comonad.com/latex/72830d280ca501adac8178a3be715d1f.png' title=' \inference{A \wedge B}{A}[$\wedge$-E1] \,\,\,\,\,\, \inference{A \wedge B}{B}[$\wedge$-E2]' alt=' \inference{A \wedge B}{A}[$\wedge$-E1] \,\,\,\,\,\, \inference{A \wedge B}{B}[$\wedge$-E2]' align=absmiddle> </p>
</div>
<p>This spartan style gets a bit annoying (in my opinion) for the hypothetical premises of the implication introduction, but this can be solved by adding contexts:</p>
<div class="codeblock">
<p align="center"> <img src='http://comonad.com/latex/9b10e662928fdfe29c4969fe8b301a33.png' title=' \inference{\Gamma, A \vdash B}{\Gamma \vdash A \rightarrow B}[$\rightarrow$-I] ' alt=' \inference{\Gamma, A \vdash B}{\Gamma \vdash A \rightarrow B}[$\rightarrow$-I] ' align=absmiddle> </p>
<p align="center"> <img src='http://comonad.com/latex/2ebd29c4b4b2726fdc20e9e4f6bb4fa3.png' title=' \inference{\Gamma \vdash A \rightarrow B \,\,\,\,\,\,\,\,\, \Gamma \vdash A}{\Gamma \vdash B}[$\rightarrow$-E] ' alt=' \inference{\Gamma \vdash A \rightarrow B \,\,\,\,\,\,\,\,\, \Gamma \vdash A}{\Gamma \vdash B}[$\rightarrow$-E] ' align=absmiddle> </p>
</div>
<p>This is the style most commonly adopted for presenting type theories, except we reason about terms with a type, rather than just propositions. The context we added for convenience above also becomes fairly essential for keeping track of variables:</p>
<div class="codeblock">
<p align="center"> <img src='http://comonad.com/latex/a443c308ea53f52ac8c79390c6dd8151.png' title=' \inference{\Gamma \vdash M : A \,\,\,\,\,\,\,\,\, \Gamma \vdash N : B}{\Gamma \vdash (M, N) : A \times B}[$\times$-I] ' alt=' \inference{\Gamma \vdash M : A \,\,\,\,\,\,\,\,\, \Gamma \vdash N : B}{\Gamma \vdash (M, N) : A \times B}[$\times$-I] ' align=absmiddle> </p>
<p align="center"> <img src='http://comonad.com/latex/ec4510483acc5255daecda473c747b43.png' title=' \inference{\Gamma \vdash M : A \times B}{\Gamma \vdash \mathsf{fst}\, M : A}[$\times$-E1] ' alt=' \inference{\Gamma \vdash M : A \times B}{\Gamma \vdash \mathsf{fst}\, M : A}[$\times$-E1] ' align=absmiddle> </p>
<p align="center"> <img src='http://comonad.com/latex/09fff955437d0808666db20270638ee7.png' title=' \inference{\Gamma \vdash M : A \times B}{\Gamma \vdash \mathsf{snd}\, M : B}[$\times$-E2] ' alt=' \inference{\Gamma \vdash M : A \times B}{\Gamma \vdash \mathsf{snd}\, M : B}[$\times$-E2] ' align=absmiddle> </p>
<p align="center"> <img src='http://comonad.com/latex/3e743e06355407c7d58e5933cbb0bb2f.png' title=' \inference{\Gamma, x : A \vdash M : B}{\Gamma \vdash (\lambda x:A. \,\, M) : A \rightarrow B}[$\rightarrow$-I] ' alt=' \inference{\Gamma, x : A \vdash M : B}{\Gamma \vdash (\lambda x:A. \,\, M) : A \rightarrow B}[$\rightarrow$-I] ' align=absmiddle> </p>
<p align="center"> <img src='http://comonad.com/latex/55b21349085679b21328e7f97bbb5aa4.png' title=' \inference{\Gamma \vdash M : A \rightarrow B \,\,\,\,\,\,\,\,\, \Gamma \vdash N : A}{\Gamma \vdash M \, N : B}[$\rightarrow$-E] ' alt=' \inference{\Gamma \vdash M : A \rightarrow B \,\,\,\,\,\,\,\,\, \Gamma \vdash N : A}{\Gamma \vdash M \, N : B}[$\rightarrow$-E] ' align=absmiddle> </p>
</div>
<p>As can be seen, all the rules involve taking terms from the premise and building on them in the conclusion.</p>
<h2>Sequent Calculi</h2>
<p>The other type of system in question, sequent calculus, looks very similar, but represents a subtle shift in focus for our purposes (sequent calculi are a lot more obviously different when presenting classical logics). First, the inference rules relate sequents, which look a lot like our contextual judgments above, and I'll write them the same way. The difference is that not all rules operate on the conclusion side; some operate just on the context. Generally, introduction rules stay similar to natural deduction (and are called right rules), while elimination rules are replaced by manipulations of the context, and are called left rules. For pairs, we can use the rules:</p>
<div class="codeblock">
<p align="center"> <img src='http://comonad.com/latex/026317e5c95937857e51a76c0cb1e430.png' title=' \inference{\Gamma \vdash A \,\,\,\,\,\,\,\,\, \Gamma \vdash B}{\Gamma \vdash A \wedge B}[$\wedge$-R] ' alt=' \inference{\Gamma \vdash A \,\,\,\,\,\,\,\,\, \Gamma \vdash B}{\Gamma \vdash A \wedge B}[$\wedge$-R] ' align=absmiddle> </p>
<p align="center"> <img src='http://comonad.com/latex/3494cc388869c925dbb52144fd97d30d.png' title=' \inference{\Gamma, A, B \vdash C}{\Gamma, A \wedge B \vdash C}[$\wedge$-L] ' alt=' \inference{\Gamma, A, B \vdash C}{\Gamma, A \wedge B \vdash C}[$\wedge$-L] ' align=absmiddle> </p>
</div>
<p>We could also have two separate left rules:</p>
<div class="codeblock">
<p align="center"><img src='http://comonad.com/latex/110c2bbcf5f66f7c6398c3f6ba990f07.png' title='\inference{\Gamma, A \vdash C}{\Gamma, A \wedge B \vdash C}[$\wedge$-L1]' alt='\inference{\Gamma, A \vdash C}{\Gamma, A \wedge B \vdash C}[$\wedge$-L1]' align=absmiddle></p>
<p align="center"><img src='http://comonad.com/latex/84aa197282ba310d5b850f2cd0a60be3.png' title='\inference{\Gamma, B \vdash C}{\Gamma, A \wedge B \vdash C}[$\wedge$-L2]' alt='\inference{\Gamma, B \vdash C}{\Gamma, A \wedge B \vdash C}[$\wedge$-L2]' align=absmiddle></p>
</div>
<p>But these two different sets are equivalent as long as we're not considering substructural logics. Do note, however, that we're moving from <img src='http://comonad.com/latex/7fc56270e7a70fa81a5935b72eacbe29.png' title='A' alt='A' align=absmiddle> on the top left to <img src='http://comonad.com/latex/b05f38111aa635f08d594f45b197586a.png' title='A \wedge B' alt='A \wedge B' align=absmiddle> on the bottom left, using the fact that <img src='http://comonad.com/latex/b05f38111aa635f08d594f45b197586a.png' title='A \wedge B' alt='A \wedge B' align=absmiddle> is sufficient to imply <img src='http://comonad.com/latex/7fc56270e7a70fa81a5935b72eacbe29.png' title='A' alt='A' align=absmiddle>. That is, projections apply contravariantly to the left.</p>
<p>It turns out that almost no type theory is done in this style; natural deduction is far and away more popular. There are, I think, a few reasons for this. The first is: how do we even extend the left rules to type theory (eliminations are obvious, by contrast)? I know of two ways. The first is to introduce pattern matching into the contexts, so our left rule becomes:</p>
<div class="codeblock">
<p align="center"> <img src='http://comonad.com/latex/9013cfad42a40c2e76a7ecd7049e0e65.png' title=' \inference{\Gamma, x : A, y : B \vdash M : C}{\Gamma, (x, y) : A \times B \vdash M : C}[$\times$-L] ' alt=' \inference{\Gamma, x : A, y : B \vdash M : C}{\Gamma, (x, y) : A \times B \vdash M : C}[$\times$-L] ' align=absmiddle> </p>
</div>
<p>This is an acceptable choice (and may avoid some of the pitfalls in the next option), but it doesn't gel with your typical lambda calculus. It's probably more suited to a pattern calculus of some sort (although, even then, if you want to bend your brain, go look at the left rule for implication and try to figure out how it translates into such a theory; I think you probably need higher-order contexts of some sort). Anyhow, I'm not going to explore this further.</p>
<p>The other option (and one that I've seen in the literature) is that left rules actually involve a variable substitution. So we come up with the following rule:</p>
<div class="codeblock">
<p align="center"> <img src='http://comonad.com/latex/8b9164f5b58ce45f73a1dd4e5d792d2c.png' title=' \inference{\Gamma, x : A, y : B \vdash M : C}{\Gamma, p : A \times B \vdash M[x := \mathsf{fst}\, p, y := \mathsf{snd}\, p] : C}[$\times$-L] ' alt=' \inference{\Gamma, x : A, y : B \vdash M : C}{\Gamma, p : A \times B \vdash M[x := \mathsf{fst}\, p, y := \mathsf{snd}\, p] : C}[$\times$-L] ' align=absmiddle> </p>
</div>
<p>And with this rule, it becomes (I think) more obvious why natural deduction is preferred over sequent calculus, as implementing this rule in a type checker seems significantly harder. Checking the rules of natural deduction involves examining some outer-most structure of the term, and then checking the constituents of the term, possibly in an augmented context, and which rule we're dealing with is always syntax directed. But this left rule has no syntactic correspondent, so it seems as though we must nondeterministically try all left rules at each step, which is unlikely to result in a good algorithm. This is the same kind of problem that plagues extensional type theory, and ultimately results in only <em>derivations</em> being checkable, not terms.</p>
<h2>The Type Class Connection</h2>
<p>However, there are certain problems that I believe are well modeled by such a sequent calculus, and one of them is type class checking and associated dictionary translations. This is due mainly to the fact that the process is mainly context-directed term building, rather than term-directed type checking. As far as the type class algorithm goes, there are two interesting cases, having to do with the following two varieties of declaration:</p>
<pre class="haskell">&nbsp;
  <span style="color: #06c; font-weight: bold;">class</span> <a href="http://haskell.org/ghc/docs/latest/html/libraries/base/Prelude.html#t:Eq"><span style="background-color: #efefbf; font-weight: bold;">Eq</span></a> a =&gt; <a href="http://haskell.org/ghc/docs/latest/html/libraries/base/Prelude.html#t:Ord"><span style="background-color: #efefbf; font-weight: bold;">Ord</span></a> a <span style="color: #06c; font-weight: bold;">where</span> ...
  <span style="color: #06c; font-weight: bold;">instance</span> <span style="color: green;">&#40;</span><a href="http://haskell.org/ghc/docs/latest/html/libraries/base/Prelude.html#t:Eq"><span style="background-color: #efefbf; font-weight: bold;">Eq</span></a> a, <a href="http://haskell.org/ghc/docs/latest/html/libraries/base/Prelude.html#t:Eq"><span style="background-color: #efefbf; font-weight: bold;">Eq</span></a> b<span style="color: green;">&#41;</span> =&gt; <a href="http://haskell.org/ghc/docs/latest/html/libraries/base/Prelude.html#t:Eq"><span style="background-color: #efefbf; font-weight: bold;">Eq</span></a> <span style="color: green;">&#40;</span>a, b<span style="color: green;">&#41;</span> <span style="color: #06c; font-weight: bold;">where</span> ...
&nbsp;</pre>
<p>It turns out that each of these leads to a left rule in a kind of type class sequent calculus:</p>
<div class="codeblock">
<p align="center"> <img src='http://comonad.com/latex/f75290bbac8202c1d47fb62954e7606b.png' title=' \inference{\Gamma, \mathbf{Eq} \, a \vdash M : T}{\Gamma, \mathbf{Ord} \,  a \vdash M : T}[Eq-pre-Ord] ' alt=' \inference{\Gamma, \mathbf{Eq} \, a \vdash M : T}{\Gamma, \mathbf{Ord} \,  a \vdash M : T}[Eq-pre-Ord] ' align=absmiddle> </p>
<p align="center"> <img src='http://comonad.com/latex/4093e2180dce354d1d940438588e32a9.png' title=' \inference{\Gamma, \mathbf{Eq} \, (a, b) \vdash M : T}{\Gamma, \mathbf{Eq} \, a, \mathbf{Eq} \, b \vdash M : T}[Eq-pair] ' alt=' \inference{\Gamma, \mathbf{Eq} \, (a, b) \vdash M : T}{\Gamma, \mathbf{Eq} \, a, \mathbf{Eq} \, b \vdash M : T}[Eq-pair] ' align=absmiddle> </p>
</div>
<p>That is:</p>
<ol>
<li> if <code>Eq a</code> is a sufficient constraint for <code>M : T</code>, then the stronger constraint <code>Ord a</code> is also sufficient, so we can discharge the <code>Eq a</code> constraint and use <code>Ord a</code> instead.</li>
<li> We can discharge an <code>Eq (a, b)</code> constraint using two constraints, <code>Eq a, Eq b</code> together with an instance telling us how to do so. This also works for instances without contexts, giving us rules like:
<div class="codeblock">
<p align="center"><img src='http://comonad.com/latex/81d80ab8d9bd02d1b409ec1e59b4cdb4.png' title='\inference{\Gamma, \mathbf{Show\, Int} \vdash M : T}{\Gamma \vdash M : T}[Show-Int] ' alt='\inference{\Gamma, \mathbf{Show\, Int} \vdash M : T}{\Gamma \vdash M : T}[Show-Int] ' align=absmiddle></p>
</div>
</li>
</ol>
<p>Importantly, the type inference algorithm for type classes specifies when we should use these rules based only on the contexts we're dealing with. Now, these look more like the logical sequent rules, but it turns out that they have corresponding type theory-like versions when we consider dictionary passing:</p>
<div class="codeblock">
<p align="center"> <img src='http://comonad.com/latex/46926ac44142bdb8f4b1e07f8f6fd2b8.png' title=' \inference{\Gamma, eqd : \mathbf{Eq} \, a \vdash M : T}{\Gamma, ordd : \mathbf{Ord} \,  a \vdash M[eqd := \mathsf{eqOrdPrj}\, ordd] : T}[Eq-pre-Ord] ' alt=' \inference{\Gamma, eqd : \mathbf{Eq} \, a \vdash M : T}{\Gamma, ordd : \mathbf{Ord} \,  a \vdash M[eqd := \mathsf{eqOrdPrj}\, ordd] : T}[Eq-pre-Ord] ' align=absmiddle> </p>
<p align="center"> <img src='http://comonad.com/latex/89345750380d8f1f636ab4a29d31ef11.png' title='\inference{\Gamma, peq : \mathbf{Eq} \, (a, b) \vdash M : T}{\Gamma, aeq : \mathbf{Eq} \, a, beq : \mathbf{Eq} \, b \vdash M[peq := \mathsf{eqPair} \, aeq \, beq] : T}[Eq-pair]' alt='\inference{\Gamma, peq : \mathbf{Eq} \, (a, b) \vdash M : T}{\Gamma, aeq : \mathbf{Eq} \, a, beq : \mathbf{Eq} \, b \vdash M[peq := \mathsf{eqPair} \, aeq \, beq] : T}[Eq-pair]' align=absmiddle> </p>
</div>
<p>And this kind of substituting into dictionary variables produces exactly the evidence passing translation we want.</p>
<p>Another way to look at the difference in feasibility is that type checking involves moving bottom-to-top across the rules; in natural deduction, this is always easy, and we need look only at the terms to figure out which we should do. Type class checking and dictionary translation moves from top-to-bottom, directed by the left hand context, and produces terms on the right via complex operations, and that is a perfect fit for the sequent calculus rules.</p>
<p>I believe this corresponds to the general opinion on those who have studied sequent calculi with regard to type theory. A quick search revealed mostly papers on proof search, rather than type checking, and type classes rather fall into that realm (they're a very limited form of proof search).</p>
]]></content:encoded>
			<wfw:commentRss>http://comonad.com/reader/2012/natural-deduction-sequent-calculus-and-type-classes/feed/</wfw:commentRss>
		<slash:comments>3</slash:comments>
		</item>
		<item>
		<title>What Constraints Entail: Part 2</title>
		<link>http://comonad.com/reader/2011/what-constraints-entail-part-2/</link>
		<comments>http://comonad.com/reader/2011/what-constraints-entail-part-2/#comments</comments>
		<pubDate>Thu, 03 Nov 2011 07:23:53 +0000</pubDate>
		<dc:creator>Edward Kmett</dc:creator>
				<category><![CDATA[Constraint Kinds]]></category>
		<category><![CDATA[Haskell]]></category>
		<category><![CDATA[Logic]]></category>
		<category><![CDATA[Monads]]></category>
		<category><![CDATA[Type Hackery]]></category>
		<category><![CDATA[Uncategorized]]></category>

		<guid isPermaLink="false">http://comonad.com/reader/?p=461</guid>
		<description><![CDATA[Last time we derived an entailment relation for constraints, now let's get some use out of it.
Reflecting Classes and Instances
Most of the implications we use on a day to day basis come from our class and instance declarations, but last time we only really dealt with constraint products.

For example given: 
&#160;
#if 0
class Eq a =&#62; [...]]]></description>
			<content:encoded><![CDATA[<p><a href="http://comonad.com/reader/2011/what-constraints-entail-part-1/">Last time</a> we derived an entailment relation for constraints, now let's get some use out of it.</p>
<h2>Reflecting Classes and Instances</h2>
<p>Most of the implications we use on a day to day basis come from our class and instance declarations, but last time we only really dealt with constraint products.</p>
<p><span id="more-461"></span></p>
<p>For example given: </p>
<pre class="haskell">&nbsp;
#if <span style="color: red;">0</span>
<span style="color: #06c; font-weight: bold;">class</span> <a href="http://haskell.org/ghc/docs/latest/html/libraries/base/Prelude.html#t:Eq"><span style="background-color: #efefbf; font-weight: bold;">Eq</span></a> a =&gt; <a href="http://haskell.org/ghc/docs/latest/html/libraries/base/Prelude.html#t:Ord"><span style="background-color: #efefbf; font-weight: bold;">Ord</span></a> a
<span style="color: #06c; font-weight: bold;">instance</span> <a href="http://haskell.org/ghc/docs/latest/html/libraries/base/Prelude.html#t:Eq"><span style="background-color: #efefbf; font-weight: bold;">Eq</span></a> a =&gt; <a href="http://haskell.org/ghc/docs/latest/html/libraries/base/Prelude.html#t:Eq"><span style="background-color: #efefbf; font-weight: bold;">Eq</span></a> <span style="color: green;">&#91;</span>a<span style="color: green;">&#93;</span>
#endif
&nbsp;</pre>
<p>we could provide the following witnesses</p>
<pre class="haskell">&nbsp;
ordEq :: <a href="http://haskell.org/ghc/docs/latest/html/libraries/base/Prelude.html#t:Ord"><span style="background-color: #efefbf; font-weight: bold;">Ord</span></a> a :- <a href="http://haskell.org/ghc/docs/latest/html/libraries/base/Prelude.html#t:Eq"><span style="background-color: #efefbf; font-weight: bold;">Eq</span></a> a
ordEq = Sub Dict
&nbsp;
eqList :: <a href="http://haskell.org/ghc/docs/latest/html/libraries/base/Prelude.html#t:Eq"><span style="background-color: #efefbf; font-weight: bold;">Eq</span></a> a :- <a href="http://haskell.org/ghc/docs/latest/html/libraries/base/Prelude.html#t:Eq"><span style="background-color: #efefbf; font-weight: bold;">Eq</span></a> <span style="color: green;">&#91;</span>a<span style="color: green;">&#93;</span>
eqList = Sub Dict
&nbsp;</pre>
<p>But this would require a lot of names and become remarkably tedious.</p>
<p>So lets define classes to reflect the entailment provided by class definitions and instance declarations and then use them to reflect themselves.</p>
<pre class="haskell">&nbsp;
<span style="color: #06c; font-weight: bold;">class</span> Class b h | h -&gt; b <span style="color: #06c; font-weight: bold;">where</span>
  cls :: h :- b
&nbsp;
<span style="color: #06c; font-weight: bold;">infixr</span> <span style="color: red;">9</span> :=&gt;
<span style="color: #06c; font-weight: bold;">class</span> b :=&gt; h | h -&gt; b <span style="color: #06c; font-weight: bold;">where</span>
  ins :: b :- h
&nbsp;
<span style="color: #06c; font-weight: bold;">instance</span> Class <span style="color: green;">&#40;</span><span style="color: green;">&#41;</span> <span style="color: green;">&#40;</span>Class b a<span style="color: green;">&#41;</span> <span style="color: #06c; font-weight: bold;">where</span> cls = Sub Dict
<span style="color: #06c; font-weight: bold;">instance</span> Class <span style="color: green;">&#40;</span><span style="color: green;">&#41;</span> <span style="color: green;">&#40;</span>b :=&gt; a<span style="color: green;">&#41;</span> <span style="color: #06c; font-weight: bold;">where</span> cls = Sub Dict
&nbsp;</pre>
<p>Now we can reflect classes and instances as instances of Class and (:=>) respectively with:</p>
<pre class="haskell">&nbsp;
<span style="color: #5d478b; font-style: italic;">-- class Eq a =&gt; Ord a where ...</span>
<span style="color: #06c; font-weight: bold;">instance</span> Class <span style="color: green;">&#40;</span><a href="http://haskell.org/ghc/docs/latest/html/libraries/base/Prelude.html#t:Eq"><span style="background-color: #efefbf; font-weight: bold;">Eq</span></a> a<span style="color: green;">&#41;</span> <span style="color: green;">&#40;</span><a href="http://haskell.org/ghc/docs/latest/html/libraries/base/Prelude.html#t:Ord"><span style="background-color: #efefbf; font-weight: bold;">Ord</span></a> a<span style="color: green;">&#41;</span> <span style="color: #06c; font-weight: bold;">where</span> cls = Sub Dict
<span style="color: #5d478b; font-style: italic;">-- instance Eq a =&gt; Eq [a] where ...</span>
<span style="color: #06c; font-weight: bold;">instance</span> <a href="http://haskell.org/ghc/docs/latest/html/libraries/base/Prelude.html#t:Eq"><span style="background-color: #efefbf; font-weight: bold;">Eq</span></a> a :=&gt; <a href="http://haskell.org/ghc/docs/latest/html/libraries/base/Prelude.html#t:Eq"><span style="background-color: #efefbf; font-weight: bold;">Eq</span></a> <span style="color: green;">&#91;</span>a<span style="color: green;">&#93;</span> <span style="color: #06c; font-weight: bold;">where</span> ins = Sub Dict
&nbsp;</pre>
<p>That said, instances of Class and Instance should never require a context themselves, because the modules that the class and instance declarations live in can't taken one, so we can define the following instances which bootstrap the instances of (:=>) for Class and (:=>) once and for all.</p>
<pre class="haskell">&nbsp;
#ifdef UNDECIDABLE
<span style="color: #06c; font-weight: bold;">instance</span> Class b a =&gt; <span style="color: green;">&#40;</span><span style="color: green;">&#41;</span> :=&gt; Class b a <span style="color: #06c; font-weight: bold;">where</span> ins = Sub Dict
<span style="color: #06c; font-weight: bold;">instance</span> <span style="color: green;">&#40;</span>b :=&gt; a<span style="color: green;">&#41;</span> =&gt; <span style="color: green;">&#40;</span><span style="color: green;">&#41;</span> :=&gt; b :=&gt; a <span style="color: #06c; font-weight: bold;">where</span> ins = Sub Dict
#endif
&nbsp;</pre>
<p>These two instances are both decidable, and following a recent bug fix, the current version of GHC HEAD supports them, but my local version isn't that recent, hence the #ifdef.</p>
<p>We can also give admissable-if-not-ever-stated instances of Class and (:=>) for () as well.</p>
<pre class="haskell">&nbsp;
<span style="color: #06c; font-weight: bold;">instance</span> Class <span style="color: green;">&#40;</span><span style="color: green;">&#41;</span> <span style="color: green;">&#40;</span><span style="color: green;">&#41;</span> <span style="color: #06c; font-weight: bold;">where</span> cls = Sub Dict
<span style="color: #06c; font-weight: bold;">instance</span> <span style="color: green;">&#40;</span><span style="color: green;">&#41;</span> :=&gt; <span style="color: green;">&#40;</span><span style="color: green;">&#41;</span> <span style="color: #06c; font-weight: bold;">where</span> ins = Sub Dict
&nbsp;</pre>
<h2>Reflecting the Prelude</h2>
<p>So now that we've written a handful of instances, lets take the plunge and just reflect the entire Prelude, and (most of) the instances for the other modules we've loaded.</p>
<pre class="haskell">&nbsp;
<span style="color: #06c; font-weight: bold;">instance</span> Class <span style="color: green;">&#40;</span><span style="color: green;">&#41;</span> <span style="color: green;">&#40;</span><a href="http://haskell.org/ghc/docs/latest/html/libraries/base/Prelude.html#t:Eq"><span style="background-color: #efefbf; font-weight: bold;">Eq</span></a> a<span style="color: green;">&#41;</span> <span style="color: #06c; font-weight: bold;">where</span> cls = Sub Dict
<span style="color: #06c; font-weight: bold;">instance</span> <span style="color: green;">&#40;</span><span style="color: green;">&#41;</span> :=&gt; <a href="http://haskell.org/ghc/docs/latest/html/libraries/base/Prelude.html#t:Eq"><span style="background-color: #efefbf; font-weight: bold;">Eq</span></a> <span style="color: green;">&#40;</span><span style="color: green;">&#41;</span> <span style="color: #06c; font-weight: bold;">where</span> ins = Sub Dict
<span style="color: #06c; font-weight: bold;">instance</span> <span style="color: green;">&#40;</span><span style="color: green;">&#41;</span> :=&gt; <a href="http://haskell.org/ghc/docs/latest/html/libraries/base/Prelude.html#t:Eq"><span style="background-color: #efefbf; font-weight: bold;">Eq</span></a> <a href="http://haskell.org/ghc/docs/latest/html/libraries/base/Prelude.html#t:Int"><span style="background-color: #efefbf; font-weight: bold;">Int</span></a> <span style="color: #06c; font-weight: bold;">where</span> ins = Sub Dict
<span style="color: #06c; font-weight: bold;">instance</span> <span style="color: green;">&#40;</span><span style="color: green;">&#41;</span> :=&gt; <a href="http://haskell.org/ghc/docs/latest/html/libraries/base/Prelude.html#t:Eq"><span style="background-color: #efefbf; font-weight: bold;">Eq</span></a> <a href="http://haskell.org/ghc/docs/latest/html/libraries/base/Prelude.html#t:Bool"><span style="background-color: #efefbf; font-weight: bold;">Bool</span></a> <span style="color: #06c; font-weight: bold;">where</span> ins = Sub Dict
<span style="color: #06c; font-weight: bold;">instance</span> <span style="color: green;">&#40;</span><span style="color: green;">&#41;</span> :=&gt; <a href="http://haskell.org/ghc/docs/latest/html/libraries/base/Prelude.html#t:Eq"><span style="background-color: #efefbf; font-weight: bold;">Eq</span></a> <a href="http://haskell.org/ghc/docs/latest/html/libraries/base/Prelude.html#t:Integer"><span style="background-color: #efefbf; font-weight: bold;">Integer</span></a> <span style="color: #06c; font-weight: bold;">where</span> ins = Sub Dict
<span style="color: #06c; font-weight: bold;">instance</span> <span style="color: green;">&#40;</span><span style="color: green;">&#41;</span> :=&gt; <a href="http://haskell.org/ghc/docs/latest/html/libraries/base/Prelude.html#t:Eq"><span style="background-color: #efefbf; font-weight: bold;">Eq</span></a> <a href="http://haskell.org/ghc/docs/latest/html/libraries/base/Prelude.html#t:Float"><span style="background-color: #efefbf; font-weight: bold;">Float</span></a> <span style="color: #06c; font-weight: bold;">where</span> ins = Sub Dict
<span style="color: #06c; font-weight: bold;">instance</span> <span style="color: green;">&#40;</span><span style="color: green;">&#41;</span> :=&gt; <a href="http://haskell.org/ghc/docs/latest/html/libraries/base/Prelude.html#t:Eq"><span style="background-color: #efefbf; font-weight: bold;">Eq</span></a> <a href="http://haskell.org/ghc/docs/latest/html/libraries/base/Prelude.html#t:Double"><span style="background-color: #efefbf; font-weight: bold;">Double</span></a> <span style="color: #06c; font-weight: bold;">where</span> ins = Sub Dict
<span style="color: #06c; font-weight: bold;">instance</span> <a href="http://haskell.org/ghc/docs/latest/html/libraries/base/Prelude.html#t:Eq"><span style="background-color: #efefbf; font-weight: bold;">Eq</span></a> a :=&gt; <a href="http://haskell.org/ghc/docs/latest/html/libraries/base/Prelude.html#t:Eq"><span style="background-color: #efefbf; font-weight: bold;">Eq</span></a> <span style="color: green;">&#91;</span>a<span style="color: green;">&#93;</span> <span style="color: #06c; font-weight: bold;">where</span> ins = Sub Dict
<span style="color: #06c; font-weight: bold;">instance</span> <a href="http://haskell.org/ghc/docs/latest/html/libraries/base/Prelude.html#t:Eq"><span style="background-color: #efefbf; font-weight: bold;">Eq</span></a> a :=&gt; <a href="http://haskell.org/ghc/docs/latest/html/libraries/base/Prelude.html#t:Eq"><span style="background-color: #efefbf; font-weight: bold;">Eq</span></a> <span style="color: green;">&#40;</span><a href="http://haskell.org/ghc/docs/latest/html/libraries/base/Prelude.html#t:Maybe"><span style="background-color: #efefbf; font-weight: bold;">Maybe</span></a> a<span style="color: green;">&#41;</span> <span style="color: #06c; font-weight: bold;">where</span> ins = Sub Dict
<span style="color: #06c; font-weight: bold;">instance</span> <a href="http://haskell.org/ghc/docs/latest/html/libraries/base/Prelude.html#t:Eq"><span style="background-color: #efefbf; font-weight: bold;">Eq</span></a> a :=&gt; <a href="http://haskell.org/ghc/docs/latest/html/libraries/base/Prelude.html#t:Eq"><span style="background-color: #efefbf; font-weight: bold;">Eq</span></a> <span style="color: green;">&#40;</span>Complex a<span style="color: green;">&#41;</span> <span style="color: #06c; font-weight: bold;">where</span> ins = Sub Dict
<span style="color: #06c; font-weight: bold;">instance</span> <a href="http://haskell.org/ghc/docs/latest/html/libraries/base/Prelude.html#t:Eq"><span style="background-color: #efefbf; font-weight: bold;">Eq</span></a> a :=&gt; <a href="http://haskell.org/ghc/docs/latest/html/libraries/base/Prelude.html#t:Eq"><span style="background-color: #efefbf; font-weight: bold;">Eq</span></a> <span style="color: green;">&#40;</span>Ratio a<span style="color: green;">&#41;</span> <span style="color: #06c; font-weight: bold;">where</span> ins = Sub Dict
<span style="color: #06c; font-weight: bold;">instance</span> <span style="color: green;">&#40;</span><a href="http://haskell.org/ghc/docs/latest/html/libraries/base/Prelude.html#t:Eq"><span style="background-color: #efefbf; font-weight: bold;">Eq</span></a> a, <a href="http://haskell.org/ghc/docs/latest/html/libraries/base/Prelude.html#t:Eq"><span style="background-color: #efefbf; font-weight: bold;">Eq</span></a> b<span style="color: green;">&#41;</span> :=&gt; <a href="http://haskell.org/ghc/docs/latest/html/libraries/base/Prelude.html#t:Eq"><span style="background-color: #efefbf; font-weight: bold;">Eq</span></a> <span style="color: green;">&#40;</span>a, b<span style="color: green;">&#41;</span> <span style="color: #06c; font-weight: bold;">where</span> ins = Sub Dict
<span style="color: #06c; font-weight: bold;">instance</span> <span style="color: green;">&#40;</span><a href="http://haskell.org/ghc/docs/latest/html/libraries/base/Prelude.html#t:Eq"><span style="background-color: #efefbf; font-weight: bold;">Eq</span></a> a, <a href="http://haskell.org/ghc/docs/latest/html/libraries/base/Prelude.html#t:Eq"><span style="background-color: #efefbf; font-weight: bold;">Eq</span></a> b<span style="color: green;">&#41;</span> :=&gt; <a href="http://haskell.org/ghc/docs/latest/html/libraries/base/Prelude.html#t:Eq"><span style="background-color: #efefbf; font-weight: bold;">Eq</span></a> <span style="color: green;">&#40;</span><a href="http://haskell.org/ghc/docs/latest/html/libraries/base/Prelude.html#t:Either"><span style="background-color: #efefbf; font-weight: bold;">Either</span></a> a b<span style="color: green;">&#41;</span> <span style="color: #06c; font-weight: bold;">where</span> ins = Sub Dict
<span style="color: #06c; font-weight: bold;">instance</span> <span style="color: green;">&#40;</span><span style="color: green;">&#41;</span> :=&gt; <a href="http://haskell.org/ghc/docs/latest/html/libraries/base/Prelude.html#t:Eq"><span style="background-color: #efefbf; font-weight: bold;">Eq</span></a> <span style="color: green;">&#40;</span>Dict a<span style="color: green;">&#41;</span> <span style="color: #06c; font-weight: bold;">where</span> ins = Sub Dict
<span style="color: #06c; font-weight: bold;">instance</span> <span style="color: green;">&#40;</span><span style="color: green;">&#41;</span> :=&gt; <a href="http://haskell.org/ghc/docs/latest/html/libraries/base/Prelude.html#t:Eq"><span style="background-color: #efefbf; font-weight: bold;">Eq</span></a> <span style="color: green;">&#40;</span>a :- b<span style="color: green;">&#41;</span> <span style="color: #06c; font-weight: bold;">where</span> ins = Sub Dict
&nbsp;</pre>
<pre class="haskell">&nbsp;
<span style="color: #06c; font-weight: bold;">instance</span> Class <span style="color: green;">&#40;</span><a href="http://haskell.org/ghc/docs/latest/html/libraries/base/Prelude.html#t:Eq"><span style="background-color: #efefbf; font-weight: bold;">Eq</span></a> a<span style="color: green;">&#41;</span> <span style="color: green;">&#40;</span><a href="http://haskell.org/ghc/docs/latest/html/libraries/base/Prelude.html#t:Ord"><span style="background-color: #efefbf; font-weight: bold;">Ord</span></a> a<span style="color: green;">&#41;</span> <span style="color: #06c; font-weight: bold;">where</span> cls = Sub Dict
<span style="color: #06c; font-weight: bold;">instance</span> <span style="color: green;">&#40;</span><span style="color: green;">&#41;</span> :=&gt; <a href="http://haskell.org/ghc/docs/latest/html/libraries/base/Prelude.html#t:Ord"><span style="background-color: #efefbf; font-weight: bold;">Ord</span></a> <span style="color: green;">&#40;</span><span style="color: green;">&#41;</span> <span style="color: #06c; font-weight: bold;">where</span> ins = Sub Dict
<span style="color: #06c; font-weight: bold;">instance</span> <span style="color: green;">&#40;</span><span style="color: green;">&#41;</span> :=&gt; <a href="http://haskell.org/ghc/docs/latest/html/libraries/base/Prelude.html#t:Ord"><span style="background-color: #efefbf; font-weight: bold;">Ord</span></a> <a href="http://haskell.org/ghc/docs/latest/html/libraries/base/Prelude.html#t:Bool"><span style="background-color: #efefbf; font-weight: bold;">Bool</span></a> <span style="color: #06c; font-weight: bold;">where</span> ins = Sub Dict
<span style="color: #06c; font-weight: bold;">instance</span> <span style="color: green;">&#40;</span><span style="color: green;">&#41;</span> :=&gt; <a href="http://haskell.org/ghc/docs/latest/html/libraries/base/Prelude.html#t:Ord"><span style="background-color: #efefbf; font-weight: bold;">Ord</span></a> <a href="http://haskell.org/ghc/docs/latest/html/libraries/base/Prelude.html#t:Int"><span style="background-color: #efefbf; font-weight: bold;">Int</span></a> <span style="color: #06c; font-weight: bold;">where</span> ins = Sub Dict
<span style="color: #06c; font-weight: bold;">instance</span> <span style="color: green;">&#40;</span><span style="color: green;">&#41;</span>:=&gt; <a href="http://haskell.org/ghc/docs/latest/html/libraries/base/Prelude.html#t:Ord"><span style="background-color: #efefbf; font-weight: bold;">Ord</span></a> <a href="http://haskell.org/ghc/docs/latest/html/libraries/base/Prelude.html#t:Integer"><span style="background-color: #efefbf; font-weight: bold;">Integer</span></a> <span style="color: #06c; font-weight: bold;">where</span> ins = Sub Dict
<span style="color: #06c; font-weight: bold;">instance</span> <span style="color: green;">&#40;</span><span style="color: green;">&#41;</span> :=&gt; <a href="http://haskell.org/ghc/docs/latest/html/libraries/base/Prelude.html#t:Ord"><span style="background-color: #efefbf; font-weight: bold;">Ord</span></a> <a href="http://haskell.org/ghc/docs/latest/html/libraries/base/Prelude.html#t:Float"><span style="background-color: #efefbf; font-weight: bold;">Float</span></a> <span style="color: #06c; font-weight: bold;">where</span> ins = Sub Dict
<span style="color: #06c; font-weight: bold;">instance</span> <span style="color: green;">&#40;</span><span style="color: green;">&#41;</span>:=&gt; <a href="http://haskell.org/ghc/docs/latest/html/libraries/base/Prelude.html#t:Ord"><span style="background-color: #efefbf; font-weight: bold;">Ord</span></a> <a href="http://haskell.org/ghc/docs/latest/html/libraries/base/Prelude.html#t:Double"><span style="background-color: #efefbf; font-weight: bold;">Double</span></a> <span style="color: #06c; font-weight: bold;">where</span> ins = Sub Dict
<span style="color: #06c; font-weight: bold;">instance</span> <span style="color: green;">&#40;</span><span style="color: green;">&#41;</span> :=&gt; <a href="http://haskell.org/ghc/docs/latest/html/libraries/base/Prelude.html#t:Ord"><span style="background-color: #efefbf; font-weight: bold;">Ord</span></a> <a href="http://haskell.org/ghc/docs/latest/html/libraries/base/Prelude.html#t:Char"><span style="background-color: #efefbf; font-weight: bold;">Char</span></a> <span style="color: #06c; font-weight: bold;">where</span> ins = Sub Dict
<span style="color: #06c; font-weight: bold;">instance</span> <a href="http://haskell.org/ghc/docs/latest/html/libraries/base/Prelude.html#t:Ord"><span style="background-color: #efefbf; font-weight: bold;">Ord</span></a> a :=&gt; <a href="http://haskell.org/ghc/docs/latest/html/libraries/base/Prelude.html#t:Ord"><span style="background-color: #efefbf; font-weight: bold;">Ord</span></a> <span style="color: green;">&#40;</span><a href="http://haskell.org/ghc/docs/latest/html/libraries/base/Prelude.html#t:Maybe"><span style="background-color: #efefbf; font-weight: bold;">Maybe</span></a> a<span style="color: green;">&#41;</span> <span style="color: #06c; font-weight: bold;">where</span> ins = Sub Dict
<span style="color: #06c; font-weight: bold;">instance</span> <a href="http://haskell.org/ghc/docs/latest/html/libraries/base/Prelude.html#t:Ord"><span style="background-color: #efefbf; font-weight: bold;">Ord</span></a> a :=&gt; <a href="http://haskell.org/ghc/docs/latest/html/libraries/base/Prelude.html#t:Ord"><span style="background-color: #efefbf; font-weight: bold;">Ord</span></a> <span style="color: green;">&#91;</span>a<span style="color: green;">&#93;</span> <span style="color: #06c; font-weight: bold;">where</span> ins = Sub Dict
<span style="color: #06c; font-weight: bold;">instance</span> <span style="color: green;">&#40;</span><a href="http://haskell.org/ghc/docs/latest/html/libraries/base/Prelude.html#t:Ord"><span style="background-color: #efefbf; font-weight: bold;">Ord</span></a> a, <a href="http://haskell.org/ghc/docs/latest/html/libraries/base/Prelude.html#t:Ord"><span style="background-color: #efefbf; font-weight: bold;">Ord</span></a> b<span style="color: green;">&#41;</span> :=&gt; <a href="http://haskell.org/ghc/docs/latest/html/libraries/base/Prelude.html#t:Ord"><span style="background-color: #efefbf; font-weight: bold;">Ord</span></a> <span style="color: green;">&#40;</span>a, b<span style="color: green;">&#41;</span> <span style="color: #06c; font-weight: bold;">where</span> ins = Sub Dict
<span style="color: #06c; font-weight: bold;">instance</span> <span style="color: green;">&#40;</span><a href="http://haskell.org/ghc/docs/latest/html/libraries/base/Prelude.html#t:Ord"><span style="background-color: #efefbf; font-weight: bold;">Ord</span></a> a, <a href="http://haskell.org/ghc/docs/latest/html/libraries/base/Prelude.html#t:Ord"><span style="background-color: #efefbf; font-weight: bold;">Ord</span></a> b<span style="color: green;">&#41;</span> :=&gt; <a href="http://haskell.org/ghc/docs/latest/html/libraries/base/Prelude.html#t:Ord"><span style="background-color: #efefbf; font-weight: bold;">Ord</span></a> <span style="color: green;">&#40;</span><a href="http://haskell.org/ghc/docs/latest/html/libraries/base/Prelude.html#t:Either"><span style="background-color: #efefbf; font-weight: bold;">Either</span></a> a b<span style="color: green;">&#41;</span> <span style="color: #06c; font-weight: bold;">where</span> ins = Sub Dict
<span style="color: #06c; font-weight: bold;">instance</span> <a href="http://haskell.org/ghc/docs/latest/html/libraries/base/Prelude.html#t:Integral"><span style="background-color: #efefbf; font-weight: bold;">Integral</span></a> a :=&gt; <a href="http://haskell.org/ghc/docs/latest/html/libraries/base/Prelude.html#t:Ord"><span style="background-color: #efefbf; font-weight: bold;">Ord</span></a> <span style="color: green;">&#40;</span>Ratio a<span style="color: green;">&#41;</span> <span style="color: #06c; font-weight: bold;">where</span> ins = Sub Dict
<span style="color: #06c; font-weight: bold;">instance</span> <span style="color: green;">&#40;</span><span style="color: green;">&#41;</span> :=&gt; <a href="http://haskell.org/ghc/docs/latest/html/libraries/base/Prelude.html#t:Ord"><span style="background-color: #efefbf; font-weight: bold;">Ord</span></a> <span style="color: green;">&#40;</span>Dict a<span style="color: green;">&#41;</span> <span style="color: #06c; font-weight: bold;">where</span> ins = Sub Dict
<span style="color: #06c; font-weight: bold;">instance</span> <span style="color: green;">&#40;</span><span style="color: green;">&#41;</span> :=&gt; <a href="http://haskell.org/ghc/docs/latest/html/libraries/base/Prelude.html#t:Ord"><span style="background-color: #efefbf; font-weight: bold;">Ord</span></a> <span style="color: green;">&#40;</span>a :- b<span style="color: green;">&#41;</span> <span style="color: #06c; font-weight: bold;">where</span> ins = Sub Dict
&nbsp;</pre>
<pre class="haskell">&nbsp;
<span style="color: #06c; font-weight: bold;">instance</span> Class <span style="color: green;">&#40;</span><span style="color: green;">&#41;</span> <span style="color: green;">&#40;</span><a href="http://haskell.org/ghc/docs/latest/html/libraries/base/Prelude.html#t:Show"><span style="background-color: #efefbf; font-weight: bold;">Show</span></a> a<span style="color: green;">&#41;</span> <span style="color: #06c; font-weight: bold;">where</span> cls = Sub Dict
<span style="color: #06c; font-weight: bold;">instance</span> <span style="color: green;">&#40;</span><span style="color: green;">&#41;</span> :=&gt; <a href="http://haskell.org/ghc/docs/latest/html/libraries/base/Prelude.html#t:Show"><span style="background-color: #efefbf; font-weight: bold;">Show</span></a> <span style="color: green;">&#40;</span><span style="color: green;">&#41;</span> <span style="color: #06c; font-weight: bold;">where</span> ins = Sub Dict
<span style="color: #06c; font-weight: bold;">instance</span> <span style="color: green;">&#40;</span><span style="color: green;">&#41;</span> :=&gt; <a href="http://haskell.org/ghc/docs/latest/html/libraries/base/Prelude.html#t:Show"><span style="background-color: #efefbf; font-weight: bold;">Show</span></a> <a href="http://haskell.org/ghc/docs/latest/html/libraries/base/Prelude.html#t:Bool"><span style="background-color: #efefbf; font-weight: bold;">Bool</span></a> <span style="color: #06c; font-weight: bold;">where</span> ins = Sub Dict
<span style="color: #06c; font-weight: bold;">instance</span> <span style="color: green;">&#40;</span><span style="color: green;">&#41;</span> :=&gt; <a href="http://haskell.org/ghc/docs/latest/html/libraries/base/Prelude.html#t:Show"><span style="background-color: #efefbf; font-weight: bold;">Show</span></a> <a href="http://haskell.org/ghc/docs/latest/html/libraries/base/Prelude.html#t:Ordering"><span style="background-color: #efefbf; font-weight: bold;">Ordering</span></a> <span style="color: #06c; font-weight: bold;">where</span> ins = Sub Dict
<span style="color: #06c; font-weight: bold;">instance</span> <span style="color: green;">&#40;</span><span style="color: green;">&#41;</span> :=&gt; <a href="http://haskell.org/ghc/docs/latest/html/libraries/base/Prelude.html#t:Show"><span style="background-color: #efefbf; font-weight: bold;">Show</span></a> <a href="http://haskell.org/ghc/docs/latest/html/libraries/base/Prelude.html#t:Char"><span style="background-color: #efefbf; font-weight: bold;">Char</span></a> <span style="color: #06c; font-weight: bold;">where</span> ins = Sub Dict
<span style="color: #06c; font-weight: bold;">instance</span> <a href="http://haskell.org/ghc/docs/latest/html/libraries/base/Prelude.html#t:Show"><span style="background-color: #efefbf; font-weight: bold;">Show</span></a> a :=&gt; <a href="http://haskell.org/ghc/docs/latest/html/libraries/base/Prelude.html#t:Show"><span style="background-color: #efefbf; font-weight: bold;">Show</span></a> <span style="color: green;">&#40;</span>Complex a<span style="color: green;">&#41;</span> <span style="color: #06c; font-weight: bold;">where</span> ins = Sub Dict
<span style="color: #06c; font-weight: bold;">instance</span> <a href="http://haskell.org/ghc/docs/latest/html/libraries/base/Prelude.html#t:Show"><span style="background-color: #efefbf; font-weight: bold;">Show</span></a> a :=&gt; <a href="http://haskell.org/ghc/docs/latest/html/libraries/base/Prelude.html#t:Show"><span style="background-color: #efefbf; font-weight: bold;">Show</span></a> <span style="color: green;">&#91;</span>a<span style="color: green;">&#93;</span> <span style="color: #06c; font-weight: bold;">where</span> ins = Sub Dict
<span style="color: #06c; font-weight: bold;">instance</span> <a href="http://haskell.org/ghc/docs/latest/html/libraries/base/Prelude.html#t:Show"><span style="background-color: #efefbf; font-weight: bold;">Show</span></a> a :=&gt; <a href="http://haskell.org/ghc/docs/latest/html/libraries/base/Prelude.html#t:Show"><span style="background-color: #efefbf; font-weight: bold;">Show</span></a> <span style="color: green;">&#40;</span><a href="http://haskell.org/ghc/docs/latest/html/libraries/base/Prelude.html#t:Maybe"><span style="background-color: #efefbf; font-weight: bold;">Maybe</span></a> a<span style="color: green;">&#41;</span> <span style="color: #06c; font-weight: bold;">where</span> ins = Sub Dict
<span style="color: #06c; font-weight: bold;">instance</span> <span style="color: green;">&#40;</span><a href="http://haskell.org/ghc/docs/latest/html/libraries/base/Prelude.html#t:Show"><span style="background-color: #efefbf; font-weight: bold;">Show</span></a> a, <a href="http://haskell.org/ghc/docs/latest/html/libraries/base/Prelude.html#t:Show"><span style="background-color: #efefbf; font-weight: bold;">Show</span></a> b<span style="color: green;">&#41;</span> :=&gt; <a href="http://haskell.org/ghc/docs/latest/html/libraries/base/Prelude.html#t:Show"><span style="background-color: #efefbf; font-weight: bold;">Show</span></a> <span style="color: green;">&#40;</span>a, b<span style="color: green;">&#41;</span> <span style="color: #06c; font-weight: bold;">where</span> ins = Sub Dict
<span style="color: #06c; font-weight: bold;">instance</span> <span style="color: green;">&#40;</span><a href="http://haskell.org/ghc/docs/latest/html/libraries/base/Prelude.html#t:Show"><span style="background-color: #efefbf; font-weight: bold;">Show</span></a> a, <a href="http://haskell.org/ghc/docs/latest/html/libraries/base/Prelude.html#t:Show"><span style="background-color: #efefbf; font-weight: bold;">Show</span></a> b<span style="color: green;">&#41;</span> :=&gt; <a href="http://haskell.org/ghc/docs/latest/html/libraries/base/Prelude.html#t:Show"><span style="background-color: #efefbf; font-weight: bold;">Show</span></a> <span style="color: green;">&#40;</span><a href="http://haskell.org/ghc/docs/latest/html/libraries/base/Prelude.html#t:Either"><span style="background-color: #efefbf; font-weight: bold;">Either</span></a> a b<span style="color: green;">&#41;</span> <span style="color: #06c; font-weight: bold;">where</span> ins = Sub Dict
<span style="color: #06c; font-weight: bold;">instance</span> <span style="color: green;">&#40;</span><a href="http://haskell.org/ghc/docs/latest/html/libraries/base/Prelude.html#t:Integral"><span style="background-color: #efefbf; font-weight: bold;">Integral</span></a> a, <a href="http://haskell.org/ghc/docs/latest/html/libraries/base/Prelude.html#t:Show"><span style="background-color: #efefbf; font-weight: bold;">Show</span></a> a<span style="color: green;">&#41;</span> :=&gt; <a href="http://haskell.org/ghc/docs/latest/html/libraries/base/Prelude.html#t:Show"><span style="background-color: #efefbf; font-weight: bold;">Show</span></a> <span style="color: green;">&#40;</span>Ratio a<span style="color: green;">&#41;</span> <span style="color: #06c; font-weight: bold;">where</span> ins = Sub Dict
<span style="color: #06c; font-weight: bold;">instance</span> <span style="color: green;">&#40;</span><span style="color: green;">&#41;</span> :=&gt; <a href="http://haskell.org/ghc/docs/latest/html/libraries/base/Prelude.html#t:Show"><span style="background-color: #efefbf; font-weight: bold;">Show</span></a> <span style="color: green;">&#40;</span>Dict a<span style="color: green;">&#41;</span> <span style="color: #06c; font-weight: bold;">where</span> ins = Sub Dict
<span style="color: #06c; font-weight: bold;">instance</span> <span style="color: green;">&#40;</span><span style="color: green;">&#41;</span> :=&gt; <a href="http://haskell.org/ghc/docs/latest/html/libraries/base/Prelude.html#t:Show"><span style="background-color: #efefbf; font-weight: bold;">Show</span></a> <span style="color: green;">&#40;</span>a :- b<span style="color: green;">&#41;</span> <span style="color: #06c; font-weight: bold;">where</span> ins = Sub Dict
&nbsp;</pre>
<pre class="haskell">&nbsp;
<span style="color: #06c; font-weight: bold;">instance</span> Class <span style="color: green;">&#40;</span><span style="color: green;">&#41;</span> <span style="color: green;">&#40;</span><a href="http://haskell.org/ghc/docs/latest/html/libraries/base/Prelude.html#t:Read"><span style="background-color: #efefbf; font-weight: bold;">Read</span></a> a<span style="color: green;">&#41;</span> <span style="color: #06c; font-weight: bold;">where</span> cls = Sub Dict
<span style="color: #06c; font-weight: bold;">instance</span> <span style="color: green;">&#40;</span><span style="color: green;">&#41;</span> :=&gt; <a href="http://haskell.org/ghc/docs/latest/html/libraries/base/Prelude.html#t:Read"><span style="background-color: #efefbf; font-weight: bold;">Read</span></a> <span style="color: green;">&#40;</span><span style="color: green;">&#41;</span> <span style="color: #06c; font-weight: bold;">where</span> ins = Sub Dict
<span style="color: #06c; font-weight: bold;">instance</span> <span style="color: green;">&#40;</span><span style="color: green;">&#41;</span> :=&gt; <a href="http://haskell.org/ghc/docs/latest/html/libraries/base/Prelude.html#t:Read"><span style="background-color: #efefbf; font-weight: bold;">Read</span></a> <a href="http://haskell.org/ghc/docs/latest/html/libraries/base/Prelude.html#t:Bool"><span style="background-color: #efefbf; font-weight: bold;">Bool</span></a> <span style="color: #06c; font-weight: bold;">where</span> ins = Sub Dict
<span style="color: #06c; font-weight: bold;">instance</span> <span style="color: green;">&#40;</span><span style="color: green;">&#41;</span> :=&gt; <a href="http://haskell.org/ghc/docs/latest/html/libraries/base/Prelude.html#t:Read"><span style="background-color: #efefbf; font-weight: bold;">Read</span></a> <a href="http://haskell.org/ghc/docs/latest/html/libraries/base/Prelude.html#t:Ordering"><span style="background-color: #efefbf; font-weight: bold;">Ordering</span></a> <span style="color: #06c; font-weight: bold;">where</span> ins = Sub Dict
<span style="color: #06c; font-weight: bold;">instance</span> <span style="color: green;">&#40;</span><span style="color: green;">&#41;</span> :=&gt; <a href="http://haskell.org/ghc/docs/latest/html/libraries/base/Prelude.html#t:Read"><span style="background-color: #efefbf; font-weight: bold;">Read</span></a> <a href="http://haskell.org/ghc/docs/latest/html/libraries/base/Prelude.html#t:Char"><span style="background-color: #efefbf; font-weight: bold;">Char</span></a> <span style="color: #06c; font-weight: bold;">where</span> ins = Sub Dict
<span style="color: #06c; font-weight: bold;">instance</span> <a href="http://haskell.org/ghc/docs/latest/html/libraries/base/Prelude.html#t:Read"><span style="background-color: #efefbf; font-weight: bold;">Read</span></a> a :=&gt; <a href="http://haskell.org/ghc/docs/latest/html/libraries/base/Prelude.html#t:Read"><span style="background-color: #efefbf; font-weight: bold;">Read</span></a> <span style="color: green;">&#40;</span>Complex a<span style="color: green;">&#41;</span> <span style="color: #06c; font-weight: bold;">where</span> ins = Sub Dict
<span style="color: #06c; font-weight: bold;">instance</span> <a href="http://haskell.org/ghc/docs/latest/html/libraries/base/Prelude.html#t:Read"><span style="background-color: #efefbf; font-weight: bold;">Read</span></a> a :=&gt; <a href="http://haskell.org/ghc/docs/latest/html/libraries/base/Prelude.html#t:Read"><span style="background-color: #efefbf; font-weight: bold;">Read</span></a> <span style="color: green;">&#91;</span>a<span style="color: green;">&#93;</span> <span style="color: #06c; font-weight: bold;">where</span> ins = Sub Dict
<span style="color: #06c; font-weight: bold;">instance</span> <a href="http://haskell.org/ghc/docs/latest/html/libraries/base/Prelude.html#t:Read"><span style="background-color: #efefbf; font-weight: bold;">Read</span></a> a :=&gt; <a href="http://haskell.org/ghc/docs/latest/html/libraries/base/Prelude.html#t:Read"><span style="background-color: #efefbf; font-weight: bold;">Read</span></a> <span style="color: green;">&#40;</span><a href="http://haskell.org/ghc/docs/latest/html/libraries/base/Prelude.html#t:Maybe"><span style="background-color: #efefbf; font-weight: bold;">Maybe</span></a> a<span style="color: green;">&#41;</span> <span style="color: #06c; font-weight: bold;">where</span> ins = Sub Dict
<span style="color: #06c; font-weight: bold;">instance</span> <span style="color: green;">&#40;</span><a href="http://haskell.org/ghc/docs/latest/html/libraries/base/Prelude.html#t:Read"><span style="background-color: #efefbf; font-weight: bold;">Read</span></a> a, <a href="http://haskell.org/ghc/docs/latest/html/libraries/base/Prelude.html#t:Read"><span style="background-color: #efefbf; font-weight: bold;">Read</span></a> b<span style="color: green;">&#41;</span> :=&gt; <a href="http://haskell.org/ghc/docs/latest/html/libraries/base/Prelude.html#t:Read"><span style="background-color: #efefbf; font-weight: bold;">Read</span></a> <span style="color: green;">&#40;</span>a, b<span style="color: green;">&#41;</span> <span style="color: #06c; font-weight: bold;">where</span> ins = Sub Dict
<span style="color: #06c; font-weight: bold;">instance</span> <span style="color: green;">&#40;</span><a href="http://haskell.org/ghc/docs/latest/html/libraries/base/Prelude.html#t:Read"><span style="background-color: #efefbf; font-weight: bold;">Read</span></a> a, <a href="http://haskell.org/ghc/docs/latest/html/libraries/base/Prelude.html#t:Read"><span style="background-color: #efefbf; font-weight: bold;">Read</span></a> b<span style="color: green;">&#41;</span> :=&gt; <a href="http://haskell.org/ghc/docs/latest/html/libraries/base/Prelude.html#t:Read"><span style="background-color: #efefbf; font-weight: bold;">Read</span></a> <span style="color: green;">&#40;</span><a href="http://haskell.org/ghc/docs/latest/html/libraries/base/Prelude.html#t:Either"><span style="background-color: #efefbf; font-weight: bold;">Either</span></a> a b<span style="color: green;">&#41;</span> <span style="color: #06c; font-weight: bold;">where</span> ins = Sub Dict
<span style="color: #06c; font-weight: bold;">instance</span> <span style="color: green;">&#40;</span><a href="http://haskell.org/ghc/docs/latest/html/libraries/base/Prelude.html#t:Integral"><span style="background-color: #efefbf; font-weight: bold;">Integral</span></a> a, <a href="http://haskell.org/ghc/docs/latest/html/libraries/base/Prelude.html#t:Read"><span style="background-color: #efefbf; font-weight: bold;">Read</span></a> a<span style="color: green;">&#41;</span> :=&gt; <a href="http://haskell.org/ghc/docs/latest/html/libraries/base/Prelude.html#t:Read"><span style="background-color: #efefbf; font-weight: bold;">Read</span></a> <span style="color: green;">&#40;</span>Ratio a<span style="color: green;">&#41;</span> <span style="color: #06c; font-weight: bold;">where</span> ins = Sub Dict
&nbsp;</pre>
<pre class="haskell">&nbsp;
<span style="color: #06c; font-weight: bold;">instance</span> Class <span style="color: green;">&#40;</span><span style="color: green;">&#41;</span> <span style="color: green;">&#40;</span><a href="http://haskell.org/ghc/docs/latest/html/libraries/base/Prelude.html#t:Enum"><span style="background-color: #efefbf; font-weight: bold;">Enum</span></a> a<span style="color: green;">&#41;</span> <span style="color: #06c; font-weight: bold;">where</span> cls = Sub Dict
<span style="color: #06c; font-weight: bold;">instance</span> <span style="color: green;">&#40;</span><span style="color: green;">&#41;</span> :=&gt; <a href="http://haskell.org/ghc/docs/latest/html/libraries/base/Prelude.html#t:Enum"><span style="background-color: #efefbf; font-weight: bold;">Enum</span></a> <span style="color: green;">&#40;</span><span style="color: green;">&#41;</span> <span style="color: #06c; font-weight: bold;">where</span> ins = Sub Dict
<span style="color: #06c; font-weight: bold;">instance</span> <span style="color: green;">&#40;</span><span style="color: green;">&#41;</span> :=&gt; <a href="http://haskell.org/ghc/docs/latest/html/libraries/base/Prelude.html#t:Enum"><span style="background-color: #efefbf; font-weight: bold;">Enum</span></a> <a href="http://haskell.org/ghc/docs/latest/html/libraries/base/Prelude.html#t:Bool"><span style="background-color: #efefbf; font-weight: bold;">Bool</span></a> <span style="color: #06c; font-weight: bold;">where</span> ins = Sub Dict
<span style="color: #06c; font-weight: bold;">instance</span> <span style="color: green;">&#40;</span><span style="color: green;">&#41;</span> :=&gt; <a href="http://haskell.org/ghc/docs/latest/html/libraries/base/Prelude.html#t:Enum"><span style="background-color: #efefbf; font-weight: bold;">Enum</span></a> <a href="http://haskell.org/ghc/docs/latest/html/libraries/base/Prelude.html#t:Ordering"><span style="background-color: #efefbf; font-weight: bold;">Ordering</span></a> <span style="color: #06c; font-weight: bold;">where</span> ins = Sub Dict
<span style="color: #06c; font-weight: bold;">instance</span> <span style="color: green;">&#40;</span><span style="color: green;">&#41;</span> :=&gt; <a href="http://haskell.org/ghc/docs/latest/html/libraries/base/Prelude.html#t:Enum"><span style="background-color: #efefbf; font-weight: bold;">Enum</span></a> <a href="http://haskell.org/ghc/docs/latest/html/libraries/base/Prelude.html#t:Char"><span style="background-color: #efefbf; font-weight: bold;">Char</span></a> <span style="color: #06c; font-weight: bold;">where</span> ins = Sub Dict
<span style="color: #06c; font-weight: bold;">instance</span> <span style="color: green;">&#40;</span><span style="color: green;">&#41;</span> :=&gt; <a href="http://haskell.org/ghc/docs/latest/html/libraries/base/Prelude.html#t:Enum"><span style="background-color: #efefbf; font-weight: bold;">Enum</span></a> <a href="http://haskell.org/ghc/docs/latest/html/libraries/base/Prelude.html#t:Int"><span style="background-color: #efefbf; font-weight: bold;">Int</span></a> <span style="color: #06c; font-weight: bold;">where</span> ins = Sub Dict
<span style="color: #06c; font-weight: bold;">instance</span> <span style="color: green;">&#40;</span><span style="color: green;">&#41;</span> :=&gt; <a href="http://haskell.org/ghc/docs/latest/html/libraries/base/Prelude.html#t:Enum"><span style="background-color: #efefbf; font-weight: bold;">Enum</span></a> <a href="http://haskell.org/ghc/docs/latest/html/libraries/base/Prelude.html#t:Integer"><span style="background-color: #efefbf; font-weight: bold;">Integer</span></a> <span style="color: #06c; font-weight: bold;">where</span> ins = Sub Dict
<span style="color: #06c; font-weight: bold;">instance</span> <span style="color: green;">&#40;</span><span style="color: green;">&#41;</span> :=&gt; <a href="http://haskell.org/ghc/docs/latest/html/libraries/base/Prelude.html#t:Enum"><span style="background-color: #efefbf; font-weight: bold;">Enum</span></a> <a href="http://haskell.org/ghc/docs/latest/html/libraries/base/Prelude.html#t:Float"><span style="background-color: #efefbf; font-weight: bold;">Float</span></a> <span style="color: #06c; font-weight: bold;">where</span> ins = Sub Dict
<span style="color: #06c; font-weight: bold;">instance</span> <span style="color: green;">&#40;</span><span style="color: green;">&#41;</span> :=&gt; <a href="http://haskell.org/ghc/docs/latest/html/libraries/base/Prelude.html#t:Enum"><span style="background-color: #efefbf; font-weight: bold;">Enum</span></a> <a href="http://haskell.org/ghc/docs/latest/html/libraries/base/Prelude.html#t:Double"><span style="background-color: #efefbf; font-weight: bold;">Double</span></a> <span style="color: #06c; font-weight: bold;">where</span> ins = Sub Dict
<span style="color: #06c; font-weight: bold;">instance</span> <a href="http://haskell.org/ghc/docs/latest/html/libraries/base/Prelude.html#t:Integral"><span style="background-color: #efefbf; font-weight: bold;">Integral</span></a> a :=&gt; <a href="http://haskell.org/ghc/docs/latest/html/libraries/base/Prelude.html#t:Enum"><span style="background-color: #efefbf; font-weight: bold;">Enum</span></a> <span style="color: green;">&#40;</span>Ratio a<span style="color: green;">&#41;</span> <span style="color: #06c; font-weight: bold;">where</span> ins = Sub Dict
&nbsp;</pre>
<pre class="haskell">&nbsp;
<span style="color: #06c; font-weight: bold;">instance</span> Class <span style="color: green;">&#40;</span><span style="color: green;">&#41;</span> <span style="color: green;">&#40;</span><a href="http://haskell.org/ghc/docs/latest/html/libraries/base/Prelude.html#t:Bounded"><span style="background-color: #efefbf; font-weight: bold;">Bounded</span></a> a<span style="color: green;">&#41;</span> <span style="color: #06c; font-weight: bold;">where</span> cls = Sub Dict
<span style="color: #06c; font-weight: bold;">instance</span> <span style="color: green;">&#40;</span><span style="color: green;">&#41;</span> :=&gt; <a href="http://haskell.org/ghc/docs/latest/html/libraries/base/Prelude.html#t:Bounded"><span style="background-color: #efefbf; font-weight: bold;">Bounded</span></a> <span style="color: green;">&#40;</span><span style="color: green;">&#41;</span> <span style="color: #06c; font-weight: bold;">where</span> ins = Sub Dict
<span style="color: #06c; font-weight: bold;">instance</span> <span style="color: green;">&#40;</span><span style="color: green;">&#41;</span> :=&gt; <a href="http://haskell.org/ghc/docs/latest/html/libraries/base/Prelude.html#t:Bounded"><span style="background-color: #efefbf; font-weight: bold;">Bounded</span></a> <a href="http://haskell.org/ghc/docs/latest/html/libraries/base/Prelude.html#t:Ordering"><span style="background-color: #efefbf; font-weight: bold;">Ordering</span></a> <span style="color: #06c; font-weight: bold;">where</span> ins = Sub Dict
<span style="color: #06c; font-weight: bold;">instance</span> <span style="color: green;">&#40;</span><span style="color: green;">&#41;</span> :=&gt; <a href="http://haskell.org/ghc/docs/latest/html/libraries/base/Prelude.html#t:Bounded"><span style="background-color: #efefbf; font-weight: bold;">Bounded</span></a> <a href="http://haskell.org/ghc/docs/latest/html/libraries/base/Prelude.html#t:Bool"><span style="background-color: #efefbf; font-weight: bold;">Bool</span></a> <span style="color: #06c; font-weight: bold;">where</span> ins = Sub Dict
<span style="color: #06c; font-weight: bold;">instance</span> <span style="color: green;">&#40;</span><span style="color: green;">&#41;</span> :=&gt; <a href="http://haskell.org/ghc/docs/latest/html/libraries/base/Prelude.html#t:Bounded"><span style="background-color: #efefbf; font-weight: bold;">Bounded</span></a> <a href="http://haskell.org/ghc/docs/latest/html/libraries/base/Prelude.html#t:Int"><span style="background-color: #efefbf; font-weight: bold;">Int</span></a> <span style="color: #06c; font-weight: bold;">where</span> ins = Sub Dict
<span style="color: #06c; font-weight: bold;">instance</span> <span style="color: green;">&#40;</span><span style="color: green;">&#41;</span> :=&gt; <a href="http://haskell.org/ghc/docs/latest/html/libraries/base/Prelude.html#t:Bounded"><span style="background-color: #efefbf; font-weight: bold;">Bounded</span></a> <a href="http://haskell.org/ghc/docs/latest/html/libraries/base/Prelude.html#t:Char"><span style="background-color: #efefbf; font-weight: bold;">Char</span></a> <span style="color: #06c; font-weight: bold;">where</span> ins = Sub Dict
<span style="color: #06c; font-weight: bold;">instance</span> <span style="color: green;">&#40;</span><a href="http://haskell.org/ghc/docs/latest/html/libraries/base/Prelude.html#t:Bounded"><span style="background-color: #efefbf; font-weight: bold;">Bounded</span></a> a, <a href="http://haskell.org/ghc/docs/latest/html/libraries/base/Prelude.html#t:Bounded"><span style="background-color: #efefbf; font-weight: bold;">Bounded</span></a> b<span style="color: green;">&#41;</span> :=&gt; <a href="http://haskell.org/ghc/docs/latest/html/libraries/base/Prelude.html#t:Bounded"><span style="background-color: #efefbf; font-weight: bold;">Bounded</span></a> <span style="color: green;">&#40;</span>a,b<span style="color: green;">&#41;</span> <span style="color: #06c; font-weight: bold;">where</span> ins = Sub Dict
&nbsp;</pre>
<pre class="haskell">&nbsp;
<span style="color: #06c; font-weight: bold;">instance</span> Class <span style="color: green;">&#40;</span><span style="color: green;">&#41;</span> <span style="color: green;">&#40;</span><a href="http://haskell.org/ghc/docs/latest/html/libraries/base/Prelude.html#t:Num"><span style="background-color: #efefbf; font-weight: bold;">Num</span></a> a<span style="color: green;">&#41;</span> <span style="color: #06c; font-weight: bold;">where</span> cls = Sub Dict
<span style="color: #06c; font-weight: bold;">instance</span> <span style="color: green;">&#40;</span><span style="color: green;">&#41;</span> :=&gt; <a href="http://haskell.org/ghc/docs/latest/html/libraries/base/Prelude.html#t:Num"><span style="background-color: #efefbf; font-weight: bold;">Num</span></a> <a href="http://haskell.org/ghc/docs/latest/html/libraries/base/Prelude.html#t:Int"><span style="background-color: #efefbf; font-weight: bold;">Int</span></a> <span style="color: #06c; font-weight: bold;">where</span> ins = Sub Dict
<span style="color: #06c; font-weight: bold;">instance</span> <span style="color: green;">&#40;</span><span style="color: green;">&#41;</span> :=&gt; <a href="http://haskell.org/ghc/docs/latest/html/libraries/base/Prelude.html#t:Num"><span style="background-color: #efefbf; font-weight: bold;">Num</span></a> <a href="http://haskell.org/ghc/docs/latest/html/libraries/base/Prelude.html#t:Integer"><span style="background-color: #efefbf; font-weight: bold;">Integer</span></a> <span style="color: #06c; font-weight: bold;">where</span> ins = Sub Dict
<span style="color: #06c; font-weight: bold;">instance</span> <span style="color: green;">&#40;</span><span style="color: green;">&#41;</span> :=&gt; <a href="http://haskell.org/ghc/docs/latest/html/libraries/base/Prelude.html#t:Num"><span style="background-color: #efefbf; font-weight: bold;">Num</span></a> <a href="http://haskell.org/ghc/docs/latest/html/libraries/base/Prelude.html#t:Float"><span style="background-color: #efefbf; font-weight: bold;">Float</span></a> <span style="color: #06c; font-weight: bold;">where</span> ins = Sub Dict
<span style="color: #06c; font-weight: bold;">instance</span> <span style="color: green;">&#40;</span><span style="color: green;">&#41;</span> :=&gt; <a href="http://haskell.org/ghc/docs/latest/html/libraries/base/Prelude.html#t:Num"><span style="background-color: #efefbf; font-weight: bold;">Num</span></a> <a href="http://haskell.org/ghc/docs/latest/html/libraries/base/Prelude.html#t:Double"><span style="background-color: #efefbf; font-weight: bold;">Double</span></a> <span style="color: #06c; font-weight: bold;">where</span> ins = Sub Dict
<span style="color: #06c; font-weight: bold;">instance</span> <a href="http://haskell.org/ghc/docs/latest/html/libraries/base/Prelude.html#t:RealFloat"><span style="background-color: #efefbf; font-weight: bold;">RealFloat</span></a> a :=&gt; <a href="http://haskell.org/ghc/docs/latest/html/libraries/base/Prelude.html#t:Num"><span style="background-color: #efefbf; font-weight: bold;">Num</span></a> <span style="color: green;">&#40;</span>Complex a<span style="color: green;">&#41;</span> <span style="color: #06c; font-weight: bold;">where</span> ins = Sub Dict
<span style="color: #06c; font-weight: bold;">instance</span> <a href="http://haskell.org/ghc/docs/latest/html/libraries/base/Prelude.html#t:Integral"><span style="background-color: #efefbf; font-weight: bold;">Integral</span></a> a :=&gt; <a href="http://haskell.org/ghc/docs/latest/html/libraries/base/Prelude.html#t:Num"><span style="background-color: #efefbf; font-weight: bold;">Num</span></a> <span style="color: green;">&#40;</span>Ratio a<span style="color: green;">&#41;</span> <span style="color: #06c; font-weight: bold;">where</span> ins = Sub Dict
&nbsp;</pre>
<pre class="haskell">&nbsp;
<span style="color: #06c; font-weight: bold;">instance</span> Class <span style="color: green;">&#40;</span><a href="http://haskell.org/ghc/docs/latest/html/libraries/base/Prelude.html#t:Num"><span style="background-color: #efefbf; font-weight: bold;">Num</span></a> a, <a href="http://haskell.org/ghc/docs/latest/html/libraries/base/Prelude.html#t:Ord"><span style="background-color: #efefbf; font-weight: bold;">Ord</span></a> a<span style="color: green;">&#41;</span> <span style="color: green;">&#40;</span><a href="http://haskell.org/ghc/docs/latest/html/libraries/base/Prelude.html#t:Real"><span style="background-color: #efefbf; font-weight: bold;">Real</span></a> a<span style="color: green;">&#41;</span> <span style="color: #06c; font-weight: bold;">where</span> cls = Sub Dict
<span style="color: #06c; font-weight: bold;">instance</span> <span style="color: green;">&#40;</span><span style="color: green;">&#41;</span> :=&gt; <a href="http://haskell.org/ghc/docs/latest/html/libraries/base/Prelude.html#t:Real"><span style="background-color: #efefbf; font-weight: bold;">Real</span></a> <a href="http://haskell.org/ghc/docs/latest/html/libraries/base/Prelude.html#t:Int"><span style="background-color: #efefbf; font-weight: bold;">Int</span></a> <span style="color: #06c; font-weight: bold;">where</span> ins = Sub Dict
<span style="color: #06c; font-weight: bold;">instance</span> <span style="color: green;">&#40;</span><span style="color: green;">&#41;</span> :=&gt; <a href="http://haskell.org/ghc/docs/latest/html/libraries/base/Prelude.html#t:Real"><span style="background-color: #efefbf; font-weight: bold;">Real</span></a> <a href="http://haskell.org/ghc/docs/latest/html/libraries/base/Prelude.html#t:Integer"><span style="background-color: #efefbf; font-weight: bold;">Integer</span></a> <span style="color: #06c; font-weight: bold;">where</span> ins = Sub Dict
<span style="color: #06c; font-weight: bold;">instance</span> <span style="color: green;">&#40;</span><span style="color: green;">&#41;</span> :=&gt; <a href="http://haskell.org/ghc/docs/latest/html/libraries/base/Prelude.html#t:Real"><span style="background-color: #efefbf; font-weight: bold;">Real</span></a> <a href="http://haskell.org/ghc/docs/latest/html/libraries/base/Prelude.html#t:Float"><span style="background-color: #efefbf; font-weight: bold;">Float</span></a> <span style="color: #06c; font-weight: bold;">where</span> ins = Sub Dict
<span style="color: #06c; font-weight: bold;">instance</span> <span style="color: green;">&#40;</span><span style="color: green;">&#41;</span> :=&gt; <a href="http://haskell.org/ghc/docs/latest/html/libraries/base/Prelude.html#t:Real"><span style="background-color: #efefbf; font-weight: bold;">Real</span></a> <a href="http://haskell.org/ghc/docs/latest/html/libraries/base/Prelude.html#t:Double"><span style="background-color: #efefbf; font-weight: bold;">Double</span></a> <span style="color: #06c; font-weight: bold;">where</span> ins = Sub Dict
<span style="color: #06c; font-weight: bold;">instance</span> <a href="http://haskell.org/ghc/docs/latest/html/libraries/base/Prelude.html#t:Integral"><span style="background-color: #efefbf; font-weight: bold;">Integral</span></a> a :=&gt; <a href="http://haskell.org/ghc/docs/latest/html/libraries/base/Prelude.html#t:Real"><span style="background-color: #efefbf; font-weight: bold;">Real</span></a> <span style="color: green;">&#40;</span>Ratio a<span style="color: green;">&#41;</span> <span style="color: #06c; font-weight: bold;">where</span> ins = Sub Dict
&nbsp;</pre>
<pre class="haskell">&nbsp;
<span style="color: #06c; font-weight: bold;">instance</span> Class <span style="color: green;">&#40;</span><a href="http://haskell.org/ghc/docs/latest/html/libraries/base/Prelude.html#t:Real"><span style="background-color: #efefbf; font-weight: bold;">Real</span></a> a, <a href="http://haskell.org/ghc/docs/latest/html/libraries/base/Prelude.html#t:Enum"><span style="background-color: #efefbf; font-weight: bold;">Enum</span></a> a<span style="color: green;">&#41;</span> <span style="color: green;">&#40;</span><a href="http://haskell.org/ghc/docs/latest/html/libraries/base/Prelude.html#t:Integral"><span style="background-color: #efefbf; font-weight: bold;">Integral</span></a> a<span style="color: green;">&#41;</span> <span style="color: #06c; font-weight: bold;">where</span> cls = Sub Dict
<span style="color: #06c; font-weight: bold;">instance</span> <span style="color: green;">&#40;</span><span style="color: green;">&#41;</span> :=&gt; <a href="http://haskell.org/ghc/docs/latest/html/libraries/base/Prelude.html#t:Integral"><span style="background-color: #efefbf; font-weight: bold;">Integral</span></a> <a href="http://haskell.org/ghc/docs/latest/html/libraries/base/Prelude.html#t:Int"><span style="background-color: #efefbf; font-weight: bold;">Int</span></a> <span style="color: #06c; font-weight: bold;">where</span> ins = Sub Dict
<span style="color: #06c; font-weight: bold;">instance</span> <span style="color: green;">&#40;</span><span style="color: green;">&#41;</span> :=&gt; <a href="http://haskell.org/ghc/docs/latest/html/libraries/base/Prelude.html#t:Integral"><span style="background-color: #efefbf; font-weight: bold;">Integral</span></a> <a href="http://haskell.org/ghc/docs/latest/html/libraries/base/Prelude.html#t:Integer"><span style="background-color: #efefbf; font-weight: bold;">Integer</span></a> <span style="color: #06c; font-weight: bold;">where</span> ins = Sub Dict
&nbsp;</pre>
<pre class="haskell">&nbsp;
<span style="color: #06c; font-weight: bold;">instance</span> Class <span style="color: green;">&#40;</span><a href="http://haskell.org/ghc/docs/latest/html/libraries/base/Prelude.html#t:Num"><span style="background-color: #efefbf; font-weight: bold;">Num</span></a> a<span style="color: green;">&#41;</span> <span style="color: green;">&#40;</span><a href="http://haskell.org/ghc/docs/latest/html/libraries/base/Prelude.html#t:Fractional"><span style="background-color: #efefbf; font-weight: bold;">Fractional</span></a> a<span style="color: green;">&#41;</span> <span style="color: #06c; font-weight: bold;">where</span> cls = Sub Dict
<span style="color: #06c; font-weight: bold;">instance</span> <span style="color: green;">&#40;</span><span style="color: green;">&#41;</span> :=&gt; <a href="http://haskell.org/ghc/docs/latest/html/libraries/base/Prelude.html#t:Fractional"><span style="background-color: #efefbf; font-weight: bold;">Fractional</span></a> <a href="http://haskell.org/ghc/docs/latest/html/libraries/base/Prelude.html#t:Float"><span style="background-color: #efefbf; font-weight: bold;">Float</span></a> <span style="color: #06c; font-weight: bold;">where</span> ins = Sub Dict
<span style="color: #06c; font-weight: bold;">instance</span> <span style="color: green;">&#40;</span><span style="color: green;">&#41;</span> :=&gt; <a href="http://haskell.org/ghc/docs/latest/html/libraries/base/Prelude.html#t:Fractional"><span style="background-color: #efefbf; font-weight: bold;">Fractional</span></a> <a href="http://haskell.org/ghc/docs/latest/html/libraries/base/Prelude.html#t:Double"><span style="background-color: #efefbf; font-weight: bold;">Double</span></a> <span style="color: #06c; font-weight: bold;">where</span> ins = Sub Dict
<span style="color: #06c; font-weight: bold;">instance</span> <a href="http://haskell.org/ghc/docs/latest/html/libraries/base/Prelude.html#t:RealFloat"><span style="background-color: #efefbf; font-weight: bold;">RealFloat</span></a> a :=&gt; <a href="http://haskell.org/ghc/docs/latest/html/libraries/base/Prelude.html#t:Fractional"><span style="background-color: #efefbf; font-weight: bold;">Fractional</span></a> <span style="color: green;">&#40;</span>Complex a<span style="color: green;">&#41;</span> <span style="color: #06c; font-weight: bold;">where</span> ins = Sub Dict
<span style="color: #06c; font-weight: bold;">instance</span> <a href="http://haskell.org/ghc/docs/latest/html/libraries/base/Prelude.html#t:Integral"><span style="background-color: #efefbf; font-weight: bold;">Integral</span></a> a :=&gt; <a href="http://haskell.org/ghc/docs/latest/html/libraries/base/Prelude.html#t:Fractional"><span style="background-color: #efefbf; font-weight: bold;">Fractional</span></a> <span style="color: green;">&#40;</span>Ratio a<span style="color: green;">&#41;</span> <span style="color: #06c; font-weight: bold;">where</span> ins = Sub Dict
&nbsp;</pre>
<pre class="haskell">&nbsp;
<span style="color: #06c; font-weight: bold;">instance</span> Class <span style="color: green;">&#40;</span><a href="http://haskell.org/ghc/docs/latest/html/libraries/base/Prelude.html#t:Fractional"><span style="background-color: #efefbf; font-weight: bold;">Fractional</span></a> a<span style="color: green;">&#41;</span> <span style="color: green;">&#40;</span><a href="http://haskell.org/ghc/docs/latest/html/libraries/base/Prelude.html#t:Floating"><span style="background-color: #efefbf; font-weight: bold;">Floating</span></a> a<span style="color: green;">&#41;</span> <span style="color: #06c; font-weight: bold;">where</span> cls = Sub Dict
<span style="color: #06c; font-weight: bold;">instance</span> <span style="color: green;">&#40;</span><span style="color: green;">&#41;</span> :=&gt; <a href="http://haskell.org/ghc/docs/latest/html/libraries/base/Prelude.html#t:Floating"><span style="background-color: #efefbf; font-weight: bold;">Floating</span></a> <a href="http://haskell.org/ghc/docs/latest/html/libraries/base/Prelude.html#t:Float"><span style="background-color: #efefbf; font-weight: bold;">Float</span></a> <span style="color: #06c; font-weight: bold;">where</span> ins = Sub Dict
<span style="color: #06c; font-weight: bold;">instance</span> <span style="color: green;">&#40;</span><span style="color: green;">&#41;</span> :=&gt; <a href="http://haskell.org/ghc/docs/latest/html/libraries/base/Prelude.html#t:Floating"><span style="background-color: #efefbf; font-weight: bold;">Floating</span></a> <a href="http://haskell.org/ghc/docs/latest/html/libraries/base/Prelude.html#t:Double"><span style="background-color: #efefbf; font-weight: bold;">Double</span></a> <span style="color: #06c; font-weight: bold;">where</span> ins = Sub Dict
<span style="color: #06c; font-weight: bold;">instance</span> <a href="http://haskell.org/ghc/docs/latest/html/libraries/base/Prelude.html#t:RealFloat"><span style="background-color: #efefbf; font-weight: bold;">RealFloat</span></a> a :=&gt; <a href="http://haskell.org/ghc/docs/latest/html/libraries/base/Prelude.html#t:Floating"><span style="background-color: #efefbf; font-weight: bold;">Floating</span></a> <span style="color: green;">&#40;</span>Complex a<span style="color: green;">&#41;</span> <span style="color: #06c; font-weight: bold;">where</span> ins = Sub Dict
&nbsp;</pre>
<pre class="haskell">&nbsp;
<span style="color: #06c; font-weight: bold;">instance</span> Class <span style="color: green;">&#40;</span><a href="http://haskell.org/ghc/docs/latest/html/libraries/base/Prelude.html#t:Real"><span style="background-color: #efefbf; font-weight: bold;">Real</span></a> a, <a href="http://haskell.org/ghc/docs/latest/html/libraries/base/Prelude.html#t:Fractional"><span style="background-color: #efefbf; font-weight: bold;">Fractional</span></a> a<span style="color: green;">&#41;</span> <span style="color: green;">&#40;</span><a href="http://haskell.org/ghc/docs/latest/html/libraries/base/Prelude.html#t:RealFrac"><span style="background-color: #efefbf; font-weight: bold;">RealFrac</span></a> a<span style="color: green;">&#41;</span> <span style="color: #06c; font-weight: bold;">where</span> cls = Sub Dict
<span style="color: #06c; font-weight: bold;">instance</span> <span style="color: green;">&#40;</span><span style="color: green;">&#41;</span> :=&gt; <a href="http://haskell.org/ghc/docs/latest/html/libraries/base/Prelude.html#t:RealFrac"><span style="background-color: #efefbf; font-weight: bold;">RealFrac</span></a> <a href="http://haskell.org/ghc/docs/latest/html/libraries/base/Prelude.html#t:Float"><span style="background-color: #efefbf; font-weight: bold;">Float</span></a> <span style="color: #06c; font-weight: bold;">where</span> ins = Sub Dict
<span style="color: #06c; font-weight: bold;">instance</span> <span style="color: green;">&#40;</span><span style="color: green;">&#41;</span> :=&gt; <a href="http://haskell.org/ghc/docs/latest/html/libraries/base/Prelude.html#t:RealFrac"><span style="background-color: #efefbf; font-weight: bold;">RealFrac</span></a> <a href="http://haskell.org/ghc/docs/latest/html/libraries/base/Prelude.html#t:Double"><span style="background-color: #efefbf; font-weight: bold;">Double</span></a> <span style="color: #06c; font-weight: bold;">where</span> ins = Sub Dict
<span style="color: #06c; font-weight: bold;">instance</span> <a href="http://haskell.org/ghc/docs/latest/html/libraries/base/Prelude.html#t:Integral"><span style="background-color: #efefbf; font-weight: bold;">Integral</span></a> a :=&gt; <a href="http://haskell.org/ghc/docs/latest/html/libraries/base/Prelude.html#t:RealFrac"><span style="background-color: #efefbf; font-weight: bold;">RealFrac</span></a> <span style="color: green;">&#40;</span>Ratio a<span style="color: green;">&#41;</span> <span style="color: #06c; font-weight: bold;">where</span> ins = Sub Dict
&nbsp;</pre>
<pre class="haskell">&nbsp;
<span style="color: #06c; font-weight: bold;">instance</span> Class <span style="color: green;">&#40;</span><a href="http://haskell.org/ghc/docs/latest/html/libraries/base/Prelude.html#t:RealFrac"><span style="background-color: #efefbf; font-weight: bold;">RealFrac</span></a> a, <a href="http://haskell.org/ghc/docs/latest/html/libraries/base/Prelude.html#t:Floating"><span style="background-color: #efefbf; font-weight: bold;">Floating</span></a> a<span style="color: green;">&#41;</span> <span style="color: green;">&#40;</span><a href="http://haskell.org/ghc/docs/latest/html/libraries/base/Prelude.html#t:RealFloat"><span style="background-color: #efefbf; font-weight: bold;">RealFloat</span></a> a<span style="color: green;">&#41;</span> <span style="color: #06c; font-weight: bold;">where</span> cls = Sub Dict
<span style="color: #06c; font-weight: bold;">instance</span> <span style="color: green;">&#40;</span><span style="color: green;">&#41;</span> :=&gt; <a href="http://haskell.org/ghc/docs/latest/html/libraries/base/Prelude.html#t:RealFloat"><span style="background-color: #efefbf; font-weight: bold;">RealFloat</span></a> <a href="http://haskell.org/ghc/docs/latest/html/libraries/base/Prelude.html#t:Float"><span style="background-color: #efefbf; font-weight: bold;">Float</span></a> <span style="color: #06c; font-weight: bold;">where</span> ins = Sub Dict
<span style="color: #06c; font-weight: bold;">instance</span> <span style="color: green;">&#40;</span><span style="color: green;">&#41;</span> :=&gt; <a href="http://haskell.org/ghc/docs/latest/html/libraries/base/Prelude.html#t:RealFloat"><span style="background-color: #efefbf; font-weight: bold;">RealFloat</span></a> <a href="http://haskell.org/ghc/docs/latest/html/libraries/base/Prelude.html#t:Double"><span style="background-color: #efefbf; font-weight: bold;">Double</span></a> <span style="color: #06c; font-weight: bold;">where</span> ins = Sub Dict
&nbsp;</pre>
<pre class="haskell">&nbsp;
<span style="color: #06c; font-weight: bold;">instance</span> Class <span style="color: green;">&#40;</span><span style="color: green;">&#41;</span> <span style="color: green;">&#40;</span>Monoid a<span style="color: green;">&#41;</span> <span style="color: #06c; font-weight: bold;">where</span> cls = Sub Dict
<span style="color: #06c; font-weight: bold;">instance</span> <span style="color: green;">&#40;</span><span style="color: green;">&#41;</span> :=&gt; Monoid <span style="color: green;">&#40;</span><span style="color: green;">&#41;</span> <span style="color: #06c; font-weight: bold;">where</span> ins = Sub Dict
<span style="color: #06c; font-weight: bold;">instance</span> <span style="color: green;">&#40;</span><span style="color: green;">&#41;</span> :=&gt; Monoid <a href="http://haskell.org/ghc/docs/latest/html/libraries/base/Prelude.html#t:Ordering"><span style="background-color: #efefbf; font-weight: bold;">Ordering</span></a> <span style="color: #06c; font-weight: bold;">where</span> ins = Sub Dict
<span style="color: #06c; font-weight: bold;">instance</span> <span style="color: green;">&#40;</span><span style="color: green;">&#41;</span> :=&gt; Monoid <span style="color: green;">&#91;</span>a<span style="color: green;">&#93;</span> <span style="color: #06c; font-weight: bold;">where</span> ins = Sub Dict
<span style="color: #06c; font-weight: bold;">instance</span> Monoid a :=&gt; Monoid <span style="color: green;">&#40;</span><a href="http://haskell.org/ghc/docs/latest/html/libraries/base/Prelude.html#t:Maybe"><span style="background-color: #efefbf; font-weight: bold;">Maybe</span></a> a<span style="color: green;">&#41;</span> <span style="color: #06c; font-weight: bold;">where</span> ins = Sub Dict
<span style="color: #06c; font-weight: bold;">instance</span> <span style="color: green;">&#40;</span>Monoid a, Monoid b<span style="color: green;">&#41;</span> :=&gt; Monoid <span style="color: green;">&#40;</span>a, b<span style="color: green;">&#41;</span> <span style="color: #06c; font-weight: bold;">where</span> ins = Sub Dict
&nbsp;</pre>
<pre class="haskell">&nbsp;
<span style="color: #06c; font-weight: bold;">instance</span> Class <span style="color: green;">&#40;</span><span style="color: green;">&#41;</span> <span style="color: green;">&#40;</span><a href="http://haskell.org/ghc/docs/latest/html/libraries/base/Prelude.html#t:Functor"><span style="background-color: #efefbf; font-weight: bold;">Functor</span></a> f<span style="color: green;">&#41;</span> <span style="color: #06c; font-weight: bold;">where</span> cls = Sub Dict
<span style="color: #06c; font-weight: bold;">instance</span> <span style="color: green;">&#40;</span><span style="color: green;">&#41;</span> :=&gt; <a href="http://haskell.org/ghc/docs/latest/html/libraries/base/Prelude.html#t:Functor"><span style="background-color: #efefbf; font-weight: bold;">Functor</span></a> <span style="color: green;">&#91;</span><span style="color: green;">&#93;</span> <span style="color: #06c; font-weight: bold;">where</span> ins = Sub Dict
<span style="color: #06c; font-weight: bold;">instance</span> <span style="color: green;">&#40;</span><span style="color: green;">&#41;</span> :=&gt; <a href="http://haskell.org/ghc/docs/latest/html/libraries/base/Prelude.html#t:Functor"><span style="background-color: #efefbf; font-weight: bold;">Functor</span></a> <a href="http://haskell.org/ghc/docs/latest/html/libraries/base/Prelude.html#t:Maybe"><span style="background-color: #efefbf; font-weight: bold;">Maybe</span></a> <span style="color: #06c; font-weight: bold;">where</span> ins = Sub Dict
<span style="color: #06c; font-weight: bold;">instance</span> <span style="color: green;">&#40;</span><span style="color: green;">&#41;</span> :=&gt; <a href="http://haskell.org/ghc/docs/latest/html/libraries/base/Prelude.html#t:Functor"><span style="background-color: #efefbf; font-weight: bold;">Functor</span></a> <span style="color: green;">&#40;</span><a href="http://haskell.org/ghc/docs/latest/html/libraries/base/Prelude.html#t:Either"><span style="background-color: #efefbf; font-weight: bold;">Either</span></a> a<span style="color: green;">&#41;</span> <span style="color: #06c; font-weight: bold;">where</span> ins = Sub Dict
<span style="color: #06c; font-weight: bold;">instance</span> <span style="color: green;">&#40;</span><span style="color: green;">&#41;</span> :=&gt; <a href="http://haskell.org/ghc/docs/latest/html/libraries/base/Prelude.html#t:Functor"><span style="background-color: #efefbf; font-weight: bold;">Functor</span></a> <span style="color: green;">&#40;</span><span style="color: green;">&#40;</span>-&gt;<span style="color: green;">&#41;</span> a<span style="color: green;">&#41;</span> <span style="color: #06c; font-weight: bold;">where</span> ins = Sub Dict
<span style="color: #06c; font-weight: bold;">instance</span> <span style="color: green;">&#40;</span><span style="color: green;">&#41;</span> :=&gt; <a href="http://haskell.org/ghc/docs/latest/html/libraries/base/Prelude.html#t:Functor"><span style="background-color: #efefbf; font-weight: bold;">Functor</span></a> <span style="color: green;">&#40;</span><span style="color: green;">&#40;</span>,<span style="color: green;">&#41;</span> a<span style="color: green;">&#41;</span> <span style="color: #06c; font-weight: bold;">where</span> ins = Sub Dict
<span style="color: #06c; font-weight: bold;">instance</span> <span style="color: green;">&#40;</span><span style="color: green;">&#41;</span> :=&gt; <a href="http://haskell.org/ghc/docs/latest/html/libraries/base/Prelude.html#t:Functor"><span style="background-color: #efefbf; font-weight: bold;">Functor</span></a> <a href="http://haskell.org/ghc/docs/latest/html/libraries/base/Prelude.html#t:IO"><span style="background-color: #efefbf; font-weight: bold;">IO</span></a> <span style="color: #06c; font-weight: bold;">where</span> ins = Sub Dict
&nbsp;</pre>
<pre class="haskell">&nbsp;
<span style="color: #06c; font-weight: bold;">instance</span> Class <span style="color: green;">&#40;</span><a href="http://haskell.org/ghc/docs/latest/html/libraries/base/Prelude.html#t:Functor"><span style="background-color: #efefbf; font-weight: bold;">Functor</span></a> f<span style="color: green;">&#41;</span> <span style="color: green;">&#40;</span>Applicative f<span style="color: green;">&#41;</span> <span style="color: #06c; font-weight: bold;">where</span> cls = Sub Dict
<span style="color: #06c; font-weight: bold;">instance</span> <span style="color: green;">&#40;</span><span style="color: green;">&#41;</span> :=&gt; Applicative <span style="color: green;">&#91;</span><span style="color: green;">&#93;</span> <span style="color: #06c; font-weight: bold;">where</span> ins = Sub Dict
<span style="color: #06c; font-weight: bold;">instance</span> <span style="color: green;">&#40;</span><span style="color: green;">&#41;</span> :=&gt; Applicative <a href="http://haskell.org/ghc/docs/latest/html/libraries/base/Prelude.html#t:Maybe"><span style="background-color: #efefbf; font-weight: bold;">Maybe</span></a> <span style="color: #06c; font-weight: bold;">where</span> ins = Sub Dict
<span style="color: #06c; font-weight: bold;">instance</span> <span style="color: green;">&#40;</span><span style="color: green;">&#41;</span> :=&gt; Applicative <span style="color: green;">&#40;</span><a href="http://haskell.org/ghc/docs/latest/html/libraries/base/Prelude.html#t:Either"><span style="background-color: #efefbf; font-weight: bold;">Either</span></a> a<span style="color: green;">&#41;</span> <span style="color: #06c; font-weight: bold;">where</span> ins = Sub Dict
<span style="color: #06c; font-weight: bold;">instance</span> <span style="color: green;">&#40;</span><span style="color: green;">&#41;</span> :=&gt; Applicative <span style="color: green;">&#40;</span><span style="color: green;">&#40;</span>-&gt;<span style="color: green;">&#41;</span>a<span style="color: green;">&#41;</span> <span style="color: #06c; font-weight: bold;">where</span> ins = Sub Dict
<span style="color: #06c; font-weight: bold;">instance</span> <span style="color: green;">&#40;</span><span style="color: green;">&#41;</span> :=&gt; Applicative <a href="http://haskell.org/ghc/docs/latest/html/libraries/base/Prelude.html#t:IO"><span style="background-color: #efefbf; font-weight: bold;">IO</span></a> <span style="color: #06c; font-weight: bold;">where</span> ins = Sub Dict
<span style="color: #06c; font-weight: bold;">instance</span> Monoid a :=&gt; Applicative <span style="color: green;">&#40;</span><span style="color: green;">&#40;</span>,<span style="color: green;">&#41;</span>a<span style="color: green;">&#41;</span> <span style="color: #06c; font-weight: bold;">where</span> ins = Sub Dict
&nbsp;</pre>
<pre class="haskell">&nbsp;
<span style="color: #06c; font-weight: bold;">instance</span> Class <span style="color: green;">&#40;</span>Applicative f<span style="color: green;">&#41;</span> <span style="color: green;">&#40;</span>Alternative f<span style="color: green;">&#41;</span> <span style="color: #06c; font-weight: bold;">where</span> cls = Sub Dict
<span style="color: #06c; font-weight: bold;">instance</span> <span style="color: green;">&#40;</span><span style="color: green;">&#41;</span> :=&gt; Alternative <span style="color: green;">&#91;</span><span style="color: green;">&#93;</span> <span style="color: #06c; font-weight: bold;">where</span> ins = Sub Dict
<span style="color: #06c; font-weight: bold;">instance</span> <span style="color: green;">&#40;</span><span style="color: green;">&#41;</span> :=&gt; Alternative <a href="http://haskell.org/ghc/docs/latest/html/libraries/base/Prelude.html#t:Maybe"><span style="background-color: #efefbf; font-weight: bold;">Maybe</span></a> <span style="color: #06c; font-weight: bold;">where</span> ins = Sub Dict
&nbsp;</pre>
<pre class="haskell">&nbsp;
<span style="color: #06c; font-weight: bold;">instance</span> Class <span style="color: green;">&#40;</span><span style="color: green;">&#41;</span> <span style="color: green;">&#40;</span><a href="http://haskell.org/ghc/docs/latest/html/libraries/base/Prelude.html#t:Monad"><span style="background-color: #efefbf; font-weight: bold;">Monad</span></a> f<span style="color: green;">&#41;</span> <span style="color: #06c; font-weight: bold;">where</span> cls = Sub Dict
<span style="color: #06c; font-weight: bold;">instance</span> <span style="color: green;">&#40;</span><span style="color: green;">&#41;</span> :=&gt; <a href="http://haskell.org/ghc/docs/latest/html/libraries/base/Prelude.html#t:Monad"><span style="background-color: #efefbf; font-weight: bold;">Monad</span></a> <span style="color: green;">&#91;</span><span style="color: green;">&#93;</span> <span style="color: #06c; font-weight: bold;">where</span> ins = Sub Dict
<span style="color: #06c; font-weight: bold;">instance</span> <span style="color: green;">&#40;</span><span style="color: green;">&#41;</span> :=&gt; <a href="http://haskell.org/ghc/docs/latest/html/libraries/base/Prelude.html#t:Monad"><span style="background-color: #efefbf; font-weight: bold;">Monad</span></a> <span style="color: green;">&#40;</span><span style="color: green;">&#40;</span>-&gt;<span style="color: green;">&#41;</span> a<span style="color: green;">&#41;</span> <span style="color: #06c; font-weight: bold;">where</span> ins = Sub Dict
<span style="color: #06c; font-weight: bold;">instance</span> <span style="color: green;">&#40;</span><span style="color: green;">&#41;</span> :=&gt; <a href="http://haskell.org/ghc/docs/latest/html/libraries/base/Prelude.html#t:Monad"><span style="background-color: #efefbf; font-weight: bold;">Monad</span></a> <span style="color: green;">&#40;</span><a href="http://haskell.org/ghc/docs/latest/html/libraries/base/Prelude.html#t:Either"><span style="background-color: #efefbf; font-weight: bold;">Either</span></a> a<span style="color: green;">&#41;</span> <span style="color: #06c; font-weight: bold;">where</span> ins = Sub Dict
<span style="color: #06c; font-weight: bold;">instance</span> <span style="color: green;">&#40;</span><span style="color: green;">&#41;</span> :=&gt; <a href="http://haskell.org/ghc/docs/latest/html/libraries/base/Prelude.html#t:Monad"><span style="background-color: #efefbf; font-weight: bold;">Monad</span></a> <a href="http://haskell.org/ghc/docs/latest/html/libraries/base/Prelude.html#t:IO"><span style="background-color: #efefbf; font-weight: bold;">IO</span></a> <span style="color: #06c; font-weight: bold;">where</span> ins = Sub Dict
&nbsp;</pre>
<pre class="haskell">&nbsp;
<span style="color: #06c; font-weight: bold;">instance</span> Class <span style="color: green;">&#40;</span><a href="http://haskell.org/ghc/docs/latest/html/libraries/base/Prelude.html#t:Monad"><span style="background-color: #efefbf; font-weight: bold;">Monad</span></a> f<span style="color: green;">&#41;</span> <span style="color: green;">&#40;</span>MonadPlus f<span style="color: green;">&#41;</span> <span style="color: #06c; font-weight: bold;">where</span> cls = Sub Dict
<span style="color: #06c; font-weight: bold;">instance</span> <span style="color: green;">&#40;</span><span style="color: green;">&#41;</span> :=&gt; MonadPlus <span style="color: green;">&#91;</span><span style="color: green;">&#93;</span> <span style="color: #06c; font-weight: bold;">where</span> ins = Sub Dict
<span style="color: #06c; font-weight: bold;">instance</span> <span style="color: green;">&#40;</span><span style="color: green;">&#41;</span> :=&gt; MonadPlus <a href="http://haskell.org/ghc/docs/latest/html/libraries/base/Prelude.html#t:Maybe"><span style="background-color: #efefbf; font-weight: bold;">Maybe</span></a> <span style="color: #06c; font-weight: bold;">where</span> ins = Sub Dict
&nbsp;</pre>
<p>Of course, the structure of these definitions is extremely formulaic, so when template-haskell builds against HEAD again, they should be able to be generated automatically using splicing and reify, which would reduce this from a wall of text to a handful of lines with better coverage!</p>
<h2>An alternative using Default Signatures and Type Families</h2>
<p>Many of the above definitions could have been streamlined by using default definitions. However, MPTCs do not currently support default signatures. We can however, define Class and (:=>) using type families rather than functional dependencies. This enables us to use defaulting, whenever the superclass or context was ().</p>
<pre class="haskell">&nbsp;
#if <span style="color: red;">0</span>
<span style="color: #06c; font-weight: bold;">class</span> Class h <span style="color: #06c; font-weight: bold;">where</span>
  <span style="color: #06c; font-weight: bold;">type</span> Sup h :: Constraint
  <span style="color: #06c; font-weight: bold;">type</span> Sup h = <span style="color: green;">&#40;</span><span style="color: green;">&#41;</span>
  cls :: h :- Sup h
  <span style="color: #06c; font-weight: bold;">default</span> cls :: h :- <span style="color: green;">&#40;</span><span style="color: green;">&#41;</span>
  cls = Sub Dict
&nbsp;
<span style="color: #06c; font-weight: bold;">class</span> Instance h <span style="color: #06c; font-weight: bold;">where</span>
  <span style="color: #06c; font-weight: bold;">type</span> Ctx h :: Constraint
  <span style="color: #06c; font-weight: bold;">type</span> Ctx h = <span style="color: green;">&#40;</span><span style="color: green;">&#41;</span>
  ins :: Ctx h :- h
  <span style="color: #06c; font-weight: bold;">default</span> ins :: h =&gt; Ctx h :- h
  ins = Sub Dict
&nbsp;
<span style="color: #06c; font-weight: bold;">instance</span> Class <span style="color: green;">&#40;</span>Class a<span style="color: green;">&#41;</span>
<span style="color: #06c; font-weight: bold;">instance</span> Class <span style="color: green;">&#40;</span>Instance a<span style="color: green;">&#41;</span>
&nbsp;
#ifdef UNDECIDABLE
<span style="color: #06c; font-weight: bold;">instance</span> Class a =&gt; Instance <span style="color: green;">&#40;</span>Class a<span style="color: green;">&#41;</span>
<span style="color: #06c; font-weight: bold;">instance</span> Instance a =&gt; Instance <span style="color: green;">&#40;</span>Instance a<span style="color: green;">&#41;</span>
#endif
&nbsp;
<span style="color: #06c; font-weight: bold;">instance</span> Class <span style="color: green;">&#40;</span><span style="color: green;">&#41;</span>
<span style="color: #06c; font-weight: bold;">instance</span> Instance <span style="color: green;">&#40;</span><span style="color: green;">&#41;</span>
#endif
&nbsp;</pre>
<p>This seems at first to be a promising approach. Many instances are quite small:</p>
<pre class="haskell">&nbsp;
#if <span style="color: red;">0</span>
<span style="color: #06c; font-weight: bold;">instance</span> Class <span style="color: green;">&#40;</span><a href="http://haskell.org/ghc/docs/latest/html/libraries/base/Prelude.html#t:Eq"><span style="background-color: #efefbf; font-weight: bold;">Eq</span></a> a<span style="color: green;">&#41;</span>
<span style="color: #06c; font-weight: bold;">instance</span> Instance <span style="color: green;">&#40;</span><a href="http://haskell.org/ghc/docs/latest/html/libraries/base/Prelude.html#t:Eq"><span style="background-color: #efefbf; font-weight: bold;">Eq</span></a> <span style="color: green;">&#40;</span><span style="color: green;">&#41;</span><span style="color: green;">&#41;</span>
<span style="color: #06c; font-weight: bold;">instance</span> Instance <span style="color: green;">&#40;</span><a href="http://haskell.org/ghc/docs/latest/html/libraries/base/Prelude.html#t:Eq"><span style="background-color: #efefbf; font-weight: bold;">Eq</span></a> <a href="http://haskell.org/ghc/docs/latest/html/libraries/base/Prelude.html#t:Int"><span style="background-color: #efefbf; font-weight: bold;">Int</span></a><span style="color: green;">&#41;</span>
<span style="color: #06c; font-weight: bold;">instance</span> Instance <span style="color: green;">&#40;</span><a href="http://haskell.org/ghc/docs/latest/html/libraries/base/Prelude.html#t:Eq"><span style="background-color: #efefbf; font-weight: bold;">Eq</span></a> <a href="http://haskell.org/ghc/docs/latest/html/libraries/base/Prelude.html#t:Bool"><span style="background-color: #efefbf; font-weight: bold;">Bool</span></a><span style="color: green;">&#41;</span>
<span style="color: #06c; font-weight: bold;">instance</span> Instance <span style="color: green;">&#40;</span><a href="http://haskell.org/ghc/docs/latest/html/libraries/base/Prelude.html#t:Eq"><span style="background-color: #efefbf; font-weight: bold;">Eq</span></a> <a href="http://haskell.org/ghc/docs/latest/html/libraries/base/Prelude.html#t:Integer"><span style="background-color: #efefbf; font-weight: bold;">Integer</span></a><span style="color: green;">&#41;</span>
<span style="color: #06c; font-weight: bold;">instance</span> Instance <span style="color: green;">&#40;</span><a href="http://haskell.org/ghc/docs/latest/html/libraries/base/Prelude.html#t:Eq"><span style="background-color: #efefbf; font-weight: bold;">Eq</span></a> <a href="http://haskell.org/ghc/docs/latest/html/libraries/base/Prelude.html#t:Float"><span style="background-color: #efefbf; font-weight: bold;">Float</span></a><span style="color: green;">&#41;</span>
<span style="color: #06c; font-weight: bold;">instance</span> Instance <span style="color: green;">&#40;</span><a href="http://haskell.org/ghc/docs/latest/html/libraries/base/Prelude.html#t:Eq"><span style="background-color: #efefbf; font-weight: bold;">Eq</span></a> <a href="http://haskell.org/ghc/docs/latest/html/libraries/base/Prelude.html#t:Double"><span style="background-color: #efefbf; font-weight: bold;">Double</span></a><span style="color: green;">&#41;</span>
#endif
&nbsp;</pre>
<p>But those that aren't are considerably more verbose and are much harder to read off than the definitions using the MPTC based Class and (:=>).</p>
<pre class="haskell">&nbsp;
#if <span style="color: red;">0</span>
<span style="color: #06c; font-weight: bold;">instance</span> Instance <span style="color: green;">&#40;</span><a href="http://haskell.org/ghc/docs/latest/html/libraries/base/Prelude.html#t:Eq"><span style="background-color: #efefbf; font-weight: bold;">Eq</span></a> <span style="color: green;">&#91;</span>a<span style="color: green;">&#93;</span><span style="color: green;">&#41;</span> <span style="color: #06c; font-weight: bold;">where</span>
  <span style="color: #06c; font-weight: bold;">type</span> Ctx <span style="color: green;">&#40;</span><a href="http://haskell.org/ghc/docs/latest/html/libraries/base/Prelude.html#t:Eq"><span style="background-color: #efefbf; font-weight: bold;">Eq</span></a> <span style="color: green;">&#91;</span>a<span style="color: green;">&#93;</span><span style="color: green;">&#41;</span> = <a href="http://haskell.org/ghc/docs/latest/html/libraries/base/Prelude.html#t:Eq"><span style="background-color: #efefbf; font-weight: bold;">Eq</span></a> a
  ins = Sub Dict
<span style="color: #06c; font-weight: bold;">instance</span> Instance <span style="color: green;">&#40;</span><a href="http://haskell.org/ghc/docs/latest/html/libraries/base/Prelude.html#t:Eq"><span style="background-color: #efefbf; font-weight: bold;">Eq</span></a> <span style="color: green;">&#40;</span><a href="http://haskell.org/ghc/docs/latest/html/libraries/base/Prelude.html#t:Maybe"><span style="background-color: #efefbf; font-weight: bold;">Maybe</span></a> a<span style="color: green;">&#41;</span><span style="color: green;">&#41;</span> <span style="color: #06c; font-weight: bold;">where</span>
  <span style="color: #06c; font-weight: bold;">type</span> Ctx <span style="color: green;">&#40;</span><a href="http://haskell.org/ghc/docs/latest/html/libraries/base/Prelude.html#t:Eq"><span style="background-color: #efefbf; font-weight: bold;">Eq</span></a> <span style="color: green;">&#40;</span><a href="http://haskell.org/ghc/docs/latest/html/libraries/base/Prelude.html#t:Maybe"><span style="background-color: #efefbf; font-weight: bold;">Maybe</span></a> a<span style="color: green;">&#41;</span><span style="color: green;">&#41;</span> = <a href="http://haskell.org/ghc/docs/latest/html/libraries/base/Prelude.html#t:Eq"><span style="background-color: #efefbf; font-weight: bold;">Eq</span></a> a
  ins = Sub Dict
<span style="color: #06c; font-weight: bold;">instance</span> Instance <span style="color: green;">&#40;</span><a href="http://haskell.org/ghc/docs/latest/html/libraries/base/Prelude.html#t:Eq"><span style="background-color: #efefbf; font-weight: bold;">Eq</span></a> <span style="color: green;">&#40;</span>Complex a<span style="color: green;">&#41;</span><span style="color: green;">&#41;</span> <span style="color: #06c; font-weight: bold;">where</span>
  <span style="color: #06c; font-weight: bold;">type</span> Ctx <span style="color: green;">&#40;</span><a href="http://haskell.org/ghc/docs/latest/html/libraries/base/Prelude.html#t:Eq"><span style="background-color: #efefbf; font-weight: bold;">Eq</span></a> <span style="color: green;">&#40;</span>Complex a<span style="color: green;">&#41;</span><span style="color: green;">&#41;</span> = <a href="http://haskell.org/ghc/docs/latest/html/libraries/base/Prelude.html#t:Eq"><span style="background-color: #efefbf; font-weight: bold;">Eq</span></a> a
  ins = Sub Dict
<span style="color: #06c; font-weight: bold;">instance</span> Instance <span style="color: green;">&#40;</span><a href="http://haskell.org/ghc/docs/latest/html/libraries/base/Prelude.html#t:Eq"><span style="background-color: #efefbf; font-weight: bold;">Eq</span></a> <span style="color: green;">&#40;</span>Ratio a<span style="color: green;">&#41;</span><span style="color: green;">&#41;</span> <span style="color: #06c; font-weight: bold;">where</span>
  <span style="color: #06c; font-weight: bold;">type</span> Ctx <span style="color: green;">&#40;</span><a href="http://haskell.org/ghc/docs/latest/html/libraries/base/Prelude.html#t:Eq"><span style="background-color: #efefbf; font-weight: bold;">Eq</span></a> <span style="color: green;">&#40;</span>Ratio a<span style="color: green;">&#41;</span><span style="color: green;">&#41;</span> = <a href="http://haskell.org/ghc/docs/latest/html/libraries/base/Prelude.html#t:Eq"><span style="background-color: #efefbf; font-weight: bold;">Eq</span></a> a
  ins = Sub Dict
<span style="color: #06c; font-weight: bold;">instance</span> Instance <span style="color: green;">&#40;</span><a href="http://haskell.org/ghc/docs/latest/html/libraries/base/Prelude.html#t:Eq"><span style="background-color: #efefbf; font-weight: bold;">Eq</span></a> <span style="color: green;">&#40;</span>a, b<span style="color: green;">&#41;</span><span style="color: green;">&#41;</span> <span style="color: #06c; font-weight: bold;">where</span>
  <span style="color: #06c; font-weight: bold;">type</span> Ctx <span style="color: green;">&#40;</span><a href="http://haskell.org/ghc/docs/latest/html/libraries/base/Prelude.html#t:Eq"><span style="background-color: #efefbf; font-weight: bold;">Eq</span></a> <span style="color: green;">&#40;</span>a,b<span style="color: green;">&#41;</span><span style="color: green;">&#41;</span> = <span style="color: green;">&#40;</span><a href="http://haskell.org/ghc/docs/latest/html/libraries/base/Prelude.html#t:Eq"><span style="background-color: #efefbf; font-weight: bold;">Eq</span></a> a, <a href="http://haskell.org/ghc/docs/latest/html/libraries/base/Prelude.html#t:Eq"><span style="background-color: #efefbf; font-weight: bold;">Eq</span></a> b<span style="color: green;">&#41;</span>
  ins = Sub Dict
<span style="color: #06c; font-weight: bold;">instance</span> Instance <span style="color: green;">&#40;</span><a href="http://haskell.org/ghc/docs/latest/html/libraries/base/Prelude.html#t:Eq"><span style="background-color: #efefbf; font-weight: bold;">Eq</span></a> <span style="color: green;">&#40;</span><a href="http://haskell.org/ghc/docs/latest/html/libraries/base/Prelude.html#t:Either"><span style="background-color: #efefbf; font-weight: bold;">Either</span></a> a b<span style="color: green;">&#41;</span><span style="color: green;">&#41;</span> <span style="color: #06c; font-weight: bold;">where</span>
  <span style="color: #06c; font-weight: bold;">type</span> Ctx <span style="color: green;">&#40;</span><a href="http://haskell.org/ghc/docs/latest/html/libraries/base/Prelude.html#t:Eq"><span style="background-color: #efefbf; font-weight: bold;">Eq</span></a> <span style="color: green;">&#40;</span><a href="http://haskell.org/ghc/docs/latest/html/libraries/base/Prelude.html#t:Either"><span style="background-color: #efefbf; font-weight: bold;">Either</span></a> a b<span style="color: green;">&#41;</span><span style="color: green;">&#41;</span> = <span style="color: green;">&#40;</span><a href="http://haskell.org/ghc/docs/latest/html/libraries/base/Prelude.html#t:Eq"><span style="background-color: #efefbf; font-weight: bold;">Eq</span></a> a, <a href="http://haskell.org/ghc/docs/latest/html/libraries/base/Prelude.html#t:Eq"><span style="background-color: #efefbf; font-weight: bold;">Eq</span></a> b<span style="color: green;">&#41;</span>
  ins = Sub Dict
#endif
&nbsp;</pre>
<p>Having tested both approaches, the type family approach led to a ~10% larger file size, and was harder to read, so I remained with MPTCs even though it meant repeating "where ins = Sub Dict" over and over.</p>
<p>In a perfect world, we'd gain the ability to use default signatures with multiparameter type classes, and the result would be considerably shorter and easier to read!</p>
<h2>Fake Superclasses</h2>
<p>Now, that we have all this machinery, it'd be nice to get something useful out of it. Even if we could derive it by other means, it'd let us know we weren't completely wasting our time.</p>
<p>Let's define a rather horrid helper, which we'll only use where a and b are the same constraint being applied to a newtype wrapper of the same type, so we can rely on the fact that the dictionaries have the same representation.</p>
<pre class="haskell">&nbsp;
evil :: a :- b
evil = unsafeCoerce refl
&nbsp;</pre>
<p>We often bemoan the fact that we can't use Applicative sugar given just a Monad, since Applicative wasn't made a superclass of Monad due to the inability of the Haskell 98 report to foresee the future invention of Applicative.</p>
<p>There are rather verbose options to get Applicative sugar for your Monad, or to pass it to something that expects an Applicative. For instance you can use WrappedMonad from Applicative. We reflect the relevant instance here.</p>
<pre class="haskell">&nbsp;
<span style="color: #06c; font-weight: bold;">instance</span> <a href="http://haskell.org/ghc/docs/latest/html/libraries/base/Prelude.html#t:Monad"><span style="background-color: #efefbf; font-weight: bold;">Monad</span></a> m :=&gt; Applicative <span style="color: green;">&#40;</span>WrappedMonad m<span style="color: green;">&#41;</span> <span style="color: #06c; font-weight: bold;">where</span> ins = Sub Dict
&nbsp;</pre>
<p>Using that instance and the combinators defined previously, we can obtain the following </p>
<pre class="haskell">&nbsp;
applicative :: <span style="color: #06c; font-weight: bold;">forall</span> m a. <a href="http://haskell.org/ghc/docs/latest/html/libraries/base/Prelude.html#t:Monad"><span style="background-color: #efefbf; font-weight: bold;">Monad</span></a> m =&gt; <span style="color: green;">&#40;</span>Applicative m =&gt; m a<span style="color: green;">&#41;</span> -&gt; m a
applicative m =
  m \\ trans <span style="color: green;">&#40;</span>evil :: Applicative <span style="color: green;">&#40;</span>WrappedMonad m<span style="color: green;">&#41;</span> :- Applicative m<span style="color: green;">&#41;</span> ins
&nbsp;</pre>
<p>Here ins is instantiated to the instance of (:=>) above, so we use trans to compose <code>ins :: Monad m :- Applicative (WrappedMonad m)</code> with <code>evil :: Applicative (WrappedMonad m) :- Applicative m</code> to obtain an entailment of type <code>Monad m :- Applicative m</code> in local scope, and then apply that transformation to discharge the Applicative obligation on m.</p>
<p>Now, we can use this to write definitions. [Note: Frustratingly, my blog software inserts spaces after &lt;'s in code]</p>
<pre class="haskell">&nbsp;
<span style="color: green;">&#40;</span>&lt; &amp;&gt;<span style="color: green;">&#41;</span> :: <a href="http://haskell.org/ghc/docs/latest/html/libraries/base/Prelude.html#t:Monad"><span style="background-color: #efefbf; font-weight: bold;">Monad</span></a> m =&gt; m a -&gt; m b -&gt; m <span style="color: green;">&#40;</span>a, b<span style="color: green;">&#41;</span>
m &lt; &amp;&gt; n = applicative $ <span style="color: green;">&#40;</span>,<span style="color: green;">&#41;</span> &lt; $&gt; m &lt; *&gt; n
&nbsp;</pre>
<p>Which compares rather favorably to the more correct</p>
<pre class="haskell">&nbsp;
<span style="color: green;">&#40;</span>&lt; &amp;&gt;<span style="color: green;">&#41;</span> :: <a href="http://haskell.org/ghc/docs/latest/html/libraries/base/Prelude.html#t:Monad"><span style="background-color: #efefbf; font-weight: bold;">Monad</span></a> m =&gt; m a -&gt; m b -&gt; m <span style="color: green;">&#40;</span>a, b<span style="color: green;">&#41;</span>
m &lt; &amp;&gt; n = unwrapMonad $ <span style="color: green;">&#40;</span>,<span style="color: green;">&#41;</span> &lt; $&gt; WrapMonad m &lt; *&gt; WrapMonad n
&nbsp;</pre>
<p>especially considering you still have access to any other instances on m you might want to bring into scope without having to use deriving to lift them onto the newtype!</p>
<p>Similarly you can borrow <code>< |></code> and empty locally for use by your <code>MonadPlus</code> with:</p>
<pre class="haskell">&nbsp;
<span style="color: #06c; font-weight: bold;">instance</span> MonadPlus m :=&gt; Alternative <span style="color: green;">&#40;</span>WrappedMonad m<span style="color: green;">&#41;</span> <span style="color: #06c; font-weight: bold;">where</span> ins = Sub Dict
&nbsp;
alternative :: <span style="color: #06c; font-weight: bold;">forall</span> m a. MonadPlus m =&gt; <span style="color: green;">&#40;</span>Alternative m =&gt; m a<span style="color: green;">&#41;</span> -&gt; m a
alternative m =
  m \\ trans <span style="color: green;">&#40;</span>evil :: Alternative <span style="color: green;">&#40;</span>WrappedMonad m<span style="color: green;">&#41;</span> :- Alternative m<span style="color: green;">&#41;</span> ins
&nbsp;</pre>
<p>The correctness of this of course relies upon the convention that any <code>Applicative</code> and <code>Alternative</code> your <code>Monad</code> may have should agree with its <code>Monad</code> instance, so even if you use <code>Alternative</code> or <code>Applicative</code> in a context where the actual <code>Applicative</code> or <code>Alternative</code> instance for your particular type m is in scope, it shouldn't matter beyond a little bit of efficiency which instance the compiler picks to discharge the <code>Applicative</code> or <code>Alternative</code> obligation.</p>
<p>Note: It isn't that the <code>Constraint</code> kind is invalid, but rather that using <code>unsafeCoerce</code> judiciously we can bring into scope instances that don't exist for a given type by substituting those from a different type which have the right representation.</p>
<p>[<a href="https://github.com/ekmett/constraints/blob/master/Data/Constraint.hs">Source</a>]</p>
]]></content:encoded>
			<wfw:commentRss>http://comonad.com/reader/2011/what-constraints-entail-part-2/feed/</wfw:commentRss>
		<slash:comments>13</slash:comments>
		</item>
		<item>
		<title>What Constraints Entail: Part 1</title>
		<link>http://comonad.com/reader/2011/what-constraints-entail-part-1/</link>
		<comments>http://comonad.com/reader/2011/what-constraints-entail-part-1/#comments</comments>
		<pubDate>Thu, 03 Nov 2011 05:46:11 +0000</pubDate>
		<dc:creator>Edward Kmett</dc:creator>
				<category><![CDATA[Category Theory]]></category>
		<category><![CDATA[Constraint Kinds]]></category>
		<category><![CDATA[Haskell]]></category>
		<category><![CDATA[Logic]]></category>
		<category><![CDATA[Monads]]></category>
		<category><![CDATA[Type Hackery]]></category>
		<category><![CDATA[Uncategorized]]></category>

		<guid isPermaLink="false">http://comonad.com/reader/?p=430</guid>
		<description><![CDATA[Max Bolingbroke has done a wonderful job on adding Constraint kinds to GHC.
Constraint Kinds adds a new kind Constraint, such that Eq :: * -> Constraint, Monad :: (* -> *) -> Constraint, but since it is a kind, we can make type families for constraints, and even parameterize constraints on constraints. 
So, let's play [...]]]></description>
			<content:encoded><![CDATA[<p>Max Bolingbroke has done a wonderful job on adding Constraint kinds to GHC.</p>
<p>Constraint Kinds adds a new kind <code>Constraint</code>, such that <code>Eq :: * -> Constraint</code>, <code>Monad :: (* -> *) -> Constraint</code>, but since it is a kind, we can make type families for constraints, and even parameterize constraints <em>on</em> constraints. </p>
<p>So, let's play with them and see what we can come up with!</p>
<p><span id="more-430"></span></p>
<h2>A Few Extensions</h2>
<p>First, we'll need a few language features:</p>
<pre class="haskell">&nbsp;
<span style="color: #5d478b; font-style: italic;">{-# LANGUAGE
  CPP,
  ScopedTypeVariables,
  FlexibleInstances,
  FlexibleContexts,
  ConstraintKinds,
  KindSignatures,
  TypeOperators,
  FunctionalDependencies,
  Rank2Types,
  StandaloneDeriving,
  GADTs
  #-}</span>
&nbsp;</pre>
<p>Because of the particular version of GHC I'm using I'll also need</p>
<pre class="haskell">&nbsp;
<span style="color: #5d478b; font-style: italic;">{-# LANGUAGE UndecidableInstances #-}</span>
#define UNDECIDABLE
&nbsp;</pre>
<p>but this bug has been fixed in the current version of GHC Head. I'll be explicit about any instances that need UndecidableInstances by surrounding them in an <code>#ifdef UNDECIDABLE</code> block.</p>
<h2>Explicit Dictionaries</h2>
<p>So with that out of the way, let's import some definitions</p>
<pre class="haskell">&nbsp;
<span style="color: #06c; font-weight: bold;">import</span> Control.<a href="http://haskell.org/ghc/docs/latest/html/libraries/base/Prelude.html#t:Monad"><span style="background-color: #efefbf; font-weight: bold;">Monad</span></a>
<span style="color: #06c; font-weight: bold;">import</span> Control.<a href="http://haskell.org/ghc/docs/latest/html/libraries/base/Prelude.html#t:Monad"><span style="background-color: #efefbf; font-weight: bold;">Monad</span></a>.Instances
<span style="color: #06c; font-weight: bold;">import</span> Control.Applicative
<span style="color: #06c; font-weight: bold;">import</span> Data.Monoid
<span style="color: #06c; font-weight: bold;">import</span> Data.Complex
<span style="color: #06c; font-weight: bold;">import</span> Data.Ratio
<span style="color: #06c; font-weight: bold;">import</span> Unsafe.Coerce
&nbsp;</pre>
<p>and make one of our own that shows what we get out of making Constraints into a kind we can manipulate like any other.</p>
<pre class="haskell">&nbsp;
<span style="color: #06c; font-weight: bold;">data</span> Dict a <span style="color: #06c; font-weight: bold;">where</span>
  Dict :: a =&gt; Dict a
&nbsp;</pre>
<p>Previously, we coud make a Dict like data type for any one particular class constraint that we wanted to capture, but now we can write this type once and for all. The act of pattern matching on the Dict constructor will bring the constraint 'a' into scope.</p>
<p>Of course, in the absence of incoherent and overlapping instances there is at most one dictionary of a given type, so we could make instances, like we can for any other data type, but standalone deriving is smart enough to figure these out for me. (Thanks copumpkin!)</p>
<pre class="haskell">&nbsp;
<span style="color: #06c; font-weight: bold;">deriving</span> <span style="color: #06c; font-weight: bold;">instance</span> <a href="http://haskell.org/ghc/docs/latest/html/libraries/base/Prelude.html#t:Eq"><span style="background-color: #efefbf; font-weight: bold;">Eq</span></a> <span style="color: green;">&#40;</span>Dict a<span style="color: green;">&#41;</span>
<span style="color: #06c; font-weight: bold;">deriving</span> <span style="color: #06c; font-weight: bold;">instance</span> <a href="http://haskell.org/ghc/docs/latest/html/libraries/base/Prelude.html#t:Ord"><span style="background-color: #efefbf; font-weight: bold;">Ord</span></a> <span style="color: green;">&#40;</span>Dict a<span style="color: green;">&#41;</span>
<span style="color: #06c; font-weight: bold;">deriving</span> <span style="color: #06c; font-weight: bold;">instance</span> <a href="http://haskell.org/ghc/docs/latest/html/libraries/base/Prelude.html#t:Show"><span style="background-color: #efefbf; font-weight: bold;">Show</span></a> <span style="color: green;">&#40;</span>Dict a<span style="color: green;">&#41;</span>
&nbsp;</pre>
<p>If we're willing to turn on UndecidableInstances to enable the polymorphic constraint we can even add:</p>
<pre class="haskell">&nbsp;
#ifdef UNDECIDABLE
<span style="color: #06c; font-weight: bold;">deriving</span> <span style="color: #06c; font-weight: bold;">instance</span> a =&gt; <a href="http://haskell.org/ghc/docs/latest/html/libraries/base/Prelude.html#t:Read"><span style="background-color: #efefbf; font-weight: bold;">Read</span></a> <span style="color: green;">&#40;</span>Dict a<span style="color: green;">&#41;</span>
<span style="color: #06c; font-weight: bold;">instance</span> a =&gt; Monoid <span style="color: green;">&#40;</span>Dict a<span style="color: green;">&#41;</span> <span style="color: #06c; font-weight: bold;">where</span>
  mappend Dict Dict = Dict
  mempty = Dict
#endif
&nbsp;</pre>
<p>and similar polymorphically constrained instances for <code>Enum</code>, <code>Bounded</code>, etc.</p>
<h2>Entailment</h2>
<p>For that we'll need a notion of entailment.</p>
<pre class="haskell">&nbsp;
<span style="color: #06c; font-weight: bold;">infixr</span> <span style="color: red;">9</span> :-
<span style="color: #06c; font-weight: bold;">newtype</span> a :- b = Sub <span style="color: green;">&#40;</span>a =&gt; Dict b<span style="color: green;">&#41;</span>
&nbsp;
<span style="color: #06c; font-weight: bold;">instance</span> <a href="http://haskell.org/ghc/docs/latest/html/libraries/base/Prelude.html#t:Eq"><span style="background-color: #efefbf; font-weight: bold;">Eq</span></a> <span style="color: green;">&#40;</span>a :- b<span style="color: green;">&#41;</span> <span style="color: #06c; font-weight: bold;">where</span>
  _ == _ = <a href="http://haskell.org/ghc/docs/latest/html/libraries/base/Prelude.html#v:True"><span style="font-weight: bold;">True</span></a>
&nbsp;
<span style="color: #06c; font-weight: bold;">instance</span> <a href="http://haskell.org/ghc/docs/latest/html/libraries/base/Prelude.html#t:Ord"><span style="background-color: #efefbf; font-weight: bold;">Ord</span></a> <span style="color: green;">&#40;</span>a :- b<span style="color: green;">&#41;</span> <span style="color: #06c; font-weight: bold;">where</span>
  <a href="http://haskell.org/ghc/docs/latest/html/libraries/base/Prelude.html#v:compare"><span style="font-weight: bold;">compare</span></a> _ _ = EQ
&nbsp;
<span style="color: #06c; font-weight: bold;">instance</span> <a href="http://haskell.org/ghc/docs/latest/html/libraries/base/Prelude.html#t:Show"><span style="background-color: #efefbf; font-weight: bold;">Show</span></a> <span style="color: green;">&#40;</span>a :- b<span style="color: green;">&#41;</span> <span style="color: #06c; font-weight: bold;">where</span>
  showsPrec d _ = <a href="http://haskell.org/ghc/docs/latest/html/libraries/base/Prelude.html#v:showParen"><span style="font-weight: bold;">showParen</span></a> <span style="color: green;">&#40;</span>d &gt; <span style="color: red;">10</span><span style="color: green;">&#41;</span> $
    <a href="http://haskell.org/ghc/docs/latest/html/libraries/base/Prelude.html#v:showString"><span style="font-weight: bold;">showString</span></a> <span style="color: #3c7331;">&quot;Sub Dict&quot;</span>
&nbsp;</pre>
<p>Here we're saying that <code>Sub</code> takes one argument, which is a computation that when implicitly given a constraint of type <em>a</em>, can give me back a dictionary for the type <em>b</em>. Moreover, as a newtype it adds no overhead that isn't aleady present in manipulating terms of type (a => Dict b) directly.</p>
<p>The simplest thing we can define with this is that entailment is reflexive.</p>
<pre class="haskell">&nbsp;
refl :: a :- a
refl = Sub Dict
&nbsp;</pre>
<p>Max has already written up a nice restricted monad example using these, but what I want to play with today is the category of substitutability of constraints, but there are a few observations I need to make, first.</p>
<p>ConstraintKinds overloads <code>()</code> and <code>(a,b)</code> to represent the trivial constraint and the product of two constraints respectively. </p>
<p>The latter is done with a bit of a hack, which we'll talk about in a minute, but we can use the former as a terminal object for our category of entailments.</p>
<pre lang="haskell>
top :: a :- ()
top = Sub Dict
</pre>
<p>We can weaken the constraint, in a manner similar to fst or snd:</p>
<pre class="haskell">&nbsp;
weaken1 :: <span style="color: green;">&#40;</span>a, b<span style="color: green;">&#41;</span> :- a
weaken1 = Sub Dict
&nbsp;
weaken2 :: <span style="color: green;">&#40;</span>a, b<span style="color: green;">&#41;</span> :- b
weaken2 = Sub Dict
&nbsp;</pre>
<p>Constraints are idempotent, so we can duplicate one, perhaps as a prelude to transforming one of them into something else.</p>
<pre class="haskell">&nbsp;
contract :: a :- <span style="color: green;">&#40;</span>a, a<span style="color: green;">&#41;</span>
contract = Sub Dict
&nbsp;</pre>
<p>But to do much more complicated, we're going to need a notion of substitution, letting us use our entailment relation to satisfy obligations.</p>
<pre class="haskell">&nbsp;
<span style="color: #06c; font-weight: bold;">infixl</span> <span style="color: red;">1</span> \\ <span style="color: #5d478b; font-style: italic;">-- required comment</span>
<span style="color: green;">&#40;</span>\\<span style="color: green;">&#41;</span> :: a =&gt; <span style="color: green;">&#40;</span>b =&gt; r<span style="color: green;">&#41;</span> -&gt; <span style="color: green;">&#40;</span>a :- b<span style="color: green;">&#41;</span> -&gt; r
r \\ Sub Dict = r
&nbsp;</pre>
<p>The type says that given that a constraint <em>a</em> can be satisfied, a computation that needs a constraint of type <em>b</em> to be satisfied in order to obtain a result, and the fact that <em>a</em> entails <em>b</em>, we can compute the result. </p>
<p>The constraint <em>a</em> is satisfied by the type signature, and the fact that we get quietly passed whatever dictionary is needed. Pattern matching on Sub brings into scope a computation of type <code>(a => Dict b)</code>, and we are able to discharge the <em>a</em> obligation, using the dictionary we were passed, Pattern matching on <code>Dict</code> forces that computation to happen and brings b into scope, allowing us to meet the obligation of the computation of r. All of this happens for us behind the scenes just by pattern matching.</p>
<p>So what can we do with this?</p>
<p>We can use \\ to compose constraints.</p>
<pre class="haskell">&nbsp;
trans :: <span style="color: green;">&#40;</span>b :- c<span style="color: green;">&#41;</span> -&gt; <span style="color: green;">&#40;</span>a :- b<span style="color: green;">&#41;</span> -&gt; a :- c
trans f g = Sub $ Dict \\ f \\ g
&nbsp;</pre>
<p>In fact, the way the dictionaries get plumbed around inside the argument to Sub is rather nice, because we can give that same definition different type signatures, letting us make (,) more product-like, giving us the canonical product morphism to go with the weakenings/projections we defined above.</p>
<pre class="haskell">&nbsp;
<span style="color: green;">&#40;</span>&amp;&amp;&amp;<span style="color: green;">&#41;</span> :: <span style="color: green;">&#40;</span>a :- b<span style="color: green;">&#41;</span> -&gt; <span style="color: green;">&#40;</span>a :- c<span style="color: green;">&#41;</span> -&gt; a :- <span style="color: green;">&#40;</span>b, c<span style="color: green;">&#41;</span>
f &amp;&amp;&amp; g = Sub $ Dict \\ f \\ g
&nbsp;</pre>
<p>And since we're using it as a product, we can make it act like a bifunctor also using the same definition.</p>
<pre class="haskell">&nbsp;
<span style="color: green;">&#40;</span>***<span style="color: green;">&#41;</span> :: <span style="color: green;">&#40;</span>a :- b<span style="color: green;">&#41;</span> -&gt; <span style="color: green;">&#40;</span>c :- d<span style="color: green;">&#41;</span> -&gt; <span style="color: green;">&#40;</span>a, c<span style="color: green;">&#41;</span> :- <span style="color: green;">&#40;</span>b, d<span style="color: green;">&#41;</span>
f *** g = Sub $ Dict \\ f \\ g
&nbsp;</pre>
<h2>Limited Sub-Superkinding?</h2>
<p>Ideally we'd be able to capture something like that bifunctoriality using a type like</p>
<pre class="haskell">&nbsp;
#if <span style="color: red;">0</span>
<span style="color: #06c; font-weight: bold;">class</span> BifunctorS <span style="color: green;">&#40;</span>p :: Constraint -&gt; Constraint -&gt; Constraint<span style="color: green;">&#41;</span> <span style="color: #06c; font-weight: bold;">where</span>
  bimapS :: <span style="color: green;">&#40;</span>a :- b<span style="color: green;">&#41;</span> -&gt; <span style="color: green;">&#40;</span>c :- d<span style="color: green;">&#41;</span> -&gt; p a c :- p b d
#endif
&nbsp;</pre>
<p>In an even more ideal world, it would be enriched using something like</p>
<pre class="haskell">&nbsp;
#ifdef POLYMORPHIC_KINDS
<span style="color: #06c; font-weight: bold;">class</span> Category <span style="color: green;">&#40;</span>k :: x -&gt; x -&gt; *<span style="color: green;">&#41;</span> <span style="color: #06c; font-weight: bold;">where</span>
  <a href="http://haskell.org/ghc/docs/latest/html/libraries/base/Prelude.html#v:id"><span style="font-weight: bold;">id</span></a> :: k a a
  <span style="color: green;">&#40;</span>.<span style="color: green;">&#41;</span> :: k b c -&gt; k a b -&gt; k a c
<span style="color: #06c; font-weight: bold;">instance</span> Category <span style="color: green;">&#40;</span>:-<span style="color: green;">&#41;</span> <span style="color: #06c; font-weight: bold;">where</span>
  <a href="http://haskell.org/ghc/docs/latest/html/libraries/base/Prelude.html#v:id"><span style="font-weight: bold;">id</span></a> = refl
  <span style="color: green;">&#40;</span>.<span style="color: green;">&#41;</span> = trans
#endif
&nbsp;</pre>
<p>where x is a <strong>kind variable</strong>, then we could obtain a more baroque and admittedly far less thought-out bifunctor class like:</p>
<pre class="haskell">&nbsp;
#if <span style="color: red;">0</span>
<span style="color: #06c; font-weight: bold;">class</span> Bifunctor <span style="color: green;">&#40;</span>p :: x -&gt; y -&gt; z<span style="color: green;">&#41;</span> <span style="color: #06c; font-weight: bold;">where</span>
  <span style="color: #06c; font-weight: bold;">type</span> <a href="http://haskell.org/ghc/docs/latest/html/libraries/base/Prelude.html#v:Left"><span style="font-weight: bold;">Left</span></a> p :: x -&gt; x -&gt; *
  <span style="color: #06c; font-weight: bold;">type</span> <a href="http://haskell.org/ghc/docs/latest/html/libraries/base/Prelude.html#v:Left"><span style="font-weight: bold;">Left</span></a> p = <span style="color: green;">&#40;</span>-&gt;<span style="color: green;">&#41;</span>
  <span style="color: #06c; font-weight: bold;">type</span> <a href="http://haskell.org/ghc/docs/latest/html/libraries/base/Prelude.html#v:Right"><span style="font-weight: bold;">Right</span></a> p :: y -&gt; y -&gt; *
  <span style="color: #06c; font-weight: bold;">type</span> <a href="http://haskell.org/ghc/docs/latest/html/libraries/base/Prelude.html#v:Right"><span style="font-weight: bold;">Right</span></a> p = <span style="color: green;">&#40;</span>-&gt;<span style="color: green;">&#41;</span>
  <span style="color: #06c; font-weight: bold;">type</span> Cod p :: z -&gt; z -&gt; *
  <span style="color: #06c; font-weight: bold;">type</span> Cod p = <span style="color: green;">&#40;</span>-&gt;<span style="color: green;">&#41;</span>
  bimap :: <a href="http://haskell.org/ghc/docs/latest/html/libraries/base/Prelude.html#v:Left"><span style="font-weight: bold;">Left</span></a> p a b -&gt; <a href="http://haskell.org/ghc/docs/latest/html/libraries/base/Prelude.html#v:Right"><span style="font-weight: bold;">Right</span></a> p c d -&gt; Cod p <span style="color: green;">&#40;</span>p a c<span style="color: green;">&#41;</span> <span style="color: green;">&#40;</span>p b d<span style="color: green;">&#41;</span>
#endif
&nbsp;</pre>
<p>Or even more more ideally, you could use the fact that we can directly define product categories!</p>
<p>Since they are talking about kind-indexing for classes and type families, we could have separate bifunctors for (,) for both kinds * and Constraint.</p>
<p>The current constraint kind code uses a hack to let (a,b) be used as a type inhabiting * and as the syntax for constraints. This hack is limited however. It only works when the type (,) is fully applied to its arguments. Otherwise you'd wind up with the fact that the type (,) needs to have both of these kinds:</p>
<pre class="haskell">&nbsp;
<span style="color: #5d478b; font-style: italic;">-- (,) :: Constraint -&gt; Constraint -&gt; Constraint and</span>
<span style="color: #5d478b; font-style: italic;">-- (,) :: * -&gt; * -&gt; *</span>
&nbsp;</pre>
<p>What is currently done is that the kind magically switches for <code>()</code> and <code>(,)</code> in certain circumstances. GHC already had some support for this because it parses <code>(Foo a, Bar b)</code> as a type in <code>(Foo a, Bar b) => Baz a b</code> before transforming it into a bunch of constraints.</p>
<p>Since we already have a notion of sub-kinding at the kind level, we could solve this for <code>()</code> by making up a new kind, say, <code>???</code> which is the subkind of both <code>*</code> and <code>Constraint</code>, but this would break the nice join lattice properties of the current system.</p>
<p>[Edit: in the initial draft, I had said superkind]</p>
<pre class="haskell">&nbsp;
<span style="color: #5d478b; font-style: italic;">--    ?</span>
<span style="color: #5d478b; font-style: italic;">--   / \</span>
<span style="color: #5d478b; font-style: italic;">-- (#)  ??</span>
<span style="color: #5d478b; font-style: italic;">--     /  \</span>
<span style="color: #5d478b; font-style: italic;">--    #    *  Constraint</span>
<span style="color: #5d478b; font-style: italic;">--          \ /</span>
<span style="color: #5d478b; font-style: italic;">--          ???</span>
&nbsp;</pre>
<p>But this doesn't address the kind of <code>(,)</code> above. With the new polymorphic kinds that Brent Yorgey and company have been working on and a limited notion of sub-superkinding, this could be resolved by making a new super-kind <code>@</code> that is the super-kind of both <code>*</code> and <code>Constraint</code>, and which is a sub-superkind of the usual unnamed Box superkind. </p>
<pre class="haskell">&nbsp;
<span style="color: #5d478b; font-style: italic;">-- Box</span>
<span style="color: #5d478b; font-style: italic;">--  |</span>
<span style="color: #5d478b; font-style: italic;">--  @</span>
&nbsp;</pre>
<p>Then we can have:</p>
<pre class="haskell">&nbsp;
<span style="color: #5d478b; font-style: italic;">-- (,) :: forall (k :: @). k -&gt; k -&gt; k</span>
<span style="color: #5d478b; font-style: italic;">-- () :: forall (k :: @). k</span>
&nbsp;</pre>
<p>and kind checking/inference will do the right thing about keeping the kind ambiguous for types like <code>(,) () :: forall (k :: @). k</code></p>
<p>This would get rid of the hack and let me make a proper bifunctor for <code>(,)</code> in the category of entailments.</p>
<p>The version of GHC head I'm working with right now doesn't support polymorphic kinds, so I've only been playing with these in a toy type checker, but I'm really looking forward to being able to have product categories!</p>
<h2>Stay Tuned</h2>
<p><a href="http://comonad.com/reader/2011/what-constraints-entail-part-2/">Next</a>, we'll go over how to reflect the class and instance declarations so we can derive entailment of a superclass for a class, and the entailment of instances.</p>
<p>[<a href="https://github.com/ekmett/constraints/blob/master/Data/Constraint.hs">Source</a>]</p>
]]></content:encoded>
			<wfw:commentRss>http://comonad.com/reader/2011/what-constraints-entail-part-1/feed/</wfw:commentRss>
		<slash:comments>4</slash:comments>
		</item>
		<item>
		<title>A Parsec Full of Rats, Part 2</title>
		<link>http://comonad.com/reader/2011/a-parsec-full-of-rats-part-2/</link>
		<comments>http://comonad.com/reader/2011/a-parsec-full-of-rats-part-2/#comments</comments>
		<pubDate>Sat, 24 Sep 2011 03:07:32 +0000</pubDate>
		<dc:creator>Edward Kmett</dc:creator>
				<category><![CDATA[Algorithms]]></category>
		<category><![CDATA[Data Structures]]></category>
		<category><![CDATA[Haskell]]></category>
		<category><![CDATA[Monads]]></category>
		<category><![CDATA[Parsing]]></category>
		<category><![CDATA[Uncategorized]]></category>
		<category><![CDATA[packrat]]></category>
		<category><![CDATA[parsec]]></category>
		<category><![CDATA[trifecta]]></category>

		<guid isPermaLink="false">http://comonad.com/reader/?p=397</guid>
		<description><![CDATA[Last time, I showed that we can build a small parsec clone with packrat support.
This time I intend to implement packrat directly on top of Parsec 3.
One of the main topics of discussion when it comes to packrat parsing since Bryan Ford's initial release of Pappy has been the fact that in general you shouldn't [...]]]></description>
			<content:encoded><![CDATA[<p>Last time, I showed that we can build a small parsec clone with packrat support.</p>
<p>This time I intend to implement packrat directly on top of Parsec 3.</p>
<p>One of the main topics of discussion when it comes to packrat parsing since Bryan Ford's initial release of Pappy has been the fact that in general you shouldn't use packrat to memoize every rule, and that instead you should apply Amdahl's law to look for the cases where the lookup time is paid back in terms of repetitive evaluation, computation time and the hit rate. This is great news for us, since, we only want to memoize a handful of expensive combinators.</p>
<p><span id="more-397"></span></p>
<p>First, we'll need to import enough of Parsec to do something interesting.</p>
<pre class="haskell">&nbsp;
<span style="color: #5d478b; font-style: italic;">{-# LANGUAGE RecordWildCards, ViewPatterns, FlexibleInstances, MultiParamTypeClasses #-}</span>
&nbsp;
<span style="color: #06c; font-weight: bold;">import</span> Text.Parsec
<span style="color: #06c; font-weight: bold;">import</span> <span style="color: #06c; font-weight: bold;">qualified</span> Text.Parsec.Token <span style="color: #06c; font-weight: bold;">as</span> T
<span style="color: #06c; font-weight: bold;">import</span> Text.Parsec.Token
    <span style="color: green;">&#40;</span>GenLanguageDef<span style="color: green;">&#40;</span>..<span style="color: green;">&#41;</span>, GenTokenParser<span style="color: green;">&#40;</span>TokenParser<span style="color: green;">&#41;</span><span style="color: green;">&#41;</span>
<span style="color: #06c; font-weight: bold;">import</span> Text.Parsec.Pos <span style="color: green;">&#40;</span>initialPos, updatePosChar<span style="color: green;">&#41;</span>
<span style="color: #06c; font-weight: bold;">import</span> Data.<a href="http://haskell.org/ghc/docs/latest/html/libraries/base/Prelude.html#t:Functor"><span style="background-color: #efefbf; font-weight: bold;">Functor</span></a>.Identity <span style="color: green;">&#40;</span>Identity<span style="color: green;">&#40;</span>..<span style="color: green;">&#41;</span><span style="color: green;">&#41;</span>
<span style="color: #06c; font-weight: bold;">import</span> Control.Applicative <span style="color: #06c; font-weight: bold;">hiding</span> <span style="color: green;">&#40;</span><span style="color: green;">&#40;</span>&lt; |&gt;<span style="color: green;">&#41;</span><span style="color: green;">&#41;</span>
<span style="color: #06c; font-weight: bold;">import</span> Control.<a href="http://haskell.org/ghc/docs/latest/html/libraries/base/Prelude.html#t:Monad"><span style="background-color: #efefbf; font-weight: bold;">Monad</span></a>.Fix <span style="color: green;">&#40;</span>fix<span style="color: green;">&#41;</span>
&nbsp;</pre>
<p>Then as before, we'll define PEG-style backtracking:</p>
<pre class="haskell">&nbsp;
<span style="color: green;">&#40;</span>&lt; /&gt;<span style="color: green;">&#41;</span> :: <a href="http://haskell.org/ghc/docs/latest/html/libraries/base/Prelude.html#t:Monad"><span style="background-color: #efefbf; font-weight: bold;">Monad</span></a> m =&gt; ParsecT s u m a -&gt; ParsecT s u m a -&gt;
    ParsecT s u m a
p &lt; /&gt; q = try p &lt; |&gt; q
<span style="color: #06c; font-weight: bold;">infixl</span> <span style="color: red;">3</span> &lt; /&gt;
&nbsp;</pre>
<p>Now we need an analogue to our Result type from last time, which recalled whether or not we had consumed input, and what the current cursor location is. Fortunately, we can recycle the definitions from Parsec to this end.</p>
<pre class="haskell">&nbsp;
<span style="color: #06c; font-weight: bold;">type</span> Result d a = Consumed <span style="color: green;">&#40;</span>Reply d <span style="color: green;">&#40;</span><span style="color: green;">&#41;</span> a<span style="color: green;">&#41;</span>
&nbsp;</pre>
<p>We'll define a combinator to build a parser directly from a field accessor. Last time, this was just the use of the "Rat" constructor. Now it is a bit trickier, because we need to turn <code>Consumed (Reply d () a)</code> into <code>m (Consumed (m (Reply d u a)))</code> by wrapping it in the appropriate monad, and giving the user back his state unmolested. </p>
<pre class="haskell">&nbsp;
rat :: <a href="http://haskell.org/ghc/docs/latest/html/libraries/base/Prelude.html#t:Monad"><span style="background-color: #efefbf; font-weight: bold;">Monad</span></a> m =&gt; <span style="color: green;">&#40;</span>d -&gt; Result d a<span style="color: green;">&#41;</span> -&gt; ParsecT d u m a
rat f   = mkPT $ \s0 -&gt; <a href="http://haskell.org/ghc/docs/latest/html/libraries/base/Prelude.html#v:return"><span style="font-weight: bold;">return</span></a> $
    <a href="http://haskell.org/ghc/docs/latest/html/libraries/base/Prelude.html#v:return"><span style="font-weight: bold;">return</span></a> . patch s0 &lt; $&gt; f <span style="color: green;">&#40;</span>stateInput s0<span style="color: green;">&#41;</span> <span style="color: #06c; font-weight: bold;">where</span>
  patch <span style="color: green;">&#40;</span>State _ _ u<span style="color: green;">&#41;</span> <span style="color: green;">&#40;</span>Ok a <span style="color: green;">&#40;</span>State s p _<span style="color: green;">&#41;</span> err<span style="color: green;">&#41;</span> = Ok a <span style="color: green;">&#40;</span>State s p u<span style="color: green;">&#41;</span> err
  patch _             <span style="color: green;">&#40;</span>Error e<span style="color: green;">&#41;</span>                = Error e
&nbsp;</pre>
<p>Last time we could go from a parser to a result just by applying the user stream type, but with parsec we also have to supply their notion of a position. This leads to the following combinator. By running in the Identity monad with no user state it should be obvious that we've duplicated the functionality of the previous 'Rat' parser (with the addition of a source position).</p>
<pre class="haskell">&nbsp;
womp :: d -&gt; SourcePos -&gt; ParsecT d <span style="color: green;">&#40;</span><span style="color: green;">&#41;</span> Identity a -&gt; Result d a
womp d pos p = <a href="http://haskell.org/ghc/docs/latest/html/libraries/base/Prelude.html#v:fmap"><span style="font-weight: bold;">fmap</span></a> runIdentity . runIdentity $
    runParsecT p <span style="color: green;">&#40;</span>State d pos <span style="color: green;">&#40;</span><span style="color: green;">&#41;</span><span style="color: green;">&#41;</span>
&nbsp;</pre>
<p>The combinator is so named because we needed a big space-rat rather than a little pack-rat to keep with the theme.</p>
<blockquote><p>It's not impossible. I used to bullseye womp rats in my T-16 back home, they're not much bigger than two meters.</p></blockquote>
<p>Now we'll write a bit of annoyingly verbose boilerplate to convince <code>Parsec</code> that we really want a <code>LanguageDef</code> for some monad other than Identity. (As an aside, why <code>Text.Parsec.Language</code> doesn't contain GenLanguageDefs that are parametric in their choice of Monad is beyond me.) </p>
<pre class="haskell">&nbsp;
myLanguageDef :: <a href="http://haskell.org/ghc/docs/latest/html/libraries/base/Prelude.html#t:Monad"><span style="background-color: #efefbf; font-weight: bold;">Monad</span></a> m =&gt; T.GenLanguageDef D u m
myLanguageDef = T.LanguageDef
  <span style="color: green;">&#123;</span> commentStart    = <span style="color: #3c7331;">&quot;{-&quot;</span>
  , commentEnd      = <span style="color: #3c7331;">&quot;-}&quot;</span>
  , commentLine     = <span style="color: #3c7331;">&quot;--&quot;</span>
  , nestedComments  = <a href="http://haskell.org/ghc/docs/latest/html/libraries/base/Prelude.html#v:True"><span style="font-weight: bold;">True</span></a>
  , identStart      = letter &lt; |&gt; char '_'
  , identLetter     = alphaNum &lt; |&gt; oneOf <span style="color: #3c7331;">&quot;_'&quot;</span>
  , opStart         = opLetter myLanguageDef
  , opLetter        = oneOf <span style="color: #3c7331;">&quot;:!#$%&amp;*+./&lt; =&gt;?@<span style="">\\</span>^|-~&quot;</span>
  , reservedOpNames = <span style="color: green;">&#91;</span><span style="color: green;">&#93;</span>
  , reservedNames   = <span style="color: green;">&#91;</span><span style="color: green;">&#93;</span>
  , caseSensitive   = <a href="http://haskell.org/ghc/docs/latest/html/libraries/base/Prelude.html#v:True"><span style="font-weight: bold;">True</span></a>
  <span style="color: green;">&#125;</span>
&nbsp;</pre>
<p>As a shameless plug, trifecta offers a particularly nice solution to this problem, breaking up the monolithic Token type into separate concerns and letting you layer parser transformers that enrich the parser to deal with things like Haskell-style layout, literate comments, parsing comments in whitespace, etc. </p>
<p>And as one last bit of boilerplate, we'll abuse RecordWildcards once again to avoid the usual 20 lines of boilerplate that are expected of us, so we can get access to parsec's token parsers.</p>
<pre class="haskell">&nbsp;
TokenParser <span style="color: green;">&#123;</span>..<span style="color: green;">&#125;</span> = T.makeTokenParser myLanguageDef
&nbsp;</pre>
<p>Now we're ready to define our incredibly straightforward stream type:</p>
<pre class="haskell">&nbsp;
<span style="color: #06c; font-weight: bold;">data</span> D = D
  <span style="color: green;">&#123;</span> _add        :: Result D <a href="http://haskell.org/ghc/docs/latest/html/libraries/base/Prelude.html#t:Integer"><span style="background-color: #efefbf; font-weight: bold;">Integer</span></a>
  , _mult       :: Result D <a href="http://haskell.org/ghc/docs/latest/html/libraries/base/Prelude.html#t:Integer"><span style="background-color: #efefbf; font-weight: bold;">Integer</span></a>
  , _primary    :: Result D <a href="http://haskell.org/ghc/docs/latest/html/libraries/base/Prelude.html#t:Integer"><span style="background-color: #efefbf; font-weight: bold;">Integer</span></a>
  , _dec        :: Result D <a href="http://haskell.org/ghc/docs/latest/html/libraries/base/Prelude.html#t:Integer"><span style="background-color: #efefbf; font-weight: bold;">Integer</span></a>
  , _uncons     :: <a href="http://haskell.org/ghc/docs/latest/html/libraries/base/Prelude.html#t:Maybe"><span style="background-color: #efefbf; font-weight: bold;">Maybe</span></a> <span style="color: green;">&#40;</span><a href="http://haskell.org/ghc/docs/latest/html/libraries/base/Prelude.html#t:Char"><span style="background-color: #efefbf; font-weight: bold;">Char</span></a>, D<span style="color: green;">&#41;</span>
  <span style="color: green;">&#125;</span>
&nbsp;
<span style="color: #06c; font-weight: bold;">instance</span> <a href="http://haskell.org/ghc/docs/latest/html/libraries/base/Prelude.html#t:Monad"><span style="background-color: #efefbf; font-weight: bold;">Monad</span></a> m =&gt; Stream D m <a href="http://haskell.org/ghc/docs/latest/html/libraries/base/Prelude.html#t:Char"><span style="background-color: #efefbf; font-weight: bold;">Char</span></a> <span style="color: #06c; font-weight: bold;">where</span>
  uncons = <a href="http://haskell.org/ghc/docs/latest/html/libraries/base/Prelude.html#v:return"><span style="font-weight: bold;">return</span></a> . _uncons
&nbsp;</pre>
<p>And using the general purpose <code>rat</code> combinator from earlier, we can write some memoized parsers:</p>
<pre class="haskell">&nbsp;
add, mult, primary, dec :: Parsec D u <a href="http://haskell.org/ghc/docs/latest/html/libraries/base/Prelude.html#t:Integer"><span style="background-color: #efefbf; font-weight: bold;">Integer</span></a>
add     = rat _add
mult    = rat _mult
primary = rat _primary
dec     = rat _dec
&nbsp;</pre>
<p>And finally, we write the code to tie the knot and build the stream:</p>
<pre class="haskell">&nbsp;
parse :: SourceName -&gt; <a href="http://haskell.org/ghc/docs/latest/html/libraries/base/Prelude.html#t:String"><span style="background-color: #efefbf; font-weight: bold;">String</span></a> -&gt; D
parse n = go <span style="color: green;">&#40;</span>initialPos n<span style="color: green;">&#41;</span> <span style="color: #06c; font-weight: bold;">where</span>
  go p s = fix $ \d -&gt; <span style="color: #06c; font-weight: bold;">let</span>
    <span style="color: green;">&#40;</span>womp d p -&gt; _add<span style="color: green;">&#41;</span> =
            <span style="color: green;">&#40;</span>+<span style="color: green;">&#41;</span> &lt; $&gt; mult &lt; * reservedOp <span style="color: #3c7331;">&quot;+&quot;</span> &lt;*&gt; add
        &lt; /&gt; mult &lt; ?&gt; <span style="color: #3c7331;">&quot;summand&quot;</span>
    <span style="color: green;">&#40;</span>womp d p -&gt; _mult<span style="color: green;">&#41;</span> =
            <span style="color: green;">&#40;</span>*<span style="color: green;">&#41;</span> &lt; $&gt; primary &lt; * reservedOp <span style="color: #3c7331;">&quot;*&quot;</span> &lt;*&gt; mult
        &lt; /&gt; primary &lt; ?&gt; <span style="color: #3c7331;">&quot;factor&quot;</span>
    <span style="color: green;">&#40;</span>womp d p -&gt; _primary<span style="color: green;">&#41;</span> =
            parens add
        &lt; /&gt; dec &lt; ?&gt; <span style="color: #3c7331;">&quot;number&quot;</span>
    <span style="color: green;">&#40;</span>womp d p -&gt; _dec<span style="color: green;">&#41;</span> = natural
    _uncons = <span style="color: #06c; font-weight: bold;">case</span> s <span style="color: #06c; font-weight: bold;">of</span>
      <span style="color: green;">&#40;</span>x:xs<span style="color: green;">&#41;</span> -&gt; <a href="http://haskell.org/ghc/docs/latest/html/libraries/base/Prelude.html#v:Just"><span style="font-weight: bold;">Just</span></a> <span style="color: green;">&#40;</span>x, go <span style="color: green;">&#40;</span>updatePosChar p x<span style="color: green;">&#41;</span> xs<span style="color: green;">&#41;</span>
      <span style="color: green;">&#91;</span><span style="color: green;">&#93;</span>     -&gt; <a href="http://haskell.org/ghc/docs/latest/html/libraries/base/Prelude.html#v:Nothing"><span style="font-weight: bold;">Nothing</span></a>
    <span style="color: #06c; font-weight: bold;">in</span> D <span style="color: green;">&#123;</span> .. <span style="color: green;">&#125;</span>
&nbsp;
runD :: Parsec D u a -&gt; u -&gt; SourceName -&gt; <a href="http://haskell.org/ghc/docs/latest/html/libraries/base/Prelude.html#t:String"><span style="background-color: #efefbf; font-weight: bold;">String</span></a> -&gt; <a href="http://haskell.org/ghc/docs/latest/html/libraries/base/Prelude.html#t:Either"><span style="background-color: #efefbf; font-weight: bold;">Either</span></a> ParseError a
runD p u fn s = runParser p u fn <span style="color: green;">&#40;</span>prep fn s<span style="color: green;">&#41;</span>
&nbsp;</pre>
<p>and finally, let it rip:</p>
<pre class="haskell">&nbsp;
eval :: <a href="http://haskell.org/ghc/docs/latest/html/libraries/base/Prelude.html#t:String"><span style="background-color: #efefbf; font-weight: bold;">String</span></a> -&gt; <a href="http://haskell.org/ghc/docs/latest/html/libraries/base/Prelude.html#t:Integer"><span style="background-color: #efefbf; font-weight: bold;">Integer</span></a>
eval s = <a href="http://haskell.org/ghc/docs/latest/html/libraries/base/Prelude.html#v:either"><span style="font-weight: bold;">either</span></a> <span style="color: green;">&#40;</span><a href="http://haskell.org/ghc/docs/latest/html/libraries/base/Prelude.html#v:error"><span style="font-weight: bold;">error</span></a> . <a href="http://haskell.org/ghc/docs/latest/html/libraries/base/Prelude.html#v:show"><span style="font-weight: bold;">show</span></a><span style="color: green;">&#41;</span> <a href="http://haskell.org/ghc/docs/latest/html/libraries/base/Prelude.html#v:id"><span style="font-weight: bold;">id</span></a> $
    runD <span style="color: green;">&#40;</span>whiteSpace *&gt; add &lt; * eof<span style="color: green;">&#41;</span> <span style="color: green;">&#40;</span><span style="color: green;">&#41;</span> <span style="color: #3c7331;">&quot;-&quot;</span> s
&nbsp;</pre>
<p>While this approach tends to encourage memoizing fewer combinators than libraries such as frisby, this is exactly what <a href="http://www.mercury.csse.unimelb.edu.au/information/papers/packrat.pdf">current research suggests you probably should do</a> with packrat parsing!</p>
<p>The other purported advantage of packrat parsers is that they <a href="http://www.vpri.org/pdf/tr2007002_packrat.pdf">can deal with left recursion in the grammar</a>. However, that is not the case, hidden left recursion in the presence of the algorithm used in the scala parsing combinator libraries leads to incorrect non-left-most parses <a href="http://tratt.net/laurie/research/publications/papers/tratt__direct_left_recursive_parsing_expression_grammars.pdf">as shown by Tratt</a>.</p>
<p>I leave it as an exercise for the reader to extend this material with the parsec+iteratees approach from my original talk on trifecta to get packrat parsing of streaming input. Either that or you can wait until it is integrated into trifecta.</p>
<p>You can download the source to this (without the spurious spaces inserted by wordpress) <a href="https://github.com/ekmett/trifecta/blob/master/wip/Womprat.hs">here</a>.</p>
<p>If I can find the time, I hope to spend some time addressing Scott and Johnstone's GLL parsers, which actually achieve the O(n^3) worst case bounds touted for Tomita's GLR algorithm (which is actually O(n^4) as it was originally defined despite the author's claims), and how to encode them in Haskell with an eye towards building a memoizing parser combinator library that can parse LL(1) fragments in O(1), deal with arbitrary context-free grammars in O(n^3), and degrade reasonably gracefully in the presence of context-sensitivity, while supporting hidden left recursion as long as such recursion passes through at least one memoized rule. This is important because CFGs are closed under extensions to the grammar, which is a nice property to have if you want to have a language where you can add new statement types easily without concerning yourself overmuch with the order in which you insert the rules or load the different extensions.</p>
</pre>
]]></content:encoded>
			<wfw:commentRss>http://comonad.com/reader/2011/a-parsec-full-of-rats-part-2/feed/</wfw:commentRss>
		<slash:comments>0</slash:comments>
		</item>
		<item>
		<title>A Parsec Full of Rats, Part 1</title>
		<link>http://comonad.com/reader/2011/a-parsec-full-of-rats/</link>
		<comments>http://comonad.com/reader/2011/a-parsec-full-of-rats/#comments</comments>
		<pubDate>Sat, 24 Sep 2011 02:10:06 +0000</pubDate>
		<dc:creator>Edward Kmett</dc:creator>
				<category><![CDATA[Algorithms]]></category>
		<category><![CDATA[Data Structures]]></category>
		<category><![CDATA[Haskell]]></category>
		<category><![CDATA[Monads]]></category>
		<category><![CDATA[Parsing]]></category>
		<category><![CDATA[Uncategorized]]></category>
		<category><![CDATA[packrat]]></category>
		<category><![CDATA[trifecta]]></category>

		<guid isPermaLink="false">http://comonad.com/reader/?p=380</guid>
		<description><![CDATA[You never heard of the Millenium Falcon? It's the ship that made the Kessel Run in 12 parsecs.
I've been working on a parser combinator library called trifecta, and so I decided I'd share some thoughts on parsing. 
Packrat parsing (as provided by frisby, pappy, rats! and the Scala parsing combinators) and more traditional recursive descent [...]]]></description>
			<content:encoded><![CDATA[<blockquote><p>You never heard of the Millenium Falcon? It's the ship that made the Kessel Run in 12 parsecs.</p></blockquote>
<p>I've been working on a parser combinator library called <a href="http://hackage.haskell.org/package/trifecta">trifecta</a>, and so I decided I'd share some thoughts on parsing. </p>
<p><a href="http://pdos.csail.mit.edu/~baford/packrat/">Packrat parsing</a> (as provided by <a href="http://hackage.haskell.org/package/frisby">frisby</a>, <a href="http://hackage.haskell.org/package/pappy">pappy</a>, <a href="http://cs.nyu.edu/rgrimm/xtc/">rats!</a> and the Scala parsing combinators) and more traditional recursive descent parsers (like Parsec) are often held up as somehow different. </p>
<p>Today I'll show that you can add monadic parsing to a packrat parser, sacrificing asymptotic guarantees in exchange for the convenient context sensitivity, and conversely how you can easily add packrat parsing to a traditional monadic parser combinator library.</p>
<p><span id="more-380"></span></p>
<p>To keep this post self-contained, I'm going to start by defining a small packrat parsing library by hand, which acts rather like parsec in its backtracking behavior. First, some imports:</p>
<pre class="haskell">&nbsp;
<span style="color: #5d478b; font-style: italic;">{-# LANGUAGE RecordWildCards, ViewPatterns, DeriveFunctor #-}</span>
<span style="color: #06c; font-weight: bold;">import</span> Control.Applicative
<span style="color: #06c; font-weight: bold;">import</span> Control.<a href="http://haskell.org/ghc/docs/latest/html/libraries/base/Prelude.html#t:Monad"><span style="background-color: #efefbf; font-weight: bold;">Monad</span></a> <span style="color: green;">&#40;</span>MonadPlus<span style="color: green;">&#40;</span>..<span style="color: green;">&#41;</span>, guard<span style="color: green;">&#41;</span>
<span style="color: #06c; font-weight: bold;">import</span> Control.<a href="http://haskell.org/ghc/docs/latest/html/libraries/base/Prelude.html#t:Monad"><span style="background-color: #efefbf; font-weight: bold;">Monad</span></a>.Fix <span style="color: green;">&#40;</span>fix<span style="color: green;">&#41;</span>
<span style="color: #06c; font-weight: bold;">import</span> Data.<a href="http://haskell.org/ghc/docs/latest/html/libraries/base/Prelude.html#t:Char"><span style="background-color: #efefbf; font-weight: bold;">Char</span></a> <span style="color: green;">&#40;</span>isDigit, digitToInt, isSpace<span style="color: green;">&#41;</span>
&nbsp;</pre>
<p>Second, we'll define a bog simple parser, which consumes an input stream of type d, yielding a possible answer and telling us whether or not it has actually consumed any input as it went.</p>
<pre class="haskell">&nbsp;
<span style="color: #06c; font-weight: bold;">newtype</span> Rat d a = Rat <span style="color: green;">&#123;</span> runRat :: d -&gt; Result d a <span style="color: green;">&#125;</span>
  <span style="color: #06c; font-weight: bold;">deriving</span> <a href="http://haskell.org/ghc/docs/latest/html/libraries/base/Prelude.html#t:Functor"><span style="background-color: #efefbf; font-weight: bold;">Functor</span></a>
&nbsp;
<span style="color: #06c; font-weight: bold;">data</span> Result d a
  = Pure a             <span style="color: #5d478b; font-style: italic;">-- didn't consume anything, can backtrack</span>
  | Commit d a      <span style="color: #5d478b; font-style: italic;">-- consumed input</span>
  | Fail <a href="http://haskell.org/ghc/docs/latest/html/libraries/base/Prelude.html#t:String"><span style="background-color: #efefbf; font-weight: bold;">String</span></a> <a href="http://haskell.org/ghc/docs/latest/html/libraries/base/Prelude.html#t:Bool"><span style="background-color: #efefbf; font-weight: bold;">Bool</span></a> <span style="color: #5d478b; font-style: italic;">-- failed, flagged if consumed</span>
  <span style="color: #06c; font-weight: bold;">deriving</span> <a href="http://haskell.org/ghc/docs/latest/html/libraries/base/Prelude.html#t:Functor"><span style="background-color: #efefbf; font-weight: bold;">Functor</span></a>
&nbsp;</pre>
<p>Now, we can finally implement some type classes:</p>
<pre class="haskell">&nbsp;
<span style="color: #06c; font-weight: bold;">instance</span> Applicative <span style="color: green;">&#40;</span>Rat d<span style="color: green;">&#41;</span> <span style="color: #06c; font-weight: bold;">where</span>
  pure a = Rat $ \ _ -&gt; Pure a
  Rat mf &lt; *&gt; Rat ma = Rat $ \ d -&gt; <span style="color: #06c; font-weight: bold;">case</span> mf d <span style="color: #06c; font-weight: bold;">of</span>
    Pure f      -&gt; <a href="http://haskell.org/ghc/docs/latest/html/libraries/base/Prelude.html#v:fmap"><span style="font-weight: bold;">fmap</span></a> f <span style="color: green;">&#40;</span>ma d<span style="color: green;">&#41;</span>
    Fail s c    -&gt; Fail s c
    Commit d' f -&gt; <span style="color: #06c; font-weight: bold;">case</span> ma d' <span style="color: #06c; font-weight: bold;">of</span>
      Pure a       -&gt; Commit d' <span style="color: green;">&#40;</span>f a<span style="color: green;">&#41;</span>
      Fail s _     -&gt; Fail s <a href="http://haskell.org/ghc/docs/latest/html/libraries/base/Prelude.html#v:True"><span style="font-weight: bold;">True</span></a>
      Commit d'' a -&gt; Commit d'' <span style="color: green;">&#40;</span>f a<span style="color: green;">&#41;</span>
&nbsp;</pre>
<p>including an instance of Alternative that behaves like parsec, only backtracking on failure if no input was unconsumed.</p>
<pre class="haskell">&nbsp;
<span style="color: #06c; font-weight: bold;">instance</span> Alternative <span style="color: green;">&#40;</span>Rat d<span style="color: green;">&#41;</span> <span style="color: #06c; font-weight: bold;">where</span>
  Rat ma &lt; |&gt; Rat mb = Rat $ \ d -&gt; <span style="color: #06c; font-weight: bold;">case</span> ma d <span style="color: #06c; font-weight: bold;">of</span>
    Fail _ <a href="http://haskell.org/ghc/docs/latest/html/libraries/base/Prelude.html#v:False"><span style="font-weight: bold;">False</span></a> -&gt; mb d
    x            -&gt; x
  empty = Rat $ \ _ -&gt; Fail <span style="color: #3c7331;">&quot;empty&quot;</span> <a href="http://haskell.org/ghc/docs/latest/html/libraries/base/Prelude.html#v:False"><span style="font-weight: bold;">False</span></a>
&nbsp;</pre>
<p>For those willing to forego the asymptotic guarantees of packrat, we'll offer a monad.</p>
<pre class="haskell">&nbsp;
<span style="color: #06c; font-weight: bold;">instance</span> <a href="http://haskell.org/ghc/docs/latest/html/libraries/base/Prelude.html#t:Monad"><span style="background-color: #efefbf; font-weight: bold;">Monad</span></a> <span style="color: green;">&#40;</span>Rat d<span style="color: green;">&#41;</span> <span style="color: #06c; font-weight: bold;">where</span>
  <a href="http://haskell.org/ghc/docs/latest/html/libraries/base/Prelude.html#v:return"><span style="font-weight: bold;">return</span></a> a = Rat $ \_ -&gt; Pure a
  Rat m &gt;&gt;= k = Rat $ \d -&gt; <span style="color: #06c; font-weight: bold;">case</span> m d <span style="color: #06c; font-weight: bold;">of</span>
    Pure a -&gt; runRat <span style="color: green;">&#40;</span>k a<span style="color: green;">&#41;</span> d
    Commit d' a -&gt; <span style="color: #06c; font-weight: bold;">case</span> runRat <span style="color: green;">&#40;</span>k a<span style="color: green;">&#41;</span> d' <span style="color: #06c; font-weight: bold;">of</span>
      Pure b -&gt; Commit d' b
      Fail s _ -&gt; Fail s <a href="http://haskell.org/ghc/docs/latest/html/libraries/base/Prelude.html#v:True"><span style="font-weight: bold;">True</span></a>
      commit -&gt; commit
    Fail s c -&gt; Fail s c
  <a href="http://haskell.org/ghc/docs/latest/html/libraries/base/Prelude.html#v:fail"><span style="font-weight: bold;">fail</span></a> s = Rat $ \ _ -&gt; Fail s <a href="http://haskell.org/ghc/docs/latest/html/libraries/base/Prelude.html#v:False"><span style="font-weight: bold;">False</span></a>
&nbsp;
<span style="color: #06c; font-weight: bold;">instance</span> MonadPlus <span style="color: green;">&#40;</span>Rat d<span style="color: green;">&#41;</span> <span style="color: #06c; font-weight: bold;">where</span>
  mplus = <span style="color: green;">&#40;</span>&lt; |&gt;<span style="color: green;">&#41;</span>
  mzero = empty
&nbsp;</pre>
<p>and a Parsec-style "try", which rewinds on failure, so that < |> can try again.</p>
<pre class="haskell">&nbsp;
try :: Rat d a -&gt; Rat d a
try <span style="color: green;">&#40;</span>Rat m<span style="color: green;">&#41;</span> = Rat $ \d -&gt; <span style="color: #06c; font-weight: bold;">case</span> m d <span style="color: #06c; font-weight: bold;">of</span>
  Fail s _ -&gt; Fail s <a href="http://haskell.org/ghc/docs/latest/html/libraries/base/Prelude.html#v:False"><span style="font-weight: bold;">False</span></a>
  x        -&gt; x
&nbsp;</pre>
<p>Since we've consumed < |> with parsec semantics. Let's give a PEG-style backtracking (< />).</p>
<pre class="haskell">&nbsp;
<span style="color: green;">&#40;</span>&lt; /&gt;<span style="color: green;">&#41;</span> :: Rat d a -&gt; Rat d a -&gt; Rat d a
p &lt; /&gt; q = try p &lt; |&gt; q
<span style="color: #06c; font-weight: bold;">infixl</span> <span style="color: red;">3</span> &lt; /&gt;
&nbsp;</pre>
<p>So far nothing we have done involves packrat at all. These are all general purpose recursive descent combinators.</p>
<p>We can define an input stream and a number of combinators to read input.</p>
<pre class="haskell">&nbsp;
<span style="color: #06c; font-weight: bold;">class</span> Stream d <span style="color: #06c; font-weight: bold;">where</span>
  anyChar :: Rat d <a href="http://haskell.org/ghc/docs/latest/html/libraries/base/Prelude.html#t:Char"><span style="background-color: #efefbf; font-weight: bold;">Char</span></a>
&nbsp;
whiteSpace :: Stream d =&gt; Rat d <span style="color: green;">&#40;</span><span style="color: green;">&#41;</span>
whiteSpace = <span style="color: green;">&#40;</span><span style="color: green;">&#41;</span> &lt; $ many <span style="color: green;">&#40;</span>satisfy isSpace<span style="color: green;">&#41;</span>
phrase :: Stream d =&gt; Rat d a -&gt; Rat d a
phrase m = whiteSpace *&gt; m &lt; * eof
&nbsp;
notFollowedBy :: Rat d a -&gt; Rat d <span style="color: green;">&#40;</span><span style="color: green;">&#41;</span>
notFollowedBy <span style="color: green;">&#40;</span>Rat m<span style="color: green;">&#41;</span> = Rat $ \d -&gt; <span style="color: #06c; font-weight: bold;">case</span> m d <span style="color: #06c; font-weight: bold;">of</span>
  Fail<span style="color: green;">&#123;</span><span style="color: green;">&#125;</span> -&gt; Pure <span style="color: green;">&#40;</span><span style="color: green;">&#41;</span>
  _      -&gt; Fail <span style="color: #3c7331;">&quot;unexpected&quot;</span> <a href="http://haskell.org/ghc/docs/latest/html/libraries/base/Prelude.html#v:False"><span style="font-weight: bold;">False</span></a>
&nbsp;
eof :: Stream d =&gt; Rat d <span style="color: green;">&#40;</span><span style="color: green;">&#41;</span>
eof = notFollowedBy anyChar
&nbsp;
satisfy :: Stream d =&gt; <span style="color: green;">&#40;</span><a href="http://haskell.org/ghc/docs/latest/html/libraries/base/Prelude.html#t:Char"><span style="background-color: #efefbf; font-weight: bold;">Char</span></a> -&gt; <a href="http://haskell.org/ghc/docs/latest/html/libraries/base/Prelude.html#t:Bool"><span style="background-color: #efefbf; font-weight: bold;">Bool</span></a><span style="color: green;">&#41;</span> -&gt; Rat d <a href="http://haskell.org/ghc/docs/latest/html/libraries/base/Prelude.html#t:Char"><span style="background-color: #efefbf; font-weight: bold;">Char</span></a>
satisfy p = try $ <span style="color: #06c; font-weight: bold;">do</span>
  x &lt; - anyChar
  x &lt;$ guard <span style="color: green;">&#40;</span>p x<span style="color: green;">&#41;</span>
&nbsp;
char :: Stream d =&gt; <a href="http://haskell.org/ghc/docs/latest/html/libraries/base/Prelude.html#t:Char"><span style="background-color: #efefbf; font-weight: bold;">Char</span></a> -&gt; Rat d <a href="http://haskell.org/ghc/docs/latest/html/libraries/base/Prelude.html#t:Char"><span style="background-color: #efefbf; font-weight: bold;">Char</span></a>
char c = satisfy <span style="color: green;">&#40;</span>c ==<span style="color: green;">&#41;</span>
&nbsp;
lexeme :: Stream d =&gt; Rat d a -&gt; Rat d a
lexeme m = m &lt; * whiteSpace
&nbsp;
symbol :: Stream d =&gt; <a href="http://haskell.org/ghc/docs/latest/html/libraries/base/Prelude.html#t:Char"><span style="background-color: #efefbf; font-weight: bold;">Char</span></a> -&gt; Rat d <a href="http://haskell.org/ghc/docs/latest/html/libraries/base/Prelude.html#t:Char"><span style="background-color: #efefbf; font-weight: bold;">Char</span></a>
symbol c = lexeme <span style="color: green;">&#40;</span>char c<span style="color: green;">&#41;</span>
&nbsp;
digit :: Stream d =&gt; Rat d <a href="http://haskell.org/ghc/docs/latest/html/libraries/base/Prelude.html#t:Int"><span style="background-color: #efefbf; font-weight: bold;">Int</span></a>
digit = digitToInt &lt; $&gt; satisfy isDigit
&nbsp;</pre>
<p>And we can of course use a string as our input stream:</p>
<pre class="haskell">&nbsp;
<span style="color: #06c; font-weight: bold;">instance</span> Stream <span style="color: green;">&#91;</span><a href="http://haskell.org/ghc/docs/latest/html/libraries/base/Prelude.html#t:Char"><span style="background-color: #efefbf; font-weight: bold;">Char</span></a><span style="color: green;">&#93;</span> <span style="color: #06c; font-weight: bold;">where</span>
  anyChar = Rat $ \s -&gt; <span style="color: #06c; font-weight: bold;">case</span> s <span style="color: #06c; font-weight: bold;">of</span>
    <span style="color: green;">&#40;</span>x:xs<span style="color: green;">&#41;</span> -&gt; Commit xs x
    <span style="color: green;">&#91;</span><span style="color: green;">&#93;</span> -&gt; Fail <span style="color: #3c7331;">&quot;EOF&quot;</span> <a href="http://haskell.org/ghc/docs/latest/html/libraries/base/Prelude.html#v:False"><span style="font-weight: bold;">False</span></a>
&nbsp;</pre>
<p>Now that we've built a poor man's Parsec, let's do something more interesting. Instead of just using String as out input stream, let's include slots for use in memoizing the results from our various parsers at each location. To keep things concrete, we'll memoize the ArithPackrat.hs example that Bryan Ford used in his initial packrat presentation enriched with some whitespace handling.</p>
<pre class="haskell">&nbsp;
<span style="color: #06c; font-weight: bold;">data</span> D = D
  <span style="color: green;">&#123;</span> _add        :: Result D <a href="http://haskell.org/ghc/docs/latest/html/libraries/base/Prelude.html#t:Int"><span style="background-color: #efefbf; font-weight: bold;">Int</span></a>
  , _mult       :: Result D <a href="http://haskell.org/ghc/docs/latest/html/libraries/base/Prelude.html#t:Int"><span style="background-color: #efefbf; font-weight: bold;">Int</span></a>
  , _primary    :: Result D <a href="http://haskell.org/ghc/docs/latest/html/libraries/base/Prelude.html#t:Int"><span style="background-color: #efefbf; font-weight: bold;">Int</span></a>
  , _decimal    :: Result D <a href="http://haskell.org/ghc/docs/latest/html/libraries/base/Prelude.html#t:Int"><span style="background-color: #efefbf; font-weight: bold;">Int</span></a>
  , anyCharD    :: Result D <a href="http://haskell.org/ghc/docs/latest/html/libraries/base/Prelude.html#t:Char"><span style="background-color: #efefbf; font-weight: bold;">Char</span></a>
  <span style="color: green;">&#125;</span>
&nbsp;</pre>
<p>If you look at the type of each of those functions you'll see that <code>_add :: D -> Result D Int</code>, which is exactly our Rat newtype expects as its argument, we we can bundle them directly:</p>
<pre class="haskell">&nbsp;
&nbsp;
add, mult, primary, decimal :: Rat D <a href="http://haskell.org/ghc/docs/latest/html/libraries/base/Prelude.html#t:Int"><span style="background-color: #efefbf; font-weight: bold;">Int</span></a>
add     = Rat _add
mult    = Rat _mult
primary = Rat _primary
decimal = Rat _decimal
&nbsp;</pre>
<p>We can similarly juse use the character parse result.</p>
<pre class="haskell">&nbsp;
<span style="color: #06c; font-weight: bold;">instance</span> Stream D <span style="color: #06c; font-weight: bold;">where</span>
  anyChar = Rat anyCharD
&nbsp;</pre>
<p>Now we just need to build a D from a String. I'm using view patterns and record wildcards to shrink the amount of repetitive naming.</p>
<pre class="haskell">&nbsp;
parse :: <a href="http://haskell.org/ghc/docs/latest/html/libraries/base/Prelude.html#t:String"><span style="background-color: #efefbf; font-weight: bold;">String</span></a> -&gt; D
parse s = fix $ \d -&gt; <span style="color: #06c; font-weight: bold;">let</span>
  Rat <span style="color: green;">&#40;</span>dv d -&gt; _add<span style="color: green;">&#41;</span> =
        <span style="color: green;">&#40;</span>+<span style="color: green;">&#41;</span> &lt; $&gt; mult &lt; * symbol '+' &lt;*&gt; add
     &lt; /&gt; mult
  Rat <span style="color: green;">&#40;</span>dv d -&gt; _mult<span style="color: green;">&#41;</span> =
        <span style="color: green;">&#40;</span>*<span style="color: green;">&#41;</span> &lt; $&gt; primary &lt; * symbol '*' &lt;*&gt; mult
    &lt; /&gt; primary
  Rat <span style="color: green;">&#40;</span>dv d -&gt; _primary<span style="color: green;">&#41;</span> =
        symbol '<span style="color: green;">&#40;</span>' *&gt; add &lt; * symbol '<span style="color: green;">&#41;</span>'
    &lt;/&gt; decimal
  Rat <span style="color: green;">&#40;</span>dv d -&gt; _decimal<span style="color: green;">&#41;</span> =
     <a href="http://haskell.org/ghc/docs/latest/html/libraries/base/Prelude.html#v:foldl"><span style="font-weight: bold;">foldl</span></a>' <span style="color: green;">&#40;</span>\b a -&gt; b * <span style="color: red;">10</span> + a<span style="color: green;">&#41;</span> <span style="color: red;">0</span> &lt; $&gt; lexeme <span style="color: green;">&#40;</span>some digit<span style="color: green;">&#41;</span>
  anyCharD = <span style="color: #06c; font-weight: bold;">case</span> s <span style="color: #06c; font-weight: bold;">of</span>
    <span style="color: green;">&#40;</span>x:xs<span style="color: green;">&#41;</span> -&gt; Commit <span style="color: green;">&#40;</span>parse xs<span style="color: green;">&#41;</span> x
    <span style="color: green;">&#91;</span><span style="color: green;">&#93;</span>     -&gt; Fail <span style="color: #3c7331;">&quot;EOF&quot;</span> <a href="http://haskell.org/ghc/docs/latest/html/libraries/base/Prelude.html#v:False"><span style="font-weight: bold;">False</span></a>
  <span style="color: #06c; font-weight: bold;">in</span> D <span style="color: green;">&#123;</span> .. <span style="color: green;">&#125;</span>
&nbsp;
dv :: d -&gt; <span style="color: green;">&#40;</span>d -&gt; b<span style="color: green;">&#41;</span> -&gt; b
dv d f = f d
&nbsp;</pre>
<p>Note that we didn't really bother factoring the grammar, since packrat will take care of memoizing the redundant calls!</p>
<p>And with that, we can define an evaluator.</p>
<pre class="haskell">&nbsp;
eval :: <a href="http://haskell.org/ghc/docs/latest/html/libraries/base/Prelude.html#t:String"><span style="background-color: #efefbf; font-weight: bold;">String</span></a> -&gt; <a href="http://haskell.org/ghc/docs/latest/html/libraries/base/Prelude.html#t:Int"><span style="background-color: #efefbf; font-weight: bold;">Int</span></a>
eval s = <span style="color: #06c; font-weight: bold;">case</span> runRat <span style="color: green;">&#40;</span>whiteSpace *&gt; add &lt; * eof<span style="color: green;">&#41;</span> <span style="color: green;">&#40;</span>parse s<span style="color: green;">&#41;</span> <span style="color: #06c; font-weight: bold;">of</span>
  Pure a -&gt; a
  Commit _ a -&gt; a
  Fail s _ -&gt; <a href="http://haskell.org/ghc/docs/latest/html/libraries/base/Prelude.html#v:error"><span style="font-weight: bold;">error</span></a> s
&nbsp;</pre>
<p>Note that because the input stream D contains the result directly and parse is the only thing that ever generates a D, and it does so when we start up, it should be obvious that the parse results for each location can't depend on any additional information smuggled in via our monad.</p>
<p>Next time, we'll add a packratted Stream type directly to Parsec, which will necessitate some delicate handling of user state.</p>
<p>The small parser implemented here can be <a href="https://github.com/ekmett/trifecta/blob/master/wip/Rat.hs">found on my github account</a>, where it hasn't been adulterated with unnecessary spaces by my blog software.</p>
<p>P.S. To explain the quote, had I thought of it earlier, I could have named my parsing combinator library "Kessel Run" as by the time I'm done with it "it will contain at least 12 parsecs" between its different parser implementations.</p>
]]></content:encoded>
			<wfw:commentRss>http://comonad.com/reader/2011/a-parsec-full-of-rats/feed/</wfw:commentRss>
		<slash:comments>2</slash:comments>
		</item>
		<item>
		<title>The Pointed-Set Comonad</title>
		<link>http://comonad.com/reader/2008/the-pointed-set-comonad/</link>
		<comments>http://comonad.com/reader/2008/the-pointed-set-comonad/#comments</comments>
		<pubDate>Thu, 04 Dec 2008 18:56:15 +0000</pubDate>
		<dc:creator>Edward Kmett</dc:creator>
				<category><![CDATA[Comonads]]></category>
		<category><![CDATA[Haskell]]></category>
		<category><![CDATA[Uncategorized]]></category>

		<guid isPermaLink="false">http://comonad.com/reader/2008/the-pointed-set-comonad/</guid>
		<description><![CDATA[Last night, Chung-Chieh Shan posted an example of a pointed-set monad on his blog, which happens to be isomorphic to a non-empty stream monad with a different emphasis. 
But, I thought I should point out that the pointed set that he posted also has a comonadic structure, which may be exploited since it is just [...]]]></description>
			<content:encoded><![CDATA[<p>Last night, Chung-Chieh Shan posted an example of a <a href="http://conway.rutgers.edu/~ccshan/wiki/blog/posts/Pointed_set/">pointed-set monad</a> on his blog, which happens to be isomorphic to a non-empty stream monad with a different emphasis. </p>
<p>But, I thought I should point out that the pointed set that he posted also has a comonadic structure, which may be exploited since it is just a variation on the "zipper comonad," a structure that is perhaps more correctly called a "pointing comonad."</p>
<p><span id="more-80"></span></p>
<p>But first, a little background:</p>
<p>With <a href="http://en.wikipedia.org/wiki/Combinatorial_species">combinatorial species</a> you point a data structure by marking a single element in it as special. We can represent that with the product of an element and the <a href="http://en.wikipedia.org/wiki/Derivative_(generalizations)#Set_theory_and_logic">derivative</a> of the original type.</p>
<pre>
F*[A] = A * F'[A]
</pre>
<p>So, then looking at Shan's pointed set, we can ask what combinatorial species has a list as its derivative? </p>
<p>The answer is a cycle, not a set. </p>
<p>This fact doesn't matter to the monad, since the only way a monadic action interacts with that extra structure is safely through bind, but does for the comonad where every comonadic action has access to that structure, but no control over the shape of the result.</p>
<p>However, we don't really have a way to represent an unordered set in Haskell, so if you are treating a list as a set, the derivative of a set is another set then we can also view the a * [a] as a pointed set, so long as we don't depend on the order of the elements in the list in any way in obtaining the result of our comonadic actions.</p>
<p>I've changed the name of his data type to <code>PointedSet</code> to avoid conflicting with the definitions of <code>Pointed</code> and <code>Copointed</code> functors in category extras.</p>
<pre class="haskell">&nbsp;
<span style="color: #06c; font-weight: bold;">module</span> PointedSet <span style="color: #06c; font-weight: bold;">where</span>
&nbsp;
<span style="color: #06c; font-weight: bold;">import</span> Control.<a href="http://comonad.com/haskell/category-extras/dist/doc/html/category-extras/Control-Comonad.html#t:Comonad"><span style="background-color: #efefbf; font-weight: bold;">Comonad</span></a> <span style="color: #5d478b; font-style: italic;">-- from my category-extras library</span>
<span style="color: #06c; font-weight: bold;">import</span> Data.List <span style="color: green;">&#40;</span>inits,tails<span style="color: green;">&#41;</span> <span style="color: #5d478b; font-style: italic;">-- used much later below</span>
&nbsp;
<span style="color: #06c; font-weight: bold;">data</span> PointedSet a = PointedSet a <span style="color: green;">&#91;</span>a<span style="color: green;">&#93;</span> <span style="color: #06c; font-weight: bold;">deriving</span> <span style="color: green;">&#40;</span><a href="http://haskell.org/ghc/docs/latest/html/libraries/base/Prelude.html#t:Eq"><span style="background-color: #efefbf; font-weight: bold;">Eq</span></a>, <a href="http://haskell.org/ghc/docs/latest/html/libraries/base/Prelude.html#t:Ord"><span style="background-color: #efefbf; font-weight: bold;">Ord</span></a>, <a href="http://haskell.org/ghc/docs/latest/html/libraries/base/Prelude.html#t:Show"><span style="background-color: #efefbf; font-weight: bold;">Show</span></a>, <a href="http://haskell.org/ghc/docs/latest/html/libraries/base/Prelude.html#t:Read"><span style="background-color: #efefbf; font-weight: bold;">Read</span></a><span style="color: green;">&#41;</span>
&nbsp;
<span style="color: #06c; font-weight: bold;">instance</span> <a href="http://haskell.org/ghc/docs/latest/html/libraries/base/Prelude.html#t:Functor"><span style="background-color: #efefbf; font-weight: bold;">Functor</span></a> PointedSet <span style="color: #06c; font-weight: bold;">where</span>
    <a href="http://haskell.org/ghc/docs/latest/html/libraries/base/Prelude.html#v:fmap"><span style="font-weight: bold;">fmap</span></a> f <span style="color: green;">&#40;</span>PointedSet x xs<span style="color: green;">&#41;</span> = PointedSet <span style="color: green;">&#40;</span>f x<span style="color: green;">&#41;</span> $ <a href="http://haskell.org/ghc/docs/latest/html/libraries/base/Prelude.html#v:fmap"><span style="font-weight: bold;">fmap</span></a> f xs
&nbsp;</pre>
<p>The definition for extract is obvious, since you have already selected a point, just return it. </p>
<pre class="haskell">&nbsp;
<span style="color: #06c; font-weight: bold;">instance</span> Copointed PointedSet <span style="color: #06c; font-weight: bold;">where</span>
    <a href="http://comonad.com/haskell/category-extras/dist/doc/html/category-extras/Control-Comonad.html#v:extract"><span style="font-weight: bold;">extract</span></a> <span style="color: green;">&#40;</span>PointedSet x _<span style="color: green;">&#41;</span> = x
&nbsp;</pre>
<p>On the other hand, for duplicate we have a couple of options. An obvious and correct, but boring implementation transforms a value as follows:</p>
<pre class="haskell">&nbsp;
boring_duplicate :: PointedSet a -&gt; PointedSet <span style="color: green;">&#40;</span>PointedSet a<span style="color: green;">&#41;</span>
boring_duplicate xxs@<span style="color: green;">&#40;</span>PointedSet x xs<span style="color: green;">&#41;</span> =
    PointedSet xxs $ <a href="http://haskell.org/ghc/docs/latest/html/libraries/base/Prelude.html#v:fmap"><span style="font-weight: bold;">fmap</span></a> <span style="color: green;">&#40;</span><a href="http://haskell.org/ghc/docs/latest/html/libraries/base/Prelude.html#v:flip"><span style="font-weight: bold;">flip</span></a> PointedSet <span style="color: green;">&#91;</span><span style="color: green;">&#93;</span><span style="color: green;">&#41;</span> xs
&nbsp;</pre>
<pre class="haskell">&nbsp;
*PointedSet&gt; boring_duplicate $ PointedSet <span style="color: red;">0</span> <span style="color: green;">&#91;</span><span style="color: red;">1</span>..<span style="color: red;">3</span><span style="color: green;">&#93;</span>
PointedSet <span style="color: green;">&#40;</span>PointedSet <span style="color: red;">0</span> <span style="color: green;">&#91;</span><span style="color: red;">1</span>..<span style="color: red;">3</span><span style="color: green;">&#93;</span><span style="color: green;">&#41;</span> <span style="color: green;">&#91;</span>
    PointedSet <span style="color: red;">1</span> <span style="color: green;">&#91;</span><span style="color: green;">&#93;</span>,
    PointedSet <span style="color: red;">2</span> <span style="color: green;">&#91;</span><span style="color: green;">&#93;</span>,
    PointedSet <span style="color: red;">3</span> <span style="color: green;">&#91;</span><span style="color: green;">&#93;</span>
<span style="color: green;">&#93;</span>
&nbsp;</pre>
<p>but that just abuses the fact that we can always return an empty list. </p>
<p>Another fairly boring interpretation is to just use the guts of the definition of the Stream comonad, but that doesn't model a set with a single memory singled out.</p>
<p>A more interesting version refocuses on each element of the list in turn, which makes the connection to the zipper comonad much more obvious. Since we want a pointed set and not a pointed cycle, we can focus on an element just by swapping out the element in the list in that position for the focus.</p>
<p>Again, since we can't specify general species in Haskell, this is as close as we can come to the correct comonadic structure for a pointed set. Due to the limitations of our type system, the comonadic action can still see the order of elements in the set, but it shouldn't use that information. </p>
<p>Since we don't care to preserve the order of the miscellaneous set elements, the <code>refocus</code> helper function below can just accumulate preceding elements in an accumulating parameter in reverse order.</p>
<pre class="haskell">&nbsp;
<span style="color: #06c; font-weight: bold;">instance</span> <a href="http://comonad.com/haskell/category-extras/dist/doc/html/category-extras/Control-Comonad.html#t:Comonad"><span style="background-color: #efefbf; font-weight: bold;">Comonad</span></a> PointedSet <span style="color: #06c; font-weight: bold;">where</span>
    <a href="http://comonad.com/haskell/category-extras/dist/doc/html/category-extras/Control-Comonad.html#v:duplicate"><span style="font-weight: bold;">duplicate</span></a> xxs@<span style="color: green;">&#40;</span>PointedSet x xs<span style="color: green;">&#41;</span> = PointedSet xxs $ refocus <span style="color: green;">&#91;</span><span style="color: green;">&#93;</span> x xs
      <span style="color: #06c; font-weight: bold;">where</span>
        refocus :: <span style="color: green;">&#91;</span>a<span style="color: green;">&#93;</span> -&gt; a -&gt; <span style="color: green;">&#91;</span>a<span style="color: green;">&#93;</span> -&gt; <span style="color: green;">&#91;</span>PointedSet a<span style="color: green;">&#93;</span>
        refocus acc x <span style="color: green;">&#40;</span>y:ys<span style="color: green;">&#41;</span> =
            PointedSet y <span style="color: green;">&#40;</span>acc ++ <span style="color: green;">&#40;</span>x:ys<span style="color: green;">&#41;</span><span style="color: green;">&#41;</span> : refocus <span style="color: green;">&#40;</span>y:acc<span style="color: green;">&#41;</span> x ys
        refocus acc x <span style="color: green;">&#91;</span><span style="color: green;">&#93;</span> = <span style="color: green;">&#91;</span><span style="color: green;">&#93;</span>
&nbsp;</pre>
<p>Now,</p>
<pre class="haskell">&nbsp;
*PointedSet&gt; <a href="http://comonad.com/haskell/category-extras/dist/doc/html/category-extras/Control-Comonad.html#v:duplicate"><span style="font-weight: bold;">duplicate</span></a> $ PointedSet <span style="color: red;">0</span> <span style="color: green;">&#91;</span><span style="color: red;">1</span>..<span style="color: red;">3</span><span style="color: green;">&#93;</span> =
PointedSet <span style="color: green;">&#40;</span>PointedSet <span style="color: red;">0</span> <span style="color: green;">&#91;</span><span style="color: red;">1</span>,<span style="color: red;">2</span>,<span style="color: red;">3</span><span style="color: green;">&#93;</span><span style="color: green;">&#41;</span> <span style="color: green;">&#91;</span>
    PointedSet <span style="color: red;">1</span> <span style="color: green;">&#91;</span><span style="color: red;">0</span>,<span style="color: red;">2</span>,<span style="color: red;">3</span><span style="color: green;">&#93;</span>,
    PointedSet <span style="color: red;">2</span> <span style="color: green;">&#91;</span><span style="color: red;">1</span>,<span style="color: red;">0</span>,<span style="color: red;">3</span><span style="color: green;">&#93;</span>,
    PointedSet <span style="color: red;">3</span> <span style="color: green;">&#91;</span><span style="color: red;">2</span>,<span style="color: red;">1</span>,<span style="color: red;">0</span><span style="color: green;">&#93;</span>
<span style="color: green;">&#93;</span>
&nbsp;</pre>
<p>With that in hand we can define comonadic actions that can look at an entire <code>PointedSet</code> and return a value, then extend them comonadically to generate new pointed sets.</p>
<p>For instance, if we had a numerical pointed set and wanted to blur our focus somewhat we could weight an average between the focused and unfocused elements:</p>
<pre>
smooth :: Fractional a => a -> PointedSet a -> a
smooth w (PointedSet a as) =
    w * a +
    (1 - w) * sum as / fromIntegral (length as)
</pre>
<p>Smoothing is a safe pointed-set comonadic operation because it doesn't care about the order of the elements in the list.</p>
<p>And so now we can blur the distinction between the focused element and the rest of the set: </p>
<pre class="haskell">&nbsp;
*PointedSet&gt; <a href="http://comonad.com/haskell/category-extras/dist/doc/html/category-extras/Control-Comonad.html#v:extend"><span style="font-weight: bold;">extend</span></a> <span style="color: green;">&#40;</span>smooth <span style="color: red;">0.5</span><span style="color: green;">&#41;</span> $ PointedSet <span style="color: red;">10</span> <span style="color: green;">&#91;</span><span style="color: red;">1</span>..<span style="color: red;">5</span><span style="color: green;">&#93;</span>
PointedSet <span style="color: red;">6.5</span> <span style="color: green;">&#91;</span><span style="color: red;">2.9</span>,<span style="color: red;">3.3</span>,<span style="color: red;">3.7</span>,<span style="color: red;">4.1</span>,<span style="color: red;">4.5</span><span style="color: green;">&#93;</span>
&nbsp;</pre>
<p>A quick pass over the comonad laws shows that they all check out.</p>
<p>As noted above, if your comonadic action uses the order of the elements in the list beyond the selection of the focus, then it isn't really a valid pointed set comonadic operation. This is because we are abusing a list to approximate a (multi)set.</p>
<p><b>The Pointed-Cycle Comonad</b></p>
<p>A slight variation on this theme keeps the order of the elements the same in exchange for a more expensive refocusing operation and just rotates them through the focus. </p>
<pre class="haskell">&nbsp;
<span style="color: #06c; font-weight: bold;">data</span> PointedCycle a = PointedCycle a <span style="color: green;">&#91;</span>a<span style="color: green;">&#93;</span> <span style="color: #06c; font-weight: bold;">deriving</span> <span style="color: green;">&#40;</span><a href="http://haskell.org/ghc/docs/latest/html/libraries/base/Prelude.html#t:Eq"><span style="background-color: #efefbf; font-weight: bold;">Eq</span></a>, <a href="http://haskell.org/ghc/docs/latest/html/libraries/base/Prelude.html#t:Ord"><span style="background-color: #efefbf; font-weight: bold;">Ord</span></a>, <a href="http://haskell.org/ghc/docs/latest/html/libraries/base/Prelude.html#t:Show"><span style="background-color: #efefbf; font-weight: bold;">Show</span></a>,<a href="http://haskell.org/ghc/docs/latest/html/libraries/base/Prelude.html#t:Read"><span style="background-color: #efefbf; font-weight: bold;">Read</span></a><span style="color: green;">&#41;</span>
&nbsp;
<span style="color: #06c; font-weight: bold;">instance</span> <a href="http://haskell.org/ghc/docs/latest/html/libraries/base/Prelude.html#t:Functor"><span style="background-color: #efefbf; font-weight: bold;">Functor</span></a> PointedCycle <span style="color: #06c; font-weight: bold;">where</span>
    <a href="http://haskell.org/ghc/docs/latest/html/libraries/base/Prelude.html#v:fmap"><span style="font-weight: bold;">fmap</span></a> f <span style="color: green;">&#40;</span>PointedCycle x xs<span style="color: green;">&#41;</span> = PointedCycle <span style="color: green;">&#40;</span>f x<span style="color: green;">&#41;</span> $ <a href="http://haskell.org/ghc/docs/latest/html/libraries/base/Prelude.html#v:fmap"><span style="font-weight: bold;">fmap</span></a> f xs
&nbsp;
<span style="color: #06c; font-weight: bold;">instance</span> Copointed PointedCycle <span style="color: #06c; font-weight: bold;">where</span>
    <a href="http://comonad.com/haskell/category-extras/dist/doc/html/category-extras/Control-Comonad.html#v:extract"><span style="font-weight: bold;">extract</span></a> <span style="color: green;">&#40;</span>PointedCycle x _<span style="color: green;">&#41;</span> = x
&nbsp;
<span style="color: #06c; font-weight: bold;">instance</span> <a href="http://comonad.com/haskell/category-extras/dist/doc/html/category-extras/Control-Comonad.html#t:Comonad"><span style="background-color: #efefbf; font-weight: bold;">Comonad</span></a> PointedCycle <span style="color: #06c; font-weight: bold;">where</span>
   <a href="http://comonad.com/haskell/category-extras/dist/doc/html/category-extras/Control-Comonad.html#v:duplicate"><span style="font-weight: bold;">duplicate</span></a> xxs@<span style="color: green;">&#40;</span>PointedCycle x xs<span style="color: green;">&#41;</span> =
        PointedCycle xxs . <a href="http://haskell.org/ghc/docs/latest/html/libraries/base/Prelude.html#v:fmap"><span style="font-weight: bold;">fmap</span></a> listToCycle . <a href="http://haskell.org/ghc/docs/latest/html/libraries/base/Prelude.html#v:tail"><span style="font-weight: bold;">tail</span></a> $ rotations <span style="color: green;">&#40;</span>x:xs<span style="color: green;">&#41;</span>
     <span style="color: #06c; font-weight: bold;">where</span>
        rotations :: <span style="color: green;">&#91;</span>a<span style="color: green;">&#93;</span> -&gt; <span style="color: green;">&#91;</span><span style="color: green;">&#91;</span>a<span style="color: green;">&#93;</span><span style="color: green;">&#93;</span>
        rotations xs = <a href="http://haskell.org/ghc/docs/latest/html/libraries/base/Prelude.html#v:init"><span style="font-weight: bold;">init</span></a> $ <a href="http://haskell.org/ghc/docs/latest/html/libraries/base/Prelude.html#v:zipWith"><span style="font-weight: bold;">zipWith</span></a> <span style="color: green;">&#40;</span>++<span style="color: green;">&#41;</span> <span style="color: green;">&#40;</span>tails xs<span style="color: green;">&#41;</span> <span style="color: green;">&#40;</span>inits xs<span style="color: green;">&#41;</span>
        listToCycle <span style="color: green;">&#40;</span>x:xs<span style="color: green;">&#41;</span> = PointedCycle x xs
&nbsp;</pre>
<p>With that you acknowledge that you really have a pointed cycle and the writer of the comonadic action can safely use the ordering information intrinsic to the list as a natural consequence of having taken the derivative of a cycle.</p>
<pre class="haskell">&nbsp;
*PointedSet&gt; <a href="http://comonad.com/haskell/category-extras/dist/doc/html/category-extras/Control-Comonad.html#v:duplicate"><span style="font-weight: bold;">duplicate</span></a> $ PointedCycle <span style="color: red;">0</span> <span style="color: green;">&#91;</span><span style="color: red;">1</span>..<span style="color: red;">3</span><span style="color: green;">&#93;</span>
PointedCycle <span style="color: green;">&#40;</span>PointedCycle <span style="color: red;">0</span> <span style="color: green;">&#91;</span><span style="color: red;">1</span>,<span style="color: red;">2</span>,<span style="color: red;">3</span><span style="color: green;">&#93;</span><span style="color: green;">&#41;</span> <span style="color: green;">&#91;</span>
    PointedCycle <span style="color: red;">1</span> <span style="color: green;">&#91;</span><span style="color: red;">2</span>,<span style="color: red;">3</span>,<span style="color: red;">0</span><span style="color: green;">&#93;</span>,
    PointedCycle <span style="color: red;">2</span> <span style="color: green;">&#91;</span><span style="color: red;">3</span>,<span style="color: red;">0</span>,<span style="color: red;">1</span><span style="color: green;">&#93;</span>,
    PointedCycle <span style="color: red;">3</span> <span style="color: green;">&#91;</span><span style="color: red;">0</span>,<span style="color: red;">1</span>,<span style="color: red;">2</span><span style="color: green;">&#93;</span>
<span style="color: green;">&#93;</span>
&nbsp;</pre>
]]></content:encoded>
			<wfw:commentRss>http://comonad.com/reader/2008/the-pointed-set-comonad/feed/</wfw:commentRss>
		<slash:comments>3</slash:comments>
		</item>
		<item>
		<title>Still Alive</title>
		<link>http://comonad.com/reader/2008/still-alive/</link>
		<comments>http://comonad.com/reader/2008/still-alive/#comments</comments>
		<pubDate>Sat, 08 Nov 2008 14:45:45 +0000</pubDate>
		<dc:creator>Edward Kmett</dc:creator>
				<category><![CDATA[Uncategorized]]></category>

		<guid isPermaLink="false">http://comonad.com/reader/2008/still-alive/</guid>
		<description><![CDATA[To those that have asked, I'm still alive. 
I had to restore the blog database from a backup and so I lost a few posts, including the index for the various recursion schemes entries. Fortunately, before that happened I had replicated the catamorphism post as a knol.
Should I find myself with a copious glut of [...]]]></description>
			<content:encoded><![CDATA[<p>To those that have asked, I'm still alive. </p>
<p>I had to restore the blog database from a backup and so I lost a few posts, including the index for the various recursion schemes entries. Fortunately, before that happened I had replicated the <a href="http://knol.google.com/k/edward-kmett/catamorphisms/">catamorphism post as a knol</a>.</p>
<p>Should I find myself with a copious glut of free time, I shall happily re-scribe and finish the rest, but I've been very busy. </p>
]]></content:encoded>
			<wfw:commentRss>http://comonad.com/reader/2008/still-alive/feed/</wfw:commentRss>
		<slash:comments>6</slash:comments>
		</item>
		<item>
		<title>Forgetful Laziness</title>
		<link>http://comonad.com/reader/2008/forgetful-laziness/</link>
		<comments>http://comonad.com/reader/2008/forgetful-laziness/#comments</comments>
		<pubDate>Fri, 16 May 2008 22:25:06 +0000</pubDate>
		<dc:creator>Edward Kmett</dc:creator>
				<category><![CDATA[Haskell]]></category>
		<category><![CDATA[Uncategorized]]></category>

		<guid isPermaLink="false">http://comonad.com/reader/2008/forgetful-laziness/</guid>
		<description><![CDATA[Does anyone know of any work on "forgetful laziness?"

The basic idea being that for each thunk instead of overwriting it with the answer as usual in call-by-need, you'd just write a forwarding pointer, and allow GC to collect the answers over time. 
This results in recalculation and may be subject to thrashing, so the obvious [...]]]></description>
			<content:encoded><![CDATA[<p>Does anyone know of any work on "forgetful laziness?"</p>
<p><span id="more-59"></span></p>
<p>The basic idea being that for each thunk instead of overwriting it with the answer as usual in call-by-need, you'd just write a forwarding pointer, and allow GC to collect the answers over time. </p>
<p>This results in recalculation and may be subject to thrashing, so the obvious fix would be either</p>
<ol>
<li> a 'forget at most once' policy, which would only mitigate the kind of memory leaks you get from laziness under limited conditions, but which has a worst case payout of doubling the workload or
</li>
<li> an exponential backoff on how often you'll try to recollect a given value, which should preserve for practical purposes the asymptotic behavior of any algorithm, but with a much larger constant for pathological access patterns. [Edit: it may affect asymptotic behavior, because you could lose sharing]
</li>
</ol>
<p>This would allow the recollection of large CAFs, etc. eventually once they had bitrotted long enough. </p>
<p>Not sure if its worth the cost of recalculating and of storing any backoff counter, but most of the horror stories you hear about Haskell center around its occasional horrific memory usage profile.</p>
<p>Tuning points might include studying average thunk lifetimes to construct thunk access profiles rather than use a naive exponential backoff.</p>
<p>It also may exascerbate the opposite problem where naive code often builds up a tower of thunks it needs to evaluate all at once in order to provide an answer (i.e. when working with a lazy accumulating parameter).</p>
]]></content:encoded>
			<wfw:commentRss>http://comonad.com/reader/2008/forgetful-laziness/feed/</wfw:commentRss>
		<slash:comments>6</slash:comments>
		</item>
	</channel>
</rss>
