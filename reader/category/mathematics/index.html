<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head profile="http://gmpg.org/xfn/11">
	<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
	<title>The Comonad.Reader &raquo; Mathematics</title>
	<meta name="generator" content="WordPress 2.8.4" /> <!-- leave this for stats please -->
	<style type="text/css" media="screen">
		@import url( ../../wp-content/themes/connections/style.css );
	</style>
        <link rel="openid.server" href="https://api.screenname.aol.com/auth/openidServer"/>
        <link rel="openid.delegate" href="http://openid.aol.com/edwardallankmett"/>
	<link rel="alternate" type="application/rss+xml" title="RSS 2.0" href="../../feed/index.html" />
	<link rel="alternate" type="application/atom+xml" title="Atom 0.3" href="../../feed/atom/index.html" />
	<link rel="pingback" href="../../xmlrpc.php.html" />
        <link rel="shortcut icon" href="../../wp-content/themes/connections/favicon.ico" />
        	<link rel='archives' title='September 2012' href='../../2012/09/index.html' />
	<link rel='archives' title='August 2012' href='../../2012/08/index.html' />
	<link rel='archives' title='June 2012' href='../../2012/06/index.html' />
	<link rel='archives' title='May 2012' href='../../2012/05/index.html' />
	<link rel='archives' title='April 2012' href='../../2012/04/index.html' />
	<link rel='archives' title='December 2011' href='../../2011/12/index.html' />
	<link rel='archives' title='November 2011' href='../../2011/11/index.html' />
	<link rel='archives' title='October 2011' href='../../2011/10/index.html' />
	<link rel='archives' title='September 2011' href='../../2011/09/index.html' />
	<link rel='archives' title='July 2011' href='../../2011/07/index.html' />
	<link rel='archives' title='June 2011' href='../../2011/06/index.html' />
	<link rel='archives' title='July 2010' href='../../2010/07/index.html' />
	<link rel='archives' title='May 2010' href='../../2010/05/index.html' />
	<link rel='archives' title='April 2010' href='../../2010/04/index.html' />
	<link rel='archives' title='September 2009' href='../../2009/09/index.html' />
	<link rel='archives' title='August 2009' href='../../2009/08/index.html' />
	<link rel='archives' title='July 2009' href='../../2009/07/index.html' />
	<link rel='archives' title='June 2009' href='../../2009/06/index.html' />
	<link rel='archives' title='March 2009' href='../../2009/03/index.html' />
	<link rel='archives' title='December 2008' href='../../2008/12/index.html' />
	<link rel='archives' title='November 2008' href='../../2008/11/index.html' />
	<link rel='archives' title='June 2008' href='../../2008/06/index.html' />
	<link rel='archives' title='May 2008' href='../../2008/05/index.html' />
	<link rel='archives' title='April 2008' href='../../2008/04/index.html' />
	<link rel='archives' title='March 2008' href='../../2008/03/index.html' />
	<link rel='archives' title='January 2008' href='../../2008/01/index.html' />
	<link rel='archives' title='July 2007' href='../../2007/07/index.html' />
	<link rel='archives' title='May 2007' href='../../2007/05/index.html' />
	<link rel='archives' title='November 2006' href='../../2006/11/index.html' />
	<link rel='archives' title='October 2006' href='../../2006/10/index.html' />
	<link rel="alternate" type="application/rss+xml" title="The Comonad.Reader &raquo; Mathematics Category Feed" href="feed/index.html" />
<link rel="EditURI" type="application/rsd+xml" title="RSD" href="../../xmlrpc-rsd.php.html" />
<link rel="wlwmanifest" type="application/wlwmanifest+xml" href="../../wp-includes/wlwmanifest.xml" /> 
<link rel='index' title='The Comonad.Reader' href='../../index.html' />
<meta name="generator" content="WordPress 2.8.4" />
</head>

<body id="archives">
<div id="rap">
	<div id="header">
	<ul id="topnav">
		<li><a href="../../index.html" id="navHome" title="Posted Recently" accesskey="h">Home |</a></li>
		<li><a href="../../about/index.html" id="navAbout" title="About the Author" accesskey="a">About |</a></li>
		<li><a href="../../source/index-item=libraries.html" id="navSource" title="Source Code" accesskey="s">Source |</a></li>
		<li><a href="mailto:ekmett@gmail.com" id="navContact" title="Contact the Author" accesskey="c">Contact </a></li>
	</ul>
	<a href="../../index.html" id="logoHome" title="Posted Recently"><img id="logo" src="../../pngbehavior/blank.gif" ></a>
	<h1><a href="../../index.html" title="The Comonad.Reader">The Comonad.Reader</a></h1>		
	<div id="desc">types, (co)monads, substructural logic</div>
</div>
	
	<div id="main">
	<div id="content">
<div id="fpjobs">
<!-- Begin Functional Jobs Affiliate Code -->
<script type="text/javascript" class="fja" src="https://d1ih2qjlwy0iio.cloudfront.net/static/js/affiliates.min.js">
{
        "api_key":"86dec4630f050b0e692605e1e2f90eef",
        "size":"480x60"
}
</script>
<noscript>
        <strong><a href="http://functionaljobs.com">Functional Jobs</a></strong>&mdash;Dream Jobs for Functional Programmers
</noscript>
<!-- End Functional Jobs Affiliate Code -->
</div>

					<h3>Mathematics</h3>
			<div class="post-info">Archived Posts from this Category</div>		
			<br/>				
							
				<div class="post">
					<p class="post-date">Sat 22 Sep 2012</p>
<div class="post-info"><h2 class="post-title"><a href="../../2012/unnatural-transformations-and-quantifiers/index.html" rel="bookmark" title="Permanent Link: Unnatural Transformations and Quantifiers">Unnatural Transformations and Quantifiers</a></h2>
Posted by Dan Doel under <a href="../category-theory/index.html" title="View all posts in Category Theory" rel="category tag">Category Theory</a> ,  <a href="../haskell/index.html" title="View all posts in Haskell" rel="category tag">Haskell</a> ,  <a href="../kan-extensions/index.html" title="View all posts in Kan Extensions" rel="category tag">Kan Extensions</a> ,  <a href="index.html" title="View all posts in Mathematics" rel="category tag">Mathematics</a> ,  <a href="../monads/index.html" title="View all posts in Monads" rel="category tag">Monads</a> <br/><a href="../../2012/unnatural-transformations-and-quantifiers/index.html#comments" title="Comment on Unnatural Transformations and Quantifiers">[2] Comments</a>&nbsp;</div>
<div class="post-content">
	<p>Recently, a fellow in category land <a href="http://golem.ph.utexas.edu/category/2012/09/where_do_monads_come_from.html">discovered</a> a fact that we in Haskell land have actually known for a while (in addition to things most of us probably don't). Specifically, given two categories <img src='../../../latex/db5f7b3e9934fbc5a2859d88c4ba84a3.png' title='$\mathcal{C}$' alt='$\mathcal{C}$' align=absmiddle> and <img src='../../../latex/eaf85f2b753a4c7585def4cc7ecade43.png' title='$\mathcal{D}$' alt='$\mathcal{D}$' align=absmiddle>, a functor <img src='../../../latex/28408c9aaded61e50623807633e3ce37.png' title='$G : \mathcal{C} \rightarrow \mathcal{D}$' alt='$G : \mathcal{C} \rightarrow \mathcal{D}$' align=absmiddle>, and provided some conditions in <img src='../../../latex/eaf85f2b753a4c7585def4cc7ecade43.png' title='$\mathcal{D}$' alt='$\mathcal{D}$' align=absmiddle> hold, there exists a monad <img src='../../../latex/e049fb90e6d941ff5046ca1c48041c8b.png' title='$T^G$' alt='$T^G$' align=absmiddle>, the codensity monad of <img src='../../../latex/5201385589993766eea584cd3aa6fa13.png' title='$G$' alt='$G$' align=absmiddle>.</p>
<p>In category theory, the codensity monad is given by the rather frightening expression:</p>
<p><img src='../../../latex/050bb5034bed82159df4c52c89c07f3c.png' title='$ T^G(a) = \int_r \left[\mathcal{D}(a, Gr), Gr\right] $' alt='$ T^G(a) = \int_r \left[\mathcal{D}(a, Gr), Gr\right] $' align=absmiddle></p>
<p>Where the integral notation denotes an <a href="../../2008/kan-extension-iii/index.html">end</a>, and the square brackets denote a <a href="http://nlab.mathforge.org/nlab/show/power">power</a>, which allows us to take what is essentially an exponential of the objects of <img src='../../../latex/eaf85f2b753a4c7585def4cc7ecade43.png' title='$\mathcal{D}$' alt='$\mathcal{D}$' align=absmiddle> by objects of <img src='../../../latex/76105ebc974ce8a02de91bcaf0d6d25f.png' title='$\mathcal{V}$' alt='$\mathcal{V}$' align=absmiddle>, where <img src='../../../latex/eaf85f2b753a4c7585def4cc7ecade43.png' title='$\mathcal{D}$' alt='$\mathcal{D}$' align=absmiddle> is <a href="http://nlab.mathforge.org/nlab/show/enriched+category">enriched</a> in <img src='../../../latex/76105ebc974ce8a02de91bcaf0d6d25f.png' title='$\mathcal{V}$' alt='$\mathcal{V}$' align=absmiddle>. Provided the above end exists, <img src='../../../latex/e049fb90e6d941ff5046ca1c48041c8b.png' title='$T^G$' alt='$T^G$' align=absmiddle> is a monad regardless of whether <img src='../../../latex/5201385589993766eea584cd3aa6fa13.png' title='$G$' alt='$G$' align=absmiddle> has an <a href="../../2008/kan-extensions-ii/index.html">adjoint</a>, which is the usual way one thinks of functors (in general) giving rise to monads.</p>
<p>It also turns out that this construction is a sort of generalization of the adjunction case. If we do have <img src='../../../latex/754907e967821ca061438630f9c72a7d.png' title='$F \dashv G$' alt='$F \dashv G$' align=absmiddle>, this gives rise to a monad <img src='../../../latex/a095e64d5e4cfbbc3f2bdfd533130212.png' title='$GF$' alt='$GF$' align=absmiddle>. But, in such a case, <img src='../../../latex/1e0adde1d1e9eba3705ea3cd2880c6f8.png' title='$T^G \cong GF$' alt='$T^G \cong GF$' align=absmiddle>, so the codensity monad is the same as the monad given by the adjunction when it exists, but codensity may exist when there is no adjunction.</p>
<p>In Haskell, this all becomes a bit simpler (to my eyes, at least). Our category <img src='../../../latex/eaf85f2b753a4c7585def4cc7ecade43.png' title='$\mathcal{D}$' alt='$\mathcal{D}$' align=absmiddle> is always <img src='../../../latex/129cf6e597bd76a4da1b575b1fa73b20.png' title='$\mathbf{Hask}$' alt='$\mathbf{Hask}$' align=absmiddle>, which is enriched in itself, so powers are just function spaces. And all the functors we write will be rather like <img src='../../../latex/129cf6e597bd76a4da1b575b1fa73b20.png' title='$\mathbf{Hask}$' alt='$\mathbf{Hask}$' align=absmiddle> (objects will come from kinds we can quantify over), so ends of functors will look like <code>forall r. F r r</code> where <img src='../../../latex/b075975319f2e91538b5f7f577347d83.png' title='$F : \mathcal{C}^{op} \times \mathcal{C} \rightarrow \mathbf{Hask}$' alt='$F : \mathcal{C}^{op} \times \mathcal{C} \rightarrow \mathbf{Hask}$' align=absmiddle>. Then:<br />
<code><br />
newtype Codensity f a = Codensity (forall r. (a -> f r) -> f r)<br />
</code></p>
<p>As mentioned, we've known for a while that we can write a Monad instance for <code>Codensity f</code> without caring at all about <code>f</code>.</p>
<p>As for the adjunction correspondence, consider the adjunction between products and exponentials: <img src='../../../latex/179c9a295a34edbdbd4b2f184a62cdc9.png' title='$ - \times S \dashv S \rightarrow - $' alt='$ - \times S \dashv S \rightarrow - $' align=absmiddle></p>
<p>This gives rise to the monad <img src='../../../latex/4da4a1547d8498791e0069e7616d7040.png' title='$S \rightarrow (- \times S)$' alt='$S \rightarrow (- \times S)$' align=absmiddle>, the state monad. According to the facts above, we should have that <code>Codensity (s ->)</code> (excuse the sectioning) is the same as state, and if we look, we see:<br />
<code><br />
forall r. (a -> s -> r) -> s -> r<br />
</code></p>
<p>which is the continuation passing, or Church (or <a href="http://comments.gmane.org/gmane.comp.lang.haskell.cafe/100508">Boehm-Berarducci</a>) encoding of the monad.</p>
<p>Now, it's also well known that for any monad, we can construct an adjunction that gives rise to it. There are multiple ways to do this, but the most accessible in Haskell is probably via the Kleisli category. So, given a monad <img src='../../../latex/fb97d38bcc19230b0acd442e17db879c.png' title='$M$' alt='$M$' align=absmiddle> on <img src='../../../latex/129cf6e597bd76a4da1b575b1fa73b20.png' title='$\mathbf{Hask}$' alt='$\mathbf{Hask}$' align=absmiddle>, there is a category <img src='../../../latex/a4b150035aa58ceef406ef607d2c3c70.png' title='$\mathbf{Hask}_M$' alt='$\mathbf{Hask}_M$' align=absmiddle> with the same objects, but where <img src='../../../latex/bc31ad3fd58dd9ca8691a1719354e0fb.png' title='$\mathbf{Hask}_M(a, b) = \mathbf{Hask}(a, Mb)$' alt='$\mathbf{Hask}_M(a, b) = \mathbf{Hask}(a, Mb)$' align=absmiddle>. The identity for each object is <code>return</code> and composition of arrows is:<br />
<code><br />
(f >=> g) x = f x >>= g<br />
</code></p>
<p>Our two functors are:<br />
<code><br />
F a = a<br />
F f = return . f</p>
<p>U a = M a<br />
U f = (>>= f)<br />
</code></p>
<p>Verifying that <img src='../../../latex/388ff8dfabfc1466d587e51adb83212a.png' title='$F \dashv U$' alt='$F \dashv U$' align=absmiddle> requires only that <img src='../../../latex/1f96b28abbe86107fdb6e1a8ffe2ea35.png' title='$\mathbf{Hask}_M(F-, =) \cong \mathbf{Hask}(-, U\!\!=)$' alt='$\mathbf{Hask}_M(F-, =) \cong \mathbf{Hask}(-, U\!\!=)$' align=absmiddle>, but this is just <img src='../../../latex/d29fe5c1dc21ef08d41e2b5f780f1521.png' title='$\mathbf{Hask}(-, M\!\!=) \cong \mathbf{Hask}(-, M\!\!=)$' alt='$\mathbf{Hask}(-, M\!\!=) \cong \mathbf{Hask}(-, M\!\!=)$' align=absmiddle>, which is a triviality. Now we should have that <img src='../../../latex/bf2765813f7499243599cc3bf3e7f73b.png' title='$T^U = M$' alt='$T^U = M$' align=absmiddle>.</p>
<p>So, one of the simplest monads is reader, <img src='../../../latex/0b94f1fc58a44d88f75b94e136f017db.png' title='$(e \rightarrow)$' alt='$(e \rightarrow)$' align=absmiddle>. Now, <img src='../../../latex/6bac6ec50c01592407695ef84f457232.png' title='$U$' alt='$U$' align=absmiddle> just takes objects in the Kleisli category (which are objects in <img src='../../../latex/129cf6e597bd76a4da1b575b1fa73b20.png' title='$\mathbf{Hask}$' alt='$\mathbf{Hask}$' align=absmiddle>) and applies <img src='../../../latex/fb97d38bcc19230b0acd442e17db879c.png' title='$M$' alt='$M$' align=absmiddle> to them, so we should have <code>Codensity (e ->)</code> is reader. But earlier we had <code>Codensity (e ->)</code> was state. So reader is state, right?</p>
<p>We can actually arrive at this result another way. One of the most famous pieces of category theory is the <a href="http://blog.sigfpe.com/2006/11/yoneda-lemma.html">Yoneda lemma</a>, which states that the following correspondence holds for any functor <img src='../../../latex/d15d65be74350891964d514d80d23f4e.png' title='$F : \mathcal{C} \rightarrow \mathbf{Set}$' alt='$F : \mathcal{C} \rightarrow \mathbf{Set}$' align=absmiddle>:</p>
<p><img src='../../../latex/291bd125d994fd0c7d00a147403dc44e.png' title='$ Fa \,\, \cong \, \mathbf{Set}^\mathcal{C}\left(C(a,-), F\right) $' alt='$ Fa \,\, \cong \, \mathbf{Set}^\mathcal{C}\left(C(a,-), F\right) $' align=absmiddle></p>
<p>This also works for any functor into <img src='../../../latex/129cf6e597bd76a4da1b575b1fa73b20.png' title='$\mathbf{Hask}$' alt='$\mathbf{Hask}$' align=absmiddle> and looks like:<br />
<code><br />
F a ~= forall r. (a -> r) -> F r<br />
</code></p>
<p>for <img src='../../../latex/e426801111acba9fcbd11a4bde602af4.png' title='$F : \mathbf{Hask} \rightarrow \mathbf{Hask}$' alt='$F : \mathbf{Hask} \rightarrow \mathbf{Hask}$' align=absmiddle>. But we also have our functor <img src='../../../latex/d721b9a42081d5f73eec6b96d40c8f87.png' title='$U : \mathbf{Hask}_M \rightarrow \mathbf{Hask}$' alt='$U : \mathbf{Hask}_M \rightarrow \mathbf{Hask}$' align=absmiddle>, which should look more like:</p>
<p><code> U a ~= forall r. (a -> M r) -> U r<br />
M a ~= forall r. (a -> M r) -> M r</code></p>
<p>So, we fill in <code>M = (e ->)</code> and get that reader is isomorphic to state, right? What's going on?</p>
<p>To see, we have to take a closer look at natural transformations. Given two categories <img src='../../../latex/db5f7b3e9934fbc5a2859d88c4ba84a3.png' title='$\mathcal{C}$' alt='$\mathcal{C}$' align=absmiddle> and <img src='../../../latex/eaf85f2b753a4c7585def4cc7ecade43.png' title='$\mathcal{D}$' alt='$\mathcal{D}$' align=absmiddle>, and functors <img src='../../../latex/f9715681e693462be2b2901abbdce20e.png' title='$F, G : \mathcal{C} \rightarrow \mathcal{D}$' alt='$F, G : \mathcal{C} \rightarrow \mathcal{D}$' align=absmiddle>, a natural transformation <img src='../../../latex/08bda09160c0fde7f63da195d07031c3.png' title='$\phi : F \Rightarrow G$' alt='$\phi : F \Rightarrow G$' align=absmiddle> is a family of maps <img src='../../../latex/86b3a786efd28fc240d095754564a874.png' title='$\phi_a : Fa \rightarrow Ga$' alt='$\phi_a : Fa \rightarrow Ga$' align=absmiddle> such that for every <img src='../../../latex/78c2fecc46b4ab88b04b97e64cc513f7.png' title='$f : a \rightarrow b$' alt='$f : a \rightarrow b$' align=absmiddle> the following diagram commutes:</p>
<div style="text-align: center"><img src='../../../latex/f3b765d571311e2ac37cb7a4d5c849d6.png' title='$ \bfig \square&amp;lt;1000,1000&gt;[Fa`Ga`Fb`Gb;\phi_a`Ff`Gf`\phi_b]\efig $' alt='$ \bfig \square&amp;lt;1000,1000&gt;[Fa`Ga`Fb`Gb;\phi_a`Ff`Gf`\phi_b]\efig $' align=absmiddle></div>
<p>The key piece is what the morphisms look like. It's well known that parametricity ensures the naturality of <code>t :: forall a. F a -> G a</code> for <img src='../../../latex/764d49adf41244778f7b1f65677bd4ec.png' title='$F, G : \mathbf{Hask} \rightarrow \mathbf{Hask}$' alt='$F, G : \mathbf{Hask} \rightarrow \mathbf{Hask}$' align=absmiddle>, and it also works when the source is <img src='../../../latex/142c3f0a398b3921283c65dba9b426f6.png' title='$\mathbf{Hask}^{op}$' alt='$\mathbf{Hask}^{op}$' align=absmiddle>. It should also work for a category, call it <img src='../../../latex/b7581780b90f85bba660172715c3991e.png' title='$\mathbf{Hask}^{\sim}$' alt='$\mathbf{Hask}^{\sim}$' align=absmiddle>, which has Haskell types as objects, but where <img src='../../../latex/90c1cbbbf7ae5d1def60bc7bd8600cc1.png' title='$\mathbf{Hask}^{\sim}(a, b) = \mathbf{Hask}(a, b) \times \mathbf{Hask}(b, a)$' alt='$\mathbf{Hask}^{\sim}(a, b) = \mathbf{Hask}(a, b) \times \mathbf{Hask}(b, a)$' align=absmiddle>, which is the sort of category that <code>newtype Endo a = Endo (a -> a)</code> is a functor from. So we should be at liberty to say:<br />
<code><br />
Codensity Endo a = forall r. (a -> r -> r) -> r -> r ~= [a]<br />
</code></p>
<p>However, hom types for <img src='../../../latex/a4b150035aa58ceef406ef607d2c3c70.png' title='$\mathbf{Hask}_M$' alt='$\mathbf{Hask}_M$' align=absmiddle> are not merely made up of <img src='../../../latex/129cf6e597bd76a4da1b575b1fa73b20.png' title='$\mathbf{Hask}$' alt='$\mathbf{Hask}$' align=absmiddle> hom types on the same arguments, so naturality turns out not to be guaranteed. A functor <img src='../../../latex/46cde8a293393bfb788e2146a377dfd6.png' title='$F : \mathbf{Hask}_M \rightarrow \mathbf{Hask}$' alt='$F : \mathbf{Hask}_M \rightarrow \mathbf{Hask}$' align=absmiddle> must take a Kleisli arrow <img src='../../../latex/4f2fe22635b432c01d95ba33d4fc994e.png' title='$f : b \rightarrow Mc$' alt='$f : b \rightarrow Mc$' align=absmiddle> to an arrow <img src='../../../latex/ec40c947207bed2928a683a7a8014fb7.png' title='$Ff : Fb \rightarrow Fc$' alt='$Ff : Fb \rightarrow Fc$' align=absmiddle>, and transformations must commute with that mapping. So, if we look at our use of Yoneda, we are considering transformations <img src='../../../latex/47051979f30f700aee1fda6eab3554f3.png' title='$\phi : \mathbf{Hask}_M(a, -) \Rightarrow U$' alt='$\phi : \mathbf{Hask}_M(a, -) \Rightarrow U$' align=absmiddle>:</p>
<div style="text-align: center"><img src='../../../latex/b2ed6d7df91f89030039a41b41533753.png' title='$ \bfig\square&amp;lt;1000,1000&gt;[\mathbf{Hask}_M(a,b)`Ub`\mathbf{Hask}_M(a,c)`Uc;\phi_a`\mathbf{Hask}_M(a,f)`Uf`\phi_h]\efig $' alt='$ \bfig\square&amp;lt;1000,1000&gt;[\mathbf{Hask}_M(a,b)`Ub`\mathbf{Hask}_M(a,c)`Uc;\phi_a`\mathbf{Hask}_M(a,f)`Uf`\phi_h]\efig $' align=absmiddle></div>
<p>Now, <img src='../../../latex/7bb5b195ef8bd7e285fdf865d6e658a0.png' title='$\mathbf{Hask}_M(a,b) = \mathbf{Hask}(a, Mb)$' alt='$\mathbf{Hask}_M(a,b) = \mathbf{Hask}(a, Mb)$' align=absmiddle> and <img src='../../../latex/9c2c2564bc88a3ea51f03f36675984c1.png' title='$Ub = Mb$' alt='$Ub = Mb$' align=absmiddle>. So</p>
<p><code>t :: forall r. (a -> M r) -> M r</code></p>
<p>will get us the right type of maps. But, the above commutative square corresponds to the condition that for all <code>f :: b -> M c</code>:<br />
<code><br />
t . (>=> f) = (>>= f) . t<br />
</code></p>
<p>So, if we have <code>h :: a -> M b</code>, Kleisli composing it with <code>f</code> and then feeding to <code>t</code> is the same as feeding <code>h</code> to <code>t</code> and then binding the result with <code>f</code>.</p>
<p>Now, if we go back to reader, we can consider the reader morphism:<br />
<code><br />
f = const id :: a -> e -> e<br />
</code></p>
<p>For all relevant <code>m</code> and <code>g</code>, <code> m >>= f = id</code> and <code>g >=> f = f</code>. So the<br />
naturality condition here states that <code>t f = id</code>.</p>
<p>Now, <code>t :: forall r. (a -> e -> r) -> e -> r</code>. The general form of these is state actions (I've split <code>e -> (a, e)</code> into two pieces):</p>
<pre language="haskell">
t f e = f (v e) (st e)
  where
  rd :: e -> a
  st :: e -> e
</pre>
<p>If <code>f = const id</code>, then:</p>
<pre language="haskell">
t (const id) e = st e
 where
 st :: e -> e
</pre>
<p>But our naturality condition states that this must be the identity, so we must have <code>st = id</code>. That is, the naturality condition selects <code>t</code> for which the corresponding state action does not change the state, meaning it is equivalent to a reader action! Presumably the definition of an end (which involves dinaturality) enforces a similar condition, although I won't work through it, as it'd be rather more complicated.</p>
<p>However, we have learned a lesson. Quantifiers do not necessarily enforce (di)naturality for every category with objects of the relevant kind. It is important to look at the hom types, not just the objects .In this case, the point of failure seems to be the common, extra <code>s</code>. Even though the type contains nautral transformations for the similar functors over <img src='../../../latex/129cf6e597bd76a4da1b575b1fa73b20.png' title='$\mathbf{Hask}$' alt='$\mathbf{Hask}$' align=absmiddle>, they can (in general) still manipulate the shared parameter in ways that are not natural for the domain in question.</p>
<p>I am unsure of how exactly one could enforce the above condition in (Haskell's) types. For instance, if we consider:</p>
<p><code>forall r m. Monad m => (a -> m r) -> m r</code></p>
<p>This still contains transformations of the form:</p>
<p><code> t k = k a >> k a </code></p>
<p>And for this to be natural would require:</p>
<p><code> (k >=> f) a >> (k >=> f) a = (k a >> k a) >>= f </code></p>
<p>Which is not true for all possible instantiations of f. It seems as though leaving <code>m</code> unconstrained would be sufficient, as all that could happen is <code>t</code> feeding a value to <code>k</code> and yielding the result, but it seems likely to be over-restrictive.</p>
	<div class="post-info">
			</div>
	<div class="post-footer">&nbsp;</div>
</div>
									</div>
							
				<div class="post">
					<p class="post-date">Sun 25 Dec 2011</p>
<div class="post-info"><h2 class="post-title"><a href="../../2011/searching-infinity/index.html" rel="bookmark" title="Permanent Link: Searching Infinity Parametrically">Searching Infinity Parametrically</a></h2>
Posted by Edward Kmett under <a href="../algorithms/index.html" title="View all posts in Algorithms" rel="category tag">Algorithms</a> ,  <a href="../haskell/index.html" title="View all posts in Haskell" rel="category tag">Haskell</a> ,  <a href="../kan-extensions/index.html" title="View all posts in Kan Extensions" rel="category tag">Kan Extensions</a> ,  <a href="../logic/index.html" title="View all posts in Logic" rel="category tag">Logic</a> ,  <a href="index.html" title="View all posts in Mathematics" rel="category tag">Mathematics</a> ,  <a href="../monads/index.html" title="View all posts in Monads" rel="category tag">Monads</a> ,  <a href="../type-hackery/index.html" title="View all posts in Type Hackery" rel="category tag">Type Hackery</a> <br/><a href="../../2011/searching-infinity/index.html#comments" title="Comment on Searching Infinity Parametrically">[11] Comments</a>&nbsp;</div>
<div class="post-content">
	<p>Andrej Bauer recently gave a really nice talk on how you can exploit side-effects to make a faster version of Martin Escardo's pseudo-paradoxical combinators. </p>
<p><a href="http://math.andrej.com/2011/12/06/how-to-make-the-impossible-functionals-run-even-faster/">A video of his talk is available over on his blog</a>, and his presentation is remarkably clear, and would serve as a good preamble to the code I'm going to present below.</p>
<p>Andrej gave a related invited talk back at <a href="http://msfp.org.uk/">MSFP 2008</a> in Iceland, and afterwards over lunch I cornered him (with Dan Piponi) and explained how you could use parametricity to close over the side-effects of monads (or arrows, etc) but I think that trick was lost in the chaos of the weekend, so I've chosen to resurrect it here, and improve it to handle some of his more recent performance enhancements, and show that you don't need side-effects to speed up the search after all!</p>
<p> <a href="../../2011/searching-infinity/index.html#more-510" class="more-link">(more...)</a></p>
	<div class="post-info">
			</div>
	<div class="post-footer">&nbsp;</div>
</div>
									</div>
							
				<div class="post">
					<p class="post-date">Mon 11 Jul 2011</p>
<div class="post-info"><h2 class="post-title"><a href="../../2011/free-modules-and-functional-linear-functionals/index.html" rel="bookmark" title="Permanent Link: Free Modules and Functional Linear Functionals">Free Modules and Functional Linear Functionals</a></h2>
Posted by Edward Kmett under <a href="../algorithms/index.html" title="View all posts in Algorithms" rel="category tag">Algorithms</a> ,  <a href="../category-theory/index.html" title="View all posts in Category Theory" rel="category tag">Category Theory</a> ,  <a href="../data-structures/index.html" title="View all posts in Data Structures" rel="category tag">Data Structures</a> ,  <a href="../haskell/index.html" title="View all posts in Haskell" rel="category tag">Haskell</a> ,  <a href="linear-algebra/index.html" title="View all posts in Linear Algebra" rel="category tag">Linear Algebra</a> ,  <a href="../monads/index.html" title="View all posts in Monads" rel="category tag">Monads</a> ,  <a href="../monoids/index.html" title="View all posts in Monoids" rel="category tag">Monoids</a> ,  <a href="../type-hackery/index.html" title="View all posts in Type Hackery" rel="category tag">Type Hackery</a> <br/><a href="../../2011/free-modules-and-functional-linear-functionals/index.html#comments" title="Comment on Free Modules and Functional Linear Functionals">[9] Comments</a>&nbsp;</div>
<div class="post-content">
	<p>Today I hope to start a new series of posts exploring constructive abstract algebra in Haskell.  </p>
<p>In particular, I want to talk about a novel encoding of linear functionals, polynomials and linear maps in Haskell, but first we're going to have to build up some common terminology.</p>
<p>Having obtained the blessing of Wolfgang Jeltsch, I replaced the <a href="http://hackage.haskell.org/package/algebra">algebra</a> package on hackage with something... bigger, although still very much a work in progress.</p>
<p> <a href="../../2011/free-modules-and-functional-linear-functionals/index.html#more-356" class="more-link">(more...)</a></p>
	<div class="post-info">
			</div>
	<div class="post-footer">&nbsp;</div>
</div>
									</div>
							
				<div class="post">
					<p class="post-date">Mon 27 Jun 2011</p>
<div class="post-info"><h2 class="post-title"><a href="../../2011/monads-from-comonads/index.html" rel="bookmark" title="Permanent Link: Monads from Comonads">Monads from Comonads</a></h2>
Posted by Edward Kmett under <a href="../category-theory/index.html" title="View all posts in Category Theory" rel="category tag">Category Theory</a> ,  <a href="../comonads/index.html" title="View all posts in Comonads" rel="category tag">Comonads</a> ,  <a href="../haskell/index.html" title="View all posts in Haskell" rel="category tag">Haskell</a> ,  <a href="../kan-extensions/index.html" title="View all posts in Kan Extensions" rel="category tag">Kan Extensions</a> ,  <a href="index.html" title="View all posts in Mathematics" rel="category tag">Mathematics</a> ,  <a href="../monads/index.html" title="View all posts in Monads" rel="category tag">Monads</a> <br/><a href="../../2011/monads-from-comonads/index.html#comments" title="Comment on Monads from Comonads">[9] Comments</a>&nbsp;</div>
<div class="post-content">
	<p>Today I'll show that you can derive a <code>Monad</code> from any old <code>Comonad</code> you have lying around.</p>
<p> <a href="../../2011/monads-from-comonads/index.html#more-291" class="more-link">(more...)</a></p>
	<div class="post-info">
			</div>
	<div class="post-footer">&nbsp;</div>
</div>
									</div>
							
				<div class="post">
					<p class="post-date">Thu 23 Jun 2011</p>
<div class="post-info"><h2 class="post-title"><a href="../../2011/free-monads-for-less-2/index.html" rel="bookmark" title="Permanent Link: Free Monads for Less (Part 2 of 3): Yoneda">Free Monads for Less (Part 2 of 3): Yoneda</a></h2>
Posted by Edward Kmett under <a href="../algorithms/index.html" title="View all posts in Algorithms" rel="category tag">Algorithms</a> ,  <a href="../category-theory/index.html" title="View all posts in Category Theory" rel="category tag">Category Theory</a> ,  <a href="../data-structures/index.html" title="View all posts in Data Structures" rel="category tag">Data Structures</a> ,  <a href="../haskell/index.html" title="View all posts in Haskell" rel="category tag">Haskell</a> ,  <a href="../kan-extensions/index.html" title="View all posts in Kan Extensions" rel="category tag">Kan Extensions</a> ,  <a href="index.html" title="View all posts in Mathematics" rel="category tag">Mathematics</a> ,  <a href="../monads/index.html" title="View all posts in Monads" rel="category tag">Monads</a> <br/><a href="../../2011/free-monads-for-less-2/index.html#comments" title="Comment on Free Monads for Less (Part 2 of 3): Yoneda">[3] Comments</a>&nbsp;</div>
<div class="post-content">
	<p><a href="../../2011/free-monads-for-less/index.html">Last time</a>, I started exploring whether or not <a href="http://hackage.haskell.org/packages/archive/kan-extensions/0.5.0/doc/html/Control-Monad-Codensity.html">Codensity</a> was necessary to <a href="http://www.iai.uni-bonn.de/~jv/mpc08.pdf">improve the asymptotic performance of free monads</a>.</p>
<p>This time I'll show that the answer is no; we can get by with something smaller.</p>
<p> <a href="../../2011/free-monads-for-less-2/index.html#more-243" class="more-link">(more...)</a></p>
	<div class="post-info">
			</div>
	<div class="post-footer">&nbsp;</div>
</div>
									</div>
							
				<div class="post">
					<p class="post-date">Sat 15 May 2010</p>
<div class="post-info"><h2 class="post-title"><a href="../../2010/reverse-mode-automatic-differentiation-in-haskell/index.html" rel="bookmark" title="Permanent Link: Reverse-Mode Automatic Differentiation in Haskell">Reverse-Mode Automatic Differentiation in Haskell</a></h2>
Posted by Edward Kmett under <a href="../algorithms/index.html" title="View all posts in Algorithms" rel="category tag">Algorithms</a> ,  <a href="../haskell/index.html" title="View all posts in Haskell" rel="category tag">Haskell</a> ,  <a href="index.html" title="View all posts in Mathematics" rel="category tag">Mathematics</a> <br/><a href="../../2010/reverse-mode-automatic-differentiation-in-haskell/index.html#comments" title="Comment on Reverse-Mode Automatic Differentiation in Haskell">1 Comment</a>&nbsp;</div>
<div class="post-content">
	<p>I've uploaded a package named <a href="http://hackage.haskell.org/package/rad">rad</a> to Hackage for handling reverse-mode <a href="http://en.wikipedia.org/wiki/Automatic_differentiation">automatic differentiation</a> in Haskell.<br />
 <a href="../../2010/reverse-mode-automatic-differentiation-in-haskell/index.html#more-183" class="more-link">(more...)</a></p>
	<div class="post-info">
			</div>
	<div class="post-footer">&nbsp;</div>
</div>
									</div>
							
				<div class="post">
					<p class="post-date">Tue 15 Sep 2009</p>
<div class="post-info"><h2 class="post-title"><a href="../../2009/remodeling-precision/index.html" rel="bookmark" title="Permanent Link: Remodeling Precision">Remodeling Precision</a></h2>
Posted by Edward Kmett under <a href="index.html" title="View all posts in Mathematics" rel="category tag">Mathematics</a> <br/><a href="../../2009/remodeling-precision/index.html#comments" title="Comment on Remodeling Precision">[9] Comments</a>&nbsp;</div>
<div class="post-content">
	<p>Two concepts come up when talking about information retrieval in most standard documentation, <a href="http://en.wikipedia.org/wiki/Precision_and_recall">Precision and Recall</a>. Precision is a measure that tells you if your result set contains only results that are relevant to the query, and recall tells you if your result set contains everything that is relevant to the query.</p>
<p>The formula for classical precision is:</p>
<p><img src="../../wp-content/uploads/2009/09/precision_formula.png" alt="Precision Formula" title="Precision Formula" width="514" height="47" class="alignnone size-full wp-image-158" /></p>
<p>However, I would argue that the classical notion of Precision is flawed, in that it doesn't model anything we tend to care about. Rarely are we interested in binary classification, instead we want a ranked classification of relevance.</p>
<p> <a href="../../2009/remodeling-precision/index.html#more-151" class="more-link">(more...)</a></p>
	<div class="post-info">
			</div>
	<div class="post-footer">&nbsp;</div>
</div>
									</div>
							
				<div class="post">
					<p class="post-date">Thu 20 Aug 2009</p>
<div class="post-info"><h2 class="post-title"><a href="../../2009/iteratees-parsec-and-monoid/index.html" rel="bookmark" title="Permanent Link: Iteratees, Parsec and Monoids (Slides)">Iteratees, Parsec and Monoids (Slides)</a></h2>
Posted by Edward Kmett under <a href="../algorithms/index.html" title="View all posts in Algorithms" rel="category tag">Algorithms</a> ,  <a href="../data-structures/index.html" title="View all posts in Data Structures" rel="category tag">Data Structures</a> ,  <a href="../haskell/index.html" title="View all posts in Haskell" rel="category tag">Haskell</a> ,  <a href="index.html" title="View all posts in Mathematics" rel="category tag">Mathematics</a> ,  <a href="../monoids/index.html" title="View all posts in Monoids" rel="category tag">Monoids</a> ,  <a href="../parsing/index.html" title="View all posts in Parsing" rel="category tag">Parsing</a> <br/><a href="../../2009/iteratees-parsec-and-monoid/index.html#comments" title="Comment on Iteratees, Parsec and Monoids (Slides)">[5] Comments</a>&nbsp;</div>
<div class="post-content">
	<p>I was asked to give two talks at the <a href="http://groups.google.com/group/bostonhaskell">Boston Area Haskell User Group</a> for this past Tuesday. The first was pitched at a more introductory level and the second was to go deeper into what I have been using monoids for lately.</p>
<p>The first talk covers an introduction to the mathematical notion of a monoid, introduces some of the features of my Haskell monoids library on hackage, and starts to motivate the use of monoidal parallel/incremental parsing, and the modification use of compression algorithms to recycle monoidal results.</p>
<p>The second talk covers a way to generate a locally-context sensitive parallel/incremental parser by modifying <a href="http://okmij.org/ftp/Haskell/Iteratee/Iteratee.hs">Iteratees</a> to enable them to drive a <a href="http://hackage.haskell.org/package/parsec-3.0.0">Parsec 3</a> lexer, and then wrapping that in a monoid based on <a href="http://dragonbook.stanford.edu/lecture-notes/Columbia-COMS-W4115/08-03-05.html">error productions</a> in the grammar before recycling these techniques at a higher level to deal with parsing seemingly stateful structures, such as Haskell layout.</p>
<ol>
<li><a href='../../wp-content/uploads/2009/08/IntroductionToMonoids.pdf'>Introduction To Monoids (PDF)</a></li>
<li><a href='../../wp-content/uploads/2009/08/A-Parsing-Trifecta.pdf'>Iteratees, Parsec and Monoids: A Parsing Trifecta (PDF)</a></li>
</ol>
<p>Due to a late start, I was unable to give the second talk. However, I did give a quick run through to a few die-hards who stayed late and came to the <a href="http://www.cambrew.com/">Cambridge Brewing Company</a> afterwards. As I promised some people that I would post the slides after the talk, here they are. </p>
<p>The current plan is to possibly give the second talk in full at either the September or October Boston Haskell User Group sessions, depending on scheduling and availability.</p>
<p>[ <a href='../../wp-content/uploads/2009/08/Iteratee.hs'>Iteratee.hs</a> ]</p>
	<div class="post-info">
			</div>
	<div class="post-footer">&nbsp;</div>
</div>
									</div>
							
				<div class="post">
					<p class="post-date">Fri 31 Jul 2009</p>
<div class="post-info"><h2 class="post-title"><a href="../../2009/hac-phi-slides/index.html" rel="bookmark" title="Permanent Link: Slides from Hac Phi: &#8220;All About Monoids&#8221;">Slides from Hac Phi: &#8220;All About Monoids&#8221;</a></h2>
Posted by Edward Kmett under <a href="../haskell/index.html" title="View all posts in Haskell" rel="category tag">Haskell</a> ,  <a href="index.html" title="View all posts in Mathematics" rel="category tag">Mathematics</a> ,  <a href="../monoids/index.html" title="View all posts in Monoids" rel="category tag">Monoids</a> ,  <a href="../parsing/index.html" title="View all posts in Parsing" rel="category tag">Parsing</a> <br/><a href="../../2009/hac-phi-slides/index.html#comments" title="Comment on Slides from Hac Phi: &#8220;All About Monoids&#8221;">[10] Comments</a>&nbsp;</div>
<div class="post-content">
	<p>Some people have requested my slides from the short talk I gave about monoids and monoidal parsing at Hac Phi. So, here they are.</p>
<ul>
<li><a href='../../wp-content/uploads/2009/07/AllAboutMonoids.pptx'>Hac Phi Slides (Powerpoint 2007)</a></li>
<li><a href='../../wp-content/uploads/2009/07/AllAboutMonoids.pdf'>Hac Phi Slides (PDF)</a></li>
</ul>
<p>There will be more to come at the next Boston Haskell User Group in August, where it looks like I'll be giving two short talks covering monoids. I may use the monoidal parsing engine from Kata as an example for the advanced talk if I have time and will start to cover parsing larger classes of grammars in general (regular languages, CFGs/TIGs, TAGs, PEGs, LALR, attribute-grammars, etc.)</p>
	<div class="post-info">
			</div>
	<div class="post-footer">&nbsp;</div>
</div>
									</div>
							
				<div class="post">
					<p class="post-date">Thu 11 Jun 2009</p>
<div class="post-info"><h2 class="post-title"><a href="../../2009/recursion-schemes/index.html" rel="bookmark" title="Permanent Link: Recursion Schemes: A Field Guide (Redux)">Recursion Schemes: A Field Guide (Redux)</a></h2>
Posted by Edward Kmett under <a href="../category-theory/index.html" title="View all posts in Category Theory" rel="category tag">Category Theory</a> ,  <a href="../haskell/index.html" title="View all posts in Haskell" rel="category tag">Haskell</a> ,  <a href="index.html" title="View all posts in Mathematics" rel="category tag">Mathematics</a> <br/><a href="../../2009/recursion-schemes/index.html#comments" title="Comment on Recursion Schemes: A Field Guide (Redux)">[10] Comments</a>&nbsp;</div>
<div class="post-content">
	<p>About a year back I posted a field guide of recursion schemes on this blog and then lost it a few months later when I lost a couple of months of blog entries to a <a href="../../2008/still-alive/index.html">crash</a>. I recently recovered the table of recursion schemes from the original post thanks to <a href="http://www.google.com/reader/">Google Reader</a>'s long memory and the help of Jeff Cutsinger.</p>
<p>The following recursion schemes can be found in <a href="http://hackage.haskell.org/cgi-bin/hackage-scripts/package/category-extras">category-extras</a>, along with variations on the underlying themes, so this should work as a punch-list.</p>
<table border=1>
<tr>
<th colspan=3>Folds</th>
</tr>
<tr>
<th>Scheme</th>
<th>Code</th>
<th>Description</th>
</tr>
<tr>
<td><a href="http://knol.google.com/k/edward-kmett/catamorphisms/">catamorphism</a>†</td>
<td><a href="../../../haskell/category-extras/src/Control/Morphism/Cata.hs">Cata</a></td>
<td>tears down a structure level by level</td>
</tr>
<tr>
<td>paramorphism*†</td>
<td><a href="../../../haskell/category-extras/src/Control/Morphism/Para.hs">Para</a></td>
<td>tears down a structure with primitive recursion</td>
</tr>
<tr>
<td>zygomorphism*†</td>
<td><a href="../../../haskell/category-extras/src/Control/Morphism/Zygo.hs">Zygo</a></td>
<td>tears down a structure with the aid of a helper function</td>
</tr>
<tr>
<td>histomorphism†</td>
<td><a href="../../../haskell/category-extras/src/Control/Morphism/Histo.hs">Histo</a></td>
<td>tears down a structure with the aid of the previous answers it has given.  </td>
</tr>
<tr>
<td>prepromorphism*†</td>
<td><a href="../../../haskell/category-extras/src/Control/Morphism/Prepro.hs">Prepro</a>
  </td>
<td>tears down a structure after repeatedly applying a natural transformation</td>
</tr>
<tr>
<th colspan=3>Unfolds</th>
</tr>
<tr>
<th>Scheme</th>
<th>Code</th>
<th>Description</th>
</tr>
<tr>
<td>anamorphism†</td>
<td><a href="../../../haskell/category-extras/src/Control/Morphism/Ana.hs">Ana</a></td>
<td>builds up a structure level by level</td>
</tr>
<tr>
<td>apomorphism*†</td>
<td><a href="../../../haskell/category-extras/src/Control/Morphism/Apo.hs">Apo</a></td>
<td>builds up a structure opting to return a single level or an entire branch at each point</td>
</tr>
<tr>
<td>futumorphism†</td>
<td><a href="../../../haskell/category-extras/src/Control/Morphism/Futu.hs">Futu</a></td>
<td>builds up a structure multiple levels at a time </td>
</tr>
<tr>
<td>postpromorphism*†</td>
<td>
  <a href="../../../haskell/category-extras/src/Control/Morphism/Postpro.hs">Postpro</a>
  </td>
<td>builds up a structure and repeatedly transforms it with a natural transformation</td>
</tr>
<tr>
<th colspan=3>Refolds</th>
</tr>
<tr>
<th>Scheme</th>
<th>Code</th>
<th>Description</th>
</tr>
<tr>
<td>hylomorphism†</td>
<td><a href="../../../haskell/category-extras/src/Control/Morphism/Hylo.hs">Hylo</a></td>
<td>builds up and tears down a virtual structure</td>
</tr>
<tr>
<td>chronomorphism†</td>
<td><a href="../../../haskell/category-extras/src/Control/Morphism/Chrono.hs">Chrono</a></td>
<td>builds up a virtual structure with a futumorphism and tears it down<br />
  with a histomorphism</td>
</tr>
<tr>
<td>synchromorphism</td>
<td><a href="../../../haskell/category-extras/src/Control/Morphism/Synchro.hs">Synchro</a></td>
<td>a high level transformation between data structures using a third data structure to queue intermediate results</td>
</tr>
<tr>
<td>exomorphism</td>
<td><a href="../../../haskell/category-extras/src/Control/Morphism/Exo.hs">Exo</a></td>
<td>a high level transformation between data structures from a trialgebra to a bialgebraga</td>
</tr>
<tr>
<td>metamorphism</td>
<td><a href="../../../haskell/category-extras/src/Control/Morphism/Meta/Erwig.hs">Erwig</a></td>
<td>a hylomorphism expressed in terms of bialgebras</td>
</tr>
<tr>
<td>metamorphism</td>
<td><a href="../../../haskell/category-extras/src/Control/Morphism/Meta/Gibbons.hs">Gibbons</a></td>
<td>A fold followed by an unfold; change of representation</td>
</tr>
<tr>
<td>dynamorphism†</td>
<td><a href="../../../haskell/category-extras/src/Control/Morphism/Dyna.hs">Dyna</a></td>
<td>builds up a virtual structure with an anamorphism and tears it down with a histomorphism</td>
</tr>
<tr>
<td><a href="http://arxiv.org/abs/cs/0609040">Elgot algebra</a></td>
<td><a href="../../../haskell/category-extras/src/Control/Functor/Algebra/Elgot.hs">Elgot</a></td>
<td>builds up a structure and tears it down but may shortcircuit the process during construction</td>
</tr>
<tr>
<td><a href="../../2008/elgot-coalgebras/index.html">Elgot coalgebra</a></td>
<td><a href="../../../haskell/category-extras/src/Control/Functor/Algebra/Elgot.hs">Elgot</a></td>
<td>builds up a structure and tears it down but may shortcircuit the process during deconstruction</td>
</tr>
</table>
<p>* This gives rise to a family of related recursion schemes, modeled in category-extras with distributive law combinators<br />
† The scheme can be generalized to accept one or more F-distributive (co)monads.</p>
	<div class="post-info">
			</div>
	<div class="post-footer">&nbsp;</div>
</div>
									</div>
							
				<div class="post">
					<p class="post-date">Mon 26 May 2008</p>
<div class="post-info"><h2 class="post-title"><a href="../../2008/kan-extension-iii/index.html" rel="bookmark" title="Permanent Link: Kan Extensions III: As Ends and Coends">Kan Extensions III: As Ends and Coends</a></h2>
Posted by Edward Kmett under <a href="../category-theory/index.html" title="View all posts in Category Theory" rel="category tag">Category Theory</a> ,  <a href="../haskell/index.html" title="View all posts in Haskell" rel="category tag">Haskell</a> ,  <a href="../kan-extensions/index.html" title="View all posts in Kan Extensions" rel="category tag">Kan Extensions</a> ,  <a href="index.html" title="View all posts in Mathematics" rel="category tag">Mathematics</a> <br/><a href="../../2008/kan-extension-iii/index.html#comments" title="Comment on Kan Extensions III: As Ends and Coends">[14] Comments</a>&nbsp;</div>
<div class="post-content">
	<p>Grant B. <a href="../../2008/kan-extensions/index.html#comment-1412">asked me</a> to post the derivation for the right and left Kan extension formula used in previous Kan Extension posts (<a href="../../2008/kan-extensions/index.html">1</a>,<a href="../../2008/kan-extensions-ii/index.html">2</a>). For that we can turn to the definition of Kan extensions in terms of ends, but first we need to take a couple of steps back to find a way to represent (co)ends in Haskell.</p>
<p> <a href="../../2008/kan-extension-iii/index.html#more-65" class="more-link">(more...)</a></p>
	<div class="post-info">
			</div>
	<div class="post-footer">&nbsp;</div>
</div>
									</div>
							
				<div class="post">
					<p class="post-date">Tue 20 May 2008</p>
<div class="post-info"><h2 class="post-title"><a href="../../2008/kan-extensions/index.html" rel="bookmark" title="Permanent Link: Kan Extensions">Kan Extensions</a></h2>
Posted by Edward Kmett under <a href="../category-theory/index.html" title="View all posts in Category Theory" rel="category tag">Category Theory</a> ,  <a href="../comonads/index.html" title="View all posts in Comonads" rel="category tag">Comonads</a> ,  <a href="../haskell/index.html" title="View all posts in Haskell" rel="category tag">Haskell</a> ,  <a href="../kan-extensions/index.html" title="View all posts in Kan Extensions" rel="category tag">Kan Extensions</a> ,  <a href="index.html" title="View all posts in Mathematics" rel="category tag">Mathematics</a> ,  <a href="../monads/index.html" title="View all posts in Monads" rel="category tag">Monads</a> <br/><a href="../../2008/kan-extensions/index.html#comments" title="Comment on Kan Extensions">[7] Comments</a>&nbsp;</div>
<div class="post-content">
	<p>I think I may spend a post or two talking about <a href="http://en.wikipedia.org/wiki/Kan_extension">Kan extensions</a>.</p>
<p>They appear to be black magic to Haskell programmers, but as <a href="http://en.wikipedia.org/wiki/Saunders_Mac_Lane">Saunders Mac Lane</a> said in <a href="http://www.amazon.com/Categories-Working-Mathematician-Graduate-Mathematics/dp/0387984038">Categories for the Working Mathematician</a>:</p>
<blockquote><p>All concepts are Kan extensions.</p></blockquote>
<p>So what is a Kan extension? They come in two forms: right- and left- Kan extensions. </p>
<p>First I'll talk about right Kan extensions, since Haskell programmers have a better intuition for them.</p>
<p> <a href="../../2008/kan-extensions/index.html#more-63" class="more-link">(more...)</a></p>
	<div class="post-info">
			</div>
	<div class="post-footer">&nbsp;</div>
</div>
									</div>
							
				<div class="post">
					<p class="post-date">Mon 19 May 2008</p>
<div class="post-info"><h2 class="post-title"><a href="../../2008/elgot-coalgebras/index.html" rel="bookmark" title="Permanent Link: Elgot (Co)Algebras">Elgot (Co)Algebras</a></h2>
Posted by Edward Kmett under <a href="../category-theory/index.html" title="View all posts in Category Theory" rel="category tag">Category Theory</a> ,  <a href="../comonads/index.html" title="View all posts in Comonads" rel="category tag">Comonads</a> ,  <a href="../haskell/index.html" title="View all posts in Haskell" rel="category tag">Haskell</a> ,  <a href="index.html" title="View all posts in Mathematics" rel="category tag">Mathematics</a> ,  <a href="../monads/index.html" title="View all posts in Monads" rel="category tag">Monads</a> ,  <a href="../squiggol/index.html" title="View all posts in Squiggol" rel="category tag">Squiggol</a> <br/><a href="../../2008/elgot-coalgebras/index.html#comments" title="Comment on Elgot (Co)Algebras">[4] Comments</a>&nbsp;</div>
<div class="post-content">
	<pre class="haskell">&nbsp;
&gt; <span style="color: #06c; font-weight: bold;">import</span> Control.Arrow <span style="color: green;">&#40;</span><span style="color: green;">&#40;</span>|||<span style="color: green;">&#41;</span>,<span style="color: green;">&#40;</span>&amp;&amp;&amp;<span style="color: green;">&#41;</span>,left<span style="color: green;">&#41;</span>
&gt; <span style="color: #06c; font-weight: bold;">newtype</span> Mu f = InF <span style="color: green;">&#123;</span> outF :: f <span style="color: green;">&#40;</span>Mu f<span style="color: green;">&#41;</span> <span style="color: green;">&#125;</span>
&nbsp;</pre>
<p>I want to talk about a novel recursion scheme that hasn't received a lot of attention from the Haskell community and its even more obscure dual -- which is necessarily more obscure because I believe this is the first time anyone has talked about it. </p>
<p><a href="http://www.iti.cs.tu-bs.de/~adamek/adamek.html">Jiri Adámek</a>, <a href="http://www.iti.cs.tu-bs.de/~milius/">Stefan Milius</a> and <a href="http://math.feld.cvut.cz/velebil/">Jiri Velebil</a> have done a lot of work on <a href="http://arxiv.org/abs/cs/0609040">Elgot algebras</a>.  Here I'd like to translate them into Haskell, dualize them, observe that the dual can encode primitive recursion, and provide some observations.</p>
<p>You can kind of think an Elgot algebra as a hylomorphism that cheats.</p>
<pre class="haskell">&nbsp;
&gt; <a href="../../../haskell/category-extras/dist/doc/html/category-extras/Control-Functor-Algebra-Elgot.html#v:elgot"><span style="font-weight: bold;">elgot</span></a> :: <a href="http://haskell.org/ghc/docs/latest/html/libraries/base/Prelude.html#t:Functor"><span style="background-color: #efefbf; font-weight: bold;">Functor</span></a> f =&gt; <span style="color: green;">&#40;</span>f b -&gt; b<span style="color: green;">&#41;</span> -&gt; <span style="color: green;">&#40;</span>a -&gt; <a href="http://haskell.org/ghc/docs/latest/html/libraries/base/Prelude.html#t:Either"><span style="background-color: #efefbf; font-weight: bold;">Either</span></a> b <span style="color: green;">&#40;</span>f a<span style="color: green;">&#41;</span><span style="color: green;">&#41;</span> -&gt; a -&gt; b
&gt; <a href="../../../haskell/category-extras/dist/doc/html/category-extras/Control-Functor-Algebra-Elgot.html#v:elgot"><span style="font-weight: bold;">elgot</span></a> phi psi = h <span style="color: #06c; font-weight: bold;">where</span> h = <span style="color: green;">&#40;</span><a href="http://haskell.org/ghc/docs/latest/html/libraries/base/Prelude.html#v:id"><span style="font-weight: bold;">id</span></a> ||| phi . <a href="http://haskell.org/ghc/docs/latest/html/libraries/base/Prelude.html#v:fmap"><span style="font-weight: bold;">fmap</span></a> h<span style="color: green;">&#41;</span> . psi
&nbsp;</pre>
<p> <a href="../../2008/elgot-coalgebras/index.html#more-60" class="more-link">(more...)</a></p>
	<div class="post-info">
			</div>
	<div class="post-footer">&nbsp;</div>
</div>
									</div>
							
				<div class="post">
					<p class="post-date">Wed 14 May 2008</p>
<div class="post-info"><h2 class="post-title"><a href="../../2008/generatingfunctorology/index.html" rel="bookmark" title="Permanent Link: Generatingfunctorology">Generatingfunctorology</a></h2>
Posted by Edward Kmett under <a href="../haskell/index.html" title="View all posts in Haskell" rel="category tag">Haskell</a> ,  <a href="index.html" title="View all posts in Mathematics" rel="category tag">Mathematics</a> ,  <a href="../type-theory/index.html" title="View all posts in Type Theory" rel="category tag">Type Theory</a> <br/><a href="../../2008/generatingfunctorology/index.html#comments" title="Comment on Generatingfunctorology">[11] Comments</a>&nbsp;</div>
<div class="post-content">
	<p>Ok, I decided to take a step back from my flawed approach in the <a href="../../2008/towards-formal-power-series-for-functors/index.html">last post</a> and play with the idea of power series of functors from a different perspective.</p>
<p>I dusted off my copy of Herbert Wilf's <a href="http://www.math.upenn.edu/~wilf/DownldGF.html">generatingfunctionology</a> and switched goals to try to see some well known recursive functors or <a href="http://www.cas.mcmaster.ca/~carette/species/msfp08_species.pdf">species</a> as formal power series. It appears that we can pick a few things out about the generating functions of polynomial functors.</p>
<p>As an example:</p>
<pre class="haskell">&nbsp;
<a href="http://haskell.org/ghc/docs/latest/html/libraries/base/Prelude.html#t:Maybe"><span style="background-color: #efefbf; font-weight: bold;">Maybe</span></a> x = <span style="color: red;">1</span> + x
&nbsp;</pre>
<p>Ok. We're done. Thank you very much. I'll be here all week. Try the veal... </p>
<p>For a more serious example, the formal power series for the list [x] is just a <a href="http://en.wikipedia.org/wiki/Geometric_series">geometric series</a>:</p>
<p> <a href="../../2008/generatingfunctorology/index.html#more-58" class="more-link">(more...)</a></p>
	<div class="post-info">
			</div>
	<div class="post-footer">&nbsp;</div>
</div>
									</div>
							
				<div class="post">
					<p class="post-date">Tue 13 May 2008</p>
<div class="post-info"><h2 class="post-title"><a href="../../2008/towards-formal-power-series-for-functors/index.html" rel="bookmark" title="Permanent Link: Towards Formal Power Series for Functors">Towards Formal Power Series for Functors</a></h2>
Posted by Edward Kmett under <a href="../category-theory/index.html" title="View all posts in Category Theory" rel="category tag">Category Theory</a> ,  <a href="../haskell/index.html" title="View all posts in Haskell" rel="category tag">Haskell</a> ,  <a href="index.html" title="View all posts in Mathematics" rel="category tag">Mathematics</a> ,  <a href="../type-theory/index.html" title="View all posts in Type Theory" rel="category tag">Type Theory</a> <br/><a href="../../2008/towards-formal-power-series-for-functors/index.html#comments" title="Comment on Towards Formal Power Series for Functors">[12] Comments</a>&nbsp;</div>
<div class="post-content">
	<p>The post below will only compile on a version of GHC >= 6.9, since it uses type families.</p>
<p> <a href="../../2008/towards-formal-power-series-for-functors/index.html#more-57" class="more-link">(more...)</a></p>
	<div class="post-info">
			</div>
	<div class="post-footer">&nbsp;</div>
</div>
									</div>
						<p align="center"></p>		
					
	</div>
	<div id="sidebar">		
		<h2>Wiki</h2>
<ul>
    <li><a href="../../wiki/index-item=October%202006_August%202006_July%202006.html">Old Journal</a></li>
    <li><a href="../../source/index-item=libraries.html">Source</a>
    <li><a href="../../wiki/index-item=Harmless+Algorithms_fine-occlusion+culling.html">Harmless Algorithms</a></li>
</ul>
<!--
<h2>Pages</h2>
<ul><li class="page_item page-item-2"><a href="http://comonad.com/reader/about/" title="About">About</a></li>
<li class="page_item page-item-29"><a href="http://comonad.com/reader/source/" title="Source">Source</a></li>
<li class="page_item page-item-31"><a href="http://comonad.com/reader/wiki-category/" title="View Category">View Category</a></li>
<li class="page_item page-item-30"><a href="http://comonad.com/reader/wiki/" title="Wiki">Wiki</a></li>
</ul>
-->
<!--
<h2>Blog Topics</h2>
<ul>	<li class="cat-item cat-item-29"><a href="http://comonad.com/reader/category/algorithms/" title="View all posts filed under Algorithms">Algorithms</a> (13)
</li>
	<li class="cat-item cat-item-22"><a href="http://comonad.com/reader/category/category-theory/" title="View all posts filed under Category Theory">Category Theory</a> (31)
</li>
	<li class="cat-item cat-item-23"><a href="http://comonad.com/reader/category/comonads/" title="View all posts filed under Comonads">Comonads</a> (16)
</li>
	<li class="cat-item cat-item-28"><a href="http://comonad.com/reader/category/data-structures/" title="View all posts filed under Data Structures">Data Structures</a> (12)
</li>
	<li class="cat-item cat-item-15"><a href="http://comonad.com/reader/category/haskell/" title="View all posts filed under Haskell">Haskell</a> (57)
<ul class='children'>
	<li class="cat-item cat-item-34"><a href="http://comonad.com/reader/category/haskell/boston-haskell/" title="View all posts filed under Boston Haskell">Boston Haskell</a> (6)
	<ul class='children'>
	<li class="cat-item cat-item-42"><a href="http://comonad.com/reader/category/haskell/boston-haskell/hac-boston/" title="View all posts filed under Hac Boston">Hac Boston</a> (1)
</li>
	</ul>
</li>
	<li class="cat-item cat-item-43"><a href="http://comonad.com/reader/category/haskell/constraint-kinds/" title="View all posts filed under Constraint Kinds">Constraint Kinds</a> (2)
</li>
	<li class="cat-item cat-item-52"><a href="http://comonad.com/reader/category/haskell/infrastructure/" title="View all posts filed under Infrastructure">Infrastructure</a> (1)
</li>
</ul>
</li>
	<li class="cat-item cat-item-20"><a href="http://comonad.com/reader/category/javascript/" title="View all posts filed under Javascript">Javascript</a> (1)
</li>
	<li class="cat-item cat-item-27"><a href="http://comonad.com/reader/category/kan-extensions/" title="View all posts filed under Kan Extensions">Kan Extensions</a> (12)
</li>
	<li class="cat-item cat-item-47"><a href="http://comonad.com/reader/category/lenses/" title="View all posts filed under Lenses">Lenses</a> (1)
</li>
	<li class="cat-item cat-item-13"><a href="http://comonad.com/reader/category/logic/" title="View all posts filed under Logic">Logic</a> (4)
</li>
	<li class="cat-item cat-item-33"><a href="http://comonad.com/reader/category/macros/" title="View all posts filed under Macros">Macros</a> (1)
</li>
	<li class="cat-item cat-item-25 current-cat"><a href="http://comonad.com/reader/category/mathematics/" title="View all posts filed under Mathematics">Mathematics</a> (15)
<ul class='children'>
	<li class="cat-item cat-item-37"><a href="http://comonad.com/reader/category/mathematics/linear-algebra/" title="View all posts filed under Linear Algebra">Linear Algebra</a> (1)
</li>
</ul>
</li>
	<li class="cat-item cat-item-12"><a href="http://comonad.com/reader/category/meta/" title="View all posts filed under Meta">Meta</a> (3)
</li>
	<li class="cat-item cat-item-16"><a href="http://comonad.com/reader/category/monads/" title="View all posts filed under Monads">Monads</a> (27)
</li>
	<li class="cat-item cat-item-31"><a href="http://comonad.com/reader/category/monoids/" title="View all posts filed under Monoids">Monoids</a> (6)
</li>
	<li class="cat-item cat-item-30"><a href="http://comonad.com/reader/category/parsing/" title="View all posts filed under Parsing">Parsing</a> (5)
</li>
	<li class="cat-item cat-item-32"><a href="http://comonad.com/reader/category/scheme/" title="View all posts filed under Scheme">Scheme</a> (1)
</li>
	<li class="cat-item cat-item-24"><a href="http://comonad.com/reader/category/squiggol/" title="View all posts filed under Squiggol">Squiggol</a> (3)
</li>
	<li class="cat-item cat-item-21"><a href="http://comonad.com/reader/category/type-hackery/" title="View all posts filed under Type Hackery">Type Hackery</a> (7)
</li>
	<li class="cat-item cat-item-14"><a href="http://comonad.com/reader/category/type-theory/" title="View all posts filed under Type Theory">Type Theory</a> (5)
</li>
	<li class="cat-item cat-item-1"><a href="http://comonad.com/reader/category/uncategorized/" title="View all posts filed under Uncategorized">Uncategorized</a> (10)
</li>
</ul>
-->
<h2>Tag Cloud</h2>

<h2><label for="s">Search</label></h2>
	<ul>
		<li>
			<form id="searchform" method="get" action="/reader/index.php">
				<div style="text-align:center">
					<p><input type="text" name="s" id="s" size="10" /> <input type="submit" name="submit" value="Search" /></p>
				</div>
			</form>
		</li>
	</ul>
<!--
<h2>Monthly</h2>
	<ul>	<li><a href='http://comonad.com/reader/2012/09/' title='September 2012'>September 2012</a>&nbsp;(1)</li>
	<li><a href='http://comonad.com/reader/2012/08/' title='August 2012'>August 2012</a>&nbsp;(1)</li>
	<li><a href='http://comonad.com/reader/2012/06/' title='June 2012'>June 2012</a>&nbsp;(2)</li>
	<li><a href='http://comonad.com/reader/2012/05/' title='May 2012'>May 2012</a>&nbsp;(1)</li>
	<li><a href='http://comonad.com/reader/2012/04/' title='April 2012'>April 2012</a>&nbsp;(1)</li>
	<li><a href='http://comonad.com/reader/2011/12/' title='December 2011'>December 2011</a>&nbsp;(1)</li>
	<li><a href='http://comonad.com/reader/2011/11/' title='November 2011'>November 2011</a>&nbsp;(2)</li>
	<li><a href='http://comonad.com/reader/2011/10/' title='October 2011'>October 2011</a>&nbsp;(2)</li>
	<li><a href='http://comonad.com/reader/2011/09/' title='September 2011'>September 2011</a>&nbsp;(2)</li>
	<li><a href='http://comonad.com/reader/2011/07/' title='July 2011'>July 2011</a>&nbsp;(1)</li>
	<li><a href='http://comonad.com/reader/2011/06/' title='June 2011'>June 2011</a>&nbsp;(7)</li>
	<li><a href='http://comonad.com/reader/2010/07/' title='July 2010'>July 2010</a>&nbsp;(1)</li>
	<li><a href='http://comonad.com/reader/2010/05/' title='May 2010'>May 2010</a>&nbsp;(4)</li>
	<li><a href='http://comonad.com/reader/2010/04/' title='April 2010'>April 2010</a>&nbsp;(1)</li>
	<li><a href='http://comonad.com/reader/2009/09/' title='September 2009'>September 2009</a>&nbsp;(2)</li>
	<li><a href='http://comonad.com/reader/2009/08/' title='August 2009'>August 2009</a>&nbsp;(3)</li>
	<li><a href='http://comonad.com/reader/2009/07/' title='July 2009'>July 2009</a>&nbsp;(1)</li>
	<li><a href='http://comonad.com/reader/2009/06/' title='June 2009'>June 2009</a>&nbsp;(1)</li>
	<li><a href='http://comonad.com/reader/2009/03/' title='March 2009'>March 2009</a>&nbsp;(1)</li>
	<li><a href='http://comonad.com/reader/2008/12/' title='December 2008'>December 2008</a>&nbsp;(1)</li>
	<li><a href='http://comonad.com/reader/2008/11/' title='November 2008'>November 2008</a>&nbsp;(1)</li>
	<li><a href='http://comonad.com/reader/2008/06/' title='June 2008'>June 2008</a>&nbsp;(3)</li>
	<li><a href='http://comonad.com/reader/2008/05/' title='May 2008'>May 2008</a>&nbsp;(10)</li>
	<li><a href='http://comonad.com/reader/2008/04/' title='April 2008'>April 2008</a>&nbsp;(7)</li>
	<li><a href='http://comonad.com/reader/2008/03/' title='March 2008'>March 2008</a>&nbsp;(2)</li>
	<li><a href='http://comonad.com/reader/2008/01/' title='January 2008'>January 2008</a>&nbsp;(1)</li>
	<li><a href='http://comonad.com/reader/2007/07/' title='July 2007'>July 2007</a>&nbsp;(2)</li>
	<li><a href='http://comonad.com/reader/2007/05/' title='May 2007'>May 2007</a>&nbsp;(1)</li>
	<li><a href='http://comonad.com/reader/2006/11/' title='November 2006'>November 2006</a>&nbsp;(3)</li>
	<li><a href='http://comonad.com/reader/2006/10/' title='October 2006'>October 2006</a>&nbsp;(2)</li>
</ul>
-->
		
<h2>Ads</h2><ul><li><div class="ads" align="center">
<script type="text/javascript"><!--
google_ad_client = "pub-9028661600722510";
google_ad_width = 160;
google_ad_height = 600;
google_ad_format = "160x600_as";
google_ad_type = "text_image";
//2006-10-18: Comonad.Reader
google_ad_channel = "6386706477";
google_color_border = "F3F6ED";
google_color_bg = "F3F6ED";
google_color_link = "0E2F0E"; // #0e3f0e 007733
google_color_text = "000000";
google_color_url = "007733";
//--></script><script type="text/javascript" src="http://pagead2.googlesyndication.com/pagead/show_ads.js"></script></div>
</li></ul>
<h2>RSS Feeds</h2>
	<ul>
		<li>
			<a title="RSS2 Feed for Posts" href="../../feed/index.html">Posts</a> | <a title="RSS2 Feed for Comments" href="../../comments/feed/index.html">Comments</a></li>	
	</ul>	
	</div>
<p id="footer">Design based on <a href="http://www.vanillamist.com" title="Vanilla Mist">www.vanillamist.com</a></p></div>
</div>
</body>
</html>

<!-- Localized -->