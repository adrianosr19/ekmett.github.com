<?xml version="1.0" encoding="UTF-8" ?><feed
	xmlns="http://www.w3.org/2005/Atom"
	xml:lang="en"
	xmlns:thr="http://purl.org/syndication/thread/1.0"
	>
	<title type="text">Comments on: What Constraints Entail: Part 1</title>
	<subtitle type="text">types, (co)monads, substructural logic</subtitle>

	<updated>2012-11-18T17:21:31Z</updated>
	<generator uri="http://wordpress.org/" version="2.8.4">WordPress</generator>

	<link rel="alternate" type="text/html" href="../../index.html#comments" />
	<link rel="self" type="application/atom+xml" href="index.html" />
	<id>http://comonad.com/reader/2011/what-constraints-entail-part-1/feed/atom/</id>
	<entry>
		<title>By: zzo38</title>
		<link rel="alternate" href="../../comment-page-1/index.html#comment-105339" type="text/html" />

		<author>
			<name>zzo38</name>
			
		</author>

		<id>http://comonad.com/reader/?p=430#comment-105339</id>
		<updated>2012-06-26T18:59:20Z</updated>
		<published>2012-06-26T18:59:20Z</published>
		<content type="html" xml:base="http://comonad.com/reader/2011/what-constraints-entail-part-1/comment-page-1/#comment-105339"><![CDATA[<p>What I have decided for Ibtlfmm it does not use this kind of superkinds (and Constraint is named &amp; while @ is used for program modules, although you can give them alphabetic names if you want using kind synonyms), rather I would think (,) and () and so on are macros that decide the corresponding types according to what fits. There could also be &#8220;kind classes&#8221; to rebind the syntax, although I prefer using macros. But yes () should be a constraint too. I do not think making up the new superkiind for this purpose is such a good idea (including for the reasons you have described).</p>
]]></content>
		<thr:in-reply-to ref="http://comonad.com/reader/?p=430" href="http://comonad.com/reader/2011/what-constraints-entail-part-1/" type="text/html" />
	</entry>
	<entry>
		<title>By: Doug McClean</title>
		<link rel="alternate" href="../../comment-page-1/index.html#comment-84922" type="text/html" />

		<author>
			<name>Doug McClean</name>
			
		</author>

		<id>http://comonad.com/reader/?p=430#comment-84922</id>
		<updated>2011-11-16T21:13:56Z</updated>
		<published>2011-11-16T21:13:56Z</published>
		<content type="html" xml:base="http://comonad.com/reader/2011/what-constraints-entail-part-1/comment-page-1/#comment-84922"><![CDATA[<p>This overloading problem with (,) and () seems like it&#8217;s just yet another case of there be insufficiently many kinds of bracketing characters that (a) Unicode encodes, (b) can be typed (keyboarded) easily, and (c) are visually distinguishable.</p>
<p>The same problem arises with {} signifying the empty set and the record with no attributes. Basically the same thing clutters up the possibility of having a nice concrete syntax for all of: lists, sets, bags, vectors, matrices.</p>
<p>At the same time, it adds a lot more noise to require writing Set { 3, 7, 2 } everywhere since just { 3, 7, 2 } doesn&#8217;t overlap with the concrete syntax for records like { frog := 2, apple := &#8220;moose&#8221; }.</p>
<p>It seems like the middle ground approach is to make a lot of granular &#8220;re-bindable syntax&#8221; type classes for all of the different literals.</p>
<p>Following that approach seems to work well, and ordinary type ascription expressions suffice to resolve the empty cases. Committing to it fully does feel a little silly in some cases though.</p>
<p>For example, zero is more polymorphic than other numeric literals. This arises because zero may have any dimension, but 3.7 is always dimensionless. The only language I know of that encodes this is CSS, although I&#8217;m sure there are others.</p>
<p>This sort of thing is leading to my pet language having a large number of type classes which play a role in desugaring, but I think that&#8217;s a tradeoff I&#8217;m willing to make.</p>
]]></content>
		<thr:in-reply-to ref="http://comonad.com/reader/?p=430" href="http://comonad.com/reader/2011/what-constraints-entail-part-1/" type="text/html" />
	</entry>
	<entry>
		<title>By: Edward Kmett</title>
		<link rel="alternate" href="../../comment-page-1/index.html#comment-81890" type="text/html" />

		<author>
			<name>Edward Kmett</name>
			<uri>http://comonad.com</uri>
		</author>

		<id>http://comonad.com/reader/?p=430#comment-81890</id>
		<updated>2011-11-03T15:28:41Z</updated>
		<published>2011-11-03T15:28:41Z</published>
		<content type="html" xml:base="http://comonad.com/reader/2011/what-constraints-entail-part-1/comment-page-1/#comment-81890"><![CDATA[<p>@Dan, </p>
<p>Good catch. I&#8217;d had it drawn that way on the whiteboard at work, but somewhere along the way got it flipped.</p>
<p>In practice, I think just doing the right thing and adding @ so we can do the bounded quantification at the kind level is a better idea than trying to preserve the bandaid.</p>
]]></content>
		<thr:in-reply-to ref="http://comonad.com/reader/?p=430" href="http://comonad.com/reader/2011/what-constraints-entail-part-1/" type="text/html" />
	</entry>
	<entry>
		<title>By: Dan Doel</title>
		<link rel="alternate" href="../../comment-page-1/index.html#comment-81888" type="text/html" />

		<author>
			<name>Dan Doel</name>
			
		</author>

		<id>http://comonad.com/reader/?p=430#comment-81888</id>
		<updated>2011-11-03T15:23:55Z</updated>
		<published>2011-11-03T15:23:55Z</published>
		<content type="html" xml:base="http://comonad.com/reader/2011/what-constraints-entail-part-1/comment-page-1/#comment-81888"><![CDATA[<p>I don&#8217;t think your subtyping scheme fixes the problem for (), either. If ??? includes both Constraint and *, then making () : ??? doesn&#8217;t help, because that doesn&#8217;t imply the judgments of both () : * and () : Constraint. What you would need is to make ??? a common lower bound for * and Constraint that contains ().</p>
<p>And of course, this is a long way to go to resolve a single case of overloading.</p>
]]></content>
		<thr:in-reply-to ref="http://comonad.com/reader/?p=430" href="http://comonad.com/reader/2011/what-constraints-entail-part-1/" type="text/html" />
	</entry>
</feed>

<!-- Localized -->