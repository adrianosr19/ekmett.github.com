<?xml version="1.0" encoding="UTF-8"?><rss version="2.0"
	xmlns:content="http://purl.org/rss/1.0/modules/content/"
	xmlns:dc="http://purl.org/dc/elements/1.1/"
	xmlns:atom="http://www.w3.org/2005/Atom"
	xmlns:sy="http://purl.org/rss/1.0/modules/syndication/"
		>
<channel>
	<title>Comments on: Free Monads for Less (Part 3 of 3): Yielding IO</title>
	<atom:link href="http://comonad.com/reader/2011/free-monads-for-less-3/feed/" rel="self" type="application/rss+xml" />
	<link>http://comonad.com/reader/2011/free-monads-for-less-3/</link>
	<description>types, (co)monads, substructural logic</description>
	<lastBuildDate>Sun, 18 Nov 2012 17:21:31 -0500</lastBuildDate>
	<generator>http://wordpress.org/?v=2.8.4</generator>
	<sy:updatePeriod>hourly</sy:updatePeriod>
	<sy:updateFrequency>1</sy:updateFrequency>
		<item>
		<title>By: Edward Kmett</title>
		<link>http://comonad.com/reader/2011/free-monads-for-less-3/comment-page-1/#comment-106228</link>
		<dc:creator>Edward Kmett</dc:creator>
		<pubDate>Sun, 07 Oct 2012 03:38:40 +0000</pubDate>
		<guid isPermaLink="false">http://comonad.com/reader/?p=251#comment-106228</guid>
		<description>The irony with that is that it is particularly easy to add cases to a &#039;Free&#039;/a la carte monad in scala. Just don&#039;t seal the class. ;)

To mitigate the boilerplate in Haskell at least, the typeclasses for config, db connection, etc. can be autogenerated by something like makeClassy from my lens package.</description>
		<content:encoded><![CDATA[<p>The irony with that is that it is particularly easy to add cases to a &#8216;Free&#8217;/a la carte monad in scala. Just don&#8217;t seal the class. ;)</p>
<p>To mitigate the boilerplate in Haskell at least, the typeclasses for config, db connection, etc. can be autogenerated by something like makeClassy from my lens package.</p>
]]></content:encoded>
	</item>
	<item>
		<title>By: Richard Wallace</title>
		<link>http://comonad.com/reader/2011/free-monads-for-less-3/comment-page-1/#comment-106223</link>
		<dc:creator>Richard Wallace</dc:creator>
		<pubDate>Sat, 06 Oct 2012 23:44:04 +0000</pubDate>
		<guid isPermaLink="false">http://comonad.com/reader/?p=251#comment-106223</guid>
		<description>Ok, I understand the cost of tupling up more and more and that being undesirable.  Also, you&#039;re right that adding new constructors breaks the whole &quot;a la Carte&quot; notion.

I&#039;m just looking for alternatives to the typical way of building FP apps of using a monad transformer stack with ReaderT and StateT and type-classes for all the data you want to inject (config, db connections, etc.).  I was looking at the a la Carte approach as a way of doing that.  Although, to be fair my distaste for this approach comes from a Scala app where it became a PITA to manage everything and if it had been written in Haskell the experience might have been different.</description>
		<content:encoded><![CDATA[<p>Ok, I understand the cost of tupling up more and more and that being undesirable.  Also, you&#8217;re right that adding new constructors breaks the whole &#8220;a la Carte&#8221; notion.</p>
<p>I&#8217;m just looking for alternatives to the typical way of building FP apps of using a monad transformer stack with ReaderT and StateT and type-classes for all the data you want to inject (config, db connections, etc.).  I was looking at the a la Carte approach as a way of doing that.  Although, to be fair my distaste for this approach comes from a Scala app where it became a PITA to manage everything and if it had been written in Haskell the experience might have been different.</p>
]]></content:encoded>
	</item>
	<item>
		<title>By: Edward Kmett</title>
		<link>http://comonad.com/reader/2011/free-monads-for-less-3/comment-page-1/#comment-106004</link>
		<dc:creator>Edward Kmett</dc:creator>
		<pubDate>Fri, 07 Sep 2012 13:53:58 +0000</pubDate>
		<guid isPermaLink="false">http://comonad.com/reader/?p=251#comment-106004</guid>
		<description>The difference is in order to support new operations with the usual free monad/a la carte approach you need to define a new data type or a new constructor, or tuple up more and more stuff and pay a higher and higher cost when accessing the next constructor.

We use this in a language we have here at S&amp;P Capital IQ called Ermine as our only FFI mechanism. It isn&#039;t something you could bolt into, say, GHC without changing out pretty much everything in the language, but in a new Haskell implementation, it has the benefit that you don&#039;t need to deal with magic RealWorld tokens and then restrict transformations that may attempt to commute past them. 

This enables you to transform the language more easily, in exchange, we denote operations with this separate FFI type, rather than primops, and view the runtime system as an external agent driving an asymmetric coroutine.</description>
		<content:encoded><![CDATA[<p>The difference is in order to support new operations with the usual free monad/a la carte approach you need to define a new data type or a new constructor, or tuple up more and more stuff and pay a higher and higher cost when accessing the next constructor.</p>
<p>We use this in a language we have here at S&amp;P Capital IQ called Ermine as our only FFI mechanism. It isn&#8217;t something you could bolt into, say, GHC without changing out pretty much everything in the language, but in a new Haskell implementation, it has the benefit that you don&#8217;t need to deal with magic RealWorld tokens and then restrict transformations that may attempt to commute past them. </p>
<p>This enables you to transform the language more easily, in exchange, we denote operations with this separate FFI type, rather than primops, and view the runtime system as an external agent driving an asymmetric coroutine.</p>
]]></content:encoded>
	</item>
	<item>
		<title>By: Richard Wallace</title>
		<link>http://comonad.com/reader/2011/free-monads-for-less-3/comment-page-1/#comment-106002</link>
		<dc:creator>Richard Wallace</dc:creator>
		<pubDate>Fri, 07 Sep 2012 06:24:32 +0000</pubDate>
		<guid isPermaLink="false">http://comonad.com/reader/?p=251#comment-106002</guid>
		<description>I&#039;m not clear on what you mean by the set of FFI operations being closed with the &quot;Data Types a la Carte&quot; approach. It seems to me the point of that approach is to not limit operations. You just define new operations and interpreters for those operations.

I&#039;m also not clear on how the proposed FFI type you&#039;ve presented here works.  How is it not limited? How would you define such a thing in Haskell? (Very curious about this approach because right now I&#039;m planning on using the approach from &quot;Data Types a la Carte&quot;, but am always interested in learning about/using something better.)</description>
		<content:encoded><![CDATA[<p>I&#8217;m not clear on what you mean by the set of FFI operations being closed with the &#8220;Data Types a la Carte&#8221; approach. It seems to me the point of that approach is to not limit operations. You just define new operations and interpreters for those operations.</p>
<p>I&#8217;m also not clear on how the proposed FFI type you&#8217;ve presented here works.  How is it not limited? How would you define such a thing in Haskell? (Very curious about this approach because right now I&#8217;m planning on using the approach from &#8220;Data Types a la Carte&#8221;, but am always interested in learning about/using something better.)</p>
]]></content:encoded>
	</item>
	<item>
		<title>By: Edward Kmett</title>
		<link>http://comonad.com/reader/2011/free-monads-for-less-3/comment-page-1/#comment-61443</link>
		<dc:creator>Edward Kmett</dc:creator>
		<pubDate>Sat, 25 Jun 2011 18:24:07 +0000</pubDate>
		<guid isPermaLink="false">http://comonad.com/reader/?p=251#comment-61443</guid>
		<description>@Chris: Nice!</description>
		<content:encoded><![CDATA[<p>@Chris: Nice!</p>
]]></content:encoded>
	</item>
	<item>
		<title>By: Chris Kuklewicz</title>
		<link>http://comonad.com/reader/2011/free-monads-for-less-3/comment-page-1/#comment-61413</link>
		<dc:creator>Chris Kuklewicz</dc:creator>
		<pubDate>Sat, 25 Jun 2011 14:13:18 +0000</pubDate>
		<guid isPermaLink="false">http://comonad.com/reader/?p=251#comment-61413</guid>
		<description>After being clumsy for a while, I reached the end.  Great post.

Reordering some arguments in IO to

(forall i o.  (i -&gt; r) -&gt; FFI o i -&gt; o -&gt; r)

gives the more concise

unsafePerformIO (IO m) = m id fmap

which for simple FFI functions is

unsafePerformIO (IO m) = m id (.)</description>
		<content:encoded><![CDATA[<p>After being clumsy for a while, I reached the end.  Great post.</p>
<p>Reordering some arguments in IO to</p>
<p>(forall i o.  (i -&gt; r) -&gt; FFI o i -&gt; o -&gt; r)</p>
<p>gives the more concise</p>
<p>unsafePerformIO (IO m) = m id fmap</p>
<p>which for simple FFI functions is</p>
<p>unsafePerformIO (IO m) = m id (.)</p>
]]></content:encoded>
	</item>
	<item>
		<title>By: Edward Kmett</title>
		<link>http://comonad.com/reader/2011/free-monads-for-less-3/comment-page-1/#comment-61383</link>
		<dc:creator>Edward Kmett</dc:creator>
		<pubDate>Sat, 25 Jun 2011 05:31:35 +0000</pubDate>
		<guid isPermaLink="false">http://comonad.com/reader/?p=251#comment-61383</guid>
		<description>@Wren: parallelism works fine and was a large portion of the motivation for this approach. A program exists in a quiescent state. From the outside (a thread), I can ask a term to evaluate itself apply itself to an argument, and do case analysis upon the result. We apply that to main and keep pumping. Any of those operations can be performed in parallel; the answers to them are all referentially transparent! Hence we can have as many threads running as we want demanding those answers. We aren&#039;t passing a world. The evaluator just responds transparently to demands from the RTS, potentially many such demands simultaneously.</description>
		<content:encoded><![CDATA[<p>@Wren: parallelism works fine and was a large portion of the motivation for this approach. A program exists in a quiescent state. From the outside (a thread), I can ask a term to evaluate itself apply itself to an argument, and do case analysis upon the result. We apply that to main and keep pumping. Any of those operations can be performed in parallel; the answers to them are all referentially transparent! Hence we can have as many threads running as we want demanding those answers. We aren&#8217;t passing a world. The evaluator just responds transparently to demands from the RTS, potentially many such demands simultaneously.</p>
]]></content:encoded>
	</item>
	<item>
		<title>By: wren ng thornton</title>
		<link>http://comonad.com/reader/2011/free-monads-for-less-3/comment-page-1/#comment-61376</link>
		<dc:creator>wren ng thornton</dc:creator>
		<pubDate>Sat, 25 Jun 2011 04:36:35 +0000</pubDate>
		<guid isPermaLink="false">http://comonad.com/reader/?p=251#comment-61376</guid>
		<description>Your language&#039;s IO type is extremely reminiscent of the old pre-monad Haskell days of main :: [Response]-&gt;[Request]. Except that with the coroutine structure you ensure that requests and responses can&#039;t get out of sync. That&#039;s quite elegant. Much nicer than the RealWorld baton in a lot of ways.

Have you considered how parallelism plays into this model of I/O?</description>
		<content:encoded><![CDATA[<p>Your language&#8217;s IO type is extremely reminiscent of the old pre-monad Haskell days of main :: [Response]-&gt;[Request]. Except that with the coroutine structure you ensure that requests and responses can&#8217;t get out of sync. That&#8217;s quite elegant. Much nicer than the RealWorld baton in a lot of ways.</p>
<p>Have you considered how parallelism plays into this model of I/O?</p>
]]></content:encoded>
	</item>
	<item>
		<title>By: Max Bolingbroke</title>
		<link>http://comonad.com/reader/2011/free-monads-for-less-3/comment-page-1/#comment-61279</link>
		<dc:creator>Max Bolingbroke</dc:creator>
		<pubDate>Fri, 24 Jun 2011 15:07:07 +0000</pubDate>
		<guid isPermaLink="false">http://comonad.com/reader/?p=251#comment-61279</guid>
		<description>Unspeakably awesome series of posts: the idea density is so high :-). This has answered many questions for me, but raised many more that I now need to think about..</description>
		<content:encoded><![CDATA[<p>Unspeakably awesome series of posts: the idea density is so high :-). This has answered many questions for me, but raised many more that I now need to think about..</p>
]]></content:encoded>
	</item>
</channel>
</rss>

<!-- Localized -->