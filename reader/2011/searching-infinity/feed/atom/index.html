<?xml version="1.0" encoding="UTF-8" ?><feed
	xmlns="http://www.w3.org/2005/Atom"
	xml:lang="en"
	xmlns:thr="http://purl.org/syndication/thread/1.0"
	>
	<title type="text">Comments on: Searching Infinity Parametrically</title>
	<subtitle type="text">types, (co)monads, substructural logic</subtitle>

	<updated>2012-11-18T17:21:31Z</updated>
	<generator uri="http://wordpress.org/" version="2.8.4">WordPress</generator>

	<link rel="alternate" type="text/html" href="../../index.html#comments" />
	<link rel="self" type="application/atom+xml" href="index.html" />
	<id>http://comonad.com/reader/2011/searching-infinity/feed/atom/</id>
	<entry>
		<title>By: Ryan Ingram</title>
		<link rel="alternate" href="../../comment-page-1/index.html#comment-101855" type="text/html" />

		<author>
			<name>Ryan Ingram</name>
			
		</author>

		<id>http://comonad.com/reader/?p=510#comment-101855</id>
		<updated>2012-02-22T23:43:08Z</updated>
		<published>2012-02-22T23:43:08Z</published>
		<content type="html" xml:base="http://comonad.com/reader/2011/searching-infinity/comment-page-1/#comment-101855"><![CDATA[<p>Hm, I changed my mind.  effectify requires you to order all the calls inside the otherwise pure f, which violates referential transparency; in (\k :: (String-&gt;Int) -&gt; k &#8220;a&#8221; + k &#8220;b&#8221;) (with strict (+)), the compiler is allowed to choose whether it wants to evaluate k &#8220;a&#8221; or k &#8220;b&#8221; first, while in the effectful version the caller needs to explicitly make that decision.</p>
]]></content>
		<thr:in-reply-to ref="http://comonad.com/reader/?p=510" href="http://comonad.com/reader/2011/searching-infinity/" type="text/html" />
	</entry>
	<entry>
		<title>By: Ryan Ingram</title>
		<link rel="alternate" href="../../comment-page-1/index.html#comment-101849" type="text/html" />

		<author>
			<name>Ryan Ingram</name>
			
		</author>

		<id>http://comonad.com/reader/?p=510#comment-101849</id>
		<updated>2012-02-22T23:02:20Z</updated>
		<published>2012-02-22T23:02:20Z</published>
		<content type="html" xml:base="http://comonad.com/reader/2011/searching-infinity/comment-page-1/#comment-101849"><![CDATA[<p>One thing that&#8217;s interesting to me is the transformation from</p>
<p>   type Pure a b c = (a -&gt; b) -&gt; c</p>
<p>to</p>
<p>   type Effect a b c = forall f. Monad f =&gt; (a -&gt; f b) -&gt; f c</p>
<p>Clearly f_effect is pure; you can get f_pure from f_effect by specializing f to the identity monad:</p>
<p>   purify :: Effect a b c -&gt; Pure a b c<br />
   purify f ab = runIdentity $ f $ \a -&gt; Identity $ ab a</p>
<p>But it seems to me that no unsoundness is introduced by allowing this isomorphism in the other direction as well, although I don&#8217;t think that&#8217;s implementable in Haskell.</p>
<p>   effectify :: Pure a b c -&gt; Effect a b c<br />
   effectify f = ???</p>
]]></content>
		<thr:in-reply-to ref="http://comonad.com/reader/?p=510" href="http://comonad.com/reader/2011/searching-infinity/" type="text/html" />
	</entry>
	<entry>
		<title>By: Edward Kmett</title>
		<link rel="alternate" href="../../comment-page-1/index.html#comment-92273" type="text/html" />

		<author>
			<name>Edward Kmett</name>
			<uri>http://comonad.com/</uri>
		</author>

		<id>http://comonad.com/reader/?p=510#comment-92273</id>
		<updated>2011-12-25T20:22:35Z</updated>
		<published>2011-12-25T20:22:35Z</published>
		<content type="html" xml:base="http://comonad.com/reader/2011/searching-infinity/comment-page-1/#comment-92273"><![CDATA[<p>Sean: the fact that we can search it in finite time derives from the fact that the predicate is required to evaluate in a bounded amount of time regardless of the &#8217;size&#8217; of the input. This keeps me from trying to compare with a lazy nat with infinity, and ensures I only look at so many of the results from the Cantor space. </p>
<p>The ability to do this in finite time would hold even if you had a language that could represent uncountably many programs! That I believe was Andrej&#8217;s point.</p>
<p>Consider data vs. codata. Think of the Cantor&#8217;s space as &#8216;codata&#8217;.  It is infinitely large, but we can productively consume any finite portion of it. Determining the neighborhood used by a predicate only requires a finite amount of time, and then we wrap back into codata by filling in the infinite set of other cases with a valid inhabitant.</p>
<p>Ultimately all we have to do is find the neighborhood that was inspected (which is finite and can be done in finite time) and find a member of that neighborhood where the property does or does not hold. </p>
<p>This ability to search doesn&#8217;t make any use of the finiteness of the language. The finiteness of the language is interesting but irrelevant for this purpose.</p>
]]></content>
		<thr:in-reply-to ref="http://comonad.com/reader/?p=510" href="http://comonad.com/reader/2011/searching-infinity/" type="text/html" />
	</entry>
	<entry>
		<title>By: Dan Doel</title>
		<link rel="alternate" href="../../comment-page-1/index.html#comment-92272" type="text/html" />

		<author>
			<name>Dan Doel</name>
			
		</author>

		<id>http://comonad.com/reader/?p=510#comment-92272</id>
		<updated>2011-12-25T20:14:11Z</updated>
		<published>2011-12-25T20:14:11Z</published>
		<content type="html" xml:base="http://comonad.com/reader/2011/searching-infinity/comment-page-1/#comment-92272"><![CDATA[<p>&#8220;Are you saying there are only countably many streams of bits in the real world?&#8221;</p>
<p>What would make you think there are even infinitely many streams of bits in the real world?</p>
]]></content>
		<thr:in-reply-to ref="http://comonad.com/reader/?p=510" href="http://comonad.com/reader/2011/searching-infinity/" type="text/html" />
	</entry>
	<entry>
		<title>By: Sean</title>
		<link rel="alternate" href="../../comment-page-1/index.html#comment-92257" type="text/html" />

		<author>
			<name>Sean</name>
			
		</author>

		<id>http://comonad.com/reader/?p=510#comment-92257</id>
		<updated>2011-12-25T18:40:40Z</updated>
		<published>2011-12-25T18:40:40Z</published>
		<content type="html" xml:base="http://comonad.com/reader/2011/searching-infinity/comment-page-1/#comment-92257"><![CDATA[<p>&gt; With that we jump clear from countable infinity to uncountable infinity, but it can still be searched in finite time!</p>
<p>Indeed, when we take uncountable to mean subcountable, I find it far less shocking that we can search it in finite time. To propose that we can search an uncountable ZFC set in finite time is a much stranger proposition.</p>
]]></content>
		<thr:in-reply-to ref="http://comonad.com/reader/?p=510" href="http://comonad.com/reader/2011/searching-infinity/" type="text/html" />
	</entry>
	<entry>
		<title>By: Sean</title>
		<link rel="alternate" href="../../comment-page-1/index.html#comment-92256" type="text/html" />

		<author>
			<name>Sean</name>
			
		</author>

		<id>http://comonad.com/reader/?p=510#comment-92256</id>
		<updated>2011-12-25T18:18:57Z</updated>
		<published>2011-12-25T18:18:57Z</published>
		<content type="html" xml:base="http://comonad.com/reader/2011/searching-infinity/comment-page-1/#comment-92256"><![CDATA[<p>@Dan P: I don&#8217;t see what any of this has to do with implementation details of any form. I&#8217;m just requiring some bijection between integers and strings which we interpret as Haskell code (Godel numbering will do).</p>
<p>@Andrej: Agreed (although I don&#8217;t believe I&#8217;m requiring any sort of quoting mechanism&#8230;). I&#8217;m simply arguing that while &#8220;uncountable&#8221; has the same formal definition, intuitively it behaves much differently than it does in ZFC. In ZFC it means &#8220;very large&#8221;, while in this kind of intuitionistic setting it can mean &#8220;smaller than countable&#8221; (subcountable). The meanings are so different that I&#8217;m leery to call them the same thing, for fear that we mislead the classical mathematicians.</p>
]]></content>
		<thr:in-reply-to ref="http://comonad.com/reader/?p=510" href="http://comonad.com/reader/2011/searching-infinity/" type="text/html" />
	</entry>
	<entry>
		<title>By: Andrej Bauer</title>
		<link rel="alternate" href="../../comment-page-1/index.html#comment-92237" type="text/html" />

		<author>
			<name>Andrej Bauer</name>
			<uri>http://math.andrej.com/</uri>
		</author>

		<id>http://comonad.com/reader/?p=510#comment-92237</id>
		<updated>2011-12-25T14:08:52Z</updated>
		<published>2011-12-25T14:08:52Z</published>
		<content type="html" xml:base="http://comonad.com/reader/2011/searching-infinity/comment-page-1/#comment-92237"><![CDATA[<p>@Sean: the definition of countable simply is &#8220;there is a surjection from the natural numbers&#8221;. Subsets of countable sets are called &#8220;subcountable&#8221; and can be very, very complicated in intuitionistic logic, for example they need not be countable. In addition, your proposed plan to take codes of functions does not quite work inside Haskell, as there is no way to get the code of a function in Haskell, i.e., all total maps (int -&gt; bool) -&gt; int are constant. You would have to extend Haskell by some sort of a quoting mechanism that would allow you to always access source code (or the machine instructions of the compiled code). With such modifications your idea demonstrates the fact that it is consistent to assume intuitionistically that the Cantor space is a quotient of a subset of a countable set. Nevertheless, it is still uncountable.</p>
]]></content>
		<thr:in-reply-to ref="http://comonad.com/reader/?p=510" href="http://comonad.com/reader/2011/searching-infinity/" type="text/html" />
	</entry>
	<entry>
		<title>By: Dan P</title>
		<link rel="alternate" href="../../comment-page-1/index.html#comment-92209" type="text/html" />

		<author>
			<name>Dan P</name>
			
		</author>

		<id>http://comonad.com/reader/?p=510#comment-92209</id>
		<updated>2011-12-25T10:22:47Z</updated>
		<published>2011-12-25T10:22:47Z</published>
		<content type="html" xml:base="http://comonad.com/reader/2011/searching-infinity/comment-page-1/#comment-92209"><![CDATA[<p>@Sean: one of the nice things about Haskell is that you can pretty much run it on paper or on an abstract machine. </p>
<p>We use it to model mathematical ideas all the time, ignoring the fact that (for example) Integer, being implemented on top of GMP, is finite (2^53 bits or something is the maximum allowed, even if you did have infinite memory). I think that pointing out one of the implementation details of one of Haskell&#8217;s &#8220;interpreters&#8221; (a CPU) is kind of missing the point here.</p>
]]></content>
		<thr:in-reply-to ref="http://comonad.com/reader/?p=510" href="http://comonad.com/reader/2011/searching-infinity/" type="text/html" />
	</entry>
	<entry>
		<title>By: Sean</title>
		<link rel="alternate" href="../../comment-page-1/index.html#comment-92198" type="text/html" />

		<author>
			<name>Sean</name>
			
		</author>

		<id>http://comonad.com/reader/?p=510#comment-92198</id>
		<updated>2011-12-25T08:25:02Z</updated>
		<published>2011-12-25T08:25:02Z</published>
		<content type="html" xml:base="http://comonad.com/reader/2011/searching-infinity/comment-page-1/#comment-92198"><![CDATA[<p>@Andrej: Fair enough, but if you want to stay within Haskell, your definition of &#8220;uncountable&#8221; may not be what you are expecting anymore. It&#8217;s true that there is no total surjection e : Integer -&gt; (Integer -&gt; Bool), but there is a partial surjection. Decode the Integer into Haskell code via your favorite encoding, and interpret the Haskell code. Some will fail to decode as well-typed Haskell programs of type Integer -&gt; Bool, and some will fail to terminate. But you&#8217;ll cover all of them. So in some sense there are actually &#8220;fewer&#8221; functions Integer -&gt; Bool than there are Integers.</p>
<p>As for the existence of uncountably many streams of bits in the real world, I&#8217;m not willing to make any sort of commitment on that statement. I will say that no one has yet satisfactorily shown me uncountably many streams in the real world :)</p>
]]></content>
		<thr:in-reply-to ref="http://comonad.com/reader/?p=510" href="http://comonad.com/reader/2011/searching-infinity/" type="text/html" />
	</entry>
	<entry>
		<title>By: Andrej Bauer</title>
		<link rel="alternate" href="../../comment-page-1/index.html#comment-92191" type="text/html" />

		<author>
			<name>Andrej Bauer</name>
			<uri>http://math.andrej.com/</uri>
		</author>

		<id>http://comonad.com/reader/?p=510#comment-92191</id>
		<updated>2011-12-25T07:52:56Z</updated>
		<published>2011-12-25T07:52:56Z</published>
		<content type="html" xml:base="http://comonad.com/reader/2011/searching-infinity/comment-page-1/#comment-92191"><![CDATA[<p>@Sean: It is not fair to judge a Haskell type from outside Haskell. As far as Haskell is concerned, Integer -&gt; Bool is uncountable. Given any sequence alleged enumeration e : Integer -&gt; (Integer -&gt; Bool) of cantor space, the sequence \n -&gt; not (e n n) is missed by e. So you cannot enumerate the type in Haskell, which is the relevant thing, who cares if god can enumerate Haskell types? (Yes, it takes the birth of Jesus to enumerate total functions, so Merry Christmas!) And another observation: Haskell has access to the real world and can use real-world data to construct elements of type Integer -&gt; Bool. Are you saying there are only countably many streams of bits in the real world?</p>
<p>@Edward: Very nice post. I suspected something of the kind can be done, but you&#8217;re very good at minimizing the &#8220;damage&#8221; done by explicit monads. One questions remains, I think. What specification is the input predicate supposed to satisfy? The LICS 2010 paper by Martin Hofmann et al. might be relevant, see <a href="http://www2.in.tum.de/bib/files/Hofmann10Pure.pdf" rel="nofollow">http://www2.in.tum.de/bib/files/Hofmann10Pure.pdf</a>. They also use the trick with &#8220;parametric in all monads&#8221;.</p>
]]></content>
		<thr:in-reply-to ref="http://comonad.com/reader/?p=510" href="http://comonad.com/reader/2011/searching-infinity/" type="text/html" />
	</entry>
</feed>

<!-- Localized -->