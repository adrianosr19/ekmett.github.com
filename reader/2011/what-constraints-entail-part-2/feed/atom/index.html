<?xml version="1.0" encoding="UTF-8" ?><feed
	xmlns="http://www.w3.org/2005/Atom"
	xml:lang="en"
	xmlns:thr="http://purl.org/syndication/thread/1.0"
	>
	<title type="text">Comments on: What Constraints Entail: Part 2</title>
	<subtitle type="text">types, (co)monads, substructural logic</subtitle>

	<updated>2012-11-18T17:21:31Z</updated>
	<generator uri="http://wordpress.org/" version="2.8.4">WordPress</generator>

	<link rel="alternate" type="text/html" href="../../index.html#comments" />
	<link rel="self" type="application/atom+xml" href="index.html" />
	<id>http://comonad.com/reader/2011/what-constraints-entail-part-2/feed/atom/</id>
	<entry>
		<title>By: zzo38</title>
		<link rel="alternate" href="../../comment-page-1/index.html#comment-105341" type="text/html" />

		<author>
			<name>zzo38</name>
			
		</author>

		<id>http://comonad.com/reader/?p=461#comment-105341</id>
		<updated>2012-06-26T19:08:42Z</updated>
		<published>2012-06-26T19:08:42Z</published>
		<content type="html" xml:base="http://comonad.com/reader/2011/what-constraints-entail-part-2/comment-page-1/#comment-105341"><![CDATA[<p>I like this! Nevertheless they are not perfect, not like real superclass, it is why I wanted to define my own programming language to correct these things, but at least Haskell has been improved by these thing so that much works OK.</p>
]]></content>
		<thr:in-reply-to ref="http://comonad.com/reader/?p=461" href="http://comonad.com/reader/2011/what-constraints-entail-part-2/" type="text/html" />
	</entry>
	<entry>
		<title>By: Philip J-F</title>
		<link rel="alternate" href="../../comment-page-1/index.html#comment-103013" type="text/html" />

		<author>
			<name>Philip J-F</name>
			<uri>http://joyoftypes.blogspot.com/</uri>
		</author>

		<id>http://comonad.com/reader/?p=461#comment-103013</id>
		<updated>2012-03-01T07:04:59Z</updated>
		<published>2012-03-01T07:04:59Z</published>
		<content type="html" xml:base="http://comonad.com/reader/2011/what-constraints-entail-part-2/comment-page-1/#comment-103013"><![CDATA[<p>Inspired by this discussion I wrote a post showing how to get multiple, passable, effectively first-class, instances.  I borrowed your applicative example: <a href="http://joyoftypes.blogspot.com/2012/02/haskell-supports-first-class-instances.html" rel="nofollow">http://joyoftypes.blogspot.com/2012/02/haskell-supports-first-class-instances.html</a></p>
]]></content>
		<thr:in-reply-to ref="http://comonad.com/reader/?p=461" href="http://comonad.com/reader/2011/what-constraints-entail-part-2/" type="text/html" />
	</entry>
	<entry>
		<title>By: Edward Kmett</title>
		<link rel="alternate" href="../../comment-page-1/index.html#comment-85122" type="text/html" />

		<author>
			<name>Edward Kmett</name>
			<uri>http://comonad.com/</uri>
		</author>

		<id>http://comonad.com/reader/?p=461#comment-85122</id>
		<updated>2011-11-17T19:57:21Z</updated>
		<published>2011-11-17T19:57:21Z</published>
		<content type="html" xml:base="http://comonad.com/reader/2011/what-constraints-entail-part-2/comment-page-1/#comment-85122"><![CDATA[<p>I raised the issue to Max. Not sure there is a good way for it to be defined in user land, because</p>
<p>() => q and q are interchangeable, so it would require compiler support.</p>
<p>The most compelling use case is to make code like </p>
<p>on :: (p a, p b) => (c -> c -> d) -> (forall x. p x => x -> c) -> a -> b -> d</p>
<p>inhabitable for</p>
<p>((++) `on` show)</p>
<p>but it impacts all sorts of unrelated areas in the compiler.</p>
]]></content>
		<thr:in-reply-to ref="http://comonad.com/reader/?p=461" href="http://comonad.com/reader/2011/what-constraints-entail-part-2/" type="text/html" />
	</entry>
	<entry>
		<title>By: Doug McClean</title>
		<link rel="alternate" href="../../comment-page-1/index.html#comment-85119" type="text/html" />

		<author>
			<name>Doug McClean</name>
			
		</author>

		<id>http://comonad.com/reader/?p=461#comment-85119</id>
		<updated>2011-11-17T19:43:53Z</updated>
		<published>2011-11-17T19:43:53Z</published>
		<content type="html" xml:base="http://comonad.com/reader/2011/what-constraints-entail-part-2/comment-page-1/#comment-85119"><![CDATA[<p>Yeah, I was thinking of that definition and the corresponding</p>
<p>type family Unqualified t :: *<br />
type instance Unqualified (p =&gt; q) = q</p>
<p>Alas there is a logical reason why it doesn&#8217;t make sense.</p>
<p>{-# LANGUAGE CommunistTypeSynonyms #-}?</p>
]]></content>
		<thr:in-reply-to ref="http://comonad.com/reader/?p=461" href="http://comonad.com/reader/2011/what-constraints-entail-part-2/" type="text/html" />
	</entry>
	<entry>
		<title>By: Edward Kmett</title>
		<link rel="alternate" href="../../comment-page-1/index.html#comment-85115" type="text/html" />

		<author>
			<name>Edward Kmett</name>
			<uri>http://comonad.com/</uri>
		</author>

		<id>http://comonad.com/reader/?p=461#comment-85115</id>
		<updated>2011-11-17T19:13:11Z</updated>
		<published>2011-11-17T19:13:11Z</published>
		<content type="html" xml:base="http://comonad.com/reader/2011/what-constraints-entail-part-2/comment-page-1/#comment-85115"><![CDATA[<p>As an aside, you can _write_</p>
<p>type family Constraints t :: Constraints<br />
type instance Constraints (p => q) = p</p>
<p>you just can&#8217;t use it anywhere. =/</p>
<p>The compiler complains when you go to use it that you need LiberalTypeSynonyms even if you have LiberalTypeSynonyms turned on. ;)</p>
]]></content>
		<thr:in-reply-to ref="http://comonad.com/reader/?p=461" href="http://comonad.com/reader/2011/what-constraints-entail-part-2/" type="text/html" />
	</entry>
	<entry>
		<title>By: Doug McClean</title>
		<link rel="alternate" href="../../comment-page-1/index.html#comment-85094" type="text/html" />

		<author>
			<name>Doug McClean</name>
			
		</author>

		<id>http://comonad.com/reader/?p=461#comment-85094</id>
		<updated>2011-11-17T16:39:00Z</updated>
		<published>2011-11-17T16:39:00Z</published>
		<content type="html" xml:base="http://comonad.com/reader/2011/what-constraints-entail-part-2/comment-page-1/#comment-85094"><![CDATA[<p>Ah, ok, I&#8217;m on the right page now. This can&#8217;t work because context reduction/constraint simplification is such a mess.</p>
<p>Probably a good thing, too, because for something like this you wouldn&#8217;t want any context reduction in the first place, you&#8217;d want the naively inferred context that is based solely on what class functions are actually mentioned in a definition.</p>
<p>This is because you might want to occasionally use an ordering on, say, lists other than the lexical one in the prelude (say, by sum or whatever). If the context gets reduced from Ord ([Salary]) to Ord Salary then you&#8217;ve already lost your chance.</p>
<p>Proxies it is.</p>
]]></content>
		<thr:in-reply-to ref="http://comonad.com/reader/?p=461" href="http://comonad.com/reader/2011/what-constraints-entail-part-2/" type="text/html" />
	</entry>
	<entry>
		<title>By: Edward Kmett</title>
		<link rel="alternate" href="../../comment-page-1/index.html#comment-84953" type="text/html" />

		<author>
			<name>Edward Kmett</name>
			<uri>http://comonad.com/</uri>
		</author>

		<id>http://comonad.com/reader/?p=461#comment-84953</id>
		<updated>2011-11-17T00:23:20Z</updated>
		<published>2011-11-17T00:23:20Z</published>
		<content type="html" xml:base="http://comonad.com/reader/2011/what-constraints-entail-part-2/comment-page-1/#comment-84953"><![CDATA[<p>Dan Peebles has some nice examples for things like a more polymorphic &#8216;on&#8217; that could benefit, but in the meantime, one can use explicit proxies to work around the inability to name the constraint implicitly.</p>
]]></content>
		<thr:in-reply-to ref="http://comonad.com/reader/?p=461" href="http://comonad.com/reader/2011/what-constraints-entail-part-2/" type="text/html" />
	</entry>
	<entry>
		<title>By: Edward Kmett</title>
		<link rel="alternate" href="../../comment-page-1/index.html#comment-84952" type="text/html" />

		<author>
			<name>Edward Kmett</name>
			<uri>http://comonad.com/</uri>
		</author>

		<id>http://comonad.com/reader/?p=461#comment-84952</id>
		<updated>2011-11-17T00:20:46Z</updated>
		<published>2011-11-17T00:20:46Z</published>
		<content type="html" xml:base="http://comonad.com/reader/2011/what-constraints-entail-part-2/comment-page-1/#comment-84952"><![CDATA[<p>discharge :: (c => t) -> Dict c -> t<br />
discharge t Dict = t</p>
<p>works fine.</p>
<p>as for whether the type checker has the machinery, that is somewhat harder to answer, becuase it would depend on the details of the largely underspecified constraint simplifier.</p>
]]></content>
		<thr:in-reply-to ref="http://comonad.com/reader/?p=461" href="http://comonad.com/reader/2011/what-constraints-entail-part-2/" type="text/html" />
	</entry>
	<entry>
		<title>By: Doug McClean</title>
		<link rel="alternate" href="../../comment-page-1/index.html#comment-84938" type="text/html" />

		<author>
			<name>Doug McClean</name>
			
		</author>

		<id>http://comonad.com/reader/?p=461#comment-84938</id>
		<updated>2011-11-16T22:51:10Z</updated>
		<published>2011-11-16T22:51:10Z</published>
		<content type="html" xml:base="http://comonad.com/reader/2011/what-constraints-entail-part-2/comment-page-1/#comment-84938"><![CDATA[<p>That explains why you can&#8217;t define them in Haskell, but I don&#8217;t think it bars you from adding them as primitives, does it? And the type checker already has the implementation that would back the primitive?</p>
<p>I don&#8217;t have access to a machine with bleeding edge GHC on it at the moment, but is (c =&gt; t) -&gt; Dict c -&gt; t a syntactically valid type? If not, why not?</p>
]]></content>
		<thr:in-reply-to ref="http://comonad.com/reader/?p=461" href="http://comonad.com/reader/2011/what-constraints-entail-part-2/" type="text/html" />
	</entry>
	<entry>
		<title>By: Edward Kmett</title>
		<link rel="alternate" href="../../comment-page-1/index.html#comment-84931" type="text/html" />

		<author>
			<name>Edward Kmett</name>
			<uri>http://comonad.com/</uri>
		</author>

		<id>http://comonad.com/reader/?p=461#comment-84931</id>
		<updated>2011-11-16T22:28:07Z</updated>
		<published>2011-11-16T22:28:07Z</published>
		<content type="html" xml:base="http://comonad.com/reader/2011/what-constraints-entail-part-2/comment-page-1/#comment-84931"><![CDATA[<p>The problem with Qualifier and Unqualified is that unification of types involving =&gt; isn&#8217;t done by simple unification, but instead by bi-implication for constraints, so while you can write some types with them, you typically can&#8217;t build inhabitants.</p>
]]></content>
		<thr:in-reply-to ref="http://comonad.com/reader/?p=461#comment-84914" href="http://comonad.com/reader/2011/what-constraints-entail-part-2/comment-page-1/#comment-84914" type="text/html" />
	</entry>
</feed>

<!-- Localized -->