<?xml version="1.0" encoding="UTF-8"?><rss version="2.0"
	xmlns:content="http://purl.org/rss/1.0/modules/content/"
	xmlns:dc="http://purl.org/dc/elements/1.1/"
	xmlns:atom="http://www.w3.org/2005/Atom"
	xmlns:sy="http://purl.org/rss/1.0/modules/syndication/"
		>
<channel>
	<title>Comments on: Generatingfunctorology</title>
	<atom:link href="http://comonad.com/reader/2008/generatingfunctorology/feed/" rel="self" type="application/rss+xml" />
	<link>http://comonad.com/reader/2008/generatingfunctorology/</link>
	<description>types, (co)monads, substructural logic</description>
	<lastBuildDate>Sat, 29 Dec 2012 15:18:06 -0800</lastBuildDate>
	<generator>http://wordpress.org/?v=2.8.4</generator>
	<sy:updatePeriod>hourly</sy:updatePeriod>
	<sy:updateFrequency>1</sy:updateFrequency>
		<item>
		<title>By: Đồ sơ sinh trọn gói</title>
		<link>http://comonad.com/reader/2008/generatingfunctorology/comment-page-1/#comment-106754</link>
		<dc:creator>Đồ sơ sinh trọn gói</dc:creator>
		<pubDate>Tue, 27 Nov 2012 05:19:28 +0000</pubDate>
		<guid isPermaLink="false">http://comonad.com/reader/2008/generatingfunctorology/#comment-106754</guid>
		<description>&lt;strong&gt;Đồ sơ sinh trọn gói...&lt;/strong&gt;

[...]The Comonad.Reader &#187; Generatingfunctorology[...]...</description>
		<content:encoded><![CDATA[<p><strong>Đồ sơ sinh trọn gói&#8230;</strong></p>
<p>[...]The Comonad.Reader &raquo; Generatingfunctorology[...]&#8230;</p>
]]></content:encoded>
	</item>
	<item>
		<title>By: pozorvlak</title>
		<link>http://comonad.com/reader/2008/generatingfunctorology/comment-page-1/#comment-1504</link>
		<dc:creator>pozorvlak</dc:creator>
		<pubDate>Thu, 29 May 2008 01:20:01 +0000</pubDate>
		<guid isPermaLink="false">http://comonad.com/reader/2008/generatingfunctorology/#comment-1504</guid>
		<description>aed: it&#039;s common in category theory to use + for coproduct, which in the category of sets is indeed disjoint union. If you allow a natural number n to be represented by the finite set {1, 2, ... n}, then + becomes ordinary addition :-)</description>
		<content:encoded><![CDATA[<p>aed: it&#8217;s common in category theory to use + for coproduct, which in the category of sets is indeed disjoint union. If you allow a natural number n to be represented by the finite set {1, 2, &#8230; n}, then + becomes ordinary addition :-)</p>
]]></content:encoded>
	</item>
	<item>
		<title>By: aed</title>
		<link>http://comonad.com/reader/2008/generatingfunctorology/comment-page-1/#comment-1366</link>
		<dc:creator>aed</dc:creator>
		<pubDate>Sat, 17 May 2008 23:35:01 +0000</pubDate>
		<guid isPermaLink="false">http://comonad.com/reader/2008/generatingfunctorology/#comment-1366</guid>
		<description>Oh -- I think I should stop seeing &quot;+&quot; as addition, and more as algabraic union -- the possible values of Maybe x are 1 or x.  So generating fuctions enumerate out the return values of a function (the &quot;clothesline&quot; upon which we hang numbers), but also can be composed together and manipulated with finite calculus and such.

Ach!  So confusing.</description>
		<content:encoded><![CDATA[<p>Oh &#8212; I think I should stop seeing &#8220;+&#8221; as addition, and more as algabraic union &#8212; the possible values of Maybe x are 1 or x.  So generating fuctions enumerate out the return values of a function (the &#8220;clothesline&#8221; upon which we hang numbers), but also can be composed together and manipulated with finite calculus and such.</p>
<p>Ach!  So confusing.</p>
]]></content:encoded>
	</item>
	<item>
		<title>By: Edward Kmett</title>
		<link>http://comonad.com/reader/2008/generatingfunctorology/comment-page-1/#comment-1355</link>
		<dc:creator>Edward Kmett</dc:creator>
		<pubDate>Sat, 17 May 2008 04:06:02 +0000</pubDate>
		<guid isPermaLink="false">http://comonad.com/reader/2008/generatingfunctorology/#comment-1355</guid>
		<description>Well, D is affine, as well as being singular in the fashion described.

Also, I think some of the usual isomorphisms such as the x^2 -&gt; 2*x^2/2 one break down for the same reason the connection between ~~a and a breaks down, because we are working in an intuitionistic setting.

(At least my hand-wavy attempts to try to realize negative values as continuations accepting a given value type seemed to run into that)</description>
		<content:encoded><![CDATA[<p>Well, D is affine, as well as being singular in the fashion described.</p>
<p>Also, I think some of the usual isomorphisms such as the x^2 -> 2*x^2/2 one break down for the same reason the connection between ~~a and a breaks down, because we are working in an intuitionistic setting.</p>
<p>(At least my hand-wavy attempts to try to realize negative values as continuations accepting a given value type seemed to run into that)</p>
]]></content:encoded>
	</item>
	<item>
		<title>By: Dan P</title>
		<link>http://comonad.com/reader/2008/generatingfunctorology/comment-page-1/#comment-1353</link>
		<dc:creator>Dan P</dc:creator>
		<pubDate>Sat, 17 May 2008 03:11:22 +0000</pubDate>
		<guid isPermaLink="false">http://comonad.com/reader/2008/generatingfunctorology/#comment-1353</guid>
		<description>Ah...it&#039;s called affine logic. I don&#039;t know the terminology.</description>
		<content:encoded><![CDATA[<p>Ah&#8230;it&#8217;s called affine logic. I don&#8217;t know the terminology.</p>
]]></content:encoded>
	</item>
	<item>
		<title>By: Edward Kmett</title>
		<link>http://comonad.com/reader/2008/generatingfunctorology/comment-page-1/#comment-1345</link>
		<dc:creator>Edward Kmett</dc:creator>
		<pubDate>Fri, 16 May 2008 19:14:37 +0000</pubDate>
		<guid isPermaLink="false">http://comonad.com/reader/2008/generatingfunctorology/#comment-1345</guid>
		<description>Hrmm. Just an observation:


If D^2 = 0, then given a functor F described by a generating function 

F x = a_0 + a_1*x + a_2*x^2 + ...

then 

F D = a_0 + a_1*D

cuts off the series. 

It also seems that D as a &#039;singleton pattern&#039; is affine (permits weakening), because nothing currently prevents you from &#039;not using&#039; the D, as evidenced by the possibility of a_0 being non-zero.</description>
		<content:encoded><![CDATA[<p>Hrmm. Just an observation:</p>
<p>If D^2 = 0, then given a functor F described by a generating function </p>
<p>F x = a_0 + a_1*x + a_2*x^2 + &#8230;</p>
<p>then </p>
<p>F D = a_0 + a_1*D</p>
<p>cuts off the series. </p>
<p>It also seems that D as a &#8217;singleton pattern&#8217; is affine (permits weakening), because nothing currently prevents you from &#8216;not using&#8217; the D, as evidenced by the possibility of a_0 being non-zero.</p>
]]></content:encoded>
	</item>
	<item>
		<title>By: Edward Kmett</title>
		<link>http://comonad.com/reader/2008/generatingfunctorology/comment-page-1/#comment-1341</link>
		<dc:creator>Edward Kmett</dc:creator>
		<pubDate>Fri, 16 May 2008 17:31:45 +0000</pubDate>
		<guid isPermaLink="false">http://comonad.com/reader/2008/generatingfunctorology/#comment-1341</guid>
		<description>Dan, 

I love the notion of D as a singleton type.

I&#039;ve been thinking about the idea of trying to represent the infinite cases using bivariate generating functions.

The idea would be that you &#039;hang up on the number line&#039; quantities based on two parameters. One the number of traversals of the structure of size &gt;= m that touch n values to give you an idea of the branching structure. Then clearly for n &gt; m, the tail of the series = 0.

You then count the number of cases involved in using productive corecursion to visit n values in the structure rather than the number of distinct ways you can use well-founded recursion to build a structure of a given size.

I haven&#039;t had time in the last couple of days to investigate the idea any further though. 

[Edit: this doesn&#039;t appear to be sufficient and I haven&#039;t been able to find any good closed forms this way yet]</description>
		<content:encoded><![CDATA[<p>Dan, </p>
<p>I love the notion of D as a singleton type.</p>
<p>I&#8217;ve been thinking about the idea of trying to represent the infinite cases using bivariate generating functions.</p>
<p>The idea would be that you &#8216;hang up on the number line&#8217; quantities based on two parameters. One the number of traversals of the structure of size >= m that touch n values to give you an idea of the branching structure. Then clearly for n > m, the tail of the series = 0.</p>
<p>You then count the number of cases involved in using productive corecursion to visit n values in the structure rather than the number of distinct ways you can use well-founded recursion to build a structure of a given size.</p>
<p>I haven&#8217;t had time in the last couple of days to investigate the idea any further though. </p>
<p>[Edit: this doesn't appear to be sufficient and I haven't been able to find any good closed forms this way yet]</p>
]]></content:encoded>
	</item>
	<item>
		<title>By: Edward Kmett</title>
		<link>http://comonad.com/reader/2008/generatingfunctorology/comment-page-1/#comment-1318</link>
		<dc:creator>Edward Kmett</dc:creator>
		<pubDate>Thu, 15 May 2008 06:11:58 +0000</pubDate>
		<guid isPermaLink="false">http://comonad.com/reader/2008/generatingfunctorology/#comment-1318</guid>
		<description>Ah, nice. My &#039;naive encoding&#039; was apparently better than I thought =)

Currently mining the material written on species and what is in that Flajolet/Sedgewick book. 

Awesome link, aed. Thanks!</description>
		<content:encoded><![CDATA[<p>Ah, nice. My &#8216;naive encoding&#8217; was apparently better than I thought =)</p>
<p>Currently mining the material written on species and what is in that Flajolet/Sedgewick book. </p>
<p>Awesome link, aed. Thanks!</p>
]]></content:encoded>
	</item>
	<item>
		<title>By: Pseudonym</title>
		<link>http://comonad.com/reader/2008/generatingfunctorology/comment-page-1/#comment-1317</link>
		<dc:creator>Pseudonym</dc:creator>
		<pubDate>Thu, 15 May 2008 05:40:41 +0000</pubDate>
		<guid isPermaLink="false">http://comonad.com/reader/2008/generatingfunctorology/#comment-1317</guid>
		<description>In fact, that &lt;i&gt;is&lt;/i&gt; a fairly efficient representation for trees.  I&#039;ve used something very close to it before, in C.
You have to remember that C(n) is 4^n/n^1.5 times some constant.  So to store a number between 0 and C(n), you need 2n - 1.5 log n bits.
If you think about that for a moment, it&#039;s easy to do with exactly 2n bits: Introduce a parallel array of 2n bits, each element of which represents whether or not each node has a left or right child.
If you were compressing this bit vector, you could get closer to the asymptotic behaviour by noting that there&#039;s some redundancy: In your array of 2n bits, exactly n-1 of them will be 1 and the remaining n+1 of them will be 0.  It&#039;s probably not hard to exploit this and recover a representation that&#039;s optimal in an asymptotic sense.</description>
		<content:encoded><![CDATA[<p>In fact, that <i>is</i> a fairly efficient representation for trees.  I&#8217;ve used something very close to it before, in C.<br />
You have to remember that C(n) is 4^n/n^1.5 times some constant.  So to store a number between 0 and C(n), you need 2n &#8211; 1.5 log n bits.<br />
If you think about that for a moment, it&#8217;s easy to do with exactly 2n bits: Introduce a parallel array of 2n bits, each element of which represents whether or not each node has a left or right child.<br />
If you were compressing this bit vector, you could get closer to the asymptotic behaviour by noting that there&#8217;s some redundancy: In your array of 2n bits, exactly n-1 of them will be 1 and the remaining n+1 of them will be 0.  It&#8217;s probably not hard to exploit this and recover a representation that&#8217;s optimal in an asymptotic sense.</p>
]]></content:encoded>
	</item>
	<item>
		<title>By: Dan P</title>
		<link>http://comonad.com/reader/2008/generatingfunctorology/comment-page-1/#comment-1311</link>
		<dc:creator>Dan P</dc:creator>
		<pubDate>Wed, 14 May 2008 23:24:33 +0000</pubDate>
		<guid isPermaLink="false">http://comonad.com/reader/2008/generatingfunctorology/#comment-1311</guid>
		<description>Edward,

Did you ever read &lt;a href=&quot;http://sigfpe.blogspot.com/2006/06/taylor-series-for-types.html&quot; rel=&quot;nofollow&quot;&gt;this&lt;/a&gt; or &lt;a href=&quot;http://sigfpe.blogspot.com/2006/09/infinitesimal-types.html&quot; rel=&quot;nofollow&quot;&gt;this&lt;/a&gt;? I spent lots of time thinking similar thoughts but eventually got stuck.</description>
		<content:encoded><![CDATA[<p>Edward,</p>
<p>Did you ever read <a href="http://sigfpe.blogspot.com/2006/06/taylor-series-for-types.html" rel="nofollow">this</a> or <a href="http://sigfpe.blogspot.com/2006/09/infinitesimal-types.html" rel="nofollow">this</a>? I spent lots of time thinking similar thoughts but eventually got stuck.</p>
]]></content:encoded>
	</item>
</channel>
</rss>
