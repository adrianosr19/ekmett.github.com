<?xml version="1.0" encoding="UTF-8"?><rss version="2.0"
	xmlns:content="http://purl.org/rss/1.0/modules/content/"
	xmlns:dc="http://purl.org/dc/elements/1.1/"
	xmlns:atom="http://www.w3.org/2005/Atom"
	xmlns:sy="http://purl.org/rss/1.0/modules/syndication/"
		>
<channel>
	<title>Comments for The Comonad.Reader</title>
	<atom:link href="http://comonad.com/reader/comments/feed/" rel="self" type="application/rss+xml" />
	<link>http://comonad.com/reader</link>
	<description>types, (co)monads, substructural logic</description>
	<lastBuildDate>Sun, 18 Nov 2012 17:21:31 -0500</lastBuildDate>
	<generator>http://wordpress.org/?v=2.8.4</generator>
	<sy:updatePeriod>hourly</sy:updatePeriod>
	<sy:updateFrequency>1</sy:updateFrequency>
		<item>
		<title>Comment on Free Monads for Less (Part 1 of 3): Codensity by Edward Kmett</title>
		<link>http://comonad.com/reader/2011/free-monads-for-less/comment-page-1/#comment-106591</link>
		<dc:creator>Edward Kmett</dc:creator>
		<pubDate>Sun, 18 Nov 2012 17:21:31 +0000</pubDate>
		<guid isPermaLink="false">http://comonad.com/reader/?p=218#comment-106591</guid>
		<description>@Tac-Tics: They are more or less identical.</description>
		<content:encoded><![CDATA[<p>@Tac-Tics: They are more or less identical.</p>
]]></content:encoded>
	</item>
	<item>
		<title>Comment on Unnatural Transformations and Quantifiers by Madeline Jones</title>
		<link>http://comonad.com/reader/2012/unnatural-transformations-and-quantifiers/comment-page-1/#comment-106560</link>
		<dc:creator>Madeline Jones</dc:creator>
		<pubDate>Fri, 16 Nov 2012 11:04:24 +0000</pubDate>
		<guid isPermaLink="false">http://comonad.com/reader/?p=660#comment-106560</guid>
		<description>I actually stumbled on to this site when I was looking for something else. I found it very interesting and informative. I am doing my graduation with major as math. I would appreciate if you keep updating regularly.</description>
		<content:encoded><![CDATA[<p>I actually stumbled on to this site when I was looking for something else. I found it very interesting and informative. I am doing my graduation with major as math. I would appreciate if you keep updating regularly.</p>
]]></content:encoded>
	</item>
	<item>
		<title>Comment on Free Monads for Less (Part 1 of 3): Codensity by Tac-Tics</title>
		<link>http://comonad.com/reader/2011/free-monads-for-less/comment-page-1/#comment-106387</link>
		<dc:creator>Tac-Tics</dc:creator>
		<pubDate>Fri, 26 Oct 2012 23:59:43 +0000</pubDate>
		<guid isPermaLink="false">http://comonad.com/reader/?p=218#comment-106387</guid>
		<description>I&#039;m really fascinated by the idea of correct-by-construction monads. One question, though. Control.Monad.Free seems very similar to the Control.Monad.Prompt module. What is the relationship between the two?</description>
		<content:encoded><![CDATA[<p>I&#8217;m really fascinated by the idea of correct-by-construction monads. One question, though. Control.Monad.Free seems very similar to the Control.Monad.Prompt module. What is the relationship between the two?</p>
]]></content:encoded>
	</item>
	<item>
		<title>Comment on Elgot (Co)Algebras by JanBessai</title>
		<link>http://comonad.com/reader/2008/elgot-coalgebras/comment-page-1/#comment-106278</link>
		<dc:creator>JanBessai</dc:creator>
		<pubDate>Fri, 12 Oct 2012 09:54:57 +0000</pubDate>
		<guid isPermaLink="false">http://comonad.com/reader/2008/elgot-algebras/#comment-106278</guid>
		<description>The type signature of strength&#039; needs to be flipped
&gt; strength&#039; :: Functor f =&gt; f a -&gt; t -&gt; f (t, a)</description>
		<content:encoded><![CDATA[<p>The type signature of strength&#8217; needs to be flipped<br />
&gt; strength&#8217; :: Functor f =&gt; f a -&gt; t -&gt; f (t, a)</p>
]]></content:encoded>
	</item>
	<item>
		<title>Comment on Elgot (Co)Algebras by Jan Bessai</title>
		<link>http://comonad.com/reader/2008/elgot-coalgebras/comment-page-1/#comment-106277</link>
		<dc:creator>Jan Bessai</dc:creator>
		<pubDate>Fri, 12 Oct 2012 09:41:48 +0000</pubDate>
		<guid isPermaLink="false">http://comonad.com/reader/2008/elgot-algebras/#comment-106277</guid>
		<description>This is rather old, but apo and g_apo need a small fix:
&gt; apo psi = h .Right  where h = InF . fmap h . (fmap Left . outF &#124;&#124;&#124; psi) 
&gt; g_apo g f = h .Right where h = InF . fmap h . (fmap Left . g &#124;&#124;&#124; f)
otherwise they will not typecheck.</description>
		<content:encoded><![CDATA[<p>This is rather old, but apo and g_apo need a small fix:<br />
&gt; apo psi = h .Right  where h = InF . fmap h . (fmap Left . outF ||| psi)<br />
&gt; g_apo g f = h .Right where h = InF . fmap h . (fmap Left . g ||| f)<br />
otherwise they will not typecheck.</p>
]]></content:encoded>
	</item>
	<item>
		<title>Comment on Free Monads for Less (Part 3 of 3): Yielding IO by Edward Kmett</title>
		<link>http://comonad.com/reader/2011/free-monads-for-less-3/comment-page-1/#comment-106228</link>
		<dc:creator>Edward Kmett</dc:creator>
		<pubDate>Sun, 07 Oct 2012 03:38:40 +0000</pubDate>
		<guid isPermaLink="false">http://comonad.com/reader/?p=251#comment-106228</guid>
		<description>The irony with that is that it is particularly easy to add cases to a &#039;Free&#039;/a la carte monad in scala. Just don&#039;t seal the class. ;)

To mitigate the boilerplate in Haskell at least, the typeclasses for config, db connection, etc. can be autogenerated by something like makeClassy from my lens package.</description>
		<content:encoded><![CDATA[<p>The irony with that is that it is particularly easy to add cases to a &#8216;Free&#8217;/a la carte monad in scala. Just don&#8217;t seal the class. ;)</p>
<p>To mitigate the boilerplate in Haskell at least, the typeclasses for config, db connection, etc. can be autogenerated by something like makeClassy from my lens package.</p>
]]></content:encoded>
	</item>
	<item>
		<title>Comment on Free Monads for Less (Part 3 of 3): Yielding IO by Richard Wallace</title>
		<link>http://comonad.com/reader/2011/free-monads-for-less-3/comment-page-1/#comment-106223</link>
		<dc:creator>Richard Wallace</dc:creator>
		<pubDate>Sat, 06 Oct 2012 23:44:04 +0000</pubDate>
		<guid isPermaLink="false">http://comonad.com/reader/?p=251#comment-106223</guid>
		<description>Ok, I understand the cost of tupling up more and more and that being undesirable.  Also, you&#039;re right that adding new constructors breaks the whole &quot;a la Carte&quot; notion.

I&#039;m just looking for alternatives to the typical way of building FP apps of using a monad transformer stack with ReaderT and StateT and type-classes for all the data you want to inject (config, db connections, etc.).  I was looking at the a la Carte approach as a way of doing that.  Although, to be fair my distaste for this approach comes from a Scala app where it became a PITA to manage everything and if it had been written in Haskell the experience might have been different.</description>
		<content:encoded><![CDATA[<p>Ok, I understand the cost of tupling up more and more and that being undesirable.  Also, you&#8217;re right that adding new constructors breaks the whole &#8220;a la Carte&#8221; notion.</p>
<p>I&#8217;m just looking for alternatives to the typical way of building FP apps of using a monad transformer stack with ReaderT and StateT and type-classes for all the data you want to inject (config, db connections, etc.).  I was looking at the a la Carte approach as a way of doing that.  Although, to be fair my distaste for this approach comes from a Scala app where it became a PITA to manage everything and if it had been written in Haskell the experience might have been different.</p>
]]></content:encoded>
	</item>
	<item>
		<title>Comment on Unnatural Transformations and Quantifiers by Dan Piponi</title>
		<link>http://comonad.com/reader/2012/unnatural-transformations-and-quantifiers/comment-page-1/#comment-106102</link>
		<dc:creator>Dan Piponi</dc:creator>
		<pubDate>Mon, 24 Sep 2012 01:26:49 +0000</pubDate>
		<guid isPermaLink="false">http://comonad.com/reader/?p=660#comment-106102</guid>
		<description>A while back I was playing with free theorems and was surprised to find types for which the free theorem wasn&#039;t the obvious expression of (di)naturality. I was a bit perturbed. I guess I should have considered it a feature rather than a bug and investigated further.</description>
		<content:encoded><![CDATA[<p>A while back I was playing with free theorems and was surprised to find types for which the free theorem wasn&#8217;t the obvious expression of (di)naturality. I was a bit perturbed. I guess I should have considered it a feature rather than a bug and investigated further.</p>
]]></content:encoded>
	</item>
	<item>
		<title>Comment on Kan Extensions III: As Ends and Coends by The Comonad.Reader &#187; Unnatural Transformations and Quantifiers</title>
		<link>http://comonad.com/reader/2008/kan-extension-iii/comment-page-1/#comment-106090</link>
		<dc:creator>The Comonad.Reader &#187; Unnatural Transformations and Quantifiers</dc:creator>
		<pubDate>Sun, 23 Sep 2012 03:43:18 +0000</pubDate>
		<guid isPermaLink="false">http://comonad.com/reader/2008/kan-extension-iii/#comment-106090</guid>
		<description>[...] the integral notation denotes an end, and the square brackets denote a power, which allows us to take what is essentially an exponential [...]</description>
		<content:encoded><![CDATA[<p>[...] the integral notation denotes an end, and the square brackets denote a power, which allows us to take what is essentially an exponential [...]</p>
]]></content:encoded>
	</item>
	<item>
		<title>Comment on Free Monads for Less (Part 3 of 3): Yielding IO by Edward Kmett</title>
		<link>http://comonad.com/reader/2011/free-monads-for-less-3/comment-page-1/#comment-106004</link>
		<dc:creator>Edward Kmett</dc:creator>
		<pubDate>Fri, 07 Sep 2012 13:53:58 +0000</pubDate>
		<guid isPermaLink="false">http://comonad.com/reader/?p=251#comment-106004</guid>
		<description>The difference is in order to support new operations with the usual free monad/a la carte approach you need to define a new data type or a new constructor, or tuple up more and more stuff and pay a higher and higher cost when accessing the next constructor.

We use this in a language we have here at S&amp;P Capital IQ called Ermine as our only FFI mechanism. It isn&#039;t something you could bolt into, say, GHC without changing out pretty much everything in the language, but in a new Haskell implementation, it has the benefit that you don&#039;t need to deal with magic RealWorld tokens and then restrict transformations that may attempt to commute past them. 

This enables you to transform the language more easily, in exchange, we denote operations with this separate FFI type, rather than primops, and view the runtime system as an external agent driving an asymmetric coroutine.</description>
		<content:encoded><![CDATA[<p>The difference is in order to support new operations with the usual free monad/a la carte approach you need to define a new data type or a new constructor, or tuple up more and more stuff and pay a higher and higher cost when accessing the next constructor.</p>
<p>We use this in a language we have here at S&amp;P Capital IQ called Ermine as our only FFI mechanism. It isn&#8217;t something you could bolt into, say, GHC without changing out pretty much everything in the language, but in a new Haskell implementation, it has the benefit that you don&#8217;t need to deal with magic RealWorld tokens and then restrict transformations that may attempt to commute past them. </p>
<p>This enables you to transform the language more easily, in exchange, we denote operations with this separate FFI type, rather than primops, and view the runtime system as an external agent driving an asymmetric coroutine.</p>
]]></content:encoded>
	</item>
</channel>
</rss>

<!-- Localized -->