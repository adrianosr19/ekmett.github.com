<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">

<!-- Mirrored from comonad.com/reader/category/uncategorized/ by HTTrack Website Copier/3.x [XR&CO'2013], Tue, 20 Aug 2013 22:06:24 GMT -->
<!-- Added by HTTrack --><meta http-equiv="content-type" content="text/html;charset=UTF-8" /><!-- /Added by HTTrack -->
<head profile="http://gmpg.org/xfn/11">
	<meta http-equiv="Content-Type" content="text/html; charset=UTF-8" />
	<title>The Comonad.Reader &raquo; Uncategorized</title>
	<meta name="generator" content="WordPress 2.8.4" /> <!-- leave this for stats please -->
	<style type="text/css" media="screen">
		@import url( ../../wp-content/themes/connections/style.css);
	</style>
        <link rel="openid.server" href="https://api.screenname.aol.com/auth/openidServer"/>
        <link rel="openid.delegate" href="http://openid.aol.com/edwardallankmett"/>
	<link rel="alternate" type="application/rss+xml" title="RSS 2.0" href="../../feed/index.html" />
	<link rel="alternate" type="application/atom+xml" title="Atom 0.3" href="../../feed/atom/index.html" />
	<link rel="pingback" href="../../xmlrpc.php" />
        <link rel="shortcut icon" href="../../wp-content/themes/connections/favicon.ico" />
        	<link rel='archives' title='May 2013' href='../../2013/05/index.html' />
	<link rel='archives' title='April 2013' href='../../2013/04/index.html' />
	<link rel='archives' title='January 2013' href='../../2013/01/index.html' />
	<link rel='archives' title='December 2012' href='../../2012/12/index.html' />
	<link rel='archives' title='September 2012' href='../../2012/09/index.html' />
	<link rel='archives' title='August 2012' href='../../2012/08/index.html' />
	<link rel='archives' title='June 2012' href='../../2012/06/index.html' />
	<link rel='archives' title='May 2012' href='../../2012/05/index.html' />
	<link rel='archives' title='April 2012' href='../../2012/04/index.html' />
	<link rel='archives' title='December 2011' href='../../2011/12/index.html' />
	<link rel='archives' title='November 2011' href='../../2011/11/index.html' />
	<link rel='archives' title='October 2011' href='../../2011/10/index.html' />
	<link rel='archives' title='September 2011' href='../../2011/09/index.html' />
	<link rel='archives' title='July 2011' href='../../2011/07/index.html' />
	<link rel='archives' title='June 2011' href='../../2011/06/index.html' />
	<link rel='archives' title='July 2010' href='../../2010/07/index.html' />
	<link rel='archives' title='May 2010' href='../../2010/05/index.html' />
	<link rel='archives' title='April 2010' href='../../2010/04/index.html' />
	<link rel='archives' title='September 2009' href='../../2009/09/index.html' />
	<link rel='archives' title='August 2009' href='../../2009/08/index.html' />
	<link rel='archives' title='July 2009' href='../../2009/07/index.html' />
	<link rel='archives' title='June 2009' href='../../2009/06/index.html' />
	<link rel='archives' title='March 2009' href='../../2009/03/index.html' />
	<link rel='archives' title='December 2008' href='../../2008/12/index.html' />
	<link rel='archives' title='November 2008' href='../../2008/11/index.html' />
	<link rel='archives' title='June 2008' href='../../2008/06/index.html' />
	<link rel='archives' title='May 2008' href='../../2008/05/index.html' />
	<link rel='archives' title='April 2008' href='../../2008/04/index.html' />
	<link rel='archives' title='March 2008' href='../../2008/03/index.html' />
	<link rel='archives' title='January 2008' href='../../2008/01/index.html' />
	<link rel='archives' title='July 2007' href='../../2007/07/index.html' />
	<link rel='archives' title='May 2007' href='../../2007/05/index.html' />
	<link rel='archives' title='November 2006' href='../../2006/11/index.html' />
	<link rel='archives' title='October 2006' href='../../2006/10/index.html' />
	<link rel="alternate" type="application/rss+xml" title="The Comonad.Reader &raquo; Uncategorized Category Feed" href="feed/index.html" />
<link rel="EditURI" type="application/rsd+xml" title="RSD" href="../../xmlrpc0db0.php?rsd" />
<link rel="wlwmanifest" type="application/wlwmanifest+xml" href="../../wp-includes/wlwmanifest.xml" /> 
<link rel='index' title='The Comonad.Reader' href='../../index.html' />
<meta name="generator" content="WordPress 2.8.4" />
</head>

<body id="archives">
<div id="rap">
	<div id="header">
	<ul id="topnav">
		<li><a href="../../index.html" id="navHome" title="Posted Recently" accesskey="h">Home |</a></li>
		<li><a href="../../about/index.html" id="navAbout" title="About the Author" accesskey="a">About |</a></li>
		<li><a href="../../source%3bitem%3dlibraries.html" id="navSource" title="Source Code" accesskey="s">Source |</a></li>
		<li><a href="mailto:ekmett@gmail.com" id="navContact" title="Contact the Author" accesskey="c">Contact </a></li>
	</ul>
	<a href="../../index.html" id="logoHome" title="Posted Recently"><img id="logo" src="../../pngbehavior/blank.gif" ></a>
	<h1><a href="../../index.html" title="The Comonad.Reader">The Comonad.Reader</a></h1>		
	<div id="desc">types, (co)monads, substructural logic</div>
</div>
	
	<div id="main">
	<div id="content">
<div id="fpjobs">
<!-- Begin Functional Jobs Affiliate Code -->
<script type="text/javascript" class="fja" src="https://d1ih2qjlwy0iio.cloudfront.net/static/js/affiliates.min.js">
{
        "api_key":"86dec4630f050b0e692605e1e2f90eef",
        "size":"480x60"
}
</script>
<noscript>
        <strong><a href="http://functionaljobs.com/">Functional Jobs</a></strong>&mdash;Dream Jobs for Functional Programmers
</noscript>
<!-- End Functional Jobs Affiliate Code -->
</div>

					<h3>Uncategorized</h3>
			<div class="post-info">Archived Posts from this Category</div>		
			<br/>				
							
				<div class="post">
					<p class="post-date">Thu 2 May 2013</p>
<div class="post-info"><h2 class="post-title"><a href="../../2013/representing-applicatives/index.html" rel="bookmark" title="Permanent Link: Representing Applicatives">Representing Applicatives</a></h2>
Posted by Gershom Bazerman under <a href="index.html" title="View all posts in Uncategorized" rel="category tag">Uncategorized</a> <br/><a href="../../2013/representing-applicatives/index.html#respond" title="Comment on Representing Applicatives">No Comments</a>&nbsp;</div>
<div class="post-content">
	<p>In the <a href="../../2012/abstracting-with-applicatives/index.html">previous</a> <a href="../../2013/algebras-of-applicatives/index.html">two</a> posts, we've built up a whole range of applicatives, out of Const, Identity, Reader, Compose, Product, Sum, and Fix (and some higher-order analogues). Sum has given us the most trouble, but in some sense has been the most powerful, letting us write things like possibly eventually terminating lists, or trees, or in fact any sort of structure with branching alternatives. In this post, I want to think a bit more about why it is that Sum is the trickiest of the bunch, and more generally, what we can say about when two applicative structures are the "same". In the process of doing so, we'll invent something a lot like Traversable en passant.</p>
<p>Let's do some counting exercises. <code>Product Identity Identity</code> holds exactly two things. It is therefore isomorphic to <code>((->) Bool)</code>, or if we prefer, <code>((->) Either () ())</code>. That is to say that a pair that <i>holds</i> two values of type <code>a</code> is the same as a function that <i>takes a two-valued type</i> and <i>yields</i> a value of type <code>a</code>. A product of more functors in turn is isomorphic to the reader of the sum of each of the datatypes that "represent" them. E.g. <code>Product (Product Identity Identity) (Product (Const ()) Identity)</code> is iso to <code>((->) (Either (Either () ()) ())</code>, i.e. a data type with three possible inhabitants. In making this move we took Product to Either -- multiplication to sum. We can pull a similar trick with Compose. <code>Compose (Product Identity Identity) (Product Identity Identity)</code> goes to ((->) (Either () (),Either () ())). So again we took Product to a sum type, but now we took Compose to a pair -- a product type! The intuition is that composition <i>multiplies</i> the possibilities of spaces in each nested functor.</p>
<p>Hmm.. products go to sums, composition goes to multiplication, etc. This should remind us of something -- these rules are exactly the rules for working with exponentials. x^n * x^m = x^(n + m). (x^n)^m = x^(n*m). x^0 = 1, x^1 = x.</p>
<p>Seen from the right standpoint, this isn't surprising at all, but almost inevitable. The functors we're describing are known as "representable," a term which derives from category theory. (See appendix on representable functors below).</p>
<p>In Haskell-land, a "representable functor" is just any functor isomorphic to the reader functor <code>((->) a)</code> for some appropriate a. Now if we think back to our algebraic representations of data types, we call the arrow type constructor an exponential. We can "count" <code>a -> x</code> as x^a, since e.g. there are 3^2 distinct functions that inhabit the type 2 -> 3. The intuition for this is that for each input we pick one of the possible results, so as the number of inputs goes up by one, the number of functions goes up by multiplying through by the set of possible results. 1 -> 3 = 3, 2 -> 3 = 3 * 3, (n + 1) -> 3 = 3 * (n -> 3).</p>
<p>Hence, if we "represent" our functors by exponentials, then we can work with them directly as exponentials as well, with all the usual rules. Edward Kmett has a <a href="http://hackage.haskell.org/packages/archive/representable-functors/3.0.0.1/doc/html/Data-Functor-Representable.html">library encoding representable functors in Haskell</a>.</p>
<p>Meanwhile, Peter Hancock prefers to call such functors <a href="http://sneezy.cs.nott.ac.uk/containers/blog/?p=14">"Naperian"</a> after John Napier, inventor of the logarithm (See also <a href="http://stackoverflow.com/a/13100857/371753">here</a>). Why Naperian? Because if our functors are isomorphic to exponentials, then we can take their logs! And that brings us back to the initial discussion of type mathematics. We have some functor F, and claim that it is isomorphic to -^R for some concrete data type R. Well, this means that R is the logarithm of F. E.g. <code>(R -> a, S -> a) =~ Either R S -> a</code>, which is to say that if log F = R and log G =~ S, then log (F * G) = log F + log G. Similarly, for any other data type n, again with log F = R, we have  <code>n -> F a =~ n -> R -> a =~ (n * R) -> a</code>, which is to say that log (F^n) =~ n * log F.</p>
<p>This gives us one intuition for why the sum functor is not generally representable -- it is very difficult to decompose log (F + G) into some simpler compound expression of logs.</p>
<p>So what functors are Representable? Anything that can be seen as a fixed shape with some index. Pairs, fixed-size vectors, fixed-size matrices, any nesting of fixed vectors and matricies. But also infinite structures of regular shape! However, not things whose shape can vary -- not lists, not sums. Trees of fixed depth or infinite binary trees therefore, but not trees of arbitrary depth or with ragged structure, etc.</p>
<p>Representable functors turn out to be extremely powerful tools. Once we know a functor is representable, we know exactly what its applicative instance must be, and that its applicative instance will be "zippy" -- i.e. acting pointwise across the structure. We also know that it has a monad instance! And, unfortunately, that this monad instance is typically fairly useless (in that it is also "zippy" -- i.e. the monad instance on a pair just acts on the two elements pointwise, without ever allowing anything in the first slot to affect anything in the second slot, etc.). But we know more than that. We know that a representable functor, by virtue of being a reader in disguise, cannot have effects that migrate outwards. So any two actions in a representable functor are commutative. And more than that, they are entirely independent.</p>
<p>This means that all representable functors are "<a href="http://hackage.haskell.org/packages/archive/distributive/0.3.1/doc/html/Data-Distributive.html">distributive</a>"! Given any functor f, and any data type r, then we have </p>
<pre class="haskell">&nbsp;
distributeReader :: <a href="http://haskell.org/ghc/docs/latest/html/libraries/base/Prelude.html#t:Functor"><span style="background-color: #efefbf; font-weight: bold;">Functor</span></a> f =&gt; f <span style="color: green;">&#40;</span>r -&gt; a<span style="color: green;">&#41;</span> -&gt; <span style="color: green;">&#40;</span>r -&gt; f a<span style="color: green;">&#41;</span>
distributeReader fra = \r -&gt; <a href="http://haskell.org/ghc/docs/latest/html/libraries/base/Prelude.html#v:fmap"><span style="font-weight: bold;">fmap</span></a> <span style="color: green;">&#40;</span>$r<span style="color: green;">&#41;</span> fra
&nbsp;</pre>
<p>That is to say, given an arrow "inside" a functor, we can always pull the arrow out, and "distribute" application across the contents of the functor. A list of functions from <code>Int -> Int</code> becomes a single function from <code>Int</code> to a list of <code>Int</code>, etc. More generally, since all representable functors are isomorphic to reader, given g representable, and f any functor, then we have: <code>distribute :: (Functor f, Representable g) => f (g a) -> g (f a).</code></p>
<p>This is pretty powerful sauce! And if f and g are <i>both</i> representable, then we get the transposition isomorphism, witnessed by <code>flip</code>! That's just the beginning of the good stuff. If we take functions and "unrepresent" them back to functors (i.e. take their logs), then we can do things like move from <code>((->) Bool)</code> to pairs, etc. Since we're in a pervasively lazy language, we've just created a library for <a href="http://hackage.haskell.org/packages/archive/representable-tries/3.0.2/doc/html/Data-Functor-Representable-Trie.html">memoization</a>! This is because we've gone from a function to a data structure we can index into, representing each possible argument to this function as a "slot" in the structure. And the laziness pays off because we only need to evaluate the contents of each slot on demand (otherwise we'd have a precomputed lookup table rather than a dynamically-evaluated memo table). </p>
<p>And now suppose we take our representable functor in the form <code>s -> a</code> and paired it with an "index" into that function, in the form of a concrete <code>s</code>. Then we'd be able to step that <code>s</code> forward or backwards and navigate around our structure of <code>a</code>s. And this is precisely the <a href="http://hackage.haskell.org/packages/archive/comonads-fd/3.0.1/doc/html/Control-Comonad-Store.html">Store Comonad</a>! And this in turn gives a <a href="http://patternsinfp.wordpress.com/2011/01/31/lenses-are-the-coalgebras-for-the-costate-comonad/">characterization of the lens laws</a>.</p>
<p>What this all gives us a tiny taste of, in fact, is the tremendous power of the <a href="http://blog.sigfpe.com/2006/11/yoneda-lemma.html">Yoneda lemma</a>, which, in Haskell, is all about going between values and functions, and in fact captures the important universality and uniqueness properties that make working with representable functors tractable. A further tiny taste of Yoneda comes from a nice <a href="http://conal.net/blog/posts/memoizing-polymorphic-functions-via-unmemoization">blog post</a> by Conal Elliott on memoization.</p>
<p><strong>Extra Credit on Sum Functors</strong></p>
<p>There in fact is a log identity on sums. It goes like this:</p>
<pre>
log(a + c) = log a + log (1 + c/a)
</pre>
<p>Do you have a useful computational interpretation of this? I've got the inklings of one, but not much else.</p>
<p><strong>Appendix: Notes on Representable Functors in Hask.</strong></p>
<p>The way to think about this is to take some arbitrary category C, and some category that's basically Set (in our case, Hask. In fact, in our case, C is Hask too, and we're just talking about endofunctors on Hask). Now, we take some functor F : C -> Set, and some A which is an element of C. The set of morphisms originating at A (denoted by Hom(A,-)) constitutes a functor called the "hom functor." For any object X in C, we can "plug it in" to Hom(A,-), to then get the set of all arrows from A to X. And for any morphism X -> Y in C, we can derive a morphism from Hom(A,X) to Hom(A,Y), by composition. This is equivalent to, in Haskell-land, using a function <code>f :: x -> y</code> to send <code>g :: a -> x</code> to <code>a -> y</code> by writing "functionAToY = f . g".</p>
<p>So, for any A in C, we have a hom functor on C, which is C -> Set, where the elements of the resultant Set are homomorphisms in C. Now, we have this other arbitrary functor F, which is also C -> Set. Now, if there is an isomorphism of functors between F, and Hom(A,_), then we say F is "representable". A representable functor is thus one that can be worked with entirely as an appropriate hom-functor.</p>
	<div class="post-info">
			</div>
	<div class="post-footer">&nbsp;</div>
</div>
									</div>
							
				<div class="post">
					<p class="post-date">Fri 11 Jan 2013</p>
<div class="post-info"><h2 class="post-title"><a href="../../2013/algebras-of-applicatives/index.html" rel="bookmark" title="Permanent Link: Algebras of Applicatives">Algebras of Applicatives</a></h2>
Posted by Gershom Bazerman under <a href="index.html" title="View all posts in Uncategorized" rel="category tag">Uncategorized</a> <br/><a href="../../2013/algebras-of-applicatives/index.html#respond" title="Comment on Algebras of Applicatives">No Comments</a>&nbsp;</div>
<div class="post-content">
	<p>While the <a href="../../2012/abstracting-with-applicatives.html">previous post</a> in this series was relatively immediately applicable, this one has constructions I definitely wouldn't recommend in production code. However, they do take us further in exploring the universe of applicative functors, and, more broadly, exploring which data types provide which properties by construcion.</p>
<p>It's well known that if you have any Functor <code>F a</code>, you can take its "fixpoint", creating a structure of infinitely nested Fs, like so. <code>F (F (F (...) ) )</code> Since we can't have infinite types directly in Haskell, we introduce the Fix newtype:</p>
<pre class="haskell">&nbsp;
<span style="color: #06c; font-weight: bold;">newtype</span> Fix f = Fix <span style="color: green;">&#40;</span>f <span style="color: green;">&#40;</span>Fix f<span style="color: green;">&#41;</span><span style="color: green;">&#41;</span></pre>
<p>This "wraps up" the recursion so that GHC accepts the type. <code>Fix f</code> is a <code>Fix</code> constructor, containing an "f" of <code>Fix f</code> inside. Each in turn expands out, and soforth. Fixpoints of functors have fixedpoints of functors inside 'em. And so on, and so on, ad infinitum.</p>
<p>(Digression: We speak of "algebraic data types" in Haskell. The "algebra" in question is an "F-algebra", and we can build up structures with fixpoints of functors, taking those functors as initial or terminal objects and generating either initial algebras or terminal coalgebras. These latter two concepts coincide in Haskell in the Fix description given above, as greatest and least fixpoints of data types in Haskell turn out to be the same thing. For more background, one can go to Wadler's "<a href="http://homepages.inf.ed.ac.uk/wadler/papers/free-rectypes/free-rectypes.txt">Recursive Types for Free</a>,"  or Jacobs and Rutten's "<a href="http://citeseerx.ist.psu.edu/viewdoc/summary?doi=10.1.1.37.1418">Tutorial on (Co)Algebras and (Co)Induction</a>" for starters.)</p>
<p>The family of functors built from our friends Const, Sum, Product, and Reader (exponentiation) are known as Polynomial Functors. If we take closure of these with a proper fixpoint construct (that lets us build infinite structures), we get things that are variously known as Containers, Shapely Types, and Strictly Positive types.</p>
<p>One irritating thing is that the fixpoint of a functor as we've written it is no longer itself a functor. The type constructor Fix is of kind <code>(* -> *) -> *</code>, which says it takes an "f" which takes one argument (e.g. "Maybe" or "Identity" or etc.) and returns a proper type (i.e. a value at the type level of kind *).</p>
<p>We want a fixpoint construction that gives back something of kind <code>* -> *</code> — i.e. something that is a type constructor representing a functor, and not just a plain old type. The following does the trick.</p>
<pre class="haskell">&nbsp;
<span style="color: #06c; font-weight: bold;">newtype</span> FixF f a = FixF <span style="color: green;">&#40;</span>f <span style="color: green;">&#40;</span>FixF f<span style="color: green;">&#41;</span> a<span style="color: green;">&#41;</span>
<span style="color: #06c; font-weight: bold;">deriving</span> <span style="color: #06c; font-weight: bold;">instance</span> <span style="color: green;">&#40;</span><a href="http://haskell.org/ghc/docs/latest/html/libraries/base/Prelude.html#t:Show"><span style="background-color: #efefbf; font-weight: bold;">Show</span></a> <span style="color: green;">&#40;</span>f <span style="color: green;">&#40;</span>FixF f<span style="color: green;">&#41;</span> a<span style="color: green;">&#41;</span><span style="color: green;">&#41;</span> =&gt; <a href="http://haskell.org/ghc/docs/latest/html/libraries/base/Prelude.html#t:Show"><span style="background-color: #efefbf; font-weight: bold;">Show</span></a> <span style="color: green;">&#40;</span>FixF f a<span style="color: green;">&#41;</span></pre>
<p>(I learned about FixF from <a href="http://www.cs.ox.ac.uk/ralf.hinze/SSGIP10/AdjointFolds.pdf">a paper by Ralf Hinze</a>, but I'm sure the origins go back much further).</p>
<p>FixF is of kind <code>((* -> *) -> * -> *) -> * -> *</code>. It takes the fixpoint of a "second-order Functor" (a Functor that sends a Functor to another Functor, i.e. an endofunctor on the functor category of hask), to recover a standard "first order Functor" back out. This sounds scary, but it isn't once you load it up in ghci and start playing with it. In fact, we've encountered second order functors just recently. Product, Sum, and Compose are all of kind <code>(* -> *) -> (* -> *) -> * -> *</code>. So they all send two functors to a third functor. That means that <code>Product Const</code>, <code>Sum Identity</code> and <code>Compose Maybe</code> are all second-order functors, and things appropriate to take our "second-order fixpoint" of.</p>
<p>Conceptually, "Fix f" took a value with one hole, and we filled that hole with "Fix f" so there was no room for a type parameter. Now we've got an "f" with two holes, the first of which takes a functor, and the second of which is the hole of the resulting functor.</p>
<p>Unlike boring old "Fix", we can write Functor and Applicative instances for "FixF", and they're about as simple and compositional as we could possibly hope.</p>
<pre class="haskell"><span style="color: #06c; font-weight: bold;">instance</span> <a href="http://haskell.org/ghc/docs/latest/html/libraries/base/Prelude.html#t:Functor"><span style="background-color: #efefbf; font-weight: bold;">Functor</span></a> <span style="color: green;">&#40;</span>f <span style="color: green;">&#40;</span>FixF f<span style="color: green;">&#41;</span><span style="color: green;">&#41;</span> =&gt; <a href="http://haskell.org/ghc/docs/latest/html/libraries/base/Prelude.html#t:Functor"><span style="background-color: #efefbf; font-weight: bold;">Functor</span></a> <span style="color: green;">&#40;</span>FixF f<span style="color: green;">&#41;</span> <span style="color: #06c; font-weight: bold;">where</span>
    <a href="http://haskell.org/ghc/docs/latest/html/libraries/base/Prelude.html#v:fmap"><span style="font-weight: bold;">fmap</span></a> f <span style="color: green;">&#40;</span>FixF x<span style="color: green;">&#41;</span> = FixF $ <a href="http://haskell.org/ghc/docs/latest/html/libraries/base/Prelude.html#v:fmap"><span style="font-weight: bold;">fmap</span></a> f x
&nbsp;
<span style="color: #06c; font-weight: bold;">instance</span> Applicative <span style="color: green;">&#40;</span>f <span style="color: green;">&#40;</span>FixF f<span style="color: green;">&#41;</span><span style="color: green;">&#41;</span> =&gt; Applicative <span style="color: green;">&#40;</span>FixF f<span style="color: green;">&#41;</span> <span style="color: #06c; font-weight: bold;">where</span>
    pure x = FixF $ pure x
    <span style="color: green;">&#40;</span>FixF f<span style="color: green;">&#41;</span> &lt; *&gt; <span style="color: green;">&#40;</span>FixF x<span style="color: green;">&#41;</span> = FixF <span style="color: green;">&#40;</span>f &lt; *&gt; x<span style="color: green;">&#41;</span></pre>
<p>But now we run into a new problem! It seems like this "a" parameter is just hanging out there, doing basically nothing. We take our classic functors and embed them in there, and they still only have "one hole" at the value level, so don't actually have any place to put the "a" type we now introduced. For example, we can write the following:</p>
<pre class="haskell"><span style="color: #5d478b; font-style: italic;">-- FixF . Compose . Just . FixF . Compose $ Nothing</span>
<span style="color: #5d478b; font-style: italic;">-- &gt; FixF (Compose (Just (FixF (Compose Nothing))))</span>
<span style="color: #5d478b; font-style: italic;">-- :t FixF (Compose (Just (FixF (Compose Nothing))))</span>
<span style="color: #5d478b; font-style: italic;">-- &gt; FixF (Compose Maybe) a</span></pre>
<p>We now introduce one new member of our basic constructions — a second order functor that acts like "const" on the type level, taking any functor and returning Identity.</p>
<pre class="haskell">&nbsp;
<span style="color: #06c; font-weight: bold;">newtype</span> Embed <span style="color: green;">&#40;</span>f :: * -&gt; *<span style="color: green;">&#41;</span> a = Embed a <span style="color: #06c; font-weight: bold;">deriving</span> <span style="color: green;">&#40;</span><a href="http://haskell.org/ghc/docs/latest/html/libraries/base/Prelude.html#t:Show"><span style="background-color: #efefbf; font-weight: bold;">Show</span></a><span style="color: green;">&#41;</span>
&nbsp;
<span style="color: #06c; font-weight: bold;">instance</span> <a href="http://haskell.org/ghc/docs/latest/html/libraries/base/Prelude.html#t:Functor"><span style="background-color: #efefbf; font-weight: bold;">Functor</span></a> <span style="color: green;">&#40;</span>Embed f<span style="color: green;">&#41;</span> <span style="color: #06c; font-weight: bold;">where</span>
    <a href="http://haskell.org/ghc/docs/latest/html/libraries/base/Prelude.html#v:fmap"><span style="font-weight: bold;">fmap</span></a> f <span style="color: green;">&#40;</span>Embed x<span style="color: green;">&#41;</span> = Embed $ f x
&nbsp;
<span style="color: #06c; font-weight: bold;">instance</span> Applicative <span style="color: green;">&#40;</span>Embed f<span style="color: green;">&#41;</span> <span style="color: #06c; font-weight: bold;">where</span>
    pure x = Embed x
    <span style="color: green;">&#40;</span>Embed f<span style="color: green;">&#41;</span> &lt; *&gt; <span style="color: green;">&#40;</span>Embed x<span style="color: green;">&#41;</span> = Embed <span style="color: green;">&#40;</span>f x<span style="color: green;">&#41;</span></pre>
<p>Now we can actually stick functorial values into our fixpoints:</p>
<pre class="haskell"><span style="color: #5d478b; font-style: italic;">-- FixF $ Embed &quot;hi&quot;</span>
<span style="color: #5d478b; font-style: italic;">-- &gt; FixF (Embed &quot;hi&quot;)</span>
&nbsp;
<span style="color: #5d478b; font-style: italic;">-- fmap (++ &quot; world&quot;) $ FixF (Embed &quot;hi&quot;)</span>
<span style="color: #5d478b; font-style: italic;">-- &gt; FixF (Embed &quot;hi world&quot;)</span>
&nbsp;
<span style="color: #5d478b; font-style: italic;">-- FixF . Product (Embed &quot;hi&quot;) .</span>
<span style="color: #5d478b; font-style: italic;">--        FixF . Product (Embed &quot;there&quot;) . FixF $ undefined</span>
<span style="color: #5d478b; font-style: italic;">-- &gt; FixF (Product (Embed &quot;hi&quot;)</span>
<span style="color: #5d478b; font-style: italic;">--   (FixF (Product (Embed &quot;there&quot;)</span>
<span style="color: #5d478b; font-style: italic;">--   (FixF *** Exception: Prelude.undefined</span></pre>
<p>You may have noticed that we seem to be able to use "product" to begin a chain of nested fixpoints, but we don't seem able to stick a "Maybe" in there to <strong>stop</strong> the chain. And it seems like we're not even "fixing" where we intend to be:</p>
<pre class="haskell"><span style="color: #5d478b; font-style: italic;">-- :t FixF . Product (Embed &quot;hi&quot;) . FixF . Product (Embed &quot;there&quot;) . FixF $ undefined</span>
<span style="color: #5d478b; font-style: italic;">-- &gt; FixF (Product (Embed f)) [Char]</span></pre>
<p>That's because we're applying Product, takes and yields arguments of kind <code>* -> *</code> in a context where we really want to take and yield second-order functors as arguments — things of kind <code>(* -> *) -> * -> *</code>. If we had proper kind polymorphism, "Product" and "ProductF" would be able to collapse (and maybe, soon, they will). But at least in the ghc 7.4.1 that I'm working with, we have to write the same darn thing, but "up a kind".</p>
<pre class="haskell"><span style="color: #06c; font-weight: bold;">data</span> ProductF f g <span style="color: green;">&#40;</span>b :: * -&gt; *<span style="color: green;">&#41;</span> a =
      ProductF <span style="color: green;">&#40;</span>f b a<span style="color: green;">&#41;</span> <span style="color: green;">&#40;</span>g b a<span style="color: green;">&#41;</span> <span style="color: #06c; font-weight: bold;">deriving</span> <a href="http://haskell.org/ghc/docs/latest/html/libraries/base/Prelude.html#t:Show"><span style="background-color: #efefbf; font-weight: bold;">Show</span></a>
&nbsp;
<span style="color: #06c; font-weight: bold;">instance</span> <span style="color: green;">&#40;</span><a href="http://haskell.org/ghc/docs/latest/html/libraries/base/Prelude.html#t:Functor"><span style="background-color: #efefbf; font-weight: bold;">Functor</span></a> <span style="color: green;">&#40;</span>f b<span style="color: green;">&#41;</span>, <a href="http://haskell.org/ghc/docs/latest/html/libraries/base/Prelude.html#t:Functor"><span style="background-color: #efefbf; font-weight: bold;">Functor</span></a> <span style="color: green;">&#40;</span>g b<span style="color: green;">&#41;</span><span style="color: green;">&#41;</span> =&gt;
         <a href="http://haskell.org/ghc/docs/latest/html/libraries/base/Prelude.html#t:Functor"><span style="background-color: #efefbf; font-weight: bold;">Functor</span></a> <span style="color: green;">&#40;</span>ProductF f g b<span style="color: green;">&#41;</span> <span style="color: #06c; font-weight: bold;">where</span>
                <a href="http://haskell.org/ghc/docs/latest/html/libraries/base/Prelude.html#v:fmap"><span style="font-weight: bold;">fmap</span></a> f <span style="color: green;">&#40;</span>ProductF x y<span style="color: green;">&#41;</span> = ProductF <span style="color: green;">&#40;</span><a href="http://haskell.org/ghc/docs/latest/html/libraries/base/Prelude.html#v:fmap"><span style="font-weight: bold;">fmap</span></a> f x<span style="color: green;">&#41;</span> <span style="color: green;">&#40;</span><a href="http://haskell.org/ghc/docs/latest/html/libraries/base/Prelude.html#v:fmap"><span style="font-weight: bold;">fmap</span></a> f y<span style="color: green;">&#41;</span>
&nbsp;
<span style="color: #06c; font-weight: bold;">instance</span> <span style="color: green;">&#40;</span>Applicative <span style="color: green;">&#40;</span>f b<span style="color: green;">&#41;</span>, Applicative <span style="color: green;">&#40;</span>g b<span style="color: green;">&#41;</span><span style="color: green;">&#41;</span> =&gt;
         Applicative <span style="color: green;">&#40;</span>ProductF f g b<span style="color: green;">&#41;</span> <span style="color: #06c; font-weight: bold;">where</span>
               pure x = ProductF <span style="color: green;">&#40;</span>pure x<span style="color: green;">&#41;</span> <span style="color: green;">&#40;</span>pure x<span style="color: green;">&#41;</span>
              <span style="color: green;">&#40;</span>ProductF f g<span style="color: green;">&#41;</span> &lt; *&gt; <span style="color: green;">&#40;</span>ProductF x y<span style="color: green;">&#41;</span> = ProductF <span style="color: green;">&#40;</span>f &lt; *&gt; x<span style="color: green;">&#41;</span> <span style="color: green;">&#40;</span>g &lt; *&gt; y<span style="color: green;">&#41;</span></pre>
<p>We can now do the following properly.</p>
<pre class="haskell">yy = FixF . ProductF <span style="color: green;">&#40;</span>Embed <span style="color: #3c7331;">&quot;foo&quot;</span><span style="color: green;">&#41;</span> $ InL $ Const <span style="color: green;">&#40;</span><span style="color: green;">&#41;</span>
xx = FixF . ProductF <span style="color: green;">&#40;</span>Embed <span style="color: #3c7331;">&quot;bar&quot;</span><span style="color: green;">&#41;</span> . InR .
        FixF . ProductF <span style="color: green;">&#40;</span>Embed <span style="color: #3c7331;">&quot;baz&quot;</span><span style="color: green;">&#41;</span> . InL $ Const <span style="color: green;">&#40;</span><span style="color: green;">&#41;</span></pre>
<p>So we've recovered proper lists in Haskell, as the "second-order fixpoint" of polynomial functors. And the types look right too:</p>
<pre class="haskell"><span style="color: #5d478b; font-style: italic;">-- :t yy</span>
<span style="color: #5d478b; font-style: italic;">-- &gt; FixF (ProductF Embed (Sum (Const ()))) [Char]</span></pre>
<p>Because we've built our Applicative instances compositionally, we have an applicative for our list list construction automatically:</p>
<pre class="haskell"><span style="color: #5d478b; font-style: italic;">-- (++) &lt; $&gt; yy &lt; *&gt; xx</span>
<span style="color: #5d478b; font-style: italic;">-- &gt; FixF (ProductF (Embed &quot;foobar&quot;) (InL (Const ())))</span></pre>
<p>This is precisely the "ZipList" applicative instance. In fact, our applicative instances from this "functor toolkit" are all "zippy" — matching up structure where possible, and "smashing it down" where not. This is because Sum, with its associated natural transformation logic, is the only way to introduce a disjoint choice of shape. Here are some simple examples with Sum to demonstrate:</p>
<pre class="haskell"><span style="color: #5d478b; font-style: italic;">-- liftA2 (++) (InL (Identity &quot;hi&quot;)) $</span>
<span style="color: #5d478b; font-style: italic;">--      InR (Product (Identity &quot; there&quot;) (Const ([12::Int])))</span>
<span style="color: #5d478b; font-style: italic;">-- &gt; InL (Identity &quot;hi there&quot;)</span>
<span style="color: #5d478b; font-style: italic;">-- liftA2 (++) (InR (Identity &quot;hi&quot;)) $ InL (Product (Identity &quot; there&quot;) (Const ([12::Int])))</span>
<span style="color: #5d478b; font-style: italic;">-- &gt; InL (Product (Identity &quot;hi there&quot;) (Const [12]))</span></pre>
<p>We're always "smashing" towards the left. So in the first case, that means throwing away half of the pair. In the second case, it means injecting Const mempty into a pair, and then operating with that.</p>
<p>In any case, we now have infinite and possibly infinite branching structures. And not only are they Functors, but they're also Applicatives, and in a way that's uniform and straightforward to reason about.</p>
<p>In the next post, we'll stop building out our vocabulary of "base" Functors (though it's not quite complete) and instead push forward on what else these functors can provide "beyond" Applicative.</p>
	<div class="post-info">
			</div>
	<div class="post-footer">&nbsp;</div>
</div>
									</div>
							
				<div class="post">
					<p class="post-date">Fri 7 Dec 2012</p>
<div class="post-info"><h2 class="post-title"><a href="../../2012/natural-deduction-sequent-calculus-and-type-classes/index.html" rel="bookmark" title="Permanent Link: Natural Deduction, Sequent Calculus and Type Classes">Natural Deduction, Sequent Calculus and Type Classes</a></h2>
Posted by Dan Doel under <a href="index.html" title="View all posts in Uncategorized" rel="category tag">Uncategorized</a> <br/><a href="../../2012/natural-deduction-sequent-calculus-and-type-classes/index.html#comments" title="Comment on Natural Deduction, Sequent Calculus and Type Classes">[3] Comments</a>&nbsp;</div>
<div class="post-content">
	<p>By and large, there are two sorts of proof systems that people use (these days) when studying logic: natural deduction, and sequent calculus. I know of at least one other---Hilbert style---but it is older, and the above systems were invented due to dissatisfaction with Hilbert systems (for a programming analogy, Hilbert systems are like programming entirely with combinators (S, K, etc.), rather than a lambda calculus).</p>
<h2>Natural Deduction</h2>
<p>Probably the best way to categorize the difference, for the purpose of where we're eventually going, is that natural deduction focuses on the ways to build proof terms up from their constituent parts. This comes in the form of introduction and elimination rules for the various propositions. For instance, the rules for conjunction are:</p>
<div class="codeblock">
<p align="center"> <img src='../../../latex/783ccc760a775c36798d4f43a6b1d7f0.png' title=' \inference{A \,\,\,\,\,\,\,\,\, B}{A \wedge B}[$\wedge$-I]' alt=' \inference{A \,\,\,\,\,\,\,\,\, B}{A \wedge B}[$\wedge$-I]' align=absmiddle> </p>
<p align="center"> <img src='../../../latex/72830d280ca501adac8178a3be715d1f.png' title=' \inference{A \wedge B}{A}[$\wedge$-E1] \,\,\,\,\,\, \inference{A \wedge B}{B}[$\wedge$-E2]' alt=' \inference{A \wedge B}{A}[$\wedge$-E1] \,\,\,\,\,\, \inference{A \wedge B}{B}[$\wedge$-E2]' align=absmiddle> </p>
</div>
<p>This spartan style gets a bit annoying (in my opinion) for the hypothetical premises of the implication introduction, but this can be solved by adding contexts:</p>
<div class="codeblock">
<p align="center"> <img src='../../../latex/9b10e662928fdfe29c4969fe8b301a33.png' title=' \inference{\Gamma, A \vdash B}{\Gamma \vdash A \rightarrow B}[$\rightarrow$-I] ' alt=' \inference{\Gamma, A \vdash B}{\Gamma \vdash A \rightarrow B}[$\rightarrow$-I] ' align=absmiddle> </p>
<p align="center"> <img src='../../../latex/2ebd29c4b4b2726fdc20e9e4f6bb4fa3.png' title=' \inference{\Gamma \vdash A \rightarrow B \,\,\,\,\,\,\,\,\, \Gamma \vdash A}{\Gamma \vdash B}[$\rightarrow$-E] ' alt=' \inference{\Gamma \vdash A \rightarrow B \,\,\,\,\,\,\,\,\, \Gamma \vdash A}{\Gamma \vdash B}[$\rightarrow$-E] ' align=absmiddle> </p>
</div>
<p>This is the style most commonly adopted for presenting type theories, except we reason about terms with a type, rather than just propositions. The context we added for convenience above also becomes fairly essential for keeping track of variables:</p>
<div class="codeblock">
<p align="center"> <img src='../../../latex/a443c308ea53f52ac8c79390c6dd8151.png' title=' \inference{\Gamma \vdash M : A \,\,\,\,\,\,\,\,\, \Gamma \vdash N : B}{\Gamma \vdash (M, N) : A \times B}[$\times$-I] ' alt=' \inference{\Gamma \vdash M : A \,\,\,\,\,\,\,\,\, \Gamma \vdash N : B}{\Gamma \vdash (M, N) : A \times B}[$\times$-I] ' align=absmiddle> </p>
<p align="center"> <img src='../../../latex/ec4510483acc5255daecda473c747b43.png' title=' \inference{\Gamma \vdash M : A \times B}{\Gamma \vdash \mathsf{fst}\, M : A}[$\times$-E1] ' alt=' \inference{\Gamma \vdash M : A \times B}{\Gamma \vdash \mathsf{fst}\, M : A}[$\times$-E1] ' align=absmiddle> </p>
<p align="center"> <img src='../../../latex/09fff955437d0808666db20270638ee7.png' title=' \inference{\Gamma \vdash M : A \times B}{\Gamma \vdash \mathsf{snd}\, M : B}[$\times$-E2] ' alt=' \inference{\Gamma \vdash M : A \times B}{\Gamma \vdash \mathsf{snd}\, M : B}[$\times$-E2] ' align=absmiddle> </p>
<p align="center"> <img src='../../../latex/3e743e06355407c7d58e5933cbb0bb2f.png' title=' \inference{\Gamma, x : A \vdash M : B}{\Gamma \vdash (\lambda x:A. \,\, M) : A \rightarrow B}[$\rightarrow$-I] ' alt=' \inference{\Gamma, x : A \vdash M : B}{\Gamma \vdash (\lambda x:A. \,\, M) : A \rightarrow B}[$\rightarrow$-I] ' align=absmiddle> </p>
<p align="center"> <img src='../../../latex/55b21349085679b21328e7f97bbb5aa4.png' title=' \inference{\Gamma \vdash M : A \rightarrow B \,\,\,\,\,\,\,\,\, \Gamma \vdash N : A}{\Gamma \vdash M \, N : B}[$\rightarrow$-E] ' alt=' \inference{\Gamma \vdash M : A \rightarrow B \,\,\,\,\,\,\,\,\, \Gamma \vdash N : A}{\Gamma \vdash M \, N : B}[$\rightarrow$-E] ' align=absmiddle> </p>
</div>
<p>As can be seen, all the rules involve taking terms from the premise and building on them in the conclusion.</p>
<h2>Sequent Calculi</h2>
<p>The other type of system in question, sequent calculus, looks very similar, but represents a subtle shift in focus for our purposes (sequent calculi are a lot more obviously different when presenting classical logics). First, the inference rules relate sequents, which look a lot like our contextual judgments above, and I'll write them the same way. The difference is that not all rules operate on the conclusion side; some operate just on the context. Generally, introduction rules stay similar to natural deduction (and are called right rules), while elimination rules are replaced by manipulations of the context, and are called left rules. For pairs, we can use the rules:</p>
<div class="codeblock">
<p align="center"> <img src='../../../latex/026317e5c95937857e51a76c0cb1e430.png' title=' \inference{\Gamma \vdash A \,\,\,\,\,\,\,\,\, \Gamma \vdash B}{\Gamma \vdash A \wedge B}[$\wedge$-R] ' alt=' \inference{\Gamma \vdash A \,\,\,\,\,\,\,\,\, \Gamma \vdash B}{\Gamma \vdash A \wedge B}[$\wedge$-R] ' align=absmiddle> </p>
<p align="center"> <img src='../../../latex/3494cc388869c925dbb52144fd97d30d.png' title=' \inference{\Gamma, A, B \vdash C}{\Gamma, A \wedge B \vdash C}[$\wedge$-L] ' alt=' \inference{\Gamma, A, B \vdash C}{\Gamma, A \wedge B \vdash C}[$\wedge$-L] ' align=absmiddle> </p>
</div>
<p>We could also have two separate left rules:</p>
<div class="codeblock">
<p align="center"><img src='../../../latex/110c2bbcf5f66f7c6398c3f6ba990f07.png' title='\inference{\Gamma, A \vdash C}{\Gamma, A \wedge B \vdash C}[$\wedge$-L1]' alt='\inference{\Gamma, A \vdash C}{\Gamma, A \wedge B \vdash C}[$\wedge$-L1]' align=absmiddle></p>
<p align="center"><img src='../../../latex/84aa197282ba310d5b850f2cd0a60be3.png' title='\inference{\Gamma, B \vdash C}{\Gamma, A \wedge B \vdash C}[$\wedge$-L2]' alt='\inference{\Gamma, B \vdash C}{\Gamma, A \wedge B \vdash C}[$\wedge$-L2]' align=absmiddle></p>
</div>
<p>But these two different sets are equivalent as long as we're not considering substructural logics. Do note, however, that we're moving from <img src='../../../latex/7fc56270e7a70fa81a5935b72eacbe29.png' title='A' alt='A' align=absmiddle> on the top left to <img src='../../../latex/b05f38111aa635f08d594f45b197586a.png' title='A \wedge B' alt='A \wedge B' align=absmiddle> on the bottom left, using the fact that <img src='../../../latex/b05f38111aa635f08d594f45b197586a.png' title='A \wedge B' alt='A \wedge B' align=absmiddle> is sufficient to imply <img src='../../../latex/7fc56270e7a70fa81a5935b72eacbe29.png' title='A' alt='A' align=absmiddle>. That is, projections apply contravariantly to the left.</p>
<p>It turns out that almost no type theory is done in this style; natural deduction is far and away more popular. There are, I think, a few reasons for this. The first is: how do we even extend the left rules to type theory (eliminations are obvious, by contrast)? I know of two ways. The first is to introduce pattern matching into the contexts, so our left rule becomes:</p>
<div class="codeblock">
<p align="center"> <img src='../../../latex/9013cfad42a40c2e76a7ecd7049e0e65.png' title=' \inference{\Gamma, x : A, y : B \vdash M : C}{\Gamma, (x, y) : A \times B \vdash M : C}[$\times$-L] ' alt=' \inference{\Gamma, x : A, y : B \vdash M : C}{\Gamma, (x, y) : A \times B \vdash M : C}[$\times$-L] ' align=absmiddle> </p>
</div>
<p>This is an acceptable choice (and may avoid some of the pitfalls in the next option), but it doesn't gel with your typical lambda calculus. It's probably more suited to a pattern calculus of some sort (although, even then, if you want to bend your brain, go look at the left rule for implication and try to figure out how it translates into such a theory; I think you probably need higher-order contexts of some sort). Anyhow, I'm not going to explore this further.</p>
<p>The other option (and one that I've seen in the literature) is that left rules actually involve a variable substitution. So we come up with the following rule:</p>
<div class="codeblock">
<p align="center"> <img src='../../../latex/8b9164f5b58ce45f73a1dd4e5d792d2c.png' title=' \inference{\Gamma, x : A, y : B \vdash M : C}{\Gamma, p : A \times B \vdash M[x := \mathsf{fst}\, p, y := \mathsf{snd}\, p] : C}[$\times$-L] ' alt=' \inference{\Gamma, x : A, y : B \vdash M : C}{\Gamma, p : A \times B \vdash M[x := \mathsf{fst}\, p, y := \mathsf{snd}\, p] : C}[$\times$-L] ' align=absmiddle> </p>
</div>
<p>And with this rule, it becomes (I think) more obvious why natural deduction is preferred over sequent calculus, as implementing this rule in a type checker seems significantly harder. Checking the rules of natural deduction involves examining some outer-most structure of the term, and then checking the constituents of the term, possibly in an augmented context, and which rule we're dealing with is always syntax directed. But this left rule has no syntactic correspondent, so it seems as though we must nondeterministically try all left rules at each step, which is unlikely to result in a good algorithm. This is the same kind of problem that plagues extensional type theory, and ultimately results in only <em>derivations</em> being checkable, not terms.</p>
<h2>The Type Class Connection</h2>
<p>However, there are certain problems that I believe are well modeled by such a sequent calculus, and one of them is type class checking and associated dictionary translations. This is due mainly to the fact that the process is mainly context-directed term building, rather than term-directed type checking. As far as the type class algorithm goes, there are two interesting cases, having to do with the following two varieties of declaration:</p>
<pre class="haskell">&nbsp;
  <span style="color: #06c; font-weight: bold;">class</span> <a href="http://haskell.org/ghc/docs/latest/html/libraries/base/Prelude.html#t:Eq"><span style="background-color: #efefbf; font-weight: bold;">Eq</span></a> a =&gt; <a href="http://haskell.org/ghc/docs/latest/html/libraries/base/Prelude.html#t:Ord"><span style="background-color: #efefbf; font-weight: bold;">Ord</span></a> a <span style="color: #06c; font-weight: bold;">where</span> ...
  <span style="color: #06c; font-weight: bold;">instance</span> <span style="color: green;">&#40;</span><a href="http://haskell.org/ghc/docs/latest/html/libraries/base/Prelude.html#t:Eq"><span style="background-color: #efefbf; font-weight: bold;">Eq</span></a> a, <a href="http://haskell.org/ghc/docs/latest/html/libraries/base/Prelude.html#t:Eq"><span style="background-color: #efefbf; font-weight: bold;">Eq</span></a> b<span style="color: green;">&#41;</span> =&gt; <a href="http://haskell.org/ghc/docs/latest/html/libraries/base/Prelude.html#t:Eq"><span style="background-color: #efefbf; font-weight: bold;">Eq</span></a> <span style="color: green;">&#40;</span>a, b<span style="color: green;">&#41;</span> <span style="color: #06c; font-weight: bold;">where</span> ...
&nbsp;</pre>
<p>It turns out that each of these leads to a left rule in a kind of type class sequent calculus:</p>
<div class="codeblock">
<p align="center"> <img src='../../../latex/f75290bbac8202c1d47fb62954e7606b.png' title=' \inference{\Gamma, \mathbf{Eq} \, a \vdash M : T}{\Gamma, \mathbf{Ord} \,  a \vdash M : T}[Eq-pre-Ord] ' alt=' \inference{\Gamma, \mathbf{Eq} \, a \vdash M : T}{\Gamma, \mathbf{Ord} \,  a \vdash M : T}[Eq-pre-Ord] ' align=absmiddle> </p>
<p align="center"> <img src='../../../latex/4093e2180dce354d1d940438588e32a9.png' title=' \inference{\Gamma, \mathbf{Eq} \, (a, b) \vdash M : T}{\Gamma, \mathbf{Eq} \, a, \mathbf{Eq} \, b \vdash M : T}[Eq-pair] ' alt=' \inference{\Gamma, \mathbf{Eq} \, (a, b) \vdash M : T}{\Gamma, \mathbf{Eq} \, a, \mathbf{Eq} \, b \vdash M : T}[Eq-pair] ' align=absmiddle> </p>
</div>
<p>That is:</p>
<ol>
<li> if <code>Eq a</code> is a sufficient constraint for <code>M : T</code>, then the stronger constraint <code>Ord a</code> is also sufficient, so we can discharge the <code>Eq a</code> constraint and use <code>Ord a</code> instead.</li>
<li> We can discharge an <code>Eq (a, b)</code> constraint using two constraints, <code>Eq a, Eq b</code> together with an instance telling us how to do so. This also works for instances without contexts, giving us rules like:
<div class="codeblock">
<p align="center"><img src='../../../latex/81d80ab8d9bd02d1b409ec1e59b4cdb4.png' title='\inference{\Gamma, \mathbf{Show\, Int} \vdash M : T}{\Gamma \vdash M : T}[Show-Int] ' alt='\inference{\Gamma, \mathbf{Show\, Int} \vdash M : T}{\Gamma \vdash M : T}[Show-Int] ' align=absmiddle></p>
</div>
</li>
</ol>
<p>Importantly, the type inference algorithm for type classes specifies when we should use these rules based only on the contexts we're dealing with. Now, these look more like the logical sequent rules, but it turns out that they have corresponding type theory-like versions when we consider dictionary passing:</p>
<div class="codeblock">
<p align="center"> <img src='../../../latex/46926ac44142bdb8f4b1e07f8f6fd2b8.png' title=' \inference{\Gamma, eqd : \mathbf{Eq} \, a \vdash M : T}{\Gamma, ordd : \mathbf{Ord} \,  a \vdash M[eqd := \mathsf{eqOrdPrj}\, ordd] : T}[Eq-pre-Ord] ' alt=' \inference{\Gamma, eqd : \mathbf{Eq} \, a \vdash M : T}{\Gamma, ordd : \mathbf{Ord} \,  a \vdash M[eqd := \mathsf{eqOrdPrj}\, ordd] : T}[Eq-pre-Ord] ' align=absmiddle> </p>
<p align="center"> <img src='../../../latex/89345750380d8f1f636ab4a29d31ef11.png' title='\inference{\Gamma, peq : \mathbf{Eq} \, (a, b) \vdash M : T}{\Gamma, aeq : \mathbf{Eq} \, a, beq : \mathbf{Eq} \, b \vdash M[peq := \mathsf{eqPair} \, aeq \, beq] : T}[Eq-pair]' alt='\inference{\Gamma, peq : \mathbf{Eq} \, (a, b) \vdash M : T}{\Gamma, aeq : \mathbf{Eq} \, a, beq : \mathbf{Eq} \, b \vdash M[peq := \mathsf{eqPair} \, aeq \, beq] : T}[Eq-pair]' align=absmiddle> </p>
</div>
<p>And this kind of substituting into dictionary variables produces exactly the evidence passing translation we want.</p>
<p>Another way to look at the difference in feasibility is that type checking involves moving bottom-to-top across the rules; in natural deduction, this is always easy, and we need look only at the terms to figure out which we should do. Type class checking and dictionary translation moves from top-to-bottom, directed by the left hand context, and produces terms on the right via complex operations, and that is a perfect fit for the sequent calculus rules.</p>
<p>I believe this corresponds to the general opinion on those who have studied sequent calculi with regard to type theory. A quick search revealed mostly papers on proof search, rather than type checking, and type classes rather fall into that realm (they're a very limited form of proof search).</p>
	<div class="post-info">
			</div>
	<div class="post-footer">&nbsp;</div>
</div>
									</div>
							
				<div class="post">
					<p class="post-date">Thu 3 Nov 2011</p>
<div class="post-info"><h2 class="post-title"><a href="../../2011/what-constraints-entail-part-2/index.html" rel="bookmark" title="Permanent Link: What Constraints Entail: Part 2">What Constraints Entail: Part 2</a></h2>
Posted by Edward Kmett under <a href="../haskell/constraint-kinds/index.html" title="View all posts in Constraint Kinds" rel="category tag">Constraint Kinds</a> ,  <a href="../haskell/index.html" title="View all posts in Haskell" rel="category tag">Haskell</a> ,  <a href="../logic/index.html" title="View all posts in Logic" rel="category tag">Logic</a> ,  <a href="../monads/index.html" title="View all posts in Monads" rel="category tag">Monads</a> ,  <a href="../type-hackery/index.html" title="View all posts in Type Hackery" rel="category tag">Type Hackery</a> ,  <a href="index.html" title="View all posts in Uncategorized" rel="category tag">Uncategorized</a> <br/><a href="../../2011/what-constraints-entail-part-2/index.html#comments" title="Comment on What Constraints Entail: Part 2">[13] Comments</a>&nbsp;</div>
<div class="post-content">
	<p><a href="../../2011/what-constraints-entail-part-1/index.html">Last time</a> we derived an entailment relation for constraints, now let's get some use out of it.</p>
<h2>Reflecting Classes and Instances</h2>
<p>Most of the implications we use on a day to day basis come from our class and instance declarations, but last time we only really dealt with constraint products.</p>
<p> <a href="../../2011/what-constraints-entail-part-2/index.html#more-461" class="more-link">(more...)</a></p>
	<div class="post-info">
			</div>
	<div class="post-footer">&nbsp;</div>
</div>
									</div>
							
				<div class="post">
					<p class="post-date">Thu 3 Nov 2011</p>
<div class="post-info"><h2 class="post-title"><a href="../../2011/what-constraints-entail-part-1/index.html" rel="bookmark" title="Permanent Link: What Constraints Entail: Part 1">What Constraints Entail: Part 1</a></h2>
Posted by Edward Kmett under <a href="../category-theory/index.html" title="View all posts in Category Theory" rel="category tag">Category Theory</a> ,  <a href="../haskell/constraint-kinds/index.html" title="View all posts in Constraint Kinds" rel="category tag">Constraint Kinds</a> ,  <a href="../haskell/index.html" title="View all posts in Haskell" rel="category tag">Haskell</a> ,  <a href="../logic/index.html" title="View all posts in Logic" rel="category tag">Logic</a> ,  <a href="../monads/index.html" title="View all posts in Monads" rel="category tag">Monads</a> ,  <a href="../type-hackery/index.html" title="View all posts in Type Hackery" rel="category tag">Type Hackery</a> ,  <a href="index.html" title="View all posts in Uncategorized" rel="category tag">Uncategorized</a> <br/><a href="../../2011/what-constraints-entail-part-1/index.html#comments" title="Comment on What Constraints Entail: Part 1">[4] Comments</a>&nbsp;</div>
<div class="post-content">
	<p>Max Bolingbroke has done a wonderful job on adding Constraint kinds to GHC.</p>
<p>Constraint Kinds adds a new kind <code>Constraint</code>, such that <code>Eq :: * -> Constraint</code>, <code>Monad :: (* -> *) -> Constraint</code>, but since it is a kind, we can make type families for constraints, and even parameterize constraints <em>on</em> constraints. </p>
<p>So, let's play with them and see what we can come up with!</p>
<p> <a href="../../2011/what-constraints-entail-part-1/index.html#more-430" class="more-link">(more...)</a></p>
	<div class="post-info">
			</div>
	<div class="post-footer">&nbsp;</div>
</div>
									</div>
							
				<div class="post">
					<p class="post-date">Fri 23 Sep 2011</p>
<div class="post-info"><h2 class="post-title"><a href="../../2011/a-parsec-full-of-rats-part-2/index.html" rel="bookmark" title="Permanent Link: A Parsec Full of Rats, Part 2">A Parsec Full of Rats, Part 2</a></h2>
Posted by Edward Kmett under <a href="../algorithms/index.html" title="View all posts in Algorithms" rel="category tag">Algorithms</a> ,  <a href="../data-structures/index.html" title="View all posts in Data Structures" rel="category tag">Data Structures</a> ,  <a href="../haskell/index.html" title="View all posts in Haskell" rel="category tag">Haskell</a> ,  <a href="../monads/index.html" title="View all posts in Monads" rel="category tag">Monads</a> ,  <a href="../parsing/index.html" title="View all posts in Parsing" rel="category tag">Parsing</a> ,  <a href="index.html" title="View all posts in Uncategorized" rel="category tag">Uncategorized</a> <br/><a href="../../2011/a-parsec-full-of-rats-part-2/index.html#respond" title="Comment on A Parsec Full of Rats, Part 2">No Comments</a>&nbsp;</div>
<div class="post-content">
	<p>Last time, I showed that we can build a small parsec clone with packrat support.</p>
<p>This time I intend to implement packrat directly on top of Parsec 3.</p>
<p>One of the main topics of discussion when it comes to packrat parsing since Bryan Ford's initial release of Pappy has been the fact that in general you shouldn't use packrat to memoize every rule, and that instead you should apply Amdahl's law to look for the cases where the lookup time is paid back in terms of repetitive evaluation, computation time and the hit rate. This is great news for us, since, we only want to memoize a handful of expensive combinators.</p>
<p> <a href="../../2011/a-parsec-full-of-rats-part-2/index.html#more-397" class="more-link">(more...)</a></p>
	<div class="post-info">
			</div>
	<div class="post-footer">&nbsp;</div>
</div>
									</div>
							
				<div class="post">
					<p class="post-date">Fri 23 Sep 2011</p>
<div class="post-info"><h2 class="post-title"><a href="../../2011/a-parsec-full-of-rats/index.html" rel="bookmark" title="Permanent Link: A Parsec Full of Rats, Part 1">A Parsec Full of Rats, Part 1</a></h2>
Posted by Edward Kmett under <a href="../algorithms/index.html" title="View all posts in Algorithms" rel="category tag">Algorithms</a> ,  <a href="../data-structures/index.html" title="View all posts in Data Structures" rel="category tag">Data Structures</a> ,  <a href="../haskell/index.html" title="View all posts in Haskell" rel="category tag">Haskell</a> ,  <a href="../monads/index.html" title="View all posts in Monads" rel="category tag">Monads</a> ,  <a href="../parsing/index.html" title="View all posts in Parsing" rel="category tag">Parsing</a> ,  <a href="index.html" title="View all posts in Uncategorized" rel="category tag">Uncategorized</a> <br/><a href="../../2011/a-parsec-full-of-rats/index.html#comments" title="Comment on A Parsec Full of Rats, Part 1">[2] Comments</a>&nbsp;</div>
<div class="post-content">
	<blockquote><p>You never heard of the Millenium Falcon? It's the ship that made the Kessel Run in 12 parsecs.</p></blockquote>
<p>I've been working on a parser combinator library called <a href="http://hackage.haskell.org/package/trifecta">trifecta</a>, and so I decided I'd share some thoughts on parsing. </p>
<p><a href="http://pdos.csail.mit.edu/~baford/packrat/">Packrat parsing</a> (as provided by <a href="http://hackage.haskell.org/package/frisby">frisby</a>, <a href="http://hackage.haskell.org/package/pappy">pappy</a>, <a href="http://cs.nyu.edu/rgrimm/xtc/">rats!</a> and the Scala parsing combinators) and more traditional recursive descent parsers (like Parsec) are often held up as somehow different. </p>
<p>Today I'll show that you can add monadic parsing to a packrat parser, sacrificing asymptotic guarantees in exchange for the convenient context sensitivity, and conversely how you can easily add packrat parsing to a traditional monadic parser combinator library.</p>
<p> <a href="../../2011/a-parsec-full-of-rats/index.html#more-380" class="more-link">(more...)</a></p>
	<div class="post-info">
			</div>
	<div class="post-footer">&nbsp;</div>
</div>
									</div>
							
				<div class="post">
					<p class="post-date">Thu 4 Dec 2008</p>
<div class="post-info"><h2 class="post-title"><a href="../../2008/the-pointed-set-comonad/index.html" rel="bookmark" title="Permanent Link: The Pointed-Set Comonad">The Pointed-Set Comonad</a></h2>
Posted by Edward Kmett under <a href="../comonads/index.html" title="View all posts in Comonads" rel="category tag">Comonads</a> ,  <a href="../haskell/index.html" title="View all posts in Haskell" rel="category tag">Haskell</a> ,  <a href="index.html" title="View all posts in Uncategorized" rel="category tag">Uncategorized</a> <br/><a href="../../2008/the-pointed-set-comonad/index.html#comments" title="Comment on The Pointed-Set Comonad">[3] Comments</a>&nbsp;</div>
<div class="post-content">
	<p>Last night, Chung-Chieh Shan posted an example of a <a href="http://conway.rutgers.edu/~ccshan/wiki/blog/posts/Pointed_set/">pointed-set monad</a> on his blog, which happens to be isomorphic to a non-empty stream monad with a different emphasis. </p>
<p>But, I thought I should point out that the pointed set that he posted also has a comonadic structure, which may be exploited since it is just a variation on the "zipper comonad," a structure that is perhaps more correctly called a "pointing comonad."</p>
<p> <a href="../../2008/the-pointed-set-comonad/index.html#more-80" class="more-link">(more...)</a></p>
	<div class="post-info">
			</div>
	<div class="post-footer">&nbsp;</div>
</div>
									</div>
							
				<div class="post">
					<p class="post-date">Sat 8 Nov 2008</p>
<div class="post-info"><h2 class="post-title"><a href="../../2008/still-alive/index.html" rel="bookmark" title="Permanent Link: Still Alive">Still Alive</a></h2>
Posted by Edward Kmett under <a href="index.html" title="View all posts in Uncategorized" rel="category tag">Uncategorized</a> <br/><a href="../../2008/still-alive/index.html#comments" title="Comment on Still Alive">[6] Comments</a>&nbsp;</div>
<div class="post-content">
	<p>To those that have asked, I'm still alive. </p>
<p>I had to restore the blog database from a backup and so I lost a few posts, including the index for the various recursion schemes entries. Fortunately, before that happened I had replicated the <a href="http://knol.google.com/k/edward-kmett/catamorphisms/">catamorphism post as a knol</a>.</p>
<p>Should I find myself with a copious glut of free time, I shall happily re-scribe and finish the rest, but I've been very busy. </p>
	<div class="post-info">
			</div>
	<div class="post-footer">&nbsp;</div>
</div>
									</div>
							
				<div class="post">
					<p class="post-date">Fri 16 May 2008</p>
<div class="post-info"><h2 class="post-title"><a href="../../2008/forgetful-laziness/index.html" rel="bookmark" title="Permanent Link: Forgetful Laziness">Forgetful Laziness</a></h2>
Posted by Edward Kmett under <a href="../haskell/index.html" title="View all posts in Haskell" rel="category tag">Haskell</a> ,  <a href="index.html" title="View all posts in Uncategorized" rel="category tag">Uncategorized</a> <br/><a href="../../2008/forgetful-laziness/index.html#comments" title="Comment on Forgetful Laziness">[6] Comments</a>&nbsp;</div>
<div class="post-content">
	<p>Does anyone know of any work on "forgetful laziness?"</p>
<p> <a href="../../2008/forgetful-laziness/index.html#more-59" class="more-link">(more...)</a></p>
	<div class="post-info">
			</div>
	<div class="post-footer">&nbsp;</div>
</div>
									</div>
							
				<div class="post">
					<p class="post-date">Sat 26 Apr 2008</p>
<div class="post-info"><h2 class="post-title"><a href="../../2008/unnatural-transformations/index.html" rel="bookmark" title="Permanent Link: Unnatural Transformations">Unnatural Transformations</a></h2>
Posted by Edward Kmett under <a href="../category-theory/index.html" title="View all posts in Category Theory" rel="category tag">Category Theory</a> ,  <a href="../comonads/index.html" title="View all posts in Comonads" rel="category tag">Comonads</a> ,  <a href="../haskell/index.html" title="View all posts in Haskell" rel="category tag">Haskell</a> ,  <a href="../monads/index.html" title="View all posts in Monads" rel="category tag">Monads</a> ,  <a href="index.html" title="View all posts in Uncategorized" rel="category tag">Uncategorized</a> <br/><a href="../../2008/unnatural-transformations/index.html#comments" title="Comment on Unnatural Transformations">1 Comment</a>&nbsp;</div>
<div class="post-content">
	<p>Back in the days of <a href="http://citeseer.ist.psu.edu/41091.html">HYLO</a>, it was common to write hylomorphisms with an additional natural transformation in them. Well, I was still coding in evil imperative languages back then, but I have it on reliable, er.. well supposition, that this is probably the case, or at least that they liked to do it back in the HYLO papers anyways.</p>
<p>Transcoding the category theory mumbo-jumbo into Haskell, so I can have a larger audience, we get the following 'frat combinator' -- you can blame Jules Bean from #haskell for that.</p>
<pre class="haskell">&nbsp;
hyloEta :: <a href="http://haskell.org/ghc/docs/latest/html/libraries/base/Prelude.html#t:Functor"><span style="background-color: #efefbf; font-weight: bold;">Functor</span></a> f =&gt;
     <span style="color: green;">&#40;</span>g b -&gt; b<span style="color: green;">&#41;</span> -&gt;
     <span style="color: green;">&#40;</span><span style="color: #06c; font-weight: bold;">forall</span> a. f a -&gt; g a<span style="color: green;">&#41;</span> -&gt;
     <span style="color: green;">&#40;</span>a -&gt; f a<span style="color: green;">&#41;</span>
hyloEta phi eta psi = phi . eta . <a href="http://haskell.org/ghc/docs/latest/html/libraries/base/Prelude.html#v:fmap"><span style="font-weight: bold;">fmap</span></a> <span style="color: green;">&#40;</span>hyloEta phi eta psi<span style="color: green;">&#41;</span> . psi
&nbsp;</pre>
<p>We placed eta in the middle of the argument list because it is evocative of the fact that it occurs between phi and psi, and because that seems to be where everyone else puts it. </p>
<p>Now, clearly, we could roll eta into phi and get the more traditional hylo where f = g. Less obviously we could roll it into psi because it is a <a href="http://en.wikipedia.org/wiki/Natural_transformation">natural transformation</a> and so the following diagram commutes:</p>
<div class="codeblock" align="center">
<img src='../../../latex/eb518f091c90f6025d7669a9291b6c29.png' title='\bfig \square/&gt;`&gt;`&gt;`&gt;/[F(A)`F(B)`G(A)`G(B);F {[}\hspace{-0.8pt}{[}f, g{]}\hspace{-0.8pt}{]} `\eta_A`\eta_B`G {[}\hspace{-0.8pt}{[}f, g{]}\hspace{-0.8pt}{]}] \efig ' alt='\bfig \square/&gt;`&gt;`&gt;`&gt;/[F(A)`F(B)`G(A)`G(B);F {[}\hspace{-0.8pt}{[}f, g{]}\hspace{-0.8pt}{]} `\eta_A`\eta_B`G {[}\hspace{-0.8pt}{[}f, g{]}\hspace{-0.8pt}{]}] \efig ' align=absmiddle>
</div>
<p>This 'Hylo Shift' property (mentioned in that same paper) allows us to move the 'eta' term into the phi term or into the psi term as we see fit. Since we can move the eta term around and it adds no value to the combinator, it quietly returned to the void from whence it came. hyloEta offers us no more power than hylo, so out it goes.</p>
<p>So, if its dead, why talk about it?</p>
<p> <a href="../../2008/unnatural-transformations/index.html#more-50" class="more-link">(more...)</a></p>
	<div class="post-info">
			</div>
	<div class="post-footer">&nbsp;</div>
</div>
									</div>
							
				<div class="post">
					<p class="post-date">Tue 1 Jan 2008</p>
<div class="post-info"><h2 class="post-title"><a href="../../2008/elgot-algebras/index.html" rel="bookmark" title="Permanent Link: Elgot Algebras">Elgot Algebras</a></h2>
Posted by Edward Kmett under <a href="index.html" title="View all posts in Uncategorized" rel="category tag">Uncategorized</a> <br/><span>Comments Off</span>&nbsp;</div>
<div class="post-content">
	<p>Wordpress changed the slug of this post, but Planet Haskell has the old link.</p>
<p><a href="../../2008/elgot-coalgebras.html">Here is the actual content</a>.</p>
	<div class="post-info">
			</div>
	<div class="post-footer">&nbsp;</div>
</div>
									</div>
							
				<div class="post">
					<p class="post-date">Fri 13 Jul 2007</p>
<div class="post-info"><h2 class="post-title"><a href="../../2007/updated-datatype/index.html" rel="bookmark" title="Permanent Link: Updated Data.Type.*">Updated Data.Type.*</a></h2>
Posted by Edward Kmett under <a href="../haskell/index.html" title="View all posts in Haskell" rel="category tag">Haskell</a> ,  <a href="../type-hackery/index.html" title="View all posts in Type Hackery" rel="category tag">Type Hackery</a> ,  <a href="index.html" title="View all posts in Uncategorized" rel="category tag">Uncategorized</a> <br/><a href="../../2007/updated-datatype/index.html#respond" title="Comment on Updated Data.Type.*">No Comments</a>&nbsp;</div>
<div class="post-content">
	<p>Updated my little <a href="../../../haskell/type-int/index.html">type-level 2s and 16s complement integer library</a> to be ghc 6.6 friendly and uploaded it to <a href="http://hackage.haskell.org/cgi-bin/hackage-scripts/package/type-int-0.4">hackage</a> based on popular (er.. ok, well, singular) demand. </p>
<p>O.K. it was more of a polite request, but I did update it.</p>
	<div class="post-info">
			</div>
	<div class="post-footer">&nbsp;</div>
</div>
									</div>
						<p align="center"></p>		
					
	</div>
	<div id="sidebar">		
		<h2>Wiki</h2>
<ul>
    <li><a href="../../wiki%3bitem%3dOctober%202006%3bAugust%202006%3bJuly%202006.html">Old Journal</a></li>
    <li><a href="../../source%3bitem%3dlibraries.html">Source</a>
    <li><a href="../../wiki%3bitem%3dHarmless%2bAlgorithms%3bfine-occlusion%2bculling.html">Harmless Algorithms</a></li>
</ul>
<!--
<h2>Pages</h2>
<ul><li class="page_item page-item-2"><a href="http://comonad.com/reader/about/" title="About">About</a></li>
<li class="page_item page-item-29"><a href="http://comonad.com/reader/source/" title="Source">Source</a></li>
<li class="page_item page-item-31"><a href="http://comonad.com/reader/wiki-category/" title="View Category">View Category</a></li>
<li class="page_item page-item-30"><a href="http://comonad.com/reader/wiki/" title="Wiki">Wiki</a></li>
</ul>
-->
<!--
<h2>Blog Topics</h2>
<ul>	<li class="cat-item cat-item-29"><a href="http://comonad.com/reader/category/algorithms/" title="View all posts filed under Algorithms">Algorithms</a> (13)
</li>
	<li class="cat-item cat-item-22"><a href="http://comonad.com/reader/category/category-theory/" title="View all posts filed under Category Theory">Category Theory</a> (32)
</li>
	<li class="cat-item cat-item-23"><a href="http://comonad.com/reader/category/comonads/" title="View all posts filed under Comonads">Comonads</a> (16)
</li>
	<li class="cat-item cat-item-28"><a href="http://comonad.com/reader/category/data-structures/" title="View all posts filed under Data Structures">Data Structures</a> (13)
</li>
	<li class="cat-item cat-item-15"><a href="http://comonad.com/reader/category/haskell/" title="View all posts filed under Haskell">Haskell</a> (58)
<ul class='children'>
	<li class="cat-item cat-item-34"><a href="http://comonad.com/reader/category/haskell/boston-haskell/" title="View all posts filed under Boston Haskell">Boston Haskell</a> (6)
	<ul class='children'>
	<li class="cat-item cat-item-42"><a href="http://comonad.com/reader/category/haskell/boston-haskell/hac-boston/" title="View all posts filed under Hac Boston">Hac Boston</a> (1)
</li>
	</ul>
</li>
	<li class="cat-item cat-item-43"><a href="http://comonad.com/reader/category/haskell/constraint-kinds/" title="View all posts filed under Constraint Kinds">Constraint Kinds</a> (2)
</li>
	<li class="cat-item cat-item-52"><a href="http://comonad.com/reader/category/haskell/infrastructure/" title="View all posts filed under Infrastructure">Infrastructure</a> (1)
</li>
	<li class="cat-item cat-item-54"><a href="http://comonad.com/reader/category/haskell/japan/" title="View all posts filed under Japan">Japan</a> (1)
</li>
</ul>
</li>
	<li class="cat-item cat-item-20"><a href="http://comonad.com/reader/category/javascript/" title="View all posts filed under Javascript">Javascript</a> (1)
</li>
	<li class="cat-item cat-item-27"><a href="http://comonad.com/reader/category/kan-extensions/" title="View all posts filed under Kan Extensions">Kan Extensions</a> (12)
</li>
	<li class="cat-item cat-item-47"><a href="http://comonad.com/reader/category/lenses/" title="View all posts filed under Lenses">Lenses</a> (2)
</li>
	<li class="cat-item cat-item-13"><a href="http://comonad.com/reader/category/logic/" title="View all posts filed under Logic">Logic</a> (4)
</li>
	<li class="cat-item cat-item-33"><a href="http://comonad.com/reader/category/macros/" title="View all posts filed under Macros">Macros</a> (1)
</li>
	<li class="cat-item cat-item-25"><a href="http://comonad.com/reader/category/mathematics/" title="View all posts filed under Mathematics">Mathematics</a> (16)
<ul class='children'>
	<li class="cat-item cat-item-37"><a href="http://comonad.com/reader/category/mathematics/linear-algebra/" title="View all posts filed under Linear Algebra">Linear Algebra</a> (1)
</li>
</ul>
</li>
	<li class="cat-item cat-item-12"><a href="http://comonad.com/reader/category/meta/" title="View all posts filed under Meta">Meta</a> (3)
</li>
	<li class="cat-item cat-item-16"><a href="http://comonad.com/reader/category/monads/" title="View all posts filed under Monads">Monads</a> (27)
</li>
	<li class="cat-item cat-item-31"><a href="http://comonad.com/reader/category/monoids/" title="View all posts filed under Monoids">Monoids</a> (7)
</li>
	<li class="cat-item cat-item-30"><a href="http://comonad.com/reader/category/parsing/" title="View all posts filed under Parsing">Parsing</a> (5)
</li>
	<li class="cat-item cat-item-32"><a href="http://comonad.com/reader/category/scheme/" title="View all posts filed under Scheme">Scheme</a> (1)
</li>
	<li class="cat-item cat-item-24"><a href="http://comonad.com/reader/category/squiggol/" title="View all posts filed under Squiggol">Squiggol</a> (3)
</li>
	<li class="cat-item cat-item-21"><a href="http://comonad.com/reader/category/type-hackery/" title="View all posts filed under Type Hackery">Type Hackery</a> (7)
</li>
	<li class="cat-item cat-item-14"><a href="http://comonad.com/reader/category/type-theory/" title="View all posts filed under Type Theory">Type Theory</a> (5)
</li>
	<li class="cat-item cat-item-1 current-cat"><a href="http://comonad.com/reader/category/uncategorized/" title="View all posts filed under Uncategorized">Uncategorized</a> (13)
</li>
</ul>
-->
<h2>Tag Cloud</h2>

<h2><label for="s">Search</label></h2>
	<ul>
		<li>
			<form id="searchform" method="get" action="http://comonad.com/reader/index.php">
				<div style="text-align:center">
					<p><input type="text" name="s" id="s" size="10" /> <input type="submit" name="submit" value="Search" /></p>
				</div>
			</form>
		</li>
	</ul>
<!--
<h2>Monthly</h2>
	<ul>	<li><a href='http://comonad.com/reader/2013/05/' title='May 2013'>May 2013</a>&nbsp;(1)</li>
	<li><a href='http://comonad.com/reader/2013/04/' title='April 2013'>April 2013</a>&nbsp;(1)</li>
	<li><a href='http://comonad.com/reader/2013/01/' title='January 2013'>January 2013</a>&nbsp;(1)</li>
	<li><a href='http://comonad.com/reader/2012/12/' title='December 2012'>December 2012</a>&nbsp;(2)</li>
	<li><a href='http://comonad.com/reader/2012/09/' title='September 2012'>September 2012</a>&nbsp;(1)</li>
	<li><a href='http://comonad.com/reader/2012/08/' title='August 2012'>August 2012</a>&nbsp;(1)</li>
	<li><a href='http://comonad.com/reader/2012/06/' title='June 2012'>June 2012</a>&nbsp;(2)</li>
	<li><a href='http://comonad.com/reader/2012/05/' title='May 2012'>May 2012</a>&nbsp;(1)</li>
	<li><a href='http://comonad.com/reader/2012/04/' title='April 2012'>April 2012</a>&nbsp;(1)</li>
	<li><a href='http://comonad.com/reader/2011/12/' title='December 2011'>December 2011</a>&nbsp;(1)</li>
	<li><a href='http://comonad.com/reader/2011/11/' title='November 2011'>November 2011</a>&nbsp;(2)</li>
	<li><a href='http://comonad.com/reader/2011/10/' title='October 2011'>October 2011</a>&nbsp;(2)</li>
	<li><a href='http://comonad.com/reader/2011/09/' title='September 2011'>September 2011</a>&nbsp;(2)</li>
	<li><a href='http://comonad.com/reader/2011/07/' title='July 2011'>July 2011</a>&nbsp;(1)</li>
	<li><a href='http://comonad.com/reader/2011/06/' title='June 2011'>June 2011</a>&nbsp;(7)</li>
	<li><a href='http://comonad.com/reader/2010/07/' title='July 2010'>July 2010</a>&nbsp;(1)</li>
	<li><a href='http://comonad.com/reader/2010/05/' title='May 2010'>May 2010</a>&nbsp;(4)</li>
	<li><a href='http://comonad.com/reader/2010/04/' title='April 2010'>April 2010</a>&nbsp;(1)</li>
	<li><a href='http://comonad.com/reader/2009/09/' title='September 2009'>September 2009</a>&nbsp;(2)</li>
	<li><a href='http://comonad.com/reader/2009/08/' title='August 2009'>August 2009</a>&nbsp;(3)</li>
	<li><a href='http://comonad.com/reader/2009/07/' title='July 2009'>July 2009</a>&nbsp;(1)</li>
	<li><a href='http://comonad.com/reader/2009/06/' title='June 2009'>June 2009</a>&nbsp;(1)</li>
	<li><a href='http://comonad.com/reader/2009/03/' title='March 2009'>March 2009</a>&nbsp;(1)</li>
	<li><a href='http://comonad.com/reader/2008/12/' title='December 2008'>December 2008</a>&nbsp;(1)</li>
	<li><a href='http://comonad.com/reader/2008/11/' title='November 2008'>November 2008</a>&nbsp;(1)</li>
	<li><a href='http://comonad.com/reader/2008/06/' title='June 2008'>June 2008</a>&nbsp;(3)</li>
	<li><a href='http://comonad.com/reader/2008/05/' title='May 2008'>May 2008</a>&nbsp;(10)</li>
	<li><a href='http://comonad.com/reader/2008/04/' title='April 2008'>April 2008</a>&nbsp;(7)</li>
	<li><a href='http://comonad.com/reader/2008/03/' title='March 2008'>March 2008</a>&nbsp;(2)</li>
	<li><a href='http://comonad.com/reader/2008/01/' title='January 2008'>January 2008</a>&nbsp;(1)</li>
	<li><a href='http://comonad.com/reader/2007/07/' title='July 2007'>July 2007</a>&nbsp;(2)</li>
	<li><a href='http://comonad.com/reader/2007/05/' title='May 2007'>May 2007</a>&nbsp;(1)</li>
	<li><a href='http://comonad.com/reader/2006/11/' title='November 2006'>November 2006</a>&nbsp;(3)</li>
	<li><a href='http://comonad.com/reader/2006/10/' title='October 2006'>October 2006</a>&nbsp;(2)</li>
</ul>
-->
		
<h2>Ads</h2><ul><li><div class="ads" align="center">
<script type="text/javascript"><!--
google_ad_client = "pub-9028661600722510";
google_ad_width = 160;
google_ad_height = 600;
google_ad_format = "160x600_as";
google_ad_type = "text_image";
//2006-10-18: Comonad.Reader
google_ad_channel = "6386706477";
google_color_border = "F3F6ED";
google_color_bg = "F3F6ED";
google_color_link = "0E2F0E"; // #0e3f0e 007733
google_color_text = "000000";
google_color_url = "007733.html";
//--></script><script type="text/javascript" src="http://pagead2.googlesyndication.com/pagead/show_ads.js"></script></div>
</li></ul>
<h2>RSS Feeds</h2>
	<ul>
		<li>
			<a title="RSS2 Feed for Posts" href="../../feed/index.html">Posts</a> | <a title="RSS2 Feed for Comments" href="../../comments/feed/index.html">Comments</a></li>	
	</ul>	
	</div>
<p id="footer">Design based on <a href="http://www.vanillamist.com/" title="Vanilla Mist">www.vanillamist.com</a></p></div>
</div>
</body>

<!-- Mirrored from comonad.com/reader/category/uncategorized/ by HTTrack Website Copier/3.x [XR&CO'2013], Tue, 20 Aug 2013 22:06:27 GMT -->
</html>
