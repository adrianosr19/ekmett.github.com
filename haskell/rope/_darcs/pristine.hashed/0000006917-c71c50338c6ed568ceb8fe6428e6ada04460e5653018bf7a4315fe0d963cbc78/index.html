module Data.Rope.Annotated.Internal 
    ( A(A,rope)
    , Ann
    , Annotation(..)
    , (:~>)
    , (:*:)(..)

    , null      -- :: A s a -> Bool
    , rope      -- :: A s a -> Rope
    , head      -- :: Unpackable t => A s a -> t
    , last      -- :: Unpackable t => A s a -> t

    , empty     -- :: (Annotation f) => Ann Empty f 
    , append    -- :: (Annotation f, Append a b c) => Ann a f -> Ann b f -> Ann c f

    , splitAt   -- :: (Annotation f) => Int -> Ann a f -> (forall n. Ann (Take n a) f -> Ann (Drop n a) f -> r) -> r
    , drop      -- :: (Annotation f) => Int -> Ann a f -> (forall n. Ann (Drop n a) f -> r) -> r
    , take      -- :: (Annotation f) => Int -> Ann a f -> (forall n. Ann (Take n a) f -> r) -> r

    , unit      -- :: (Annotation f, Reducer t Rope) => t -> Ann a f
    , snoc      -- :: (Annotation f, Reducer t Rope) => t -> Ann a f -> (forall c. Ann (Snoc c t a) f -> r) -> r
    , cons      -- :: (Annotation f, Reducer t Rope) => Ann a f -> t -> (forall c. Ann (Cons c t a) f -> r) -> r

    , uncons    -- :: (Annotation f, Unpackable t, Uncons t a b) => Ann a f -> Maybe (t, Ann b f)
    , unsnoc    -- :: (Annotation f, Unpackable t, Unsnoc t a b) => Ann a f -> Maybe (t, Ann b f)

    , break     -- :: (Annotation f, Breakable t) => (t -> Bool) -> Ann a f -> (forall n. Ann (Take n a) f -> Ann (Drop n a) f -> r) -> r
    , span      -- :: (Annotation f, Breakable t) => (t -> Bool) -> Ann a f -> (forall n. Ann (Take n a) f -> Ann (Drop n a) f -> r) -> r
    , takeWhile -- :: (Annotation f, Breakable t) => (t -> Bool) -> Ann a f -> (forall n. Ann (Take n a) f -> r) -> r
    , dropWhile -- :: (Annotation f, Breakable t) => (t -> Bool) -> Ann a f -> (forall n. Ann (Drop n a) f -> r) -> r

    -- * Type-level constructors
    , Drop, Take, Snoc, Cons, Tail, Init, Empty
    -- * Type-level programming classes
    , Append, Unsnoc, Uncons

    ) where

import Data.Rope.Util.Comonad

import Data.Foldable (Foldable)
import qualified Data.Foldable)
import Data.Traversable (Traversable(traverse))
import qualified Data.Rope.Internal as Rope
import Data.Rope.Internal (Rope(..))

type f :~> g = forall a. f a -> g a

data A s a = A { rope :: !Rope, extractA :: a }

null :: A s a -> Bool
null = Rope.null . rope

head :: Unpackable t => A s a -> t
head = Rope.head . rope

last :: Unpackable t => A s a -> t
last = Rope.last . rope

type Ann a f = A a (f a)

instance Functor (A a) where
    fmap f (A s a) = A s (f a) 

instance Comonad (A a) where
    extract (A _ a) = a
    extend f a@(A s _) = A s (f a)
    duplicate a@(A s _) = A s a

instance Foldable (A a) where
    foldr f z (A _ a) = f a z
    foldr1 _ (A _ a) = a
    foldl f z (A _ a) = f z a
    foldl1 _ (A _ a) = a
    foldMap f (A _ a) = f a

instance Traversable Rope where
    traverse f (A s a) = A s <$> f a

class Annotation f where
    unitA    :: Rope -> f a
    splitAtA :: Int -> Rope -> f a -> (f b, f c)
    takeA    :: Int -> Rope -> f a -> f b
    dropA    :: Int -> Rope -> f a -> f b
    snocA    :: Rope -> Int -> f a -> f b
    consA    :: Int -> Rope -> f a -> f b
    emptyA   :: f Empty
    appendA  :: Append a b c => Ann a f -> Ann b f -> f c

    takeA n r = fst . splitAtA n r
    dropA n r = snd . splitAtA n r

empty :: Annotation f => Ann Empty f
empty = A Rope.empty emptyA


unit :: (Reducer t Rope, Annotation f) => t -> Ann a f
unit t = A rope (unitA rope)
    where 
        rope :: Rope
        rope = unit t

splitAt :: Annotation f => Int -> Ann a f -> (forall n. Ann (Take n a)  f -> Ann (Drop n a) f -> r) -> r
splitAt n (A r a) k = k (A r b) (A r c)
    let (b, c) = splitAtA n r a

drop :: Annotation f => Int -> Ann a f -> (forall n. Ann (Drop n a) f -> r) -> r
drop n (A r a) k = k (A r (dropA n r a))

take :: Annotation f => Int -> Ann a f -> (forall n. Ann (Take n a) f -> r) -> r
take n (A r a) k = k (A r (takeA n r a))

snoc :: (Annotation f, Reducer t Rope) => t -> Ann a f -> (forall c. Ann (Snoc c t a) f -> r) -> r
snoc (A r a) t k = k (A r' (snocA r' (measure r' - measure r)))
    where r' = snocA r t 

cons :: (Annotation f, Reducer t Rope) => Ann a f -> t -> (forall c. Ann (Cons c t a) f -> r) -> r
cons t (A r a) k = k (A r' (cons (measure r' - measure r) r'))
    where r' = consA t r

append :: (Annotation f, Append a b c) => Ann a f -> Ann b f -> Ann c f
append (A r a) (A s b) = A (r `mappend` s) (a `appendA` b)

break     :: (Annotation f, Breakable t) => (t -> Bool) -> Ann a f -> (forall n. Ann (Take n a) f -> Ann (Drop n a) f -> r) -> r
break p (A r a) k = k (A x b) (A x c) where
    (x,y) = Rope.break p r
    (b,c) = splitAtA (measure x) r a

span      :: (Annotation f, Breakable t) => (t -> Bool) -> Ann a f -> (forall n. Ann (Take n a) f -> Ann (Drop n a) f -> r) -> r
span p (A r a) k = k (A x b) (A x c) where
    (x,y) = Rope.span p r
    (b,c) = splitAtA (measure x) r a

takeWhile :: (Annotation f, Breakable t) => (t -> Bool) -> Ann a f -> (forall n. Ann (Take n a) f -> r) -> r
takeWhile p (A r a) k = k (A x b) where
    x = Rope.takeWhile p r
    b = take (measure x) r a

dropWhile :: (Annotation f, Breakable t) => (t -> Bool) -> Ann a f -> (forall n. Ann (Drop n a) f -> r) -> r
dropWhile p (A r a) k = k (A y c) where
    y = Rope.dropWhile p r
    c = drop (measure r - measure y) r a

-- functor product

infixr 5 :*:

data (f :*: g) a = f a :*: g a

fstF :: (f :*: g) :~> f
fstF ~(f :*: _) = f

sndF :: (f :*: g) :~> g
sndF ~(_ :*: g) = g

instance (Functor f, Functor g)  => Functor (f :*: g) where
    fmap f (a :*: b) = fmap f a :*: fmap f b

instance (Foldable f, Foldable g) => Foldable (f :*: g) where
    foldMap = foldMapDefault
    
instance (Traversable f, Traversable g) => Traversable (f :*: g) where
    traverse f (a :*: b) = (:*:) <$> traverse f a <*> traverse f b

instance (Annotation f, Annotation g) => Annotation (f :*: g) where
    unitA r = unitA r :*: unitA r
    emptyA = emptyA :*: emptyA
    dropA n r (f :*: g) = dropA n r f :*: dropA n r g
    takeA n r (f :*: g) = takeA n r f :*: takeA n r g
    splitAtA n r (f :*: g) = (f' :*: g' , f'' :*: g'') where
        (f',f'') = splitAtA n r f
        (g',g'') = splitAtA n r g
    snocA r n (f :*: g) = snoca r n f :*: snoca r n g
    consA r (f :*: g) n = consa r f n :*: consa r g n
    
data Take n a
data Drop n a
data Empty
data Cons s t a
data Snoc a s t
data (:<>) a b -- Append
data Tail t a
data Init a t

class Append a b c | a b -> c
instance Append Empty a a
instance Append b c d => Append (a :<> b) c (a :<> d)
instance Append a b c => Append (Cons s t a) b (Cons s t c)
instance Append (Take n) (Drop n) n
instance Append a Empty a 
instance Append a b (a :<> b)

class Uncons t a b | t a -> b
instance Uncons t (Cons s t a) a
instance Uncons t a (Tail t a)

class Unsnoc a t b | a t -> b
instance Unsnoc (Snoc a s t) t a
instance Unsnoc a t (Init a t)

unpack :: Unpackable t => A s a -> [t]
unpack (A s _) = unpack s

