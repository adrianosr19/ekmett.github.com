module Data.Rope.Unpackable
    ( Unpackable
    , unpack    -- :: Unpackable a => Rope m -> [a]
    , head      -- :: Unpackable a => Rope m -> a
    , last      -- :: Unpackable a => Rope m -> a
    , uncons    -- :: Unpackable a => Rope m -> Maybe (a, Rope m)
    , unsnoc    -- :: Unpackable a => Rope m -> Maybe (Rope m, a)
    ) where

import Prelude hiding (head, last)

import Data.Word (Word8)

import qualified Data.Foldable as F
import Data.Foldable (Foldable)

import Data.FingerTree (ViewL(..),ViewR(..),viewl,viewr,(<|),(|>))

import qualified Data.ByteString as S
import qualified Data.ByteString.UTF8 as U
import qualified Data.ByteString.Lazy as L
import qualified Data.ByteString.Lazy.UTF8 as LU

import Data.Rope.Body (Chunk(..), cons', snoc', measureBody) -- Chunk
import Data.Rope.Internal (Elidable, splitAt', drop', take', Rope(..), body, drop', take', toLazyByteString, uncons8, unsnoc8) -- Rope, etc.
import Codec.Binary.UTF8.Generic (decode)

class Unpackable a where
    unpack :: Rope m -> [a]

    head :: Rope m -> a
    last :: Rope m -> a

    uncons :: Elidable m => Rope m -> Maybe (a, Rope m)
    unsnoc :: Elidable m => Rope m -> Maybe (Rope m, a)


instance Unpackable Word8 where
    unpack = concatMap (S.unpack . unchunk) . F.toList . body
    head (Rope t _) = case viewl t of
        Chunk a :< _ -> S.head a
    last (Rope t _) = case viewr t of
        _ :> Chunk a -> S.last a
    uncons = uncons8
    unsnoc = unsnoc8

instance Unpackable Char where
    unpack = LU.toString . toLazyByteString
    head (Rope t _) = head . unpack
    last (Rope t _) = head . unpack
    uncons = decode
    unsnoc = undefined -- TODO

instance Unpackable S.ByteString where
    unpack = map unchunk . F.toList . body
    head (Rope t _) = case viewl t of
        Chunk a :< _ -> a
        _ -> errorEmptyList "head"
    last (Rope t _) = case viewr t of
        _ :> Chunk a -> a
        _ -> errorEmptyList "last" 
    uncons r@(Rope t m) = case viewl t of
        a :< as -> Just (a, Rope as (drop' (S.length a) r))
        EmptyL -> Nothing
    unsnoc r@(Rope t m) = case viewr t of
        as :> a -> Just (Rope as (take' (measureBody as) r), a)
        EmptyR -> Nothing

instance Unpackable Chunk where
    unpack = F.toList . body
    head (Rope xs _) = case viewl xs of
        a :< _ -> a
        _ -> errorEmptyList "head"
    last (Rope xs _) = case viewr xs of
        _ :> a -> a
        _ -> errorEmptyList "last"
    uncons r@(Rope xs m) = case viewl xs of
        a :< as -> Just (a, Rope as (drop' (S.length a) r))
        EmptyL -> Nothing
    unsnoc r@(Rope xs m) = case viewr xs of
        as :> a -> Just (Rope as (take' (measureBody as) r), a)
        EmptyR -> Nothing

errorEmptyList :: String -> a
errorEmptyList t = error "Kata.Rope.Unpackable." ++ t ++ ": empty list"  
