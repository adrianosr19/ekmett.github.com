[Added parameterized monads
ekmett@gmail.com**20080504075235
 
] {
adddir ./src/Control/Comonad/Parameterized
adddir ./src/Control/Monad/Parameterized
hunk ./category-extras.cabal 3
-version:		0.4
+version:		0.41
hunk ./category-extras.cabal 14
-description: 		A collection of modules implementing various ideas from
-			category theory. Notable bits include: comonads, adjunctions,
-			functor fixedpoints and various recursion operaters ala
-			/Functional Programming with Bananas, Lenses, Envelopes
-			and Barbed Wire/. 
+			Copyright (C) 2007 Iavor Diatchki
+description: 		A vastly expanded collection of modules implementing various 
+			ideas from category theory. Notable bits include: comonads, 
+			adjunctions, functor fixedpoints and various recursion 
+			operaters ala /Functional Programming with Bananas, Lenses, 
+			Envelopes and Barbed Wire/. 
hunk ./category-extras.cabal 40
+	Control.Bifunctor.Fix,
hunk ./category-extras.cabal 53
+	Control.Comonad.Parameterized,
+	Control.Comonad.Parameterized.Class,
hunk ./category-extras.cabal 58
+	Control.Comonad.Supply
hunk ./category-extras.cabal 79
+	Control.Monad.Parameterized,
+	Control.Monad.Parameterized.Class,
hunk ./src/Control/Bifunctor/Fix.hs 16
-newtype MuB s a = InB { outB :: s a (MuB s a) }
-type NuB s a = MuB s a 
+newtype FixB s a = InB { outB :: s a (FixB s a) }
hunk ./src/Control/Bifunctor/Fix.hs 18
-instance Bifunctor s => Functor (MuB s) where
+instance Bifunctor s => Functor (FixB s) where
hunk ./src/Control/Bifunctor/Fix.hs 21
-
addfile ./src/Control/Bifunctor/HigherOrder.hs
hunk ./src/Control/Bifunctor/HigherOrder.hs 1
+-----------------------------------------------------------------------------
+-- |
+-- Module      :  Control.Bifunctor.HigherOrder
+-- Copyright   :  (C) 2008 Edward Kmett
+-- License     :  BSD-style (see the file LICENSE)
+--
+-- Maintainer  :  Edward Kmett <ekmett@gmail.com>
+-- Stability   :  experimental
+-- Portability :  non-portable (rank-2 polymorphism)
+--
+----------------------------------------------------------------------------
+module Control.Bifunctor.HigherOrder where
+
+import Control.Bifunctor
+import Control.Functor.Extras
+
+{-
+type BiNatural p q = forall a b. p a b -> q a b
+
+class HBifunctor p where
+        fbimap :: Bifunctor q => (a -> b) -> (c -> d) -> p q a c -> p q b d
+	hbimap :: BiNatural g h -> BiNatural (p g) (p h)
+
+newtype MuHB p a b = InHB { outHB :: p (MuHB p) a b }
+type NuHB p a b = MuHB p a b
+-}
addfile ./src/Control/Comonad/Parameterized.hs
hunk ./src/Control/Comonad/Parameterized.hs 1
+{-# OPTIONS -fglasgow-exts #-}
+-----------------------------------------------------------------------------
+-- |
+-- Module      :  Control.Comonad.Parameterized
+-- Copyright   :  (C) 2008 Edward Kmett
+-- License     :  BSD-style (see the file LICENSE)
+--
+-- Maintainer  :  Edward Kmett <ekmett@gmail.com>
+-- Stability   :  experimental
+-- Portability :  portable
+--
+----------------------------------------------------------------------------
+module Control.Comonad.Parameterized where
+
+import Control.Bifunctor
+import Control.Bifunctor.Fix
+import Control.Comonad
+import Control.Comonad.Parameterized.Class
+import Control.Morphism.Ana
+
+-- this does not seem to be nicely quantifiable
+copaugment :: PComonad f => ((FixB f a -> f b (FixB f a)) -> FixB f b) -> (FixB f a -> b) -> FixB f b
+copaugment g k = g (pextend (k . InB) . outB)
+
+instance PComonad f => Comonad (FixB f) where
+        extract = pextract . outB
+        extend k w = copaugment (flip biana w) k
addfile ./src/Control/Comonad/Parameterized/Class.hs
hunk ./src/Control/Comonad/Parameterized/Class.hs 1
+{-# OPTIONS -fglasgow-exts #-}
+-----------------------------------------------------------------------------
+-- |
+-- Module      :  Control.Comonad.Parameterized.Class
+-- Copyright   :  (C) 2008 Edward Kmett
+-- License     :  BSD-style (see the file LICENSE)
+--
+-- Maintainer  :  Edward Kmett <ekmett@gmail.com>
+-- Stability   :  experimental
+-- Portability :  portable
+--
+----------------------------------------------------------------------------
+module Control.Comonad.Parameterized.Class where
+
+import Control.Arrow ((|||), (+++))
+import Control.Monad
+import Control.Bifunctor
+
+class Bifunctor f => PComonad f where
+	pextract :: f a c -> a
+	pextend :: (f b c -> a) -> f b c -> f a c
+
+{- Parameterized comonad laws:
+
+> pextend pextract = id
+> pextract . pextend g = g
+> pextend (g . pextend j) = pextend g . pextend j
+> pextract . second g = pextract 
+> second g . pextend (j . second g) = pextend j . second g 
+
+-}
+
+#ifndef __HADDOCK__
+{-# RULES
+"pextend pextract" 		pextend pextract = id
+"pextract . pextend g" 		forall g. pextract . pextend g = g
+"pextract . bimap id g" 	forall g. pextract . bimap id g = pextract
+"bimap _ _ . pextract" 		forall j g. bimap id g . pextend (j . bimap id g) = pextend j . bimap id g
+ #-}
+#endif
addfile ./src/Control/Comonad/Supply.hs
hunk ./src/Control/Comonad/Supply.hs 1
+--------------------------------------------------------------------
+-- |
+-- Module    : Control.Comonad.Supply
+-- Copyright : (c) Edward Kmett 2008
+--             (c) Iavor S. Diatchki, 2007
+-- License   : BSD3
+--
+-- Maintainer: Edward Kmett <ekmett@gmail.com>
+-- Stability : provisional
+-- Portability: portable
+--
+-- The technique for generating new values is based on the paper
+-- ''On Generating Unique Names''
+-- by Lennart Augustsson, Mikael Rittri, and Dan Synek.
+-- 
+-- Integrated from value-supply-0.1
+--
+-- TODO: a SupplyT Comonad Transformer
+--------------------------------------------------------------------
+
+module Control.Comonad.Supply
+  (
+
+  -- * Creating supplies
+  Supply
+  , newSupply
+  , newEnumSupply
+  , newNumSupply
+
+  -- * Obtaining values from supplies
+  , supplyValue
+
+  -- * Generating new supplies from old
+  , supplyLeft
+  , supplyRight
+  , modifySupply
+  , split
+  , split2
+  , split3
+  , split4
+  ) where
+
+import Control.Comonad
+-- Using 'MVar's might be a bit heavy but it ensures that
+-- multiple threads that share a supply will get distinct names.
+import Control.Concurrent.MVar
+import Control.Functor.Extras
+import System.IO.Unsafe(unsafePerformIO)
+
+-- Basics ----------------------------------------------------------------------
+
+-- | A type that can be used to generate values on demand.
+-- A supply may be turned into two different supplies by using
+-- the functions 'supplyLeft' and 'supplyRight'.
+data Supply a = Node
+  { -- | Get the value of a supply.  This function, together with
+    -- 'modifySupply' forms a comonad on 'Supply'.
+    supplyValue :: a
+
+  -- | Generate a new supply.  This supply is different from the one
+  -- generated with 'supplyRight'.
+  , supplyLeft  :: Supply a
+
+  -- | Generate a new supply. This supply is different from the one
+  -- generated with 'supplyLeft'.
+  , supplyRight :: Supply a
+  }
+
+instance Functor Supply where
+  fmap f s = modifySupply s (f . supplyValue)
+
+-- | Creates a new supply of values.
+-- The arguments specify how to generate values:
+-- the first argument is an initial value, the
+-- second specifies how to generate a new value from an existing one.
+newSupply    :: a -> (a -> a) -> IO (Supply a)
+newSupply x f = fmap (gen True) (newMVar (iterate f x))
+
+  -- The extra argument to ``gen'' is passed because without
+  -- it Hugs spots that the recursive calls are the same but does
+  -- not know that unsafePerformIO is unsafe.
+  where gen _ r = Node { supplyValue  = unsafePerformIO (genSym r),
+                         supplyLeft   = gen False r,
+                         supplyRight  = gen True r }
+
+        genSym       :: MVar [a] -> IO a
+        genSym r      = do a : as <- takeMVar r
+                           putMVar r as
+                           return a
+
+-- | Generate a new supply by systematically applying a function
+-- to an existing supply.  This function, together with 'supplyValue'
+-- form a comonad on 'Supply'.
+modifySupply :: Supply a -> (Supply a -> b) -> Supply b
+modifySupply = flip extend
+
+-- (Supply, supplyValue, modifySupply) form a comonad:
+{-
+law1 s      = [ modifySupply s supplyValue, s ]
+law2 s f    = [ supplyValue (modifySupply s f), f s ]
+law3 s f g  = [ (s `modifySupply` f) `modifySupply` g
+              ,  s `modifySupply` \s1 -> g (s1 `modifySupply` f)
+              ]
+-}
+
+
+-- Derived functions -----------------------------------------------------------
+
+-- | A supply of values that are in the 'Enum' class.
+-- The initial value is @toEnum 0@, new values are generates with 'succ'.
+newEnumSupply  :: (Enum a) => IO (Supply a)
+newEnumSupply   = newSupply (toEnum 0) succ
+
+-- | A supply of values that are in the 'Num' class.
+-- The initial value is 0, new values are generated by adding 1.
+newNumSupply   :: (Num a) => IO (Supply a)
+newNumSupply    = newSupply 0 (1+)
+
+-- | Generate an infinite list of supplies by using 'supplyLeft' and
+-- 'supplyRight' repeatedly.
+split          :: Supply a -> [Supply a]
+split s         = supplyLeft s : split (supplyRight s)
+
+-- | Split a supply into two different supplies.
+-- The resulting supplies are different from the input supply.
+split2         :: Supply a -> (Supply a, Supply a)
+split2 s        = (supplyLeft s, supplyRight s)
+
+-- | Split a supply into three different supplies.
+split3         :: Supply a -> (Supply a, Supply a, Supply a)
+split3 s        = let s1 : s2 : s3 : _ = split s
+                  in (s1,s2,s3)
+
+-- | Split a supply into four different supplies.
+split4         :: Supply a -> (Supply a, Supply a, Supply a, Supply a)
+split4 s        = let s1 : s2 : s3 : s4 : _ = split s
+                  in (s1,s2,s3,s4)
+
+instance Comonad Supply where
+    extract = supplyValue
+    extend f s = Node { supplyValue = f s
+                      , supplyLeft  = modifySupply (supplyLeft s) f
+                      , supplyRight = modifySupply (supplyRight s) f
+                      }
+
+instance FunctorSplit Supply where
+    fsplit = split2
hunk ./src/Control/Functor/Extras.hs 33
+
+
+class FunctorZero f where
+	fzero :: f a
+
+-- monoid
+class FunctorZero f => FunctorPlus f where
+	fplus :: f a -> f a -> f a
+
+class FunctorSplit f where
+	fsplit :: f a -> (f a, f a)
+	
+
hunk ./src/Control/Functor/Fix.hs 18
-newtype Mu f = InF { outF :: f (Mu f) }
-type Nu f = Mu f
+newtype Fix f = InF { outF :: f (Fix f) }
hunk ./src/Control/Functor/Fix.hs 20
-outM :: (Functor f, Monad m) => CoAlgM f m (Nu f)
+outM :: (Functor f, Monad m) => CoAlgM f m (Fix f)
hunk ./src/Control/Functor/Fix.hs 23
-inW :: (Functor f, Comonad w) => AlgW f w (Mu f)
+inW :: (Functor f, Comonad w) => AlgW f w (Fix f)
hunk ./src/Control/Functor/HigherOrder.hs 25
-newtype MuH f a = InH { outH :: f (MuH f) a }
-type NuH f a = MuH f a
+newtype FixH f a = InH { outH :: f (FixH f) a }
addfile ./src/Control/Functor/KanExtension.hs
hunk ./src/Control/Functor/KanExtension.hs 1
+-----------------------------------------------------------------------------
+-- |
+-- Module      :  Control.Functor.KanExtension
+-- Copyright   :  (C) 2008 Edward Kmett
+-- License     :  BSD-style (see the file LICENSE)
+--
+-- Maintainer  :  Edward Kmett <ekmett@gmail.com>
+-- Stability   :  experimental
+-- Portability :  non-portable (rank-2 polymorphism)
+--
+----------------------------------------------------------------------------
+module Control.Functor.KanExtension where
+
+import Control.Functor.Composition.Class
+import Control.Functor.Extras
+
+-- Right Kan Extension
+newtype Ran g h a = Ran { runRan :: forall b. (a -> g b) -> h b }
+
+toRan :: (Composition c, Functor k) => Natural (c k g) h -> Natural k (Ran g h)
+toRan s t = Ran (s . compose . flip fmap t)
+
+fromRan :: Composition c => Natural k (Ran g h) -> Natural (c k g) h
+fromRan s = flip runRan id . s . decompose
+
+-- Left Kan Extension
+data Lan g h a = forall b. Lan (g b -> a) (h b)
+
+toLan :: (Composition c, Functor f) => Natural h (c f g) -> Natural (Lan g h) f
+toLan s (Lan f v) = fmap f . decompose $ s v
+
+fromLan :: Composition c => Natural (Lan g h) f -> Natural h (c f g)
+fromLan s t = compose . s $ Lan id t
hunk ./src/Control/Monad/HigherOrder.hs 20
+	--hbind k = hjoin . hfmap k
+
+hjoin :: (HMonad m, Functor (m g), Functor g) => Natural (m (m g)) (m g)
+hjoin = hbind id
+
+(>>**=) :: (HMonad m, Functor f, Functor g) => m f a -> Natural f (m g) -> m g a
+m >>**= k = hbind k m 
addfile ./src/Control/Monad/Parameterized.hs
hunk ./src/Control/Monad/Parameterized.hs 1
+{-# OPTIONS -fglasgow-exts #-}
+-----------------------------------------------------------------------------
+-- |
+-- Module      :  Control.Monad.Paramterized
+-- Copyright   :  (C) 2008 Edward Kmett
+-- License     :  BSD-style (see the file LICENSE)
+--
+-- Maintainer  :  Edward Kmett <ekmett@gmail.com>
+-- Stability   :  experimental
+-- Portability :  portable
+--
+----------------------------------------------------------------------------
+module Control.Monad.Parameterized where
+
+import Control.Arrow ((|||), (+++))
+import Control.Monad
+import Control.Bifunctor
+import Control.Bifunctor.Fix
+import Control.Monad.Parameterized.Class
+import Control.Morphism.Cata
+
+paugment :: PMonad f => (forall c. (f a c -> c) -> c) -> (a -> FixB f b) -> FixB f b
+paugment g k = g (InB . pbind (outB . k))
+
+instance PMonad f => Monad (FixB f) where
+	return = InB . preturn
+	m >>= k = paugment (flip bicata m) k
+
addfile ./src/Control/Monad/Parameterized/Class.hs
hunk ./src/Control/Monad/Parameterized/Class.hs 1
+{-# OPTIONS -fglasgow-exts #-}
+-----------------------------------------------------------------------------
+-- |
+-- Module      :  Control.Monad.Paramterized.Class
+-- Copyright   :  (C) 2008 Edward Kmett
+-- License     :  BSD-style (see the file LICENSE)
+--
+-- Maintainer  :  Edward Kmett <ekmett@gmail.com>
+-- Stability   :  experimental
+-- Portability :  portable
+--
+-- The notation >>*= was selected to indicate the kind of the parameter
+-- in this case a simple type as opposed to >>*->*= for higher order monads.
+----------------------------------------------------------------------------
+module Control.Monad.Parameterized.Class where
+
+import Control.Arrow ((|||), (+++))
+-- import Control.Functor.Exponential
+-- import Control.Functor.Contravariant
+import Control.Monad
+import Control.Bifunctor
+import Control.Bifunctor.Fix
+
+{- | Minimum definition:
+
+1. preturn & pbind
+2. preturn & pjoin
+
+-}
+	
+class Bifunctor f => PMonad f where
+	preturn :: a -> f a c
+	pbind :: (a -> f b c) -> f a c -> f b c
+	pbind f = pjoin . bimap f id
+	pjoin :: f (f a b) b -> f a b
+	pjoin = pbind id
+
+(>>*=) :: PMonad f => f a c -> (a -> f b c) -> f b c
+(>>*=) = flip pbind
+
+(=*<<) :: PMonad f => (a -> f b c) -> f a c -> f b c
+(=*<<) = pbind
+
+-- (>>*) :: PMonad f => f a c -> f b c -> f b c 
+m >>* n = m >>*= const n
+
+-- bimapPMonad :: (PMonad f, Functor (f a)) => (a -> c) -> (b -> d) -> f a b -> f c d 
+-- bimapPMonad f g xs = second g xs >>*= preturn . f
+
+{- Parameterized monad laws (from <http://crab.rutgers.edu/~pjohann/f14-ghani.pdf>)
+> pbind preturn = id
+> pbind g . preturn = g
+> pbind (pbind g . j) = pbind g . pbind j
+> pmap g . preturn = preturn
+> pbind (pmap g . j) . pmap g = pmap g . pbind j 
+-}
+
hunk ./src/Control/Morphism/Ana.hs 19
+import Control.Bifunctor
+import Control.Bifunctor.Fix
hunk ./src/Control/Morphism/Ana.hs 25
--- * Unfold Sugar
-
hunk ./src/Control/Morphism/Ana.hs 26
-ana :: Functor f => CoAlg f a -> a -> Nu f
+ana :: Functor f => CoAlg f a -> a -> Fix f
hunk ./src/Control/Morphism/Ana.hs 31
-g_ana :: (Functor f, Monad m) => Dist m f -> CoAlgM f m a -> a -> Nu f
+g_ana :: (Functor f, Monad m) => Dist m f -> CoAlgM f m a -> a -> Fix f
hunk ./src/Control/Morphism/Ana.hs 39
+biana :: Bifunctor f => CoAlg (f b) a -> a -> FixB f b
+biana g = InB . bimap id (biana g) . g
+
+g_biana :: (Bifunctor f, Monad m) => Dist m (f b) -> CoAlgM (f b) m a -> a -> FixB f b
+g_biana k g = a . return where a = InB . bimap id (a . join) . k . liftM g
+
hunk ./src/Control/Morphism/Ana.hs 46
-anaH :: HFunctor f => CoAlgH f a -> Natural a (NuH f)
-anaH g = InH . hfmap (anaH g) . g
+hana :: HFunctor f => CoAlgH f a -> Natural a (FixH f)
+hana g = InH . hfmap (hana g) . g
hunk ./src/Control/Morphism/Apo.hs 27
-apo :: Functor f => CoAlgM f (Apo f) a -> a -> Nu f
+apo :: Functor f => CoAlgM f (Apo f) a -> a -> Fix f
hunk ./src/Control/Morphism/Apo.hs 30
-g_apo :: Functor f => CoAlg f b -> CoAlgM f (GApo b) a -> a -> Nu f
+g_apo :: Functor f => CoAlg f b -> CoAlgM f (GApo b) a -> a -> Fix f
hunk ./src/Control/Morphism/Apo.hs 33
-type Apo f a 		= Either (Nu f) a
-type ApoT f m a 	= EitherT (Nu f) m a
+type Apo f a 		= Either (Fix f) a
+type ApoT f m a 	= EitherT (Fix f) m a
hunk ./src/Control/Morphism/Cata.hs 25
-cata :: Functor f => Alg f a -> Mu f -> a
+cata :: Functor f => Alg f a -> Fix f -> a
hunk ./src/Control/Morphism/Cata.hs 29
-g_cata :: (Functor f, Comonad w) => Dist f w -> AlgW f w a -> Mu f -> a
+g_cata :: (Functor f, Comonad w) => Dist f w -> AlgW f w a -> Fix f -> a
hunk ./src/Control/Morphism/Cata.hs 36
-cataB :: Bifunctor f => Alg (f b) a -> MuB f b -> a
-cataB f = f . bimap id (cataB f) . outB
+bicata :: Bifunctor f => Alg (f b) a -> FixB f b -> a
+bicata f = f . bimap id (bicata f) . outB
hunk ./src/Control/Morphism/Cata.hs 39
-g_cataB :: (Bifunctor f, Comonad w) => Dist (f b) w -> AlgW (f b) w a -> MuB f b -> a
-g_cataB k g = extract . c where c = liftW g . k . bimap id (duplicate . c) . outB
+g_bicata :: (Bifunctor f, Comonad w) => Dist (f b) w -> AlgW (f b) w a -> FixB f b -> a
+g_bicata k g = extract . c where c = liftW g . k . bimap id (duplicate . c) . outB
hunk ./src/Control/Morphism/Cata.hs 42
-cataH :: HFunctor f => AlgH f a -> Natural (MuH f) a
-cataH f = f . hfmap (cataH f) . outH
+hcata :: HFunctor f => AlgH f a -> Natural (FixH f) a
+hcata f = f . hfmap (hcata f) . outH
hunk ./src/Control/Morphism/Futu.hs 23
-futu :: Functor f => CoAlgM f (Free f) a -> a -> Nu f
+futu :: Functor f => CoAlgM f (Free f) a -> a -> Fix f
hunk ./src/Control/Morphism/Futu.hs 26
-g_futu :: (Functor f, Functor h) => Dist h f -> CoAlgM f (Free h) a -> a -> Nu f
+g_futu :: (Functor f, Functor h) => Dist h f -> CoAlgM f (Free h) a -> a -> Fix f
hunk ./src/Control/Morphism/Histo.hs 23
-histo :: Functor f => AlgW f (Cofree f) a -> Mu f -> a
+histo :: Functor f => AlgW f (Cofree f) a -> Fix f -> a
hunk ./src/Control/Morphism/Histo.hs 26
-g_histo :: (Functor f, Functor h) => Dist f h -> AlgW f (Cofree h) a -> Mu f -> a
+g_histo :: (Functor f, Functor h) => Dist f h -> AlgW f (Cofree h) a -> Fix f -> a
hunk ./src/Control/Morphism/Hylo.hs 35
-hyloB :: (Bifunctor f, Bifunctor g) => Alg (g d) b -> Natural (f c) (g d) -> CoAlg (f c) a -> a -> b
-hyloB f e g = f . e . bimap id (hyloB f e g). g 
+bihylo :: (Bifunctor f, Bifunctor g) => Alg (g d) b -> Natural (f c) (g d) -> CoAlg (f c) a -> a -> b
+bihylo f e g = f . e . bimap id (bihylo f e g). g 
hunk ./src/Control/Morphism/Hylo.hs 38
-g_hyloB :: (Comonad w, Bifunctor f, Monad m) =>
+g_bihylo :: (Comonad w, Bifunctor f, Monad m) =>
hunk ./src/Control/Morphism/Hylo.hs 40
-g_hyloB w m f e g = extract . h . return where h = liftW f . w . e . bimap id (duplicate . h . join) . m . liftM g
+g_bihylo w m f e g = extract . h . return where h = liftW f . w . e . bimap id (duplicate . h . join) . m . liftM g
hunk ./src/Control/Morphism/Hylo.hs 44
-hyloH :: HFunctor f => AlgH f b -> CoAlgH f a -> Natural a b
-hyloH f g = f . hfmap (hyloH f g) . g
+hhylo :: HFunctor f => AlgH f b -> CoAlgH f a -> Natural a b
+hhylo f g = f . hfmap (hhylo f g) . g
hunk ./src/Control/Morphism/Hylo.hs 47
-{-
-hyloHB :: HBifunctor p => (p q c b -> b) -> (a -> p q c a) -> a -> b
-hyloHB f g = f . hbimap id (hyloHB f g) . g
--}
hunk ./src/Control/Morphism/Meta.hs 27
-	  CoAlg f b -> (a -> b) -> Alg g a -> Mu g -> Nu f
+	  CoAlg f b -> (a -> b) -> Alg g a -> Fix g -> Fix f
hunk ./src/Control/Morphism/Meta.hs 31
-	  Dist m f -> Dist g w -> CoAlgM f m b -> (a -> b) -> AlgW g w a -> Mu g -> Nu f
+	  Dist m f -> Dist g w -> CoAlgM f m b -> (a -> b) -> AlgW g w a -> Fix g -> Fix f
hunk ./src/Control/Morphism/Para.hs 26
-para :: Functor f => AlgW f (Para f) a -> Mu f -> a
+para :: Functor f => AlgW f (Para f) a -> Fix f -> a
hunk ./src/Control/Morphism/Para.hs 29
-g_para :: (Functor f, Comonad w) => Dist f w -> AlgW f (ParaT f w) a -> Mu f -> a
+g_para :: (Functor f, Comonad w) => Dist f w -> AlgW f (ParaT f w) a -> Fix f -> a
hunk ./src/Control/Morphism/Para.hs 32
-type Para f a 		= (Mu f, a)
-type ParaT f w a 	= ReaderCT (Mu f) w a
+type Para f a 		= (Fix f, a)
+type ParaT f w a 	= ReaderCT (Fix f) w a
hunk ./src/Control/Morphism/Zygo.hs 27
-zygo :: Functor f => Alg f b -> AlgW f (Zygo b) a -> Mu f -> a
+zygo :: Functor f => Alg f b -> AlgW f (Zygo b) a -> Fix f -> a
hunk ./src/Control/Morphism/Zygo.hs 30
-g_zygo :: (Functor f, Comonad w) => AlgW f w b -> Dist f w -> AlgW f (ReaderCT b w) a -> Mu f -> a
+g_zygo :: (Functor f, Comonad w) => AlgW f w b -> Dist f w -> AlgW f (ReaderCT b w) a -> Fix f -> a
}
