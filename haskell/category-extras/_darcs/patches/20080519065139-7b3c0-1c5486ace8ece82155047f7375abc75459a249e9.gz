[elgot algebras
ekmett@gmail.com**20080519065139] {
adddir ./src/Control/Functor/Algebra
hunk ./CHANGELOG 12
+0.50.3
+------
+* Renamed 'Alg' to 'Algebra', renamed AlgH to HAlgebra, etc. 
+* Added Di- and Bi- algebras
+* Added Janis Voigtlaender's asymptotic free monad improvements and their dual, but noted it just uses the right Kan extension
+  of a monad.
+* Added Elgot (Co)Algebras
+
hunk ./category-extras.cabal 3
-version:                0.50.2
+version:                0.50.3
hunk ./category-extras.cabal 79
+                Control.Functor.Algebra.Elgot,
hunk ./category-extras.cabal 96
-                Control.Functor.Strong,
+                Control.Functor.Limit,
hunk ./category-extras.cabal 100
+                Control.Functor.Strong,
hunk ./category-extras.cabal 132
---              ghc-options: -D__ARROW_SUBCLASSES_CATEGORY__
-		-- if you want docs you have to use the WRONG one to get it to work with haddock!
hunk ./category-extras.cabal 136
-
hunk ./category-extras.cabal 138
+                cpp-options: -D__TYPE_FAMILIES__=1
hunk ./src/Control/Comonad/Cofree.hs 16
+	, CofreeLike(unwrap)
+	, Expensive(..)
+	, coimprove, worsten
hunk ./src/Control/Comonad/Cofree.hs 22
+import Control.Comonad
hunk ./src/Control/Comonad/Cofree.hs 25
+import Control.Functor.KanExtension
hunk ./src/Control/Comonad/Cofree.hs 42
+class (Functor f, Comonad w) => CofreeLike f w | w -> f where
+        unwrap :: w a -> f (w a)
+
+instance Functor f => CofreeLike f (Cofree f) where
+        unwrap = outCofree 
+
+instance CofreeLike f w => CofreeLike f (Lan w w) where
+        unwrap (Lan f c) = fmap (Lan f) (unwrap c)
+
+data Expensive f a = forall w. CofreeLike f w => Expensive { runExpensive :: w a }
+
+coimprove :: Functor f => Cofree f a -> Expensive f a
+coimprove m = Expensive (coabs m)
+
+worsten :: Functor f => (forall w. CofreeLike f w => w a) -> Cofree f a
+worsten m = corep m 
addfile ./src/Control/Comonad/Memo.hs
hunk ./src/Control/Comonad/Memo.hs 1
+--------------------------------------------------------------------
+-- |
+-- Module    : Control.Comonad.Memo
+-- Copyright : (c) Edward Kmett 2008
+-- License   : BSD3
+--
+-- Maintainer: Edward Kmett <ekmett@gmail.com>
+-- Stability : provisional
+-- Portability: portable
+--
+--------------------------------------------------------------------
+
+module Control.Comonad.Memo (newMemo, Memo, pureMemo) where
+
+import Control.Comonad
+import Data.Map
+import Control.Concurrent.MVar
+import System.IO.Unsafe(unsafePerformIO)
+
+-- TODO: rewrite with a memoizing context comonad
+newtype Memo k v = Memo (MVar (Map k v)) (k -> v) k
+
+newMemo :: Ord k => (k -> v) -> k -> IO (Memo k v)
+newMemo f k = fmap (gen f) (newMVar Map.empty)
+  where gen _ r = Memo (unsafePerformIO . update f r) ()
+        update :: MVar (Data.Map k v) -> IO v
+        update f r k = do 
+		m <- takeMVar r
+		let v = f k
+                putMVar r (Map.insert k v m)
+                return v
+
+pureMemo :: (k -> v) -> Memo k v ()
+pureMemo f = Memo f ()
+
+instance Functor (Memo k v) where
+	fmap f (g,a) = (g, f a)
+
+-- TODO: map this over the memo-table!
+instance Bifunctor (Memo k) where
+	bimap f g (Memo h a)) = Memo (f . h) (g a)
+
+instance Ord k => Copointed  (Memo k v) where
+	extract (Memo _ a) = a
+	
+instance Ord k => Comonad (Memo k v) where
+	duplicate (Memo f a) = Memo f (Memo f a)
+
hunk ./src/Control/Functor/Algebra.hs 11
+-- Algebras, Coalgebras, Bialgebras, and Dialgebras and their (co)monadic
+-- variants
hunk ./src/Control/Functor/Algebra.hs 14
-module Control.Functor.Algebra where
+module Control.Functor.Algebra 
+	( Dialgebra, GDialgebra
+	, Bialgebra, GBialgebra
+	, Algebra, GAlgebra
+	, Coalgebra, GCoalgebra
+	, liftAlgebra
+	, liftCoalgebra
+	, liftDialgebra
+	, fromCoalgebra
+	, fromAlgebra
+	, fromBialgebra
+	) where
hunk ./src/Control/Functor/Algebra.hs 28
+import Control.Monad.Identity
+import Control.Functor
+import Control.Functor.Extras
+import Control.Functor.Combinators.Lift
hunk ./src/Control/Functor/Algebra.hs 33
-type Alg f a = f a -> a
-type CoAlg f a = a -> f a
-type AlgW f w a = f (w a) -> a
-type CoAlgM f m a = a -> f (m a)
+-- | F,G-dialgebras generalize algebras and coalgebraas
+type Dialgebra f g a = f a -> g a
hunk ./src/Control/Functor/Algebra.hs 36
-liftAlg :: (Functor f, Comonad w) => Alg f a -> AlgW f w a
-liftAlg f = f . fmap extract
+type GDialgebra f g w m a = f (w a) -> g (m a)
hunk ./src/Control/Functor/Algebra.hs 38
-liftCoAlg :: (Functor f, Monad m) => CoAlg f a -> CoAlgM f m a
-liftCoAlg f = fmap return . f
+-- | F-G-bialgebras are representable by @DiAlg (f :+: Identity) (Identity :+: g) a@
+-- and so add no expressive power, but are a lot more convenient.
+type Bialgebra f g a = (Algebra f a, Coalgebra g a)
+type GBialgebra f g w m a = (GAlgebra f w a, GCoalgebra g m a)
hunk ./src/Control/Functor/Algebra.hs 43
+-- | F-Algebras
+type Algebra f a = f a -> a
+
+-- | F-Coalgebras
+type Coalgebra f a = a -> f a
+
+-- | F-W-Comonadic Algebras for a given comonad W
+type GAlgebra f w a = f (w a) -> a
+
+-- | F-M-Monadic Coalgebras for a given monad M
+type GCoalgebra f m a = a -> f (m a)
+
+-- | Turn an F-algebra into a F-W-algebra by throwing away the comonad
+liftAlgebra :: (Functor f, Comonad w) => Algebra f :~> GAlgebra f w 
+liftAlgebra phi = phi . fmap extract
+
+-- | Turn a F-coalgebra into a F-M-coalgebra by returning into a monad
+liftCoalgebra :: (Functor f, Monad m) => Coalgebra f :~> GCoalgebra f m
+liftCoalgebra psi = fmap return . psi
+
+liftDialgebra :: (Functor g, Functor f, Comonad w, Monad m) => Dialgebra f g :~> GDialgebra f g w m 
+liftDialgebra phi = fmap return . phi . fmap extract
+
+fromAlgebra :: Algebra f :~> Dialgebra f Identity
+fromAlgebra phi = Identity . phi
+
+fromCoalgebra :: Coalgebra f :~> Dialgebra Identity f
+fromCoalgebra psi = psi . runIdentity
+
+fromBialgebra :: Bialgebra f g :~> Dialgebra (f :*: Identity) (Identity :*: g) 
+fromBialgebra (phi,psi) = Lift . bimap (Identity . phi) (psi . runIdentity) . runLift 
addfile ./src/Control/Functor/Algebra/Elgot.hs
hunk ./src/Control/Functor/Algebra/Elgot.hs 1
+-----------------------------------------------------------------------------
+-- |
+-- Module      :  Control.Functor.Algebra.Elgot
+-- Copyright   :  (C) 2008 Edward Kmett
+-- License     :  BSD-style (see the file LICENSE)
+--
+-- Maintainer  :  Edward Kmett <ekmett@gmail.com>
+-- Stability   :  experimental
+-- Portability :  non-portable (rank-2 polymorphism)
+--
+-- Elgot algebras, and their obvious dual, based on:
+-- <http://www.iti.cs.tu-bs.de/~milius/research/elgot_lmcs.pdf>
+--
+----------------------------------------------------------------------------
+module Control.Functor.Algebra.Elgot
+	( elgot
+	, coelgot
+--	, g_elgot
+	) where
+
+import Control.Arrow ((|||),(&&&),(+++))
+import Control.Functor.Algebra
+import Control.Functor.Extras
+import Control.Comonad
+
+elgot :: Functor f => Algebra f a -> (b -> Either a (f b)) -> b -> a
+elgot a e = h where h = (id ||| a . fmap h) . e 
+
+coelgot :: Functor f => ((a, f b) -> b) -> Coalgebra f a -> a -> b
+coelgot e a = h where h = e . (id &&& fmap h . a)
+
+-- g_elgot :: (Comonad w, Functor f) => Dist f w -> GAlgebra f w a -> (b -> Either a (f b)) -> b -> a
+-- g_elgot k a e = (id ||| extract) . h where 
+--	h :: b -> Either a (w a)
+--	h = (id +++ liftW a . k . fmap (duplicate . h)) . e 
hunk ./src/Control/Functor/Fix.hs 34
-outM :: (Functor f, Monad m) => CoAlgM f m (FixF f)
-outM = liftCoAlg outF
+outM :: (Functor f, Monad m) => GCoalgebra f m (FixF f)
+outM = liftCoalgebra outF
hunk ./src/Control/Functor/Fix.hs 37
-inW :: (Functor f, Comonad w) => AlgW f w (FixF f)
-inW = liftAlg InF
+inW :: (Functor f, Comonad w) => GAlgebra f w (FixF f)
+inW = liftAlgebra InF
hunk ./src/Control/Functor/HigherOrder.hs 19
-	, AlgH
-	, CoAlgH
+	, HAlgebra
+	, HCoalgebra
hunk ./src/Control/Functor/HigherOrder.hs 28
-type AlgH f g = f g :~> g
-type CoAlgH f g = g :~> f g
+type HAlgebra f g = f g :~> g
+type HCoalgebra f g = g :~> f g
hunk ./src/Control/Functor/HigherOrder.hs 33
-	hfmap :: g :~> h -> f g :~> f h
+	hfmap :: (g :~> h) -> f g :~> f h
hunk ./src/Control/Functor/KanExtension.hs 13
--- Some reference for the Ran monad/Lan comonad below would be nice, as I 
--- constructed them from first principles, but haven't seen them in 
--- literature.
+-- Included is the 'monad generated by a functor' @Ran f f@
+-- and the comonad cogenerated by a functor @Lan f f@.
hunk ./src/Control/Functor/KanExtension.hs 21
+	, rep, abs
+	, corep, coabs
hunk ./src/Control/Functor/KanExtension.hs 25
+import Prelude hiding (abs)
hunk ./src/Control/Functor/KanExtension.hs 56
+-- | See <http://wwwtcs.inf.tu-dresden.de/%7Evoigt/mpc08.pdf>
+rep :: Monad m => m a -> Ran m m a
+rep m = Ran (m >>=)
+
+abs :: Monad m => Ran m m a -> m a 
+abs a = runRan a return
+
hunk ./src/Control/Functor/KanExtension.hs 77
-	fmap f (Lan g h) = Lan (f . g) h 
+	fmap f (Lan g h) = Lan (f . g) h
hunk ./src/Control/Functor/KanExtension.hs 85
+coabs :: Comonad w => w a -> Lan w w a
+coabs = Lan extract 
+
+corep :: Comonad w => Lan w w a -> w a 
+corep (Lan f c) = extend f c
+
+
addfile ./src/Control/Functor/Limit.hs
hunk ./src/Control/Functor/Limit.hs 1
+-----------------------------------------------------------------------------
+-- |
+-- Module      :  Control.Functor.Limit
+-- Copyright   :  (C) 2008 Edward Kmett
+-- License     :  BSD-style (see the file LICENSE)
+--
+-- Maintainer  :  Edward Kmett <ekmett@gmail.com>
+-- Stability   :  experimental
+-- Portability :  non-portable (rank-2 polymorphism/existentials in Ran/Lan)
+--
+----------------------------------------------------------------------------
+module Control.Functor.Limit
+	( Lim
+	, Colim
+	, module Control.Functor.KanExtension
+	, Void
+	, Const
+	) where
+
+import Prelude hiding (abs)
+import Control.Applicative (Const)
+import Data.Void (Void)
+import Control.Functor.KanExtension
+
+type Lim = Ran (Const Void)
+type Colim = Lan (Const Void)
hunk ./src/Control/Monad/Free.hs 12
+-- See <http://wwwtcs.inf.tu-dresden.de/%7Evoigt/mpc08.pdf> for
+-- the background on rep, abs and improve and their use. NB: the C type
+-- in that paper is just the right Kan extension of a monad 
+-- along itself, also known as the monad generated by a functor:
+-- <http://www.tac.mta.ca/tac/volumes/10/19/10-19.ps>
hunk ./src/Control/Monad/Free.hs 26
+	-- * Improving asymptotic performance with right Kan extensions
+	, FreeLike(wrap)
+	, improve
hunk ./src/Control/Monad/Free.hs 31
-import Prelude hiding ((.),id)
+import Prelude hiding ((.),id,abs)
hunk ./src/Control/Monad/Free.hs 36
+import Control.Functor.KanExtension
hunk ./src/Control/Monad/Free.hs 41
-
-type Free f a = Fix (PFree f) a
+type Free f = Fix (PFree f)
hunk ./src/Control/Monad/Free.hs 55
+class (Functor f, Monad m) => FreeLike f m where
+        wrap :: f (m a) -> m a
+
+instance FreeLike f m => FreeLike f (Ran m m) where
+        wrap t = Ran (wrap . flip fmap t . flip runRan)
+
+instance Functor f => FreeLike f (Free f) where
+        wrap = inFree
+
+improve :: Functor f => (forall m. FreeLike f m => m a) -> Free f a
+improve m = abs m 
+
addfile ./src/Control/Monad/KanExtension.hs
hunk ./src/Control/Monad/KanExtension.hs 1
+-----------------------------------------------------------------------------
+-- |
+-- Module      :  Control.Monad.KanExtension
+-- Copyright   :  (C) 2008 Edward Kmett
+-- License     :  BSD-style (see the file LICENSE)
+--
+-- Maintainer  :  Edward Kmett <ekmett@gmail.com>
+-- Stability   :  experimental
+-- Portability :  non-portable (rank-2 polymorphism)
+--
+-- Left and right Kan extensions, expressed as higher order functors
+--
+-- Included is the 'monad generated by a functor' @Ran f f@
+----------------------------------------------------------------------------
+module Control.Monad.KanExtension 
+	( rep, abs
+	, FreeLike(..) -- , improve
+	) where
+
+import Prelude hiding (abs)
+import Control.Functor.Composition
+import Control.Functor.Extras
+import Control.Functor.Pointed ()
+import Control.Functor.HigherOrder
+import Control.Comonad
+import Control.Monad.Cont
+
+rep :: Monad m => m a -> Ran m m a
+rep m = Ran (m >>=)
+
+abs :: Monad m => Ran m m a -> m a 
+abs a = runRan a return
+
+class (Functor f, Monad m) => FreeLike f m where
+	wrap :: f (m a) -> m a
+
+instance FreeLike f m => FreeLike f (Ran m m) where
+	wrap t = Ran (wrap . flip fmap t . flip runRan)
+
+instance Functor f => FreeLike f (Free f) where
+	wrap = inFree
+
+improve :: Functor f => (forall a. FreeLike f m -> m a) -> Free f a
+improve = abs
+
+-- | Left Kan Extension
+data Lan g h a = forall b. Lan (g b -> a) (h b)
+
+toLan :: (Composition o, Functor f) => (h :~> (f `o` g)) -> Lan g h :~> f
+toLan s (Lan f v) = fmap f . decompose $ s v
+
+fromLan :: Composition o => (Lan g h :~> f) -> h :~> (f `o` g)
+fromLan s = compose . s . Lan id
+
+instance Functor g => HFunctor (Lan g) where
+	ffmap f (Lan g h) = Lan (f . g) h
+	hfmap f (Lan g h) = Lan g (f h)
+
+instance Functor (Lan f g) where
+	fmap f (Lan g h) = Lan (f . g) h
+
+instance Copointed (Lan f f) where
+	extract (Lan f a) = f a
+
+instance Comonad (Lan f f) where
+	duplicate (Lan f ws) = Lan (Lan f) ws
+
+coabs :: Comonad w => w a -> Lan w w a
+coabs = Lan extract 
+
+corep :: Comonad w => Lan w w a -> w a 
+corep (Lan f c) = extend f c
+
+class (Functor f, Comonad w) => Cocheap f w where 
+	unwrap :: w a -> f (w a)
+
+-- instance Functor f => CofreeLike f (Cofree f) where
+--	unwrap = outCofree 
+
+instance Cocheap f w => Cocheap f (Lan w w) where
+	unwrap (Lan f c) = fmap (Lan f) (unwrap c)
+
+--  unwrap = snd
+
+-- coimprove :: Functor f => Cofree f a -> (forall a. Cocheap f w => w a)
+-- coimprove = coabs
+
+-- * Limits and Colimits of Functors
+-- type Lim = Ran VoidF 
+-- type Colim = Lan VoidF
hunk ./src/Control/Morphism/Ana.hs 25
-ana :: Functor f => CoAlg f a -> a -> FixF f
+ana :: Functor f => Coalgebra f a -> a -> FixF f
hunk ./src/Control/Morphism/Ana.hs 27
--- ana g = g_ana distAna (liftCoAlg g)
+-- ana g = g_ana distAna (liftCoAlgebra g)
hunk ./src/Control/Morphism/Ana.hs 30
-g_ana :: (Functor f, Monad m) => Dist m f -> CoAlgM f m a -> a -> FixF f
+g_ana :: (Functor f, Monad m) => Dist m f -> GCoalgebra f m a -> a -> FixF f
hunk ./src/Control/Morphism/Ana.hs 38
-biana :: Bifunctor f Hask Hask Hask => CoAlg (f b) a -> a -> Fix f b
+biana :: Bifunctor f Hask Hask Hask => Coalgebra (f b) a -> a -> Fix f b
hunk ./src/Control/Morphism/Ana.hs 41
-g_biana :: (Bifunctor f Hask Hask Hask, Monad m) => Dist m (f b) -> CoAlgM (f b) m a -> a -> Fix f b
+g_biana :: (Bifunctor f Hask Hask Hask, Monad m) => Dist m (f b) -> GCoalgebra (f b) m a -> a -> Fix f b
hunk ./src/Control/Morphism/Ana.hs 45
-hana :: HFunctor f => CoAlgH f a -> a :~> FixH f
+hana :: HFunctor f => HCoalgebra f a -> a :~> FixH f
hunk ./src/Control/Morphism/Apo.hs 14
-module Control.Morphism.Apo where
+module Control.Morphism.Apo 
+	( apo
+	, Apo, ApoT
+	, distApoT
+	, g_apo
+	, GApo, GApoT
+	, distGApo, distGApoT
+	) where
hunk ./src/Control/Morphism/Apo.hs 34
-apo :: Functor f => CoAlgM f (Apo f) a -> a -> FixF f
+apo :: Functor f => GCoalgebra f (Apo f) a -> a -> FixF f
hunk ./src/Control/Morphism/Apo.hs 37
-g_apo :: Functor f => CoAlg f b -> CoAlgM f (GApo b) a -> a -> FixF f
+g_apo :: Functor f => Coalgebra f b -> GCoalgebra f (GApo b) a -> a -> FixF f
hunk ./src/Control/Morphism/Apo.hs 48
-distGApo :: Functor f => CoAlg f b -> Dist (Either b) f
+distGApo :: Functor f => Coalgebra f b -> Dist (Either b) f
hunk ./src/Control/Morphism/Apo.hs 51
-distGApoT :: (Functor f, Monad m) => CoAlgM f m b -> Dist m f -> Dist (EitherT b m) f
+distGApoT :: (Functor f, Monad m) => GCoalgebra f m b -> Dist m f -> Dist (EitherT b m) f
hunk ./src/Control/Morphism/Apo.hs 55
-distApoT = distGApoT (liftCoAlg outF)
+distApoT = distGApoT (liftCoalgebra outF)
hunk ./src/Control/Morphism/Cata.hs 25
-cata :: Functor f => Alg f a -> FixF f -> a
+cata :: Functor f => Algebra f a -> FixF f -> a
hunk ./src/Control/Morphism/Cata.hs 27
--- cata f = g_cata distCata (liftAlg f)
+-- cata f = g_cata distCata (liftAlgebra f)
hunk ./src/Control/Morphism/Cata.hs 29
-g_cata :: (Functor f, Comonad w) => Dist f w -> AlgW f w a -> FixF f -> a
+g_cata :: (Functor f, Comonad w) => Dist f w -> GAlgebra f w a -> FixF f -> a
hunk ./src/Control/Morphism/Cata.hs 36
-bicata :: Bifunctor f Hask Hask Hask => Alg (f b) a -> Fix f b -> a
+bicata :: Bifunctor f Hask Hask Hask => Algebra (f b) a -> Fix f b -> a
hunk ./src/Control/Morphism/Cata.hs 39
-g_bicata :: (Bifunctor f Hask Hask Hask, Comonad w) => Dist (f b) w -> AlgW (f b) w a -> Fix f b -> a
+g_bicata :: (Bifunctor f Hask Hask Hask, Comonad w) => Dist (f b) w -> GAlgebra (f b) w a -> Fix f b -> a
hunk ./src/Control/Morphism/Cata.hs 42
-hcata :: HFunctor f => AlgH f a -> FixH f :~> a
+hcata :: HFunctor f => HAlgebra f a -> FixH f :~> a
hunk ./src/Control/Morphism/Chrono.hs 24
-chrono :: (Functor f, Functor g) => AlgW g (Cofree g) b -> (f :~> g) -> CoAlgM f (Free f) a -> a -> b
+chrono :: (Functor f, Functor g) => GAlgebra g (Cofree g) b -> (f :~> g) -> GCoalgebra f (Free f) a -> a -> b
hunk ./src/Control/Morphism/Chrono.hs 28
-	    Dist g h -> Dist j f -> AlgW g (Cofree h) b -> (f :~> g) -> CoAlgM f (Free j) a -> a -> b
+	    Dist g h -> Dist j f -> GAlgebra g (Cofree h) b -> (f :~> g) -> GCoalgebra f (Free j) a -> a -> b
hunk ./src/Control/Morphism/Dyna.hs 22
-dyna :: (Functor f, Functor g) => AlgW g (Cofree g) b -> (f :~> g) -> CoAlg f a -> a -> b
-dyna f e g = g_hylo (distHisto id) distAna f e (liftCoAlg g)
+dyna :: (Functor f, Functor g) => GAlgebra g (Cofree g) b -> (f :~> g) -> Coalgebra f a -> a -> b
+dyna f e g = g_hylo (distHisto id) distAna f e (liftCoalgebra g)
hunk ./src/Control/Morphism/Futu.hs 23
-futu :: Functor f => CoAlgM f (Free f) a -> a -> FixF f
+futu :: Functor f => GCoalgebra f (Free f) a -> a -> FixF f
hunk ./src/Control/Morphism/Futu.hs 26
-g_futu :: (Functor f, Functor h) => Dist h f -> CoAlgM f (Free h) a -> a -> FixF f
+g_futu :: (Functor f, Functor h) => Dist h f -> GCoalgebra f (Free h) a -> a -> FixF f
hunk ./src/Control/Morphism/Histo.hs 23
-histo :: Functor f => AlgW f (Cofree f) a -> FixF f -> a
+histo :: Functor f => GAlgebra f (Cofree f) a -> FixF f -> a
hunk ./src/Control/Morphism/Histo.hs 26
-g_histo :: (Functor f, Functor h) => Dist f h -> AlgW f (Cofree h) a -> FixF f -> a
+g_histo :: (Functor f, Functor h) => Dist f h -> GAlgebra f (Cofree h) a -> FixF f -> a
hunk ./src/Control/Morphism/Hylo.hs 26
-hylo :: Functor f => Alg g b -> (f :~> g) -> CoAlg f a -> a -> b
+hylo :: Functor f => Algebra g b -> (f :~> g) -> Coalgebra f a -> a -> b
hunk ./src/Control/Morphism/Hylo.hs 30
-          Dist g w -> Dist m f -> AlgW g w b -> (f :~> g) -> CoAlgM f m a -> a -> b
+          Dist g w -> Dist m f -> GAlgebra g w b -> (f :~> g) -> GCoalgebra f m a -> a -> b
hunk ./src/Control/Morphism/Hylo.hs 35
-bihylo :: (QFunctor f Hask Hask) => Alg (g d) b -> (f c :~> g d) -> CoAlg (f c) a -> a -> b
+bihylo :: (QFunctor f Hask Hask) => Algebra (g d) b -> (f c :~> g d) -> Coalgebra (f c) a -> a -> b
hunk ./src/Control/Morphism/Hylo.hs 39
-          Dist (g d) w -> Dist m (f c) -> AlgW (g d) w b -> (f c :~> g d) -> CoAlgM (f c) m a -> a -> b
+          Dist (g d) w -> Dist m (f c) -> GAlgebra (g d) w b -> (f c :~> g d) -> GCoalgebra (f c) m a -> a -> b
hunk ./src/Control/Morphism/Hylo.hs 43
-hhylo :: HFunctor f => AlgH f b -> CoAlgH f a -> a :~> b
+hhylo :: HFunctor f => HAlgebra f b -> HCoalgebra f a -> a :~> b
hunk ./src/Control/Morphism/Meta.hs 12
--- Generalized metamorphisms 
+-- A very basic Jeremy Gibbons metamorphism, without all 
+-- the productive stream stuff. See:
+-- <http://www.comlab.ox.ac.uk/oucl/work/jeremy.gibbons/publications/metamorphisms-scp.pdf>
+-- TODO: Add some support for spigot algorithms over streams/lists.
hunk ./src/Control/Morphism/Meta.hs 19
-
hunk ./src/Control/Morphism/Meta.hs 27
-
hunk ./src/Control/Morphism/Meta.hs 28
-	  CoAlg f b -> (a -> b) -> Alg g a -> FixF g -> FixF f
+	  Coalgebra f b -> (a -> b) -> Algebra g a -> FixF g -> FixF f
hunk ./src/Control/Morphism/Meta.hs 32
-	  Dist m f -> Dist g w -> CoAlgM f m b -> (a -> b) -> AlgW g w a -> FixF g -> FixF f
+	  Dist m f -> Dist g w -> GCoalgebra f m b -> (a -> b) -> GAlgebra g w a -> FixF g -> FixF f
hunk ./src/Control/Morphism/Para.hs 25
-para :: Functor f => AlgW f (Para f) a -> FixF f -> a
+type Para f 	= (,) (FixF f)
+type ParaT w f 	= CoreaderT w (FixF f)
+
+para :: Functor f => GAlgebra f (Para f) a -> FixF f -> a
hunk ./src/Control/Morphism/Para.hs 31
-g_para :: (Functor f, Comonad w) => Dist f w -> AlgW f (ParaT w f) a -> FixF f -> a
+g_para :: (Functor f, Comonad w) => Dist f w -> GAlgebra f (ParaT w f) a -> FixF f -> a
hunk ./src/Control/Morphism/Para.hs 34
-type Para f a 		= (FixF f, a)
-type ParaT w f a 	= CoreaderT w (FixF f) a
-
hunk ./src/Control/Morphism/Para.hs 35
-distParaT = distZygoT (liftAlg InF)
+distParaT = distZygoT (liftAlgebra InF)
hunk ./src/Control/Morphism/Zygo.hs 23
-type Zygo b a = (b,a)
+type Zygo = (,)
+type ZygoT = CoreaderT
hunk ./src/Control/Morphism/Zygo.hs 26
-zygo :: Functor f => Alg f b -> AlgW f (Zygo b) a -> FixF f -> a
+zygo :: Functor f => Algebra f b -> GAlgebra f (Zygo b) a -> FixF f -> a
hunk ./src/Control/Morphism/Zygo.hs 29
-g_zygo :: (Functor f, Comonad w) => AlgW f w b -> Dist f w -> AlgW f (CoreaderT w b) a -> FixF f -> a
+g_zygo :: (Functor f, Comonad w) => GAlgebra f w b -> Dist f w -> GAlgebra f (ZygoT w b) a -> FixF f -> a
hunk ./src/Control/Morphism/Zygo.hs 34
-distZygo :: Functor f => Alg f b -> Dist f (Zygo b)
+distZygo :: Functor f => Algebra f b -> Dist f (Zygo b)
hunk ./src/Control/Morphism/Zygo.hs 37
-distZygoT :: (Functor f, Comonad w) => AlgW f w b -> Dist f w -> Dist f (CoreaderT w b)
+distZygoT :: (Functor f, Comonad w) => GAlgebra f w b -> Dist f w -> Dist f (ZygoT w b)
}
