[added dyads and allegories (oops!)
ekmett@gmail.com**20080619061101
 
 added some additional toys to the discrete category of Hask as well.
 
] {
hunk ./category-extras.cabal 3
-version:       0.53.3
+version:       0.53.4
hunk ./category-extras.cabal 7
-author:        Edward A. Kmett, Dave Menendez
+author:        Edward A. Kmett
addfile ./src/Control/Allegory.hs
hunk ./src/Control/Allegory.hs 1
+{-# LANGUAGE GADTs #-}
+-------------------------------------------------------------------------------------------
+-- |
+-- Module	: Control.Allegory
+-- Copyright 	: 2008 Edward Kmett
+-- License	: BSD
+--
+-- Maintainer	: Edward Kmett <ekmett@gmail.com>
+-- Stability	: experimental
+-- Portability	: portable
+--
+-- Allegories are generalizations of categories to cover relations.
+-------------------------------------------------------------------------------------------
+module Control.Allegory where
+
+import Prelude hiding (id,(.),all)
+import Control.Category
+import Control.Functor.Categorical
+infix 5 .<=.
+
+{-
+	An allegory is a category in which every arrow has a partial ordering, meet and converse such that:
+	converse f . converse g = converse (f . g)
+	f .<=. converse g = converse f .<=. g
+
+	Allegories are to relations what categories are to functions
+-}
+class Category k => Allegory k where
+	(.<=.) :: k a b -> k a b -> Bool
+	meet :: k a b -> k a b -> k a b
+	converse :: k a b -> k b a
+
+	isSimple :: k a b -> Bool
+	isSimple r = r . converse r .<=. id
+
+	isTotal :: k a b -> Bool
+	isTotal r = id .<=. converse r . r
+
+	isMap :: k a b -> Bool
+	isMap r = isSimple r && isTotal r
+
+class Allegory k => TabulatedAllegory k f where
+	tabulateLeft  :: k a b -> k a (f a b)
+	tabulateRight :: k a b -> k b (f a b)
+
+class Allegory k => UnitalAllegory k i | k -> i where
+	-- unit of the allegory
+	all :: k a i
+
+	rightDomain :: k b a -> k b b
+	rightDomain f = converse all . all . f
+
+	leftDomain :: k b a -> k a a 
+	leftDomain f = f . converse all . all
+
+class (Allegory k1, Allegory k2, CFunctor f k1 k2) => Relator f k1 k2
+
+data Map k a b = Map { runMap :: k a b } 
+
+-- the sub-category of maps in an Allegory
+instance Allegory k => Category (Map k) where
+	id = Map id
+	Map f . Map g = Map (f . g)
+
+extractMap :: Allegory k => k a b -> Maybe (Map k a b)
+extractMap f = if isMap f then Just (Map f) else Nothing
hunk ./src/Control/Category/Discrete.hs 15
+	, mapDiscrete
+	, cast
+	, invDiscrete
hunk ./src/Control/Category/Discrete.hs 22
+import Unsafe.Coerce (unsafeCoerce)
+-- import Control.Functor.Categorical
hunk ./src/Control/Category/Discrete.hs 32
--- HasTerminalObject _|_ ?
+-- instance CFunctor f Discrete Discrete where cmap = mapDiscrete
+
+mapDiscrete :: Discrete a b -> Discrete (f a) (f b)
+mapDiscrete Refl = Refl
+
+cast :: Discrete a b -> a -> b
+cast Refl = unsafeCoerce
+
+invDiscrete :: Discrete a b -> Discrete b a
+invDiscrete Refl = Refl
addfile ./src/Control/Dyad.hs
hunk ./src/Control/Dyad.hs 1
+{-# OPTIONS_GHC -cpp #-}
+-------------------------------------------------------------------------------------------
+-- |
+-- Module	: Control.Dyad
+-- Copyright 	: 2008 Edward Kmett
+-- License	: BSD3
+--
+-- Maintainer	: Edward Kmett <ekmett@gmail.com>
+-- Stability	: experimental
+-- Portability	: portable
+--
+-- Working Towards Maarten Fokkinga's Dyads
+-------------------------------------------------------------------------------------------
+
+module Control.Dyad where
+
+import Prelude hiding (id,(.))
+import Control.Category
+import Control.Functor.Categorical
+
+class (CDistributes w m (~>), CDistributes m w (~>), CExtend w (~>), CBind m (~>)) => CDyad w m (~>) where
+	cdyid :: w a ~> m a
+
+newtype DiKleisli w m (~>) a b = DiKleisli { runDiKleisli :: w a ~> m b }
+
+-- instance CMonad m k => CFunctor (DiKleisli w m k a) k k where
+--	cmap f (DiKleisli x) = DiKleisli (cmap f . x)
+
+-- instance CMonad m k => QFunctor (DiKleisli w m k) k k where second g = 
+-- instance CComonad w k => PFunctor (DiKleisli w m k) (Dual k) k where first f = 
+-- instance (CMonad m k, CComonad w k) => Bifunctor (DiKleisli w m k) (Dual Hask) Hask Hask where bimap f g 
+
+instance CDyad w m k => Category (DiKleisli w m k) where
+	DiKleisli f . DiKleisli g = DiKleisli (cbind f . cdist . cextend g)
+	id = DiKleisli cdyid
}
