[prepromorphisms
ekmett@gmail.com**20080608065454] {
hunk ./CHANGELOG 47
+0.53.0
+------
+* Added Fokkinga's prepro- and postpro- morphisms. Generalized them to allow them to be parameterized by (co)monads and 
+  derived the corresponding methods for (zygo, para, futu, histo, etc.)-(pre|post)promorphisms.
+
hunk ./category-extras.cabal 3
-version:                0.52.3
+version:                0.53.0
hunk ./category-extras.cabal 138
+                Control.Morphism.Postpro,
+                Control.Morphism.Prepro,
hunk ./src/Control/Comonad/Fix.hs 13
-	( ComonadFix(..)
+	( cofix
hunk ./src/Control/Comonad/Fix.hs 17
-import Control.Monad.Identity
+-- import Control.Monad.Identity
hunk ./src/Control/Comonad/Fix.hs 19
-class Comonad w => ComonadFix w where
-	cofix :: w (w a -> a) -> a
+--class Comonad w => ComonadFix w where
+--	cofix :: w (w a -> a) -> a
hunk ./src/Control/Comonad/Fix.hs 22
-instance ComonadFix Identity where
-	cofix (Identity f) = fix (f . Identity)
+--instance ComonadFix Identity where
+--	cofix (Identity f) = fix (f . Identity)
+
+--instance ComonadFix ((,)e) where
+--	cofix ~(e,f) = let x = f (e,x) in x
+
+
+cofix :: Comonad w => w (w a -> a) -> a
+cofix w = extract w (extend cofix w)
hunk ./src/Control/Comonad/Fix.hs 32
-instance ComonadFix ((,)e) where
-	cofix ~(e,f) = let x = f (e,x) in x
hunk ./src/Control/Functor/Composition.hs 24
+	, preTransform
+	, postTransform
hunk ./src/Control/Functor/Composition.hs 33
+import Control.Functor.Extras
hunk ./src/Control/Functor/Composition.hs 68
+preTransform :: Composition o => (f :~> g) -> (f `o` k) :~> (g `o` k) 
+preTransform f x = compose (f (decompose x))
+
+postTransform :: (Functor k, Composition o) => (f :~> g) -> (k `o` f) :~> (k `o` g) 
+postTransform f x = compose (fmap f (decompose x))
+
hunk ./src/Control/Functor/Composition.hs 75
-associateComposition :: (Functor f, Composition c) => c (c f g) h a -> c f (c g h) a
+associateComposition :: (Functor f, Composition o) => ((f `o` g) `o` h) :~> (f `o` (g `o` h))
hunk ./src/Control/Functor/Composition.hs 78
-coassociateComposition :: (Functor f, Composition c) => c f (c g h) a -> c (c f g) h a
+coassociateComposition :: (Functor f, Composition o) => (f `o` (g `o` h)) :~> ((f `o` g) `o` h)
hunk ./src/Control/Functor/Fix.hs 66
+
hunk ./src/Control/Functor/Strong.hs 21
-strength a fb = fmap ((,)a) fb
+strength = fmap . (,)
hunk ./src/Control/Functor/Strong.hs 24
-costrength = sequence
+costrength = Data.Traversable.sequence
hunk ./src/Control/Morphism/Apo.hs 15
-	( apo
+	( apo, g_apo
+	, postpro_apo, g_postpro_apo
hunk ./src/Control/Morphism/Apo.hs 19
-	, g_apo
hunk ./src/Control/Morphism/Apo.hs 29
+import Control.Morphism.Postpro
hunk ./src/Control/Morphism/Apo.hs 40
+postpro_apo :: Functor f => GCoalgebra f (Apo f) a -> (f :~> f) -> a -> FixF f
+postpro_apo = g_postpro_apo outF
+
+g_postpro_apo :: Functor f => Coalgebra f b -> GCoalgebra f (GApo b) a -> (f :~> f) -> a -> FixF f
+g_postpro_apo g = g_postpro (distGApo g)
+
hunk ./src/Control/Morphism/Apo.hs 52
--- * Distributive Law Combinators
+-- * Distributive Law Combinators for apomorphisms
+-- NB: we don't actually have simple recursion combinators for all of these 
hunk ./src/Control/Morphism/Build.hs 20
+-- prepro/preprobuild fusion?
hunk ./src/Control/Morphism/Futu.hs 14
-module Control.Morphism.Futu where
+module Control.Morphism.Futu 
+	( futu, g_futu
+	, postpro_futu, g_postpro_futu
+	, distFutu
+	) where
hunk ./src/Control/Morphism/Futu.hs 23
-import Control.Comonad ()
hunk ./src/Control/Morphism/Futu.hs 25
+import Control.Morphism.Postpro
hunk ./src/Control/Morphism/Futu.hs 27
--- futu :: Functor f => GCoalgebra f (Free f) a -> a -> FixF f
+-- | Generalized from @futu :: Functor f => GCoalgebra f (Free f) a -> a -> FixF f@
hunk ./src/Control/Morphism/Futu.hs 34
+-- | A futumorphic postpromorphism
+postpro_futu :: (RunMonadFree f m) => GCoalgebra f m a -> (f :~> f) -> a -> FixF f
+postpro_futu = g_postpro (distFutu id)
+
+-- | A generalized-futumorphic postpromorphism
+g_postpro_futu :: (Functor f, RunMonadFree h m) => Dist h f -> GCoalgebra f m a -> (f :~> f) -> a -> FixF f
+g_postpro_futu k = g_postpro (distFutu k)
+
+-- | Turn a distributive law for a functor into a distributive law for the free monad of that functor.
+-- This has been generalized to support generating distributive laws for a number of related free-monad-like
+-- constructions such as the Codensity monad of the free monad of a functor.
hunk ./src/Control/Morphism/Futu.hs 48
-
hunk ./src/Control/Morphism/Histo.hs 14
-module Control.Morphism.Histo where
+module Control.Morphism.Histo 
+	( distHisto
+	, histo, g_histo
+	, prepro_histo, g_prepro_histo
+	) where
hunk ./src/Control/Morphism/Histo.hs 26
+import Control.Morphism.Prepro
+
+distHisto :: (RunComonadCofree h w, Functor f) => Dist f h -> Dist f w
+distHisto k = anaCofree (fmap extract) (k . fmap outCofree)
hunk ./src/Control/Morphism/Histo.hs 37
-distHisto :: (RunComonadCofree h w, Functor f) => Dist f h -> Dist f w
-distHisto k = anaCofree (fmap extract) (k . fmap outCofree)
+-- A histomorphic prepromorphism
+prepro_histo :: (RunComonadCofree f w) => GAlgebra f w a -> (f :~> f) -> FixF f -> a
+prepro_histo = g_prepro (distHisto id)
+
+-- A generalized histomorphic prepromorphism
+g_prepro_histo :: (RunComonadCofree h w, Functor f) => Dist f h -> GAlgebra f w a -> (f :~> f) -> FixF f -> a
+g_prepro_histo k = g_prepro (distHisto k)
hunk ./src/Control/Morphism/Para.hs 13
-module Control.Morphism.Para where
+module Control.Morphism.Para 
+	( Para
+	, ParaT 
+	, distParaT 
+	, para, g_para
+	, prepro_para, g_prepro_para
+	) where
hunk ./src/Control/Morphism/Para.hs 28
-
--- * Refold Sugar
+import Control.Morphism.Prepro
hunk ./src/Control/Morphism/Para.hs 30
+-- * Paramorphisms use Reader Comonads
hunk ./src/Control/Morphism/Para.hs 34
+-- * Distributive Laws
+distParaT :: (Functor f, Comonad w) => Dist f w -> Dist f (ParaT w f)
+distParaT = distZygoT (liftAlgebra InF)
+
+-- * Paramorphism
hunk ./src/Control/Morphism/Para.hs 42
+-- | Generalized paramorphisms using a comonad reader transformer to carry the primitive recursive state
hunk ./src/Control/Morphism/Para.hs 46
-distParaT :: (Functor f, Comonad w) => Dist f w -> Dist f (ParaT w f)
-distParaT = distZygoT (liftAlgebra InF)
+-- | A paramorphic prepromorphism
+prepro_para :: Functor f => GAlgebra f (Para f) a -> (f :~> f) -> FixF f -> a
+prepro_para = prepro_zygo InF
+
+-- | A generalized paramorphic prepromorphism
+g_prepro_para :: (Functor f, Comonad w) => Dist f w -> GAlgebra f (ParaT w f) a -> (f :~> f) -> FixF f -> a
+g_prepro_para f = g_prepro (distParaT f)
addfile ./src/Control/Morphism/Postpro.hs
hunk ./src/Control/Morphism/Postpro.hs 1
+{-# OPTIONS_GHC -fglasgow-exts #-}
+-----------------------------------------------------------------------------
+-- |
+-- Module      :  Control.Morphism.Postpro
+-- Copyright   :  (C) 2008 Edward Kmett
+-- License     :  BSD-style (see the file LICENSE)
+--
+-- Maintainer  :  Edward Kmett <ekmett@gmail.com>
+-- Stability   :  experimental
+-- Portability :  non-portable (rank-2 polymorphism)
+-- 
+-- See Maarten Fokkinga''s PhD Dissertation for postpro. g_postpro is 
+-- an obvious generalization.
+----------------------------------------------------------------------------
+module Control.Morphism.Postpro 
+	( postpro
+	, g_postpro
+	) where
+
+import Control.Monad
+import Control.Functor.Algebra 
+import Control.Functor.Extras
+import Control.Functor.Fix
+import Control.Morphism.Ana
+
+-- prepro f e = x where x = f . fmap (x . cata (InF . e)) . outF
+postpro :: Functor f => (c -> f c) -> (f :~> f) -> c -> FixF f
+postpro g e = x where x = InF . fmap (ana (e . outF) . x) . g
+
+-- | Generalized postpromorphisms
+g_postpro :: (Functor f, Monad m) => Dist m f -> GCoalgebra f m a -> (f :~> f) -> a -> FixF f
+g_postpro k g e = a . return where a = InF . fmap (ana (e . outF) . a . join) . k . liftM g
addfile ./src/Control/Morphism/Prepro.hs
hunk ./src/Control/Morphism/Prepro.hs 1
+{-# OPTIONS_GHC -fglasgow-exts #-}
+-----------------------------------------------------------------------------
+-- |
+-- Module      :  Control.Morphism.Prepro
+-- Copyright   :  (C) 2008 Edward Kmett
+-- License     :  BSD-style (see the file LICENSE)
+--
+-- Maintainer  :  Edward Kmett <ekmett@gmail.com>
+-- Stability   :  experimental
+-- Portability :  non-portable (rank-2 polymorphism)
+-- 
+-- See Maarten Fokkinga''s PhD Dissertation for cascade and prepro.
+-- g_prepro is an obvious generalization.
+----------------------------------------------------------------------------
+module Control.Morphism.Prepro 
+	( prepro, g_prepro, cascade
+	) where
+
+import Control.Comonad
+import Control.Category.Hask
+import Control.Functor
+import Control.Functor.Pointed
+import Control.Functor.Algebra 
+import Control.Functor.Extras
+import Control.Functor.Fix
+-- import Control.Functor.HigherOrder
+import Control.Monad.Identity
+import Control.Morphism.Cata
+
+-- | @cascade f . map f = map f . cascade f@
+cascade :: Bifunctor s Hask Hask Hask => (a -> a) -> Fix s a -> Fix s a 
+cascade f = InB . bimap id (cascade f . fmap f) . outB 
+-- equivalently:
+-- cascade f = InB . bimap id (fmap f . cascade f) . outB 
+
+prepro :: Functor f => (f c -> c) -> (f :~> f) -> FixF f -> c
+prepro f e = x where x = f . fmap (x . cata (InF . e)) . outF
+
+-- | Generalized prepromorphisms
+g_prepro :: (Functor f, Comonad w) => Dist f w -> GAlgebra f w a -> (f :~> f) -> FixF f -> a
+g_prepro k g e = extract . c where c = liftW g . k . fmap (duplicate . c . cata (InF . e)) . outF
+
+--repro :: Functor f => (f b -> b) -> (f :~> f) -> (f :~> f) -> (a -> f a) -> a -> b
+--repro f fe ge g = x where x = f . fmap (ana (fe . outF) . x . cata (InF . ge)) . g
hunk ./src/Control/Morphism/Zygo.hs 13
-module Control.Morphism.Zygo where
+module Control.Morphism.Zygo 
+	( Zygo, ZygoT
+	, distZygo, distZygoT
+	, zygo
+	, g_zygo
+	, prepro_zygo
+	, g_prepro_zygo 
+	) where
hunk ./src/Control/Morphism/Zygo.hs 29
+import Control.Morphism.Prepro
hunk ./src/Control/Morphism/Zygo.hs 34
-zygo :: Functor f => Algebra f b -> GAlgebra f (Zygo b) a -> FixF f -> a
-zygo f = g_cata (distZygo f)
-
-g_zygo :: (Functor f, Comonad w) => GAlgebra f w b -> Dist f w -> GAlgebra f (ZygoT w b) a -> FixF f -> a
-g_zygo f w = g_cata (distZygoT f w)
-
hunk ./src/Control/Morphism/Zygo.hs 42
+zygo :: Functor f => Algebra f b -> GAlgebra f (Zygo b) a -> FixF f -> a
+zygo f = g_cata (distZygo f)
+
+g_zygo :: (Functor f, Comonad w) => GAlgebra f w b -> Dist f w -> GAlgebra f (ZygoT w b) a -> FixF f -> a
+g_zygo f w = g_cata (distZygoT f w)
+
+-- | a zygomorphic prepromorphism
+prepro_zygo :: Functor f => Algebra f b -> GAlgebra f (Zygo b) a -> (f :~> f) -> FixF f -> a
+prepro_zygo f = g_prepro (distZygo f)
+
+-- | a generalized zygomorphic prepromorphism 
+g_prepro_zygo :: (Functor f, Comonad w) => GAlgebra f w b -> Dist f w -> GAlgebra f (ZygoT w b) a -> (f :~> f) -> FixF f -> a
+g_prepro_zygo f w = g_prepro (distZygoT f w)
}
