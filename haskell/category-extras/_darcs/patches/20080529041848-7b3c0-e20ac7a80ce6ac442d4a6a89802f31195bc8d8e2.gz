[0.52.1
ekmett@gmail.com**20080529041848
 
 Broke out a lot of code
 Yoneda and Density separated from Kan extensions
 Cones and cocones added
 Limits and colimits cleaned up
 ComonadTrans added
 (higher order) build/destroy morphisms
 
] {
adddir ./src/Control/Functor/KanExtension
hunk ./CHANGELOG 34
+0.51.5
+------
+* Added CoYoneda to Control.Functor.Yoneda
+* Added Lambek's lemma (and its dual) in Control.Morphism.Cata (Control.Morphism.Ana)
+* Added a Run(Co)Monad(Co)Free class to encapsulate cataFree (anaFree)
+* Generalized dyna-, futu-, histo-, and chrono- morphisms to run over the appropriate kth left- and right- Kan extensions
+  of their associated (co)free monads as well as the basic (co)free monad. This may permit asymptotic free monad
+  improvement in some recursion schemes.
+
hunk ./LICENSE 1
+Copyright 2008 Edward Kmett
+Copyright 2007 Iavor Diatchki
+Copyright 2004-2008 Dave Menendez
+
hunk ./category-extras.cabal 3
-version:                0.51.2
+version:                0.52.1
hunk ./category-extras.cabal 49
+
hunk ./category-extras.cabal 67
+                Control.Comonad.Density,
hunk ./category-extras.cabal 74
-                Control.Comonad.Supply
+                Control.Comonad.Stream,
+                Control.Comonad.Supply,
+                Control.Comonad.Trans,
hunk ./category-extras.cabal 83
+                Control.Functor.Cone,
hunk ./category-extras.cabal 100
+                Control.Functor.KanExtension.Interpreter,
+                Control.Functor.Lambek,
hunk ./category-extras.cabal 110
+                Control.Monad.Categorical,
+                Control.Monad.Codensity,
hunk ./category-extras.cabal 123
-                Control.Morphism.Hylo,
-                Control.Morphism.Cata,
hunk ./category-extras.cabal 124
-                Control.Morphism.Meta,
-                Control.Morphism.Futu,
+                Control.Morphism.Apo,
+                Control.Morphism.Build,
+                Control.Morphism.Cata,
hunk ./category-extras.cabal 128
-                Control.Morphism.Para,
+                Control.Morphism.Destroy,
hunk ./category-extras.cabal 130
-                Control.Morphism.Apo,
+                Control.Morphism.Futu,
+                Control.Morphism.Histo,
+                Control.Morphism.Hylo,
+                Control.Morphism.Meta,
+                Control.Morphism.Para,
+                Control.Morphism.Span,
hunk ./category-extras.cabal 138
-                Control.Morphism.Histo,
hunk ./src/Control/Category/Small.hs 1
-{-# OPTIONS_GHC -fglasgow-exts #-}
-module Small where
-
-import Prelude hiding (curry,uncurry)
-
-class CCC k where
-        type Exp k :: * -> * -> *
-	type Prod k :: * -> * -> *
-        apply :: k (Prod k (Exp k a b) a) b 
-        curry :: k (Prod k a b) c -> k a (Exp k b c)
-        uncurry :: k a (Exp k b c) -> k (Prod k a b) c
-
-instance CCC (->) where
-	type Exp (->) = (->)
-	type Prod (->) = (,)
-	apply ~(f,x) = f x 
-	curry f x y = f (x,y)
-	uncurry f ~(x,y) = f x y 
-
-{-
-{-# RULES
-"curry apply" curry apply = id
-"curry . uncurry" curry . uncurry = id
-"uncurry . curry" uncurry . curry = id
- #-}
--}
-
-{-
-class CoCCC k where
-        data Coexp k :: * -> * -> *
-	data Sum k :: * -> * -> *
-        coapply :: k b (Sum k (Coexp k a b) a)
-        cocurry :: k c (Sum k a b) -> k (Coexp k b c) a
-        uncocurry :: k (Coexp k b c) a -> k c (Sum k a b)
-
-{-# RULES
-"cocurry coapply"       	cocurry coapply = id
-"cocurry . uncocurry"        	cocurry . uncocurry = id
-"uncocurry . cocurry"   	uncocurry . cocurry = id
- #-}
--}
rmfile ./src/Control/Category/Small.hs
hunk ./src/Control/Comonad/Cofree.hs 12
+-- Examples: 
+-- type LV = Cofree Maybe
+-- type Stream = Cofree Identity
+
hunk ./src/Control/Comonad/Cofree.hs 19
-	, runCofree, anaCofree, cofree
+	, runCofree, cofree
hunk ./src/Control/Comonad/Cofree.hs 21
+	, RunComonadCofree(anaCofree)
hunk ./src/Control/Comonad/Cofree.hs 36
-anaCofree :: Functor f => (a -> c) -> (a -> f a) -> a -> Cofree f c
-anaCofree h t = InB . Biff . (Identity . h &&& fmap (anaCofree h t) . t)
-
hunk ./src/Control/Comonad/Cofree.hs 48
+class ComonadCofree f w => RunComonadCofree f w | w -> f where
+	anaCofree :: Functor f => (a -> c) -> (a -> f a) -> a -> w c
+
+instance Functor f => RunComonadCofree f (Cofree f) where
+	anaCofree h t = InB . Biff . (Identity . h &&& fmap (anaCofree h t) . t)
+
hunk ./src/Control/Comonad/Context.hs 44
-
hunk ./src/Control/Comonad/Context.hs 61
-
addfile ./src/Control/Comonad/Density.hs
hunk ./src/Control/Comonad/Density.hs 1
+-----------------------------------------------------------------------------
+-- |
+-- Module      :  Control.Comonad.Density
+-- Copyright   :  (C) 2008 Edward Kmett
+-- License     :  BSD-style (see the file LICENSE)
+--
+-- Maintainer  :  Edward Kmett <ekmett@gmail.com>
+-- Stability   :  experimental
+-- Portability :  non-portable (rank-2 polymorphism)
+--
+-- The density comonad for a functor. aka the comonad cogenerated by a functor
+-- The ''density'' term dates back to Dubuc''s 1974 thesis. The term 
+-- ''monad genererated by a functor'' dates back to 1972 in Street''s 
+-- ''Formal Theory of Monads''.
+----------------------------------------------------------------------------
+module Control.Comonad.Density
+	( Density(..)
+	, densityToLan, lanToDensity
+	, toDensity, fromDensity
+	, liftDensity, lowerDensity
+	, densityToAdjunction, adjunctionToDensity
+	, densityToComposedAdjunction, composedAdjunctionToDensity
+	, improveCofree
+	) where
+
+import Prelude hiding (abs)
+import Control.Comonad.Context
+import Control.Comonad.Cofree
+import Control.Comonad.Trans
+import Control.Comonad.Reader
+import Control.Functor.Adjunction
+import Control.Functor.Composition
+import Control.Functor.Extras
+import Control.Functor.Pointed ()
+import Control.Functor.KanExtension
+import Control.Monad.Identity
+
+data Density k a = forall b. Density (k b -> a) (k b)
+
+densityToLan :: Density k a -> Lan k k a
+densityToLan (Density f v) = Lan f v
+
+lanToDensity :: Lan k k a -> Density k a 
+lanToDensity (Lan f v) = Density f v
+
+-- | @Nat(k, s.k)@ is isomorphic to @Nat (Density k, s)@ (forwards)
+toDensity :: Functor s => (forall a. k a -> s (k a)) -> Density k :~> s
+toDensity s (Density f v) = fmap f $ s v
+
+-- | @Nat(k, s.k)@ is isomorphic to @Nat (Density k, s)@ (backwards)
+fromDensity :: (Density k :~> s) -> k a -> s (k a)
+fromDensity s = s . Density id
+
+instance ComonadTrans Density where
+	colift = liftDensity
+
+instance Functor (Density f) where
+	fmap f (Density g h) = Density (f . g) h
+
+instance Copointed (Density f) where
+	extract (Density f a) = f a
+
+instance Comonad (Density f) where
+	duplicate (Density f ws) = Density (Density f) ws
+
+-- | The natural isomorphism between a comonad w and the comonad generated by w (forwards).
+liftDensity :: Comonad w => w a -> Density w a
+liftDensity = Density extract 
+
+-- | The natural isomorphism between a comonad w and the comonad generated by w (backwards).
+lowerDensity :: Comonad w => Density w a -> w a 
+lowerDensity (Density f c) = extend f c
+
+densityToAdjunction :: Adjunction f g => Density f a -> f (g a)
+densityToAdjunction (Density f v) = fmap (leftAdjunct f) v
+
+adjunctionToDensity :: Adjunction f g => f (g a) -> Density f a
+adjunctionToDensity = Density counit
+
+densityToComposedAdjunction :: (Composition o, Adjunction f g) => Density f :~> (f `o` g)
+densityToComposedAdjunction (Density f v) = compose (fmap (leftAdjunct f) v)
+
+composedAdjunctionToDensity :: (Composition o, Adjunction f g) => (f `o` g) :~> Density f
+composedAdjunctionToDensity = Density counit . decompose
+
+instance ComonadReader e w => ComonadReader e (Density w) where
+	askC = askC . lowerDensity
+
+instance ComonadContext e w => ComonadContext e (Density w) where
+        getC = getC . lowerDensity 
+	modifyC f = modifyC f . lowerDensity
+
+instance ComonadCofree f w => ComonadCofree f (Density w) where
+        outCofree (Density f c) = fmap (Density f) (outCofree c)
+
+instance RunComonadCofree f w => RunComonadCofree f (Density w) where
+	anaCofree l r = liftDensity . anaCofree l r
+
+improveCofree :: Functor f => (forall w. ComonadCofree f w => w a) -> Cofree f a
+improveCofree m = lowerDensity m
addfile ./src/Control/Comonad/Stream.hs
hunk ./src/Control/Comonad/Stream.hs 1
+{-# OPTIONS_GHC -fglasgow-exts #-}
+-----------------------------------------------------------------------------
+-- |
+-- Module      :  Control.Comonad.Stream
+-- Copyright   :  (C) 2008 Edward Kmett
+-- License     :  BSD-style (see the file LICENSE)
+--
+-- Maintainer  :  Edward Kmett <ekmett@gmail.com>
+-- Stability   :  experimental
+-- Portability :  portable
+--
+----------------------------------------------------------------------------
+module Control.Comonad.Stream
+	( Stream
+	) where
+
+
+import Control.Comonad.Cofree
+import Control.Monad.Identity
+type Stream = Cofree Identity
+
+-- class ComonadStream w where fby :: a -> (w a -> a) 
+-- next :: w a -> w a 
+-- run :: (ComonadStream w, ComonadContext Int c) => (c a -> b) -> w a -> w b
addfile ./src/Control/Comonad/Trans.hs
hunk ./src/Control/Comonad/Trans.hs 1
+{-# OPTIONS_GHC -fglasgow-exts #-}
+-----------------------------------------------------------------------------
+-- |
+-- Module      :  Control.Comonad.Trans
+-- Copyright   :  (C) 2008 Edward Kmett
+--		  (C) 2004 Dave Menendez
+-- License     :  BSD-style (see the file LICENSE)
+--
+-- Maintainer  :  Edward Kmett <ekmett@gmail.com>
+-- Stability   :  experimental
+-- Portability :  portable
+----------------------------------------------------------------------------
+module Control.Comonad.Trans
+	( ComonadTrans(colift)
+	) where
+
+import Control.Comonad
+
+class ComonadTrans t where
+	colift :: Comonad w => w a -> t w a 
hunk ./src/Control/Functor/Adjunction.hs 53
+
hunk ./src/Control/Functor/Adjunction.hs 80
+instance Adjunction Identity Identity where
+	unit = Identity . Identity
+	counit = runIdentity . runIdentity 
+
addfile ./src/Control/Functor/Cone.hs
hunk ./src/Control/Functor/Cone.hs 1
+-----------------------------------------------------------------------------
+-- |
+-- Module      :  Control.Functor.Cone
+-- Copyright   :  (C) 2008 Edward Kmett
+-- License     :  BSD-style (see the file LICENSE)
+--
+-- Maintainer  :  Edward Kmett <ekmett@gmail.com>
+-- Stability   :  experimental
+-- Portability :  non-portable (rank-2 polymorphism/existentials)
+--
+----------------------------------------------------------------------------
+module Control.Functor.Cone
+	( Cone, Cocone(..)
+	) where
+
+import Control.Monad.Reader
+import Control.Functor.Limit
+
+type Cone n f = n -> forall a. f a
+
+newtype Cocone f n = Cocone { runCocone :: forall a. f a -> n }
+
+instance Functor (Cocone f) where
+	fmap f (Cocone g) = Cocone (f . g)
+
+instance Monad (Cocone f) where
+	return x = Cocone (\_ -> x)
+	Cocone r >>= f = Cocone (\e -> runCocone (f (r e)) e)
+
+instance MonadReader (Colimit f) (Cocone f) where
+	ask = Cocone Colimit
+	local f (Cocone r) = Cocone (\e -> case f (Colimit e) of Colimit e' -> r e')
hunk ./src/Control/Functor/Extras.hs 15
-infixr 0 :~>, :~~> -- to match ->
+import Control.Monad
+
+infixr 0 :~>, :~~> -- to match ->'s fixity
hunk ./src/Control/Functor/Extras.hs 45
-
-
hunk ./src/Control/Functor/Extras.hs 55
+instance FunctorZero Maybe where
+	fzero = Nothing
+
+instance FunctorPlus Maybe where
+	fplus = mplus
+
+instance FunctorZero [] where
+	fzero = []
+	
+instance FunctorPlus [] where
+	fplus = (++)
+	
+
hunk ./src/Control/Functor/KanExtension.hs 13
--- Included is the 'monad generated by a functor' @Ran f f@
--- and the comonad cogenerated by a functor @Lan f f@
--- and machinery for lifting (co)monads into and lowering (co)monads out of 
--- Kan extensions.
+-- See <http://comonad.com/reader/2008/kan-extensions/>
+-- and <http://comonad.com/reader/2008/kan-extensions-ii/>
+-- for motivation.
+--
+-- NB: @Yoneda@, @CoYoneda@, @Density@, @Codensity@ have been factored
+-- out into separate modules.
hunk ./src/Control/Functor/KanExtension.hs 25
-	, liftRan, lowerRan
hunk ./src/Control/Functor/KanExtension.hs 31
-	, liftLan, lowerLan
hunk ./src/Control/Functor/KanExtension.hs 34
-	-- * Performance tweaks for (co)free (co)monads
-	, improveFree
-	, worsenCofree
hunk ./src/Control/Functor/KanExtension.hs 37
-import Control.Comonad.Context
-import Control.Comonad.Cofree
hunk ./src/Control/Functor/KanExtension.hs 42
-import Control.Monad.State
-import Control.Monad.Reader
hunk ./src/Control/Functor/KanExtension.hs 43
-import Control.Monad.Free
hunk ./src/Control/Functor/KanExtension.hs 44
--- | Right Kan Extension
+
+-- | The right Kan Extension of h along g.
+-- An alternative definition in terms of Ends.
+--
+-- @newtype RanT g h a b b' { (a -> g b) -> h b' }@
+--
+-- @type Ran g h a = End (RanT g h a)@
hunk ./src/Control/Functor/KanExtension.hs 68
-instance Pointed (Ran f f) where
-	point x = Ran (\k -> k x)
-
-instance Monad (Ran f f) where
-	return = point
-	m >>= k = Ran (\c -> runRan m (\a -> runRan (k a) c))
-
hunk ./src/Control/Functor/KanExtension.hs 76
--- | Lift a monad into its right Kan extension along itself. This is the same operation
--- as is performed by Voightlaender's rep in <http://wwwtcs.inf.tu-dresden.de/%7Evoigt/mpc08.pdf>
--- and the ContT monad's lift operation. This is also viewable as the forward half of the 
--- natural isomorphism between a monad m and the monad generated by m.
-liftRan :: Monad m => m a -> Ran m m a
-liftRan m = Ran (m >>=)
-
--- | The natural isomorphism between a monad m and the monad generated by m (backwards)
-lowerRan :: Monad m => Ran m m a -> m a 
-lowerRan a = runRan a return
-
-instance MonadReader r m => MonadReader r (Ran m m) where
-	ask = liftRan ask
-	local f m = Ran (\c -> ask >>= \r -> local f (runRan m (local (const r) . c)))
-
-instance MonadIO m => MonadIO (Ran m m) where
-	liftIO = liftRan . liftIO 
-
-instance MonadState s m => MonadState s (Ran m m) where
-	get = liftRan get
-	put = liftRan . put
-
-instance MonadFree f m => MonadFree f (Ran m m) where
-        inFree t = Ran (inFree . flip fmap t . flip runRan)
-
hunk ./src/Control/Functor/KanExtension.hs 91
+--
+-- @newtype LanT g h a b b' { (g b -> a, h b') }@
+--
+-- @type Lan g h a = Coend (LanT g h a)@
hunk ./src/Control/Functor/KanExtension.hs 112
-instance Copointed (Lan f f) where
-	extract (Lan f a) = f a
-
-instance Comonad (Lan f f) where
-	duplicate (Lan f ws) = Lan (Lan f) ws
-
--- | The natural isomorphism between a comonad w and the comonad generated by w (forwards).
-liftLan :: Comonad w => w a -> Lan w w a
-liftLan = Lan extract 
-
--- | The natural isomorphism between a comonad w and the comonad generated by w (backwards).
-lowerLan :: Comonad w => Lan w w a -> w a 
-lowerLan (Lan f c) = extend f c
-
hunk ./src/Control/Functor/KanExtension.hs 126
-instance ComonadContext e m => ComonadContext e (Lan m m) where
-        getC = getC . lowerLan 
-	modifyC f = modifyC f . lowerLan
-
-instance ComonadCofree f w => ComonadCofree f (Lan w w) where
-        outCofree (Lan f c) = fmap (Lan f) (outCofree c)
-
hunk ./src/Control/Functor/KanExtension.hs 135
--- | Voigtlaender's asymptotic performance improvement for free monads
-improveFree :: Functor f => (forall m. MonadFree f m => m a) -> Free f a
-improveFree m = lowerRan m
-
-worsenCofree :: Functor f => (forall w. ComonadCofree f w => w a) -> Cofree f a
-worsenCofree m = lowerLan m
-
--- data AnyCofree f a = forall w. ComonadCofree f w => AnyCofree { runAnyCofree :: w a }
--- coimprove :: Functor f => Cofree f a -> AnyCofree f a
--- coimprove m = AnyCofree (liftLan m)
-
addfile ./src/Control/Functor/KanExtension/Interpreter.hs
hunk ./src/Control/Functor/KanExtension/Interpreter.hs 1
+{-# OPTIONS_GHC -fglasgow-exts #-}
+-----------------------------------------------------------------------------
+-- |
+-- Module      :  Control.Functor.KanExtension.Interpreter
+-- Copyright   :  (C) 2008 Edward Kmett
+-- License     :  BSD-style (see the file LICENSE)
+--
+-- Maintainer  :  Edward Kmett <ekmett@gmail.com>
+-- Stability   :  experimental
+-- Portability :  non-portable (rank-2 polymorphism)
+--
+-- Ghani and Johann's Interp/InterpT types from ''Initial Algebra Semantics is Enough!''
+-- <http://crab.rutgers.edu/~pjohann/tlca07-rev.pdf> and its dual.
+----------------------------------------------------------------------------
+module Control.Functor.KanExtension.Interpreter
+	( Interpreter, InterpreterT
+	, interpreterAlgebra, algebraInterpreter
+	, Cointerpreter, CointerpreterT
+	, cointerpreterCoalgebra, coalgebraCointerpreter
+	) where
+
+import Control.Functor.Extras
+import Control.Functor.HigherOrder
+import Control.Functor.KanExtension
+
+type Interpreter y g h = y :~> Ran g h
+type InterpreterT f g h = forall y. Functor y => Interpreter y g h -> Interpreter (f y) g h
+
+interpreterAlgebra :: InterpreterT f g h -> HAlgebra f (Ran g h)
+interpreterAlgebra i = i id
+
+algebraInterpreter :: HFunctor f => HAlgebra f (Ran g h) -> InterpreterT f g h
+algebraInterpreter h i = h . hfmap i
+
+type Cointerpreter y g h = Lan g h :~> y
+type CointerpreterT f g h = forall y. Functor y => Cointerpreter y g h -> Cointerpreter (f y) g h
+
+cointerpreterCoalgebra :: CointerpreterT f g h -> HCoalgebra f (Lan g h)
+cointerpreterCoalgebra i = i id
+
+coalgebraCointerpreter :: HFunctor f => HCoalgebra f (Lan g h) -> CointerpreterT f g h
+coalgebraCointerpreter h i = hfmap i . h
addfile ./src/Control/Functor/Lambek.hs
hunk ./src/Control/Functor/Lambek.hs 1
+{-# OPTIONS_GHC -fglasgow-exts #-}
+-----------------------------------------------------------------------------
+-- |
+-- Module      :  Control.Functor.Lambek
+-- Copyright   :  (C) 2008 Edward Kmett
+-- License     :  BSD-style (see the file LICENSE)
+--
+-- Maintainer  :  Edward Kmett <ekmett@gmail.com>
+-- Stability   :  experimental
+-- Portability :  non-portable (rank-2 polymorphism)
+-- 
+----------------------------------------------------------------------------
+module Control.Functor.Lambek
+	( 
+	-- * Lambek's Lemma
+	  lambek
+	, hlambek
+	, colambek
+	, hcolambek
+	) where
+
+import Control.Functor.Algebra 
+import Control.Functor.Extras
+import Control.Functor.Fix
+import Control.Functor.HigherOrder
+import Control.Morphism.Cata
+import Control.Morphism.Ana
+
+-- Lambek's lemma
+lambek :: Functor f => Algebra f (FixF f) -> Coalgebra f (FixF f)
+lambek inF = cata (fmap inF)
+
+hlambek :: HFunctor f => HAlgebra f (FixH f) -> HCoalgebra f (FixH f)
+hlambek inH = hcata (hfmap inH)
+
+colambek :: Functor f => Coalgebra f (FixF f) -> Algebra f (FixF f)
+colambek out = ana (fmap out)
+
+hcolambek :: HFunctor f => HCoalgebra f (FixH f) -> HAlgebra f (FixH f)
+hcolambek out = hana (hfmap out)
+
hunk ./src/Control/Functor/Limit.hs 9
--- Portability :  non-portable (rank-2 polymorphism/existentials in Ran/Lan)
+-- Portability :  non-portable (rank-2 polymorphism/existentials)
hunk ./src/Control/Functor/Limit.hs 13
-	( Lim
-	, Colim
-	, module Control.Functor.KanExtension
-	, Void
-	, Const
+	( Limit, HasLimit(limit)
+	, Colimit(..)
hunk ./src/Control/Functor/Limit.hs 18
-import Control.Applicative (Const)
-import Data.Void (Void)
-import Control.Functor.KanExtension
+import Data.Monoid
hunk ./src/Control/Functor/Limit.hs 20
-type Lim = Ran (Const Void)
-type Colim = Lan (Const Void)
+-- | @type Limit = Ran (Const Void)@
+-- Limit { runLimit :: forall a. f a }
+type Limit f = forall a. f a 
+
+class HasLimit f where
+	limit :: f a
+
+instance HasLimit Maybe where
+	limit = Nothing
+
+instance HasLimit [] where
+	limit = []
+
+instance Monoid a => HasLimit (Either a) where
+	limit = (Left mempty)
+
+-- | @type Colimit = Lan (Const Void)@
+data Colimit f = forall b. Colimit (f b)
hunk ./src/Control/Functor/Pointed.hs 20
-import Control.Functor
hunk ./src/Control/Functor/Pointed.hs 22
+import Control.Functor
+-- import Control.Functor.Algebra
hunk ./src/Control/Functor/Pointed.hs 29
-        point :: a -> f a
+        point :: a -> f a -- Coalgebra f a
hunk ./src/Control/Functor/Pointed.hs 32
-        extract :: f a -> a
+        extract :: f a -> a -- Algebra f a
hunk ./src/Control/Functor/Representable.hs 16
+import Control.Monad.Identity
+
hunk ./src/Control/Functor/Representable.hs 36
+instance Representable Identity () where
+	rep f = Identity (f ())
+	unrep (Identity a) = const a
+
+data Both a = Both a a 
+
+instance Functor Both where
+	fmap f (Both a b) = Both (f a) (f b)
+
+instance Representable Both Bool where
+	rep f = Both (f False) (f True)
+	unrep (Both x _) False = x
+	unrep (Both _ y) True = y
+
+-- instance Adjunction f g => Representable g (f ()) where
+-- instance Representable (Cofree Identity) (Free Identity ()) where
hunk ./src/Control/Functor/Yoneda.hs 11
--- The Yoneda lemma materialized as a Kan extension, and hence as a higher order functor
+-- The Yoneda lemma can be realized as the Kan extension along Identity
+-- However, having this special instance allows us to define Yoneda f as a monad, 
+-- comonad, etc. based on whatever properties the base functor has, without
+-- limiting ourselves to what Ran f f can manage.
+--
+-- Performance wise, Yoneda may make your monad more efficient at handling a bunch of 
+-- fmaps, while CoYoneda may do the same for a comonad assuming you require a greater than
+-- linear amount of time to fmap over your structure. You can apply each in either role
+-- but the asymptotics will probably not be in your favor.
+--
hunk ./src/Control/Functor/Yoneda.hs 24
-	( Yoneda
-	, toYoneda, fromYoneda
+	( Yoneda(Yoneda,runYoneda), ranToYoneda, yonedaToRan, lowerYoneda
+	, CoYoneda(CoYoneda), lanToCoYoneda, coYonedaToLan, liftCoYoneda
hunk ./src/Control/Functor/Yoneda.hs 28
-import Control.Functor.KanExtension
+import Control.Applicative
+import Control.Comonad.HigherOrder
+import Control.Comonad.Cofree
+import Control.Comonad.Context
+import Control.Comonad.Reader
+import Control.Comonad.Trans
hunk ./src/Control/Functor/Yoneda.hs 35
+import Control.Functor.KanExtension
+import Control.Functor.Pointed
+import Control.Functor.HigherOrder
hunk ./src/Control/Functor/Yoneda.hs 39
+import Control.Monad.HigherOrder
+import Control.Monad.Free
+import Control.Monad.Trans
+import Control.Monad.Reader.Class
+import Control.Monad.State.Class
+import Control.Monad.Writer.Class
+
+-- Yoneda ~ Ran Identity
+newtype Yoneda f a = Yoneda { runYoneda :: forall b. ((a -> b) -> f b) } 
+
+ranToYoneda :: Ran Identity f :~> Yoneda f
+ranToYoneda r = Yoneda (\f -> runRan r (Identity . f))
+
+yonedaToRan :: Yoneda f :~> Ran Identity f
+yonedaToRan y = Ran (\f -> runYoneda y (runIdentity . f))
+
+lowerYoneda :: Yoneda f :~> f 
+lowerYoneda m = runYoneda m id
+
+instance Functor (Yoneda f) where
+	fmap f m = Yoneda (\k -> runYoneda m (k . f))
+
+instance Pointed f => Pointed (Yoneda f) where
+	point a = Yoneda (\f -> point (f a))
+
+instance Applicative f => Applicative (Yoneda f) where
+	pure a = Yoneda (\f -> pure (f a))
+	m <*> n = Yoneda (\f -> runYoneda m (f .) <*> runYoneda n id)
+
+instance Monad f => Monad (Yoneda f) where
+	return a = Yoneda (\f -> return (f a))
+	m >>= k = Yoneda (\f -> runYoneda m id >>= \a -> runYoneda (k a) f)
+
+instance HFunctor Yoneda where
+	ffmap = fmap
+	hfmap f y = Yoneda (f . runYoneda y)
+
+-- f a -> Yoneda f a 
+instance HPointed Yoneda where
+	hreturn a = Yoneda (\f -> fmap f a) 
+
+-- exists because Monad doesn't require Functor!
+instance MonadTrans Yoneda where
+	lift a = Yoneda (\f -> liftM f a)
+
+instance ComonadTrans Yoneda where
+	colift = hreturn
+
+-- Yoneda f a -> f a
+instance HCopointed Yoneda where
+	hextract t = runYoneda t id
+
+instance HMonad Yoneda where
+	hbind f = f . hextract 
+
+instance HComonad Yoneda where
+	hextend f = hreturn . f
+
+instance Copointed f => Copointed (Yoneda f) where
+	extract = extract . hextract
+
+instance Comonad f => Comonad (Yoneda f) where
+	extend k m = Yoneda (\f -> extend (f . k . hreturn) (hextract m))
+
+instance MonadState e m => MonadState e (Yoneda m) where
+	get = lift get
+	put = lift . put
+
+instance MonadReader e m => MonadReader e (Yoneda m) where
+	ask = lift ask
+	local r = lift . local r . lowerYoneda
+
+instance MonadWriter e m => MonadWriter e (Yoneda m) where
+	tell = lift . tell
+	listen = lift . listen . flip runYoneda id 
+	pass = lift . pass . lowerYoneda
+
+instance MonadFree f m => MonadFree f (Yoneda m) where
+	inFree = lift . inFree . fmap lowerYoneda
+
+instance RunMonadFree f m => RunMonadFree f (Yoneda m) where
+	cataFree l r = cataFree l r . lowerYoneda
+
+instance ComonadCofree f m => ComonadCofree f (Yoneda m) where
+	outCofree = fmap colift . outCofree . lowerYoneda
+
+instance RunComonadCofree f m => RunComonadCofree f (Yoneda m) where
+	anaCofree l r = colift . anaCofree l r
+
+instance ComonadContext e m => ComonadContext e (Yoneda m) where
+	getC = getC . lowerYoneda
+	modifyC s = modifyC s . lowerYoneda
+
+instance ComonadReader e m => ComonadReader e (Yoneda m) where
+	askC = askC . lowerYoneda
+	
+
+-- | Left Kan Extensions
+-- CoYoneda ~ Lan Identity
+data CoYoneda f a = forall b. CoYoneda (b -> a) (f b)
+
+lanToCoYoneda :: Lan Identity f :~> CoYoneda f 
+lanToCoYoneda (Lan f v) = CoYoneda (f . Identity) v
+
+coYonedaToLan :: CoYoneda f :~> Lan Identity f
+coYonedaToLan (CoYoneda f v) = Lan (f . runIdentity) v
+
+instance Functor (CoYoneda f) where
+	fmap f (CoYoneda g v) = CoYoneda (f . g) v
+
+instance Pointed f => Pointed (CoYoneda f) where
+	point = hreturn . point
+
+instance Applicative f => Applicative (CoYoneda f) where
+	pure = hreturn . pure
+	m <*> n = CoYoneda id (hextract m <*> hextract n)
+
+instance Monad m => Monad (CoYoneda m) where
+	return = CoYoneda id . return
+	CoYoneda f v >>= k = CoYoneda id (v >>= (\(CoYoneda f' v') -> liftM f' v') . k . f)
+
+instance HFunctor CoYoneda where
+	ffmap = fmap 
+	hfmap f (CoYoneda g v) = CoYoneda g (f v)
+
+instance HPointed CoYoneda where
+	hreturn = CoYoneda id
+
+instance HMonad CoYoneda where
+	hbind f = f . hextract
+
+instance HComonad CoYoneda where
+	hextend f = hreturn . f
+
+instance HCopointed CoYoneda where
+	hextract (CoYoneda f v) = fmap f v
+
+liftCoYoneda :: f :~> CoYoneda f
+liftCoYoneda = CoYoneda id
+
+-- | Just a conceptual nicety for monads since they aren't functors in Haskell. this is otherwise just hextract
+lowerCoYoneda :: Monad f => CoYoneda f :~> f 
+lowerCoYoneda (CoYoneda f v) = liftM f v 
+
+instance Copointed w => Copointed (CoYoneda w) where
+	extract (CoYoneda f v) = f (extract v)
+
+instance Comonad w => Comonad (CoYoneda w) where
+	extend k (CoYoneda f v) = CoYoneda id $ extend (k . CoYoneda f) v
+
+instance MonadTrans CoYoneda where
+	lift = CoYoneda id
+
+instance ComonadTrans CoYoneda where
+	colift = CoYoneda id
+
+-- All the (Co)monadFoo CoYoneda instances
+
+instance ComonadCofree f m => ComonadCofree f (CoYoneda m) where
+	outCofree = fmap colift . outCofree . hextract
+
+instance RunComonadCofree f m => RunComonadCofree f (CoYoneda m) where
+	anaCofree l r = colift . anaCofree l r
+
+instance ComonadContext e m => ComonadContext e (CoYoneda m) where
+	getC = getC . hextract
+	modifyC s = modifyC s . hextract
+
+instance ComonadReader e m => ComonadReader e (CoYoneda m) where
+	askC = askC . hextract
+	
+instance MonadState e m => MonadState e (CoYoneda m) where
+	get = lift get
+	put = lift . put
hunk ./src/Control/Functor/Yoneda.hs 214
-type Yoneda = Ran Identity
+instance MonadReader e m => MonadReader e (CoYoneda m) where
+	ask = lift ask
+	local r = lift . local r . lowerCoYoneda
hunk ./src/Control/Functor/Yoneda.hs 218
-toYoneda :: Functor f => f :~> Yoneda f
-toYoneda a = Ran (\f -> fmap (runIdentity . f) a)
+instance MonadWriter e m => MonadWriter e (CoYoneda m) where
+	tell = lift . tell
+	listen = lift . listen . lowerCoYoneda
+	pass = lift . pass . lowerCoYoneda
hunk ./src/Control/Functor/Yoneda.hs 223
-fromYoneda :: Yoneda f :~> f 
-fromYoneda t = runRan t Identity
+instance MonadFree f m => MonadFree f (CoYoneda m) where
+	inFree = lift . inFree . fmap lowerCoYoneda
hunk ./src/Control/Functor/Yoneda.hs 226
--- newtype Yoneda f a = Yoneda { runYoneda :: forall b. (a -> b) -> f b } 
--- instance HFunctor Yoneda where
---	ffmap f (Yoneda t) = check (t f)
---	hfmap f (Yoneda t) = Yoneda (f . t)
+instance RunMonadFree f m => RunMonadFree f (CoYoneda m) where
+	cataFree l r = cataFree l r . lowerCoYoneda
hunk ./src/Control/Functor/Zap.hs 25
+
+-- zapWith :: Adjunction f g => (a -> b -> c) -> f a -> g b -> c
+-- zapWith f a b = uncurry (flip f) . counit . fmap (uncurry (flip strength)) $ strength a b
+
+-- zap :: Adjunction f g => f (a -> b) -> g a -> b
+-- zap = zapWith id
addfile ./src/Control/Monad/Categorical.hs
hunk ./src/Control/Monad/Categorical.hs 1
+module Control.Monad.Categorical where
+import Prelude hiding (id,(.))
+import Control.Category
+import Control.Functor.Categorical
+
+class CFunctor m c d => CPointed m c d where
+	creturn :: d a (m a)
+
+-- class CPointed m (~>) => CApplicative m (~>) where
+--	cap :: m (a ~> b) ~> m a ~> m b
+
+class CPointed m (~>) (~>) => CMonad m (~>) where
+	cbind :: (a ~> m b) -> m a ~> m b
+	cjoin :: m (m a) ~> m a 
+
+	cbind f = cjoin . cmap f 
+	cjoin = cbind id 
addfile ./src/Control/Monad/Codensity.hs
hunk ./src/Control/Monad/Codensity.hs 1
+-----------------------------------------------------------------------------
+-- |
+-- Module      :  Control.Monad.Codensity
+-- Copyright   :  (C) 2008 Edward Kmett
+-- License     :  BSD-style (see the file LICENSE)
+--
+-- Maintainer  :  Edward Kmett <ekmett@gmail.com>
+-- Stability   :  experimental
+-- Portability :  non-portable (rank-2 polymorphism)
+--
+----------------------------------------------------------------------------
+module Control.Monad.Codensity
+	( Codensity, liftCodensity, lowerCodensity
+	, codensityToRan, ranToCodensity
+	, toCodensity, fromCodensity
+	, codensityToAdjunction
+	, adjunctionToCodensity
+	, improveFree
+	) where
+
+import Prelude hiding (abs)
+import Control.Comonad.Context
+import Control.Functor.Extras
+import Control.Functor.Pointed ()
+import Control.Functor.Adjunction
+import Control.Functor.KanExtension
+import Control.Monad.State
+import Control.Monad.Reader
+import Control.Monad.Identity
+import Control.Monad.Free
+
+newtype Codensity m a = Codensity { runCodensity :: forall b. (a -> m b) -> m b }
+
+codensityToRan :: Codensity m :~> Ran m m
+codensityToRan x = Ran (runCodensity x)
+
+ranToCodensity :: Ran m m :~> Codensity m
+ranToCodensity x = Codensity (runRan x)
+
+liftCodensity :: Monad m => m :~> Codensity m
+liftCodensity m = Codensity (m >>=)
+
+lowerCodensity :: Monad m => Codensity m :~> m
+lowerCodensity a = runCodensity a return
+
+toCodensity :: Functor s => (forall a. s (k a) -> k a) -> s :~> Codensity k
+toCodensity s t = Codensity (s . flip fmap t)
+
+fromCodensity :: (s :~> Codensity k) -> s (k a) -> k a
+fromCodensity s = flip runCodensity id . s
+
+instance Functor (Codensity k) where
+	fmap f m = Codensity (\k -> runCodensity m (k . f))
+
+instance Pointed (Codensity f) where
+	point x = Codensity (\k -> k x)
+
+instance Monad (Codensity f) where
+	return = point
+	m >>= k = Codensity (\c -> runCodensity m (\a -> runCodensity (k a) c))
+
+instance MonadReader r m => MonadReader r (Codensity m) where
+	ask = liftCodensity ask
+	local f m = Codensity (\c -> ask >>= \r -> local f (runCodensity m (local (const r) . c)))
+
+instance MonadIO m => MonadIO (Codensity m) where
+	liftIO = liftCodensity . liftIO 
+
+instance MonadState s m => MonadState s (Codensity m) where
+	get = liftCodensity get
+	put = liftCodensity . put
+
+instance MonadFree f m => MonadFree f (Codensity m) where
+        inFree t = Codensity (inFree . flip fmap t . flip runCodensity)
+
+instance RunMonadFree f m => RunMonadFree f (Codensity m) where
+	cataFree l r = cataFree l r . lowerCodensity
+
+codensityToAdjunction :: Adjunction f g => Codensity g a -> g (f a)
+codensityToAdjunction r = runCodensity r unit
+
+adjunctionToCodensity :: Adjunction f g => g (f a) -> Codensity g a
+adjunctionToCodensity f = Codensity (\a -> fmap (rightAdjunct a) f)
+
+improveFree :: Functor f => (forall m. MonadFree f m => m a) -> Free f a
+improveFree m = lowerCodensity m
hunk ./src/Control/Monad/Free.hs 23
-	, cataFree
hunk ./src/Control/Monad/Free.hs 25
+	, RunMonadFree(cataFree)
hunk ./src/Control/Monad/Free.hs 32
+import Control.Functor.Algebra
hunk ./src/Control/Monad/Free.hs 44
-cataFree :: Functor f => (c -> a) -> (f a -> a) -> Free f c -> a
-cataFree l r = (l . runIdentity ||| r . fmap (cataFree l r)) . runBiff . outB
-
hunk ./src/Control/Monad/Free.hs 47
+class MonadFree f m => RunMonadFree f m | m -> f where
+	cataFree :: (c -> a) -> Algebra f a -> m c -> a
+
+instance Functor f => RunMonadFree f (Free f) where
+	cataFree l r = (l . runIdentity ||| r . fmap (cataFree l r)) . runBiff . outB
+
hunk ./src/Control/Morphism/Ana.hs 13
-module Control.Morphism.Ana where
+module Control.Morphism.Ana 
+	( ana, g_ana, distAna
+	, biana, g_biana
+	, hana
+	, kana, runkana
+	) where
hunk ./src/Control/Morphism/Ana.hs 26
+import Control.Functor.KanExtension
+import Control.Functor.KanExtension.Interpreter
hunk ./src/Control/Morphism/Ana.hs 55
+kana :: HFunctor f => CointerpreterT f g h -> Lan g h :~> FixH f
+kana i = hana (cointerpreterCoalgebra i)
+
+runkana :: HFunctor f => CointerpreterT f g h -> (g b -> a) -> h b -> FixH f a 
+runkana i f v = kana i (Lan f v)
+
hunk ./src/Control/Morphism/Apo.hs 56
-
addfile ./src/Control/Morphism/Build.hs
hunk ./src/Control/Morphism/Build.hs 1
+{-# OPTIONS_GHC -fglasgow-exts #-}
+-----------------------------------------------------------------------------
+-- |
+-- Module      :  Control.Morphism.Build
+-- Copyright   :  (C) 2008 Edward Kmett
+-- License     :  BSD-style (see the file LICENSE)
+--
+-- Maintainer  :  Edward Kmett <ekmett@gmail.com>
+-- Stability   :  experimental
+-- Portability :  non-portable (rank-2 polymorphism)
+-- 
+----------------------------------------------------------------------------
+module Control.Morphism.Build where
+
+import Control.Functor.Extras
+import Control.Functor.HigherOrder
+import Control.Functor.KanExtension
+-- import Control.Functor.KanExtension.Interpreter
+-- import Control.Morphism.Cata
+
+-- | @forall h g.  hcata h . hbuild g = g h@ cannot be realized as a RULE because
+-- h and g are not monotypes.
+-- Kan extended build, gbuild in Ghani/Johann parlance, but g_foo currently denotes
+-- generalized in the 'has a parameterizing (co)monad' sense.
+hbuild :: (HFunctor f, Functor c) => (forall x. HAlgebra f x -> c :~> x) -> c :~> FixH f
+hbuild g = g InH
+
+-- | @ forall h g. kcata h . kbuild g = g (interpreterAlgebra h)@ cannot be realized as 
+-- a RULE because h and g are not monotypes.
+kbuild :: HFunctor f => (forall x. HAlgebra f x -> Lan g h :~> x) -> Lan g h :~> FixH f
+kbuild = hbuild
hunk ./src/Control/Morphism/Cata.hs 13
-module Control.Morphism.Cata where
+module Control.Morphism.Cata 
+	( cata, g_cata, distCata
+	, bicata, g_bicata
+	, hcata
+	, kcata, runkcata
+	) where
hunk ./src/Control/Morphism/Cata.hs 25
-import Control.Functor.HigherOrder
hunk ./src/Control/Morphism/Cata.hs 27
+import Control.Functor.HigherOrder
+import Control.Functor.KanExtension
+import Control.Functor.KanExtension.Interpreter
hunk ./src/Control/Morphism/Cata.hs 52
+kcata :: HFunctor f => InterpreterT f g h -> FixH f :~> Ran g h
+kcata i = hcata (interpreterAlgebra i)
+
+runkcata :: HFunctor f => InterpreterT f g h -> FixH f a -> (a -> g b) -> h b
+runkcata i = runRan . kcata i
+
hunk ./src/Control/Morphism/Chrono.hs 24
-chrono :: (Functor f, Functor g) => GAlgebra g (Cofree g) b -> (f :~> g) -> GCoalgebra f (Free f) a -> a -> b
+chrono :: (RunMonadFree f m, RunComonadCofree g w) => GAlgebra g w b -> (f :~> g) -> GCoalgebra f m a -> a -> b
hunk ./src/Control/Morphism/Chrono.hs 27
-g_chrono :: (Functor f, Functor g, Functor h, Functor j) => 
-	    Dist g h -> Dist j f -> GAlgebra g (Cofree h) b -> (f :~> g) -> GCoalgebra f (Free j) a -> a -> b
+g_chrono :: (Functor f, Functor g, RunComonadCofree h w, RunMonadFree j m) => 
+	    Dist g h -> Dist j f -> GAlgebra g w b -> (f :~> g) -> GCoalgebra f m a -> a -> b
addfile ./src/Control/Morphism/Destroy.hs
hunk ./src/Control/Morphism/Destroy.hs 1
+{-# OPTIONS_GHC -fglasgow-exts #-}
+-----------------------------------------------------------------------------
+-- |
+-- Module      :  Control.Morphism.Destroy
+-- Copyright   :  (C) 2008 Edward Kmett
+-- License     :  BSD-style (see the file LICENSE)
+--
+-- Maintainer  :  Edward Kmett <ekmett@gmail.com>
+-- Stability   :  experimental
+-- Portability :  non-portable (rank-2 polymorphism)
+-- 
+----------------------------------------------------------------------------
+module Control.Morphism.Destroy where
+
+import Control.Functor.Extras
+import Control.Functor.HigherOrder
+import Control.Functor.KanExtension
+-- import Control.Morphism.Ana
+
+-- | @forall h g . hdestroy g . hana h = g h@ cannot be realized as a RULE.
+hdestroy :: (HFunctor f, Functor c) => (forall g. HCoalgebra f g -> g :~> c) -> FixH f :~> c
+hdestroy g = g outH
+
+-- | @forall h g . kdestroy g . kana h = g (cointerpreterCoalgebra h)@ cannot be realized as a RULE
+kdestroy :: HFunctor f => (forall x. HCoalgebra f x -> x :~> Ran g h) -> FixH f :~> Ran g h
+kdestroy = kdestroy
hunk ./src/Control/Morphism/Dyna.hs 22
-dyna :: (Functor f, Functor g) => GAlgebra g (Cofree g) b -> (f :~> g) -> Coalgebra f a -> a -> b
+dyna :: (Functor f, RunComonadCofree g w) => GAlgebra g w b -> (f :~> g) -> Coalgebra f a -> a -> b
hunk ./src/Control/Morphism/Futu.hs 23
-futu :: Functor f => GCoalgebra f (Free f) a -> a -> FixF f
+-- futu :: Functor f => GCoalgebra f (Free f) a -> a -> FixF f
+futu :: (RunMonadFree f m) => GCoalgebra f m a -> a -> FixF f
hunk ./src/Control/Morphism/Futu.hs 27
-g_futu :: (Functor f, Functor h) => Dist h f -> GCoalgebra f (Free h) a -> a -> FixF f
+g_futu :: (Functor f, RunMonadFree h m) => Dist h f -> GCoalgebra f m a -> a -> FixF f
hunk ./src/Control/Morphism/Futu.hs 30
-distFutu :: (Functor f, Functor h) => Dist h f -> Dist (Free h) f
+distFutu :: (Functor f, RunMonadFree h m) => Dist h f -> Dist m f
hunk ./src/Control/Morphism/Histo.hs 23
-histo :: Functor f => GAlgebra f (Cofree f) a -> FixF f -> a
+histo :: (RunComonadCofree f w) => GAlgebra f w a -> FixF f -> a
hunk ./src/Control/Morphism/Histo.hs 26
-g_histo :: (Functor f, Functor h) => Dist f h -> GAlgebra f (Cofree h) a -> FixF f -> a
+g_histo :: (RunComonadCofree h w, Functor f) => Dist f h -> GAlgebra f w a -> FixF f -> a
hunk ./src/Control/Morphism/Histo.hs 29
-distHisto :: (Functor f, Functor h) => Dist f h -> Dist f (Cofree h)
+distHisto :: (RunComonadCofree h w, Functor f) => Dist f h -> Dist f w
hunk ./src/Control/Morphism/Hylo.hs 26
+-- | hylo :: (g b -> b) -> (forall c. f c -> g c) -> (a -> f b) -> a -> b
hunk ./src/Control/Morphism/Hylo.hs 30
-g_hylo :: (Comonad w, Functor f, Monad m) =>
-          Dist g w -> Dist m f -> GAlgebra g w b -> (f :~> g) -> GCoalgebra f m a -> a -> b
+-- | g_hylo :: (Comonad w, Functor f, Monad m) => (forall d. g (w d) -> w (g d)) -> (forall e. m (f e) -> f (m e)) -> (g (w b) -> b) -> (forall c. f c -> g c) -> a -> f (m a) -> a -> b
+g_hylo :: (Comonad w, Functor f, Monad m) => Dist g w -> Dist m f -> GAlgebra g w b -> (f :~> g) -> GCoalgebra f m a -> a -> b
addfile ./src/Control/Morphism/Span.hs
hunk ./src/Control/Morphism/Span.hs 1
+{-# OPTIONS_GHC -fglasgow-exts #-}
+-----------------------------------------------------------------------------
+-- |
+-- Module      :  Control.Morphism.Span
+-- Copyright   :  (C) 2008 Edward Kmett
+-- License     :  BSD-style (see the file LICENSE)
+--
+-- Maintainer  :  Edward Kmett <ekmett@gmail.com>
+-- Stability   :  experimental
+-- Portability :  non-portable (rank-2 polymorphism)
+--
+-- Spans and Cospans
+-- <http://en.wikipedia.org/wiki/Span_(category_theory)>
+----------------------------------------------------------------------------
+module Control.Morphism.Span 
+	( Span(..)
+	, Cospan(..)
+	) where
+
+newtype Span (~>) x y z = Span { runSpan :: (y ~> x, y ~> z) }
+newtype Cospan (~>) x y z = Cospan { runCospan :: (x ~> y, z ~> y) }
}
