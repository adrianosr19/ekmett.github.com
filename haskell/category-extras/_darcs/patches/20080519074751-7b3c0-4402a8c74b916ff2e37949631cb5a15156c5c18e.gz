[typo fixes. elgot redux
ekmett@gmail.com**20080519074751] {
hunk ./src/Control/Comonad/Cofree.hs 18
-	, coimprove, worsten
+	, coimprove, worsen
hunk ./src/Control/Comonad/Cofree.hs 56
-worsten :: Functor f => (forall w. CofreeLike f w => w a) -> Cofree f a
-worsten m = corep m 
+worsen :: Functor f => (forall w. CofreeLike f w => w a) -> Cofree f a
+worsen m = corep m 
hunk ./src/Control/Functor/Algebra/Elgot.hs 14
+-- Elgot algebras given you a shortcircuitable hylomorphism where you
+-- can directly return a sub-answer to the catamorphism.
hunk ./src/Control/Functor/Algebra/Elgot.hs 21
+--	, g_coelgot
hunk ./src/Control/Functor/Algebra/Elgot.hs 24
-import Control.Arrow ((|||),(&&&),(+++))
+import Control.Arrow ((|||),(&&&))
hunk ./src/Control/Functor/Algebra/Elgot.hs 26
-import Control.Functor.Extras
-import Control.Comonad
+-- import Control.Functor.Extras
+-- import Control.Comonad
+-- import Control.Monad
hunk ./src/Control/Functor/Algebra/Elgot.hs 31
-elgot a e = h where h = (id ||| a . fmap h) . e 
+elgot phi psi = h where h = (id ||| phi . fmap h) . psi
hunk ./src/Control/Functor/Algebra/Elgot.hs 34
-coelgot e a = h where h = e . (id &&& fmap h . a)
+coelgot phi psi = h where h = phi . (id &&& fmap h . psi)
hunk ./src/Control/Functor/Algebra/Elgot.hs 36
--- g_elgot :: (Comonad w, Functor f) => Dist f w -> GAlgebra f w a -> (b -> Either a (f b)) -> b -> a
--- g_elgot k a e = (id ||| extract) . h where 
---	h :: b -> Either a (w a)
---	h = (id +++ liftW a . k . fmap (duplicate . h)) . e 
+-- ideally this would have b -> Either a (f b)
+-- g_elgot :: (Comonad w, Functor f) => Dist f w -> GAlgebra f w a -> (b -> Either (w a) (f b)) -> b -> a
+-- g_elgot k phi psi = extract . h where 
+-- 	h = (id ||| liftW phi . k . fmap (duplicate . h)) . psi
+
+-- g_coelgot :: (Monad m, Functor f) => Dist m f -> ((m a, f b) -> b) -> GCoalgebra f m a -> a -> b
+-- g_coelgot k phi psi = h . return where
+--	h = phi . (id &&& fmap (h . join) . k . liftM psi)
}
