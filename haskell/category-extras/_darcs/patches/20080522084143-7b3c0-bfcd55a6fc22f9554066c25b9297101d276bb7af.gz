[0.51.0
ekmett@gmail.com**20080522084143] {
hunk ./CHANGELOG 20
+0.50.4
+------
+* Added the Yoneda lemma as a right Kan extension along the Identity monad
+* Added limits and colimits and right and left Kan extensions
+* Added adjunction composition and higher order adjunction composition
+* Added adjunctions as Kan extensions in Control.Functor.Adjunction
+* Lifted more monad instances into right Kan extensions
+* Renamed (Co)freeLike to (Co)monad(Co)ideal
+* Added a lot of HFunctor instances including much of the MTL.
+
hunk ./Makefile 2
+# OPTIONS = --with-ghc=ghc-6.6 --with-ghc-pkg=ghc-pkg-6.6
hunk ./category-extras.cabal 3
-version:                0.50.3
+version:                0.51.0
hunk ./category-extras.cabal 22
-flag ArrowSubclassesCategory {
+flag ArrowSubclassesCategory
hunk ./category-extras.cabal 26
-}
hunk ./category-extras.cabal 27
-flag TypeFamilies {
-       description:    Support for Type Families is available to us
-}
+flag RedefinableEitherMonad
+        description:         Indicates Control.Monad.Error isn't baked into the Prelude
hunk ./category-extras.cabal 30
-flag Optimize { 
+flag TypeFamilies
+        description:    Support for Type Families is available to us
+
+flag Optimize
hunk ./category-extras.cabal 36
-}
hunk ./category-extras.cabal 37
-library { 
-        build-depends:  base > 3, mtl, array
+library
+        build-depends:  mtl >= 1.1
hunk ./category-extras.cabal 80
+                Control.Functor.Categorical,
hunk ./category-extras.cabal 102
+                Control.Functor.Yoneda,
hunk ./category-extras.cabal 124
+                Control.Morphism.Universal,
hunk ./category-extras.cabal 132
-        if flag(ArrowSubclassesCategory) {
-                build-depends: ghc >= 6.9
+        if flag(ArrowSubclassesCategory)
+                build-depends: ghc >= 6.9, base > 3, array
hunk ./category-extras.cabal 135
-        } else { 
-                build-depends: ghc < 6.9
-        }
+        else
+                build-depends: ghc < 6.9, base
+                hs-source-dirs: pre-6.9
+                exposed-modules: Control.Category
+
+        if flag(RedefinableEitherMonad)
+                build-depends: ghc >= 6.8 
+        else
+                cpp-options: -D__BROKEN_EITHER__=1
hunk ./category-extras.cabal 145
-        if flag(TypeFamilies) {
+        if flag(TypeFamilies)
hunk ./category-extras.cabal 148
-        }
hunk ./category-extras.cabal 149
-        if flag(Optimize) {
+        if flag(Optimize)
hunk ./category-extras.cabal 151
-        }
-}
-
hunk ./src/Control/Category/Cartesian.hs 30
-import qualified Prelude
+import qualified Prelude (fst,snd)
hunk ./src/Control/Category/Hask.hs 11
+-- Make it clearer when we are dealing with the category (->) that we mean the category
+-- of haskell types via its Hom bifunctor (->)
hunk ./src/Control/Category/Hask.hs 14
-module Control.Category.Hask
-	( Hask
-	) where
+module Control.Category.Hask (Hask) where
hunk ./src/Control/Comonad/Cofree.hs 15
-	, outCofree, runCofree, anaCofree, cofree
-	, CofreeLike(unwrap)
-	, Expensive(..)
-	, coimprove, worsen
+	, runCofree, anaCofree, cofree
+	, ComonadCofree(outCofree)
hunk ./src/Control/Comonad/Cofree.hs 23
-import Control.Functor.KanExtension
hunk ./src/Control/Comonad/Cofree.hs 24
+import Control.Comonad.Reader
hunk ./src/Control/Comonad/Cofree.hs 28
-outCofree :: Cofree f a -> f (Cofree f a)
-outCofree = snd . runCofree
-
hunk ./src/Control/Comonad/Cofree.hs 37
-class (Functor f, Comonad w) => CofreeLike f w | w -> f where
-        unwrap :: w a -> f (w a)
-
-instance Functor f => CofreeLike f (Cofree f) where
-        unwrap = outCofree 
-
-instance CofreeLike f w => CofreeLike f (Lan w w) where
-        unwrap (Lan f c) = fmap (Lan f) (unwrap c)
-
-data Expensive f a = forall w. CofreeLike f w => Expensive { runExpensive :: w a }
+class (Functor f, Comonad w) => ComonadCofree f w | w -> f where
+        outCofree :: w a -> f (w a)
hunk ./src/Control/Comonad/Cofree.hs 40
-coimprove :: Functor f => Cofree f a -> Expensive f a
-coimprove m = Expensive (coabs m)
+instance Functor f => ComonadCofree f (Cofree f) where
+        outCofree = snd . runCofree
hunk ./src/Control/Comonad/Cofree.hs 43
-worsen :: Functor f => (forall w. CofreeLike f w => w a) -> Cofree f a
-worsen m = corep m 
+instance ComonadCofree f w => ComonadCofree f (CoreaderT w e) where
+	outCofree = fmap CoreaderT . outCofree . runCoreaderT
hunk ./src/Control/Functor.hs 14
-	( CFunctor (cmap)
-	, PFunctor (first), first'
+	( PFunctor (first), first'
hunk ./src/Control/Functor.hs 22
-import Control.Monad.Identity
-import Control.Monad.Reader
-import Control.Monad.List
-import Control.Monad.Cont
-import Control.Monad.Writer.Strict as SW
-import Control.Monad.Writer.Lazy as LW
-import Control.Monad.State.Strict as SS
-import Control.Monad.State.Lazy as LS
-import Control.Monad.RWS.Strict as SRWS
-import Control.Monad.RWS.Lazy as LRWS
-
hunk ./src/Control/Functor.hs 62
-class (Category r, Category s) => CFunctor f r s | f r -> s,  f s -> r where
-	cmap :: r a b -> s (f a) (f b)
-
-instance CFunctor ([]) Hask Hask where cmap = fmap 
-instance CFunctor Maybe Hask Hask where cmap = fmap
-instance CFunctor (Either a) Hask Hask where cmap = fmap 
-instance CFunctor Identity Hask Hask where cmap = fmap
-instance CFunctor ((,)e) Hask Hask where cmap = fmap
-instance CFunctor (Reader e) Hask Hask where cmap = fmap
-instance CFunctor (LW.Writer e) Hask Hask where cmap = fmap
-instance CFunctor (SW.Writer e) Hask Hask where cmap = fmap
-instance CFunctor (LS.State s) Hask Hask where cmap = fmap
-instance CFunctor (SS.State s) Hask Hask where cmap = fmap
-instance CFunctor (Cont e) Hask Hask where cmap = fmap
-instance CFunctor (SRWS.RWS r w s) Hask Hask where cmap = fmap
-instance CFunctor (LRWS.RWS r w s) Hask Hask where cmap = fmap
-instance CFunctor IO Hask Hask where cmap = fmap
-
-instance Monad m => CFunctor (ReaderT e m) Hask Hask where cmap = fmap
-instance Monad m => CFunctor (LW.WriterT e m) Hask Hask where cmap = fmap
-instance Monad m => CFunctor (LS.StateT e m) Hask Hask where cmap = fmap
-instance Monad m => CFunctor (ContT r m) Hask Hask where cmap = fmap
-instance Monad m => CFunctor (ListT m) Hask Hask where cmap = fmap
-instance Monad m => CFunctor (LRWS.RWST r w s m) Hask Hask where cmap = fmap
-instance Monad m => CFunctor (SW.WriterT w m) Hask Hask where cmap = fmap
-instance Monad m => CFunctor (SS.StateT s m) Hask Hask where cmap = fmap
-instance Monad m => CFunctor (SRWS.RWST r w s m) Hask Hask where cmap = fmap
-
-
hunk ./src/Control/Functor/Adjunction.hs 14
-module Control.Functor.Adjunction where
+module Control.Functor.Adjunction 
+	( Adjunction (unit, counit, leftAdjunct, rightAdjunct)
+	, ACompF(ACompF)
+	) where
hunk ./src/Control/Functor/Adjunction.hs 22
+import Control.Functor.HigherOrder
hunk ./src/Control/Functor/Adjunction.hs 25
-import Control.Monad.Instances
-import Control.Comonad
+import Control.Monad.State
+import Control.Monad.Identity
hunk ./src/Control/Functor/Adjunction.hs 28
+import Control.Comonad.Context
hunk ./src/Control/Functor/Adjunction.hs 38
-class (Functor f, Functor g) => Adjunction f g where
+class (Functor f, Functor g) => Adjunction f g | f -> g, g -> f where
hunk ./src/Control/Functor/Adjunction.hs 49
+instance (Adjunction f1 g1, Adjunction f2 g2) => Adjunction (CompF f2 f1) (CompF g1 g2) where
+	counit = counit . fmap (counit . fmap decompose) . decompose
+	unit = compose . fmap (fmap compose . unit) . unit
hunk ./src/Control/Functor/Adjunction.hs 54
-newtype ACompF f g a = ACompF (CompF f g a) deriving (Functor, ExpFunctor, Full, Composition)
+newtype ACompF f g a = ACompF (CompF f g a) deriving (Functor, ExpFunctor, Full, Composition, HFunctor)
hunk ./src/Control/Functor/Adjunction.hs 81
--- instance Adjunction f g => Adjunction (CoreaderT e f) (ReaderT e g) where
+instance ComonadContext e ((,)e `ACompF` (->)e) where
+	getC = fst . decompose
+	modifyC f = uncurry (flip id . f) . decompose
+
+instance MonadState e ((->)e `ACompF` (,)e) where
+	get = compose $ \s -> (s,s)
+	put s = compose $ const (s,())
hunk ./src/Control/Functor/Adjunction/HigherOrder.hs 18
+import Control.Functor.HigherOrder.Composition
hunk ./src/Control/Functor/Adjunction/HigherOrder.hs 32
+
+instance (HAdjunction f1 g1, HAdjunction f2 g2) => HAdjunction (CompH f2 f1) (CompH g1 g2) where
+        hcounit = hcounit . hfmap (hcounit . hfmap hdecompose) . hdecompose
+        hunit = hcompose . hfmap (hfmap hcompose . hunit) . hunit
+
addfile ./src/Control/Functor/Categorical.hs
hunk ./src/Control/Functor/Categorical.hs 1
+-------------------------------------------------------------------------------------------
+-- |
+-- Module	: Control.Functor.Categorical
+-- Copyright 	: 2008 Edward Kmett
+-- License	: BSD3
+--
+-- Maintainer	: Edward Kmett <ekmett@gmail.com>
+-- Stability	: experimental
+-- Portability	: non-portable (functional-dependencies)
+--
+-- A more categorical definition of Functor than endofunctors in the category Hask
+-------------------------------------------------------------------------------------------
+module Control.Functor.Categorical
+	( CFunctor (cmap)
+	) where
+
+import Prelude hiding (id,(.))
+import Control.Category
+import Control.Category.Hask
+import Control.Monad.Identity
+import Control.Monad.List
+import Control.Monad.Cont
+
+import Control.Monad.Reader
+import Control.Monad.Writer as LW
+import Control.Monad.State as LS
+
+import Control.Monad.RWS as LRWS
+#if __GLASGOW_HASKELL__ >= 608
+import Control.Monad.Writer.Strict as SW
+import Control.Monad.State.Strict as SS
+import Control.Monad.RWS.Strict as SRWS
+#endif
+
+class (Category r, Category s) => CFunctor f r s | f r -> s,  f s -> r where
+	cmap :: r a b -> s (f a) (f b)
+
+instance CFunctor ([]) Hask Hask where cmap = fmap 
+instance CFunctor Maybe Hask Hask where cmap = fmap
+instance CFunctor (Either a) Hask Hask where cmap = fmap 
+instance CFunctor Identity Hask Hask where cmap = fmap
+instance CFunctor ((,)e) Hask Hask where cmap = fmap
+instance CFunctor (Reader e) Hask Hask where cmap = fmap
+instance CFunctor (LW.Writer e) Hask Hask where cmap = fmap
+instance CFunctor (LS.State s) Hask Hask where cmap = fmap
+instance CFunctor (Cont e) Hask Hask where cmap = fmap
+instance CFunctor (LRWS.RWS r w s) Hask Hask where cmap = fmap
+instance CFunctor IO Hask Hask where cmap = fmap
+
+instance Monad m => CFunctor (ReaderT e m) Hask Hask where cmap = fmap
+instance Monad m => CFunctor (LW.WriterT e m) Hask Hask where cmap = fmap
+instance Monad m => CFunctor (LS.StateT e m) Hask Hask where cmap = fmap
+instance Monad m => CFunctor (ContT r m) Hask Hask where cmap = fmap
+instance Monad m => CFunctor (ListT m) Hask Hask where cmap = fmap
+instance Monad m => CFunctor (LRWS.RWST r w s m) Hask Hask where cmap = fmap
+
+#if __GLASGOW_HASKELL__ >= 608
+instance CFunctor (SW.Writer e) Hask Hask where cmap = fmap
+instance CFunctor (SS.State s) Hask Hask where cmap = fmap
+instance CFunctor (SRWS.RWS r w s) Hask Hask where cmap = fmap
+instance Monad m => CFunctor (SW.WriterT w m) Hask Hask where cmap = fmap
+instance Monad m => CFunctor (SS.StateT s m) Hask Hask where cmap = fmap
+instance Monad m => CFunctor (SRWS.RWST r w s m) Hask Hask where cmap = fmap
+#endif
hunk ./src/Control/Functor/Combinators/Flip.hs 1
-{-# LANGUAGE TypeFamilies #-}
hunk ./src/Control/Functor/Combinators/Lift.hs 28
+import Control.Functor.HigherOrder
hunk ./src/Control/Functor/Combinators/Lift.hs 54
+instance (Bifunctor p Hask Hask Hask) => HFunctor (Ap p) where
+        ffmap f = Lift . bimap (fmap f) (fmap f) . runLift
+        hfmap f = Lift . second f . runLift
+
+
hunk ./src/Control/Functor/Composition.hs 12
--- Generalized functor composeosition.
+-- Generalized functor composition.
+-- Since we have many reasons for which you might want to compose a functor, and many 
+-- expected results. i.e. monads via adjunctions, monads via composition with a pointed
+-- endofunctor, etc. we have to make multiple composition operators.
hunk ./src/Control/Functor/Composition.hs 33
+import Control.Functor.HigherOrder
hunk ./src/Control/Functor/Composition.hs 41
+-- | Basic functor composition
hunk ./src/Control/Functor/Composition.hs 48
+instance Functor f => HFunctor (CompF f) where
+	ffmap = fmap
+	hfmap f = compose . fmap f . decompose
+
+-- | An infix alias for functor composition
hunk ./src/Control/Functor/Composition.hs 65
+-- | The only reason the compositions are all the same is for type inference. This can be liberalized.
hunk ./src/Control/Functor/Composition.hs 72
+
+-- | Bifunctor composition
hunk ./src/Control/Functor/Composition.hs 75
+-- | Bifunctor coproduct
hunk ./src/Control/Functor/Composition.hs 77
+-- | Bifunctor product
addfile ./src/Control/Functor/End.hs
hunk ./src/Control/Functor/End.hs 1
+-----------------------------------------------------------------------------
+-- |
+-- Module      :  Control.Functor.End
+-- Copyright   :  (C) 2008 Edward Kmett
+-- License     :  BSD-style (see the file LICENSE)
+--
+-- Maintainer  :  Edward Kmett <ekmett@gmail.com>
+-- Stability   :  experimental
+-- Portability :  non-portable (rank-2 polymorphism)
+--
+----------------------------------------------------------------------------
+module Control.Functor.End where
+
+newtype End f = End { runEnd :: forall i. f i i } 
+data Coend f = forall i. Coend { runCoend :: f i i } 
hunk ./src/Control/Functor/Extras.hs 18
+
hunk ./src/Control/Functor/Extras.hs 21
+
+-- Its bifunctorial analogue
hunk ./src/Control/Functor/Extras.hs 25
+-- Dinatural transformations
+type Dinatural f g = forall a. f a a -> g a a
+
hunk ./src/Control/Functor/HigherOrder.hs 25
+import Control.Functor
hunk ./src/Control/Functor/HigherOrder.hs 28
+import Control.Monad.Reader
+import Control.Monad.State.Lazy
+import Control.Monad.Writer.Lazy
+import Control.Monad.List
hunk ./src/Control/Functor/HigherOrder.hs 62
+instance HFunctor (ReaderT e) where
+	ffmap f g = ReaderT (fmap f . runReaderT g) 
+	hfmap f g = ReaderT (f . runReaderT g)
+
+instance HPointed (ReaderT e) where
+	hreturn = ReaderT . const
+
+instance HFunctor (StateT e) where
+	ffmap f (StateT g) = StateT (fmap (first f) . g)
+	hfmap f (StateT g) = StateT (f . g)
+
+instance HPointed (StateT e) where
+	hreturn m = StateT (\s -> fmap (\a -> (a,s)) m) 
+
+instance HFunctor (WriterT e) where
+	ffmap f = WriterT . fmap (first f) . runWriterT 
+	hfmap f = WriterT . f . runWriterT
+
+instance Monoid e => HPointed (WriterT e) where
+	hreturn = WriterT . fmap (\a -> (a,mempty))
+
+instance HFunctor ListT where
+	ffmap f = ListT . fmap (fmap f) . runListT 
+	hfmap f = ListT . f . runListT
+
+instance HPointed ListT where
+	hreturn = ListT . fmap return
+
hunk ./src/Control/Functor/KanExtension.hs 14
--- and the comonad cogenerated by a functor @Lan f f@.
+-- and the comonad cogenerated by a functor @Lan f f@
+-- and machinery for lifting (co)monads into and lowering (co)monads out of 
+-- Kan extensions.
hunk ./src/Control/Functor/KanExtension.hs 19
-	( Ran(..)
+	( 
+	-- * Right Kan Extensions
+	  Ran(..)
hunk ./src/Control/Functor/KanExtension.hs 23
+	, liftRan, lowerRan
+	, adjointToRan, ranToAdjoint
+	, ranToComposedAdjoint, composedAdjointToRan
+	, composeRan, decomposeRan
+	-- * Left Kan Extensions
hunk ./src/Control/Functor/KanExtension.hs 30
-	, rep, abs
-	, corep, coabs
+	, liftLan, lowerLan
+	, adjointToLan, lanToAdjoint
+	, composeLan, decomposeLan
+	, lanToComposedAdjoint, composedAdjointToLan
+	-- * Performance tweaks for (co)free comonads
+	, improveFree
+	, worsenCofree
hunk ./src/Control/Functor/KanExtension.hs 40
+import Control.Comonad.Context
+import Control.Comonad.Cofree
hunk ./src/Control/Functor/KanExtension.hs 46
-import Control.Comonad
-import Control.Monad.Cont
+import Control.Functor.Adjunction
+import Control.Monad.State
+import Control.Monad.Reader
+import Control.Monad.Identity
+import Control.Monad.Free
hunk ./src/Control/Functor/KanExtension.hs 55
+-- | Nat(k `o` g, h) is isomorphic to Nat(k, Ran g h) (forwards)
hunk ./src/Control/Functor/KanExtension.hs 59
+-- | Nat(k `o` g, h) is isomorphic to Nat(k, Ran g h) (backwards)
hunk ./src/Control/Functor/KanExtension.hs 77
--- | See <http://wwwtcs.inf.tu-dresden.de/%7Evoigt/mpc08.pdf>
-rep :: Monad m => m a -> Ran m m a
-rep m = Ran (m >>=)
+-- | The natural isomorphism from @Ran f (Ran g h)@ to @Ran (f `o` g) h@ (forwards)
+composeRan :: Composition o => Ran f (Ran g h) :~> Ran (f `o` g) h
+composeRan r = Ran (\f -> runRan (runRan r (decompose . f)) id)
hunk ./src/Control/Functor/KanExtension.hs 81
-abs :: Monad m => Ran m m a -> m a 
-abs a = runRan a return
+-- | The natural isomorphism from @Ran f (Ran g h)@ to @Ran (f `o` g) h@ (backwards)
+decomposeRan :: (Functor f, Composition o) => Ran (f `o` g) h :~> Ran f (Ran g h)
+decomposeRan r = Ran (\f -> Ran (\g -> runRan r (compose . fmap g . f)))
+
+-- | Lift a monad into its right Kan extension along itself. This is the same operation
+-- as is performed by Voightlaender's rep in <http://wwwtcs.inf.tu-dresden.de/%7Evoigt/mpc08.pdf>
+-- and the ContT monad's lift operation. This is also viewable as the forward half of the 
+-- natural isomorphism between a monad m and the monad generated by m.
+liftRan :: Monad m => m a -> Ran m m a
+liftRan m = Ran (m >>=)
+
+-- | The natural isomorphism between a monad m and the monad generated by m (backwards)
+lowerRan :: Monad m => Ran m m a -> m a 
+lowerRan a = runRan a return
+
+instance MonadReader r m => MonadReader r (Ran m m) where
+	ask = liftRan ask
+	local f m = Ran (\c -> ask >>= \r -> local f (runRan m (local (const r) . c)))
+
+instance MonadIO m => MonadIO (Ran m m) where
+	liftIO = liftRan . liftIO 
+
+instance MonadState s m => MonadState s (Ran m m) where
+	get = liftRan get
+	put = liftRan . put
+
+instance MonadFree f m => MonadFree f (Ran m m) where
+        inFree t = Ran (inFree . flip fmap t . flip runRan)
+
+-- | @f -| g@ iff @Ran g Identity@ exists (forward)
+adjointToRan :: Adjunction f g => f :~> Ran g Identity
+adjointToRan f = Ran (\a -> Identity $ rightAdjunct a f)
+
+-- | @f -| g@ iff @Ran g Identity@ exists (backwards)
+ranToAdjoint :: Adjunction f g => Ran g Identity :~> f
+ranToAdjoint r = runIdentity (runRan r unit)
+
+ranToComposedAdjoint :: (Composition o, Adjunction f g) => Ran g h :~> (h `o` f)
+ranToComposedAdjoint r = compose (runRan r unit)
+
+composedAdjointToRan :: (Functor h, Composition o, Adjunction f g) => (h `o` f) :~> Ran g h
+composedAdjointToRan f = Ran (\a -> fmap (rightAdjunct a) (decompose f))
hunk ./src/Control/Functor/KanExtension.hs 127
+-- | @Nat(h, f.g)@ is isomorphic to @Nat (Lan g h, f)@ (forwards)
hunk ./src/Control/Functor/KanExtension.hs 131
+-- | @Nat(h, f.g)@ is isomorphic to @Nat (Lan g h, f)@ (backwards)
hunk ./src/Control/Functor/KanExtension.hs 148
-coabs :: Comonad w => w a -> Lan w w a
-coabs = Lan extract 
+-- | The natural isomorphism between a comonad w and the comonad generated by w (forwards).
+liftLan :: Comonad w => w a -> Lan w w a
+liftLan = Lan extract 
+
+-- | The natural isomorphism between a comonad w and the comonad generated by w (backwards).
+lowerLan :: Comonad w => Lan w w a -> w a 
+lowerLan (Lan f c) = extend f c
+
+-- | f -| g iff Lan f Identity is inhabited (forwards)
+adjointToLan :: Adjunction f g => g :~> Lan f Identity
+adjointToLan = Lan counit . Identity
+
+-- | f -| g iff Lan f Identity is inhabited (backwards)
+lanToAdjoint :: Adjunction f g => Lan f Identity :~> g
+lanToAdjoint (Lan f v) = leftAdjunct f (runIdentity v)
+
+lanToComposedAdjoint :: (Functor h, Composition o, Adjunction f g) => Lan f h :~> (h `o` g)
+lanToComposedAdjoint (Lan f v) = compose (fmap (leftAdjunct f) v)
+
+composedAdjointToLan :: (Composition o, Adjunction f g) => (h `o` g) :~> Lan f h 
+composedAdjointToLan = Lan counit . decompose
+
+instance ComonadContext e m => ComonadContext e (Lan m m) where
+        getC = getC . lowerLan 
+	modifyC f = modifyC f . lowerLan
+
+instance ComonadCofree f w => ComonadCofree f (Lan w w) where
+        outCofree (Lan f c) = fmap (Lan f) (outCofree c)
+
+-- | the natural isomorphism from @Lan f (Lan g h)@ to @Lan (f `o` g) h@ (forwards)
+composeLan :: (Functor f, Composition o) => Lan f (Lan g h) :~> Lan (f `o` g) h
+composeLan (Lan f (Lan g h)) = Lan (f . fmap g . decompose) h
+
+-- | the natural isomorphism from @Lan f (Lan g h)@ to @Lan (f `o` g) h@ (backwards)
+decomposeLan :: Composition o => Lan (f `o` g) h :~> Lan f (Lan g h)
+decomposeLan (Lan f h) = Lan (f . compose) (Lan id h)
+
+
+-- | Voigtlaender's asymptotic performance improvement for free monads
+improveFree :: Functor f => (forall m. MonadFree f m => m a) -> Free f a
+improveFree m = lowerRan m
hunk ./src/Control/Functor/KanExtension.hs 190
-corep :: Comonad w => Lan w w a -> w a 
-corep (Lan f c) = extend f c
+worsenCofree :: Functor f => (forall w. ComonadCofree f w => w a) -> Cofree f a
+worsenCofree m = lowerLan m
hunk ./src/Control/Functor/KanExtension.hs 193
+-- data AnyCofree f a = forall w. ComonadCofree f w => AnyCofree { runAnyCofree :: w a }
+-- coimprove :: Functor f => Cofree f a -> AnyCofree f a
+-- coimprove m = AnyCofree (liftLan m)
hunk ./src/Control/Functor/Strong.hs 16
-import Prelude hiding (sequence)
+import Prelude hiding (sequence,Either)
hunk ./src/Control/Functor/Strong.hs 18
-import Control.Monad.Either ()
+import Control.Monad.Either (Either(..))
hunk ./src/Control/Functor/Strong.hs 20
-strength :: Functor f => f a -> b -> f (a,b)
-strength fa b = fmap (\a -> (a,b)) fa
+strength :: Functor f => a -> f b -> f (a,b)
+strength a fb = fmap ((,)a) fb
addfile ./src/Control/Functor/Yoneda.hs
hunk ./src/Control/Functor/Yoneda.hs 1
+-------------------------------------------------------------------------------------------
+-- |
+-- Module	: Control.Functor.Yoneda
+-- Copyright 	: 2008 Edward Kmett
+-- License	: BSD
+--
+-- Maintainer	: Edward Kmett <ekmett@gmail.com>
+-- Stability	: experimental
+-- Portability	: portable
+--
+-- The Yoneda lemma materialized as a Kan extension, and hence as a higher order functor
+-------------------------------------------------------------------------------------------
+
+module Control.Functor.Yoneda
+	( Yoneda
+	, toYoneda, fromYoneda
+	) where
+
+import Control.Functor.KanExtension
+import Control.Functor.Extras
+import Control.Monad.Identity
+
+type Yoneda = Ran Identity
+
+toYoneda :: Functor f => f :~> Yoneda f
+toYoneda a = Ran (\f -> fmap (runIdentity . f) a)
+
+fromYoneda :: Yoneda f :~> f 
+fromYoneda t = runRan t Identity
+
+-- newtype Yoneda f a = Yoneda { runYoneda :: forall b. (a -> b) -> f b } 
+-- instance HFunctor Yoneda where
+--	ffmap f (Yoneda t) = check (t f)
+--	hfmap f (Yoneda t) = Yoneda (f . t)
hunk ./src/Control/Monad/Either.hs 17
-	( Either(..)
-	, EitherT(..)
+	( Either(Left,Right)
+	, EitherT(EitherT,runEitherT)
hunk ./src/Control/Monad/Either.hs 21
-import Data.Either
+import Control.Functor.Pointed
hunk ./src/Control/Monad/Either.hs 23
-import Control.Monad
hunk ./src/Control/Monad/Either.hs 24
-import Control.Functor.Pointed
hunk ./src/Control/Monad/Either.hs 25
-newtype EitherT a m b = EitherT { runEitherT :: m (Either a b) }
+#if __BROKEN_EITHER__
+import Prelude hiding (Either(Left,Right))
+#endif
hunk ./src/Control/Monad/Either.hs 29
-{-
+-- we have to define our own because the Control.Monad.Error instance is 
+-- baked into the prelude on old versions.
+#if __BROKEN_EITHER__
+data Either a b = Left a | Right b
hunk ./src/Control/Monad/Either.hs 36
+#endif
hunk ./src/Control/Monad/Either.hs 38
-instance Pointed (Either e) where
-	point = Right
--}
+newtype EitherT a m b = EitherT { runEitherT :: m (Either a b) }
hunk ./src/Control/Monad/Either.hs 40
-instance Applicative (Either e) where
-	pure = Right
-	(<*>) = ap
+-- defined in Control.Functor.Pointed
+--instance Pointed (Either e) where
+--	point = Right
hunk ./src/Control/Monad/Either.hs 49
+instance Applicative (Either e) where
+	pure = Right
+	a <*> b = do x <- a; y <- b; return (x y)
+
hunk ./src/Control/Monad/Either.hs 61
-        fmap f = EitherT . fmap (fmap f) . runEitherT
+	fmap f = EitherT . fmap (fmap f) . runEitherT
hunk ./src/Control/Monad/Free.hs 22
-	, inFree
hunk ./src/Control/Monad/Free.hs 25
-	-- * Improving asymptotic performance with right Kan extensions
-	, FreeLike(wrap)
-	, improve
+	, MonadFree(inFree)
hunk ./src/Control/Monad/Free.hs 28
-import Prelude hiding ((.),id,abs)
+import Prelude hiding ((.),id)
hunk ./src/Control/Monad/Free.hs 33
-import Control.Functor.KanExtension
hunk ./src/Control/Monad/Free.hs 36
+import Control.Monad.Reader
hunk ./src/Control/Monad/Free.hs 40
-inFree :: f (Free f a) -> Free f a
-inFree = InB . Biff . Right
-
hunk ./src/Control/Monad/Free.hs 49
-class (Functor f, Monad m) => FreeLike f m where
-        wrap :: f (m a) -> m a
+class (Functor f, Monad m) => MonadFree f m | m -> f where
+        inFree :: f (m a) -> m a
hunk ./src/Control/Monad/Free.hs 52
-instance FreeLike f m => FreeLike f (Ran m m) where
-        wrap t = Ran (wrap . flip fmap t . flip runRan)
+instance Functor f => MonadFree f (Free f) where
+        inFree = InB . Biff . Right
hunk ./src/Control/Monad/Free.hs 55
-instance Functor f => FreeLike f (Free f) where
-        wrap = inFree
+instance MonadFree f m => MonadFree f (ReaderT e m) where
+	inFree fma = ReaderT (\e -> inFree $ fmap (flip runReaderT e) fma)
hunk ./src/Control/Monad/Free.hs 58
-improve :: Functor f => (forall m. FreeLike f m => m a) -> Free f a
-improve m = abs m 
+-- instance (MonadFree f m, Traversable f) => MonadFree f (StateT e m) where
hunk ./src/Control/Monad/Indexed/Cont.hs 10
--- Portability	: Rank-2 Types
---
+-- Portability	: rank-2 Types required for correctness of shift, but they can be removed
hunk ./src/Control/Monad/Indexed/Cont.hs 13
-module Control.Monad.Indexed.Cont where
+module Control.Monad.Indexed.Cont 
+	( IxMonadCont(reset, shift)
+	, IxContT(IxContT, runIxContT)
+	, runIxContT_
+	, IxCont(IxCont)
+	, runIxCont
+	, runIxCont_
+	) where
hunk ./src/Control/Monad/Indexed/Cont.hs 27
--- import Control.Monad.Cont.Class
-import Control.Monad.State.Class
-import Control.Monad.Reader.Class
+import Control.Monad.State
+import Control.Monad.Reader
hunk ./src/Control/Monad/Indexed/State.hs 29
-import Control.Monad.Writer.Class
-import Control.Monad.Reader.Class
-import Control.Monad.Cont.Class
+import Control.Monad.Writer
+import Control.Monad.Reader
+import Control.Monad.Cont
hunk ./src/Control/Monad/Indexed/State.hs 34
-
hunk ./src/Control/Morphism/Apo.hs 23
-
hunk ./src/Control/Morphism/Apo.hs 27
-import Control.Monad.Either
+import Control.Monad.Either 
addfile ./src/Control/Morphism/Universal.hs
hunk ./src/Control/Morphism/Universal.hs 1
+-------------------------------------------------------------------------------------------
+-- |
+-- Module	: Control.Morphism.Universal
+-- Copyright 	: 2008 Edward Kmett
+-- License	: BSD3
+--
+-- Maintainer	: Edward Kmett <ekmett@gmail.com>
+-- Stability	: experimental
+-- Portability	: portable
+--
+-- Note the choice of which is universal and which is couniversal is chosen to 
+-- make the definitions consistent with limits and colimits.
+
+-------------------------------------------------------------------------------------------
+
+module Control.Morphism.Universal
+	( Couniversal(..), extractCouniversal, universalize
+	, Universal(..), extractUniversal, couniversalize
+	) where
+
+data Couniversal a f x = Couniversal (a -> f x) (forall z. (a -> f z) -> x -> z)
+
+extractCouniversal :: Couniversal a f x -> a -> f x
+extractCouniversal (Couniversal f _) = f
+
+couniversalize :: (a -> f z) -> Couniversal a f x -> x -> z
+couniversalize f (Couniversal _ s) = s f
+
+data Universal a f x = Universal (f x -> a) (forall z. (f z -> a) -> z -> x)
+
+extractUniversal :: Universal a f x -> f x -> a
+extractUniversal (Universal f _) = f
+
+universalize :: Universal a f x -> (f z -> a) -> z -> x
+universalize (Universal _ s) f = s f 
}
