[0.52.3
ekmett@gmail.com**20080602064208
 
 Moved some things into a single interior module to clean up imports
 Left stubs in the more logical locations.
 
] {
hunk ./category-extras.cabal 3
-version:                0.52.2
+version:                0.52.3
hunk ./category-extras.cabal 48
+        other-modules:
+                Control.Functor.Internal.Adjunction,
+                Control.Functor.Internal.Ideal
hunk ./src/Control/Comonad/Coideal.hs 1
+{-# OPTIONS_GHC -fglasgow-exts #-}
hunk ./src/Control/Comonad/Coideal.hs 14
-	( module Control.Monad.Ideal
+	( 
+	-- * Coideal Comonads
+	  ComonadCoideal(..)
+	, Coideal
+	, coideal
+	, buildCoideal
+	-- * Mutual recursion for (co)ideal (co)monad (co)products
+	, Mutual(..)
+	-- * Coideal Comonad Product
+	, (:*)
hunk ./src/Control/Comonad/Coideal.hs 26
-import Control.Monad.Ideal
-
+import Control.Functor.Internal.Ideal
hunk ./src/Control/Functor/Adjunction.hs 21
-import Control.Functor.Composition
-import Control.Functor.Exponential
-import Control.Functor.Full
-import Control.Functor.Strong
-import Control.Functor.HigherOrder
-import Control.Functor.Representable
-import Control.Functor.Zap
-import Control.Applicative
-import Control.Monad.Reader
-import Control.Monad.State
-import Control.Monad.Identity
-import Control.Comonad.Reader
-import Control.Comonad.Context
-
--- | An 'Adjunction' formed by the 'Functor' f and 'Functor' g. 
-
--- Minimal definition:
-
--- 1. @leftAdjunct@ and @rightAdjunct@ 
-
--- 2. @unit@ and @counit@
-
--- The following ambiguous instances prevent the requirement that (Zap f g, Zap g f) be 
--- a prerequisite for Adjunction:
-
--- instance (Adjunction f1 g1, Adjunction f2 g2) => Zap (CompF g1 g2) (CompF f2 f1) where ...
--- instance (Adjunction f1 g1, Adjunction f2 g2) => Zap (CompF f2 f1) (CompF g1 g2) where ...
--- instance (Zap f g, Zap f' g') => Zap (CompF f f') (Comp g g')
---	zapWith f a b = zapWith (zapWith f) (decompose a) (decompose b)
--- instance (Zap f g, Zap g f, Representable g (f ()), Functor f) => Adjunction f g | f -> g, g -> f where
-class (Representable g (f ()), Functor f) => Adjunction f g | f -> g, g -> f where
-	unit   :: a -> g (f a)
-	counit :: f (g a) -> a
-	leftAdjunct  :: (f a -> b) -> a -> g b
-	rightAdjunct :: (a -> g b) -> f a -> b
-
-	unit = leftAdjunct id
-	counit = rightAdjunct id
-	leftAdjunct f = fmap f . unit
-	rightAdjunct f = counit . fmap f
-
-zapWithGF :: Adjunction g f => (a -> b -> c) -> f a -> g b -> c
-zapWithGF f a b = uncurry (flip f) . counit . fmap (uncurry (flip strength)) $ strength a b
-
--- more appropriate to use 'data Empty' or a (co)limit to ground out f ?
-repAdjunction :: Adjunction f g => (f () -> a) -> g a
-repAdjunction f = leftAdjunct f ()
-
-unrepAdjunction :: Adjunction f g => g a -> (f () -> a)
-unrepAdjunction = rightAdjunct . const
-
-	
--- TODO: widen?
-instance (Adjunction f1 g1, Adjunction f2 g2) => Representable (CompF g1 g2) (CompF f2 f1 ()) where
-	rep = repAdjunction
-	unrep = unrepAdjunction
-
-instance (Adjunction f1 g1, Adjunction f2 g2) => Adjunction (CompF f2 f1) (CompF g1 g2) where
-	counit = counit . fmap (counit . fmap decompose) . decompose
-	unit = compose . fmap (fmap compose . unit) . unit
-
--- | Adjunction-oriented composition, yields monads and comonads from adjunctions
-newtype ACompF f g a = ACompF (CompF f g a) deriving (Functor, ExpFunctor, Full, Composition, HFunctor)
-
-instance Adjunction f g => Pointed (ACompF g f) where
-        point = compose . unit
-
-instance Adjunction f g => Copointed (ACompF f g) where
-        extract = counit . decompose
-
-instance Adjunction f g => Applicative (ACompF g f) where
-	pure = point
-	(<*>) = ap
-
-instance Adjunction f g => Monad (ACompF g f) where
-        return = point
-        m >>= f = compose . fmap (rightAdjunct (decompose . f)) $ decompose m
-
-instance Adjunction f g => Comonad (ACompF f g) where
-        extend f = compose . fmap (leftAdjunct (f . compose)) . decompose
-
-instance Zap ((->)e) ((,)e) where
-	zapWith = zapWithGF
-
-instance Representable ((->)e) (e,()) where
-	rep = repAdjunction
-	unrep = unrepAdjunction
-
-instance Representable ((->)e) e where
-	rep = id
-	unrep = id
-
-instance Adjunction ((,)e) ((->)e) where
-	leftAdjunct f a e  = f (e,a)
-	rightAdjunct f ~(e,a) = f a e
-	unit a e = (e,a)
-	counit (x,f) = f x
-
-instance Representable Identity (Identity ()) where
-	rep = repAdjunction
-	unrep = unrepAdjunction
-
-instance Adjunction Identity Identity where
-	unit = Identity . Identity
-	counit = runIdentity . runIdentity 
-
-instance Zap (Reader e) (Coreader e) where
-	zapWith = zapWithGF
-
-instance Representable (Reader e) (Coreader e ()) where
-	rep = repAdjunction
-	unrep = unrepAdjunction
-
-instance Adjunction (Coreader e) (Reader e) where
-	unit a = Reader (\e -> Coreader e a)
-	counit (Coreader x f) = runReader f x
-
-instance ComonadContext e ((,)e `ACompF` (->)e) where
-	getC = fst . decompose
-	modifyC f = uncurry (flip id . f) . decompose
-
-instance MonadState e ((->)e `ACompF` (,)e) where
-	get = compose $ \s -> (s,s)
-	put s = compose $ const (s,())
+import Control.Functor.Internal.Adjunction
hunk ./src/Control/Functor/Limit.hs 15
+	, liftLimit, liftColimit
hunk ./src/Control/Functor/Limit.hs 19
+import Control.Functor.Extras
hunk ./src/Control/Functor/Limit.hs 38
+liftLimit :: (f :~> g) -> Limit f -> Limit g
+liftLimit f a = f a
+
hunk ./src/Control/Functor/Limit.hs 44
+liftColimit :: (f :~> g) -> Colimit f -> Colimit g
+liftColimit f (Colimit a) = Colimit (f a)
+
hunk ./src/Control/Functor/Representable.hs 16
---	, repAdjunction, unrepAdjunction
+	, Corepresentable, corep, uncorep
hunk ./src/Control/Functor/Representable.hs 20
-import Control.Monad.Identity
-
-class Functor f => Representable f x where
-	rep :: (x -> a) -> f a
-	unrep :: f a -> (x -> a)
-
-{-# RULES
-"rep/unrep" rep . unrep = id
-"unrep/rep" unrep . rep = id
- #-}
-
---repAdjunction :: Adjunction f g => (f () -> a) -> g a
---repAdjunction f = leftAdjunct f ()
-
---unrepAdjunction :: Adjunction f g => g a -> (f () -> a)
---unrepAdjunction = rightAdjunction . const
-
-data EitherF a b c = EitherF (a -> c) (b -> c)
-
-instance Functor (EitherF a b) where
-        fmap f (EitherF l r) = EitherF (f . l) (f . r)
-
-instance Representable (EitherF a b) (Either a b) where
-        rep f = EitherF (f . Left) (f . Right)
-        unrep (EitherF l r) = either l r
-
-instance Representable Identity () where
-	rep f = Identity (f ())
-	unrep (Identity a) = const a
-
-data Both a = Both a a 
-
-instance Functor Both where
-	fmap f (Both a b) = Both (f a) (f b)
-
-instance Representable Both Bool where
-	rep f = Both (f False) (f True)
-	unrep (Both x _) False = x
-	unrep (Both _ y) True = y
-
--- instance Adjunction f g => Representable g (f ()) where
--- instance Representable (Cofree Identity) (Free Identity ()) where
+import Control.Functor.Internal.Adjunction
hunk ./src/Control/Functor/Zap.hs 20
-import Control.Functor.Combinators.Biff
-import Control.Monad.Either ()
-import Control.Monad.Identity
-
-{- | Minimum definition: zapWith -}
-
--- zapWith :: Adjunction f g => (a -> b -> c) -> f a -> g b -> c
--- zapWith f a b = uncurry (flip f) . counit . fmap (uncurry (flip strength)) $ strength a b
-
--- zap :: Adjunction f g => f (a -> b) -> g a -> b
--- zap = zapWith id
-
-class Zap f g | f -> g, g -> f where
-	zapWith :: (a -> b -> c) -> f a -> g b -> c
-	zap :: f (a -> b) -> g a -> b
-	zap = zapWith id
-
-(>$<) :: Zap f g => f (a -> b) -> g a -> b
-(>$<) = zap
-
-instance Zap Identity Identity where
-	zapWith f (Identity a) (Identity b) = f a b
-
-{- | Minimum definition: bizapWith -}
-
-class Bizap p q | p -> q, q -> p where
-	bizapWith :: (a -> c -> e) -> (b -> d -> e) -> p a b -> q c d -> e
-
-	bizap :: p (a -> c) (b -> c) -> q a b -> c
-	bizap = bizapWith id id
-
-(>>$<<) :: Bizap p q => p (a -> c) (b -> c) -> q a b -> c
-(>>$<<) = bizap
-
-instance Bizap (,) Either where
-	bizapWith l _ (f,_) (Left a) = l f a
-	bizapWith _ r (_,g) (Right b) = r g b 
-
-instance Bizap Either (,) where
-	bizapWith l _ (Left f) (a,_) = l f a
-	bizapWith _ r (Right g) (_,b) = r g b
-
-instance (Bizap p q, Zap f g, Zap i j) => Bizap (Biff p f i) (Biff q g j) where
-	bizapWith l r fs as = bizapWith (zapWith l) (zapWith r) (runBiff fs) (runBiff as)
+import Control.Functor.Internal.Adjunction
hunk ./src/Control/Monad/Ideal.hs 20
-	-- * Coideal Comonads
-	, ComonadCoideal(..)
-	, Coideal
-	, coideal
-	, buildCoideal
hunk ./src/Control/Monad/Ideal.hs 22
-	-- * Coideal Comonad Product
-	, (:*)
hunk ./src/Control/Monad/Ideal.hs 26
-import Prelude hiding (fst, snd)
-import Control.Category.Cartesian 
-import Control.Category.Hask
-import Control.Comonad
-import Control.Functor
-import Control.Functor.Algebra
-import Control.Functor.Combinators.Lift
-import Control.Monad.Identity
--- Control.Arrow ((|||),(&&&))
--- import Control.Functor.Combinators.Biff
--- import Control.Functor.Combinators.Join
--- import Control.Applicative
-
-type Ideal = Ap Either 
--- type Ideal f = Join (PFree f)
-type Coideal = Ap (,)
--- type Coideal f = Join (PCofree f)
-
-ideal :: Either a (f a) -> Ideal f a
-ideal = mkAp
-
-coideal :: (a, f a) -> Coideal f a 
-coideal = mkAp
-
-runIdeal :: Ideal f a -> Either a (f a)
-runIdeal = runAp
-
-runCoideal :: Coideal f a -> (a, f a)
-runCoideal = runAp
-
-class Functor m => MonadIdeal m where
-	idealize :: m (Either a (m a)) -> m a
-
-instance Functor f => Pointed (Ideal f) where
-	point = Lift . Left . Identity
-
--- this only really needs 'ap' but there is no 'unpointed/pre- applicative'
-{-
-instance Applicative f => Applicative (Ideal f) where
-	pure = point
-	Ideal (Left f) <*> Ideal (Left a) = Ideal $ Left (f a)
-	Ideal (Left f) <*> Ideal (Right bs) = Ideal $ Right (fmap f bs)
-	Ideal (Right fs) <*> Ideal (Left a) = Ideal $ Right (fmap ($a) fs)
-	Ideal (Right fs) <*> Ideal (Right bs) = Ideal $ Right (fs <*> bs)
--}
-
-instance MonadIdeal m => Monad (Ideal m) where
-	return = point
-	m >>= f = ideal . (id ||| Right . idealize) . runIdeal $ fmap (runIdeal . f) m
-
-destroyIdeal :: Algebra m a -> Ideal m a -> a
-destroyIdeal phi = (id ||| phi) . runIdeal 
-
-
--- instance MonadIdeal (Fst k) where
---	idealize = mkFst . runFst
-
-class Functor w => ComonadCoideal w where
-	coidealize :: w a -> w (a, w a)
-
-instance Functor f => Copointed (Coideal f) where
-	extract = runIdentity . fst . runLift
-
-instance ComonadCoideal w => Comonad (Coideal w) where
-	extend f = fmap (f . coideal) . coideal . (id &&& coidealize . snd) . runCoideal
-
-buildCoideal :: Coalgebra m a -> a -> Coideal m a
-buildCoideal phi = coideal . (id &&& phi)
-
--- instance ComonadCoideal (Fst k) where
---	coidealize = mkFst . runFst
-
--- * (Co)ideal (Co)products
-
-newtype Mutual p m n a = Mutual { runMutual :: m (p a (Mutual p n m a)) } 
-type Mutual' p m n = Lift p (Mutual p m n) (Mutual p n m)
-type (m :+ n) = Mutual' Either m n
-type (m :* n) = Mutual' (,) m n
-
-instance (Bifunctor p Hask Hask Hask, Functor m, Functor n) => Functor (Mutual p m n) where
-	fmap f = Mutual . fmap (bimap f (fmap f)) . runMutual
-
-{-
-instance (MonadIdeal m, MonadIdeal n) => MonadIdeal (m :+ n) where
-	idealize = undefined
--}
-
-{-
-instance (ComonadCoideal w, ComonadCoideal v) => ComonadCoideal (w :* v) where
-	coidealize = undefined
--}
+import Control.Functor.Internal.Ideal
hunk ./src/Control/Monad/Indexed/Cont.hs 24
-import Control.Monad.Trans
+-- import Control.Monad.Trans
}
