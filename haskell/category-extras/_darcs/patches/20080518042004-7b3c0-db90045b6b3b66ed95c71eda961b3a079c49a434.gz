[Overhauled a lot of the API
ekmett@gmail.com**20080518042004
 
 Bifunctor reacquired the category arguments so we can avoid thinking about all this contravariance noise.
 Indexed State and Indexed Cont have picked up traditional instances for Monad et al.
 Kan Extensions have appropriate instances
 Merged some more code from my categories library
 Still have to get a working categorical Arrow type, to allow many of the instances to work over categories other than Hask
 Ideal monads/Coideal comonads simplified
 Merged the Control.Bifunctor namespace into the Control.Functor namespace
 
] {
move ./src/Control/Functor/Bifunctor.hs ./src/Control/Functor/Lift.hs
adddir ./src/Control/Category
move ./src/Control/Bifunctor/Associative.hs ./src/Control/Category/Associative.hs
move ./src/Control/Bifunctor/Braided.hs ./src/Control/Category/Braided.hs
move ./src/Control/Bifunctor/Monoidal.hs ./src/Control/Category/Monoidal.hs
adddir ./src/Control/Functor/Combinators
move ./src/Control/Bifunctor/Biff.hs ./src/Control/Functor/Combinators/Biff.hs
adddir ./src/Control/Category/Cartesian
addfile ./CHANGELOG
hunk ./CHANGELOG 1
+0.44.5
+------
+
+* Added Monad, Applicative, etc. and monad transformer instances to Control.Monad.Indexed.Cont and Control.Monad.Indexed.State
+* Created Control.Monad.Indexed.Trans and Control.Monad.Indexed.Fix
hunk ./category-extras.cabal 3
-version:                0.44.4
+version:                0.50.0
hunk ./category-extras.cabal 6
-build-depends:          base > 3, mtl, array
+build-depends:          base > 3, mtl, array, ghc > 6.9
hunk ./category-extras.cabal 30
+	TypeSynonymInstances,
hunk ./category-extras.cabal 39
-	Control.Bifunctor,
-	Control.Bifunctor.Associative,
-	Control.Bifunctor.Biff,
-	Control.Bifunctor.Braided,
-	Control.Bifunctor.Composition,
-	Control.Bifunctor.Constant,
-	Control.Bifunctor.Functor,
-	Control.Bifunctor.Fix,
-	Control.Bifunctor.Monoidal,
-	Control.Bifunctor.Pointed,
-	Control.Bifunctor.Swap,
+	Control.Category.Associative,
+	Control.Category.Monoidal,
+	Control.Category.Braided,
+	Control.Category.Cartesian,
+	Control.Category.Cartesian.Closed,
+	Control.Category.Distributive,
+	Control.Category.Dual,
+	Control.Category.Hask,
+	Control.Category.Object,
hunk ./category-extras.cabal 51
+	Control.Comonad.Coideal,
hunk ./category-extras.cabal 62
-	Control.Functor.Bifunctor,
-	Control.Functor.Composition
-	Control.Functor.Contravariant,
-	Control.Functor.Constant,
+	Control.Functor.Composition,
+	Control.Functor.Combinators.Const,
+	Control.Functor.Combinators.Lift,
+	Control.Functor.Combinators.Join,
+	Control.Functor.Combinators.Biff,
+	Control.Functor.Combinators.Flip,
+	Control.Functor.Combinators.Of,
+	Control.Functor.Contra,
hunk ./category-extras.cabal 87
-	Control.Monad.Indexed.State,
hunk ./category-extras.cabal 88
+	Control.Monad.Indexed.Fix,
+	Control.Monad.Indexed.State,
+	Control.Monad.Indexed.Trans,
hunk ./src/Control/Applicative/Parameterized.hs 18
-import Control.Bifunctor.Pointed
+import Control.Functor.Pointed
hunk ./src/Control/Bifunctor/Composition.hs 1
--------------------------------------------------------------------------------------------
--- |
--- Module	: Control.Bifunctor.Composition
--- Copyright 	: 2008 Edward Kmett
--- License	: BSD3
---
--- Maintainer	: Edward Kmett <ekmett@gmail.com>
--- Stability	: experimental
--- Portability	: portable
---
--------------------------------------------------------------------------------------------
-
-module Control.Bifunctor.Composition 
-	( module Control.Bifunctor.Braided
-	, CompB(..)
-	, liftCompB
-	) where
-
-import Control.Bifunctor.Braided
-
-newtype CompB p f g a b = CompB { runCompB :: p (f a b) (g a b) }
-
-instance (Bifunctor p, Bifunctor f, Bifunctor g) => Bifunctor (CompB p f g) where
-	bimap f g = CompB . bimap (bimap f g) (bimap f g) . runCompB
-
-liftCompB :: Bifunctor p => (f a b -> f c d) -> (g a b -> g c d) -> CompB p f g a b -> CompB p f g c d 
-liftCompB f g = CompB . bimap f g . runCompB
-
-instance (Bifunctor p, Braided f, Braided g) => Braided (CompB p f g) where
-	braid = liftCompB braid braid
-
-instance (Bifunctor p, Symmetric f, Symmetric g) => Symmetric (CompB p f g) 
-
-instance (Bifunctor p, Bifunctor f, Bifunctor g) => Functor (CompB p f g a) where
-	fmap = bimap id
-
-
rmfile ./src/Control/Bifunctor/Composition.hs
hunk ./src/Control/Bifunctor/Constant.hs 1
--------------------------------------------------------------------------------------------
--- |
--- Module	: Control.Bifunctor.Constant
--- Copyright 	: 2008 Edward Kmett
--- License	: BSD3
---
--- Maintainer	: Edward Kmett <ekmett@gmail.com>
--- Stability	: experimental
--- Portability	: portable
---
--------------------------------------------------------------------------------------------
-
-module Control.Bifunctor.Constant 
-	( module Control.Functor.Exponential
-	, module Control.Functor.Contravariant
-	, module Control.Bifunctor.Associative
-	, ConstB(..)
-	, FstB(..)
-	, SndB(..)
-	) where
-
-import Control.Bifunctor.Associative
-import Control.Functor.Exponential
-import Control.Functor.Contravariant
-
-newtype ConstB t a b = ConstB { runConstB :: t } 
-
-instance Bifunctor (ConstB t) where
-	bimap _ _ = ConstB . runConstB
-
-instance Functor (ConstB t a) where
-	fmap _ = ConstB . runConstB
-
-instance ContravariantFunctor (ConstB t a) where
-	contramap _ = ConstB . runConstB
-
-instance ExpFunctor (ConstB t a) where
-	xmap _ _ = ConstB . runConstB
-
-
-
-
-
-
-newtype FstB a b = FstB { runFstB :: a } 
-
-instance Bifunctor FstB where
-	bimap f _ = FstB . f . runFstB 
-
-instance Associative FstB where
-	associate = FstB . runFstB . runFstB
-
-instance Functor (FstB a) where
-        fmap _ (FstB a) = FstB a
-
-instance ContravariantFunctor (FstB a) where
-        contramap _ (FstB a) = FstB a
-
-instance ExpFunctor (FstB a) where
-        xmap _ _ (FstB a) = FstB a
-
-
-
-
-
-
-
-
-newtype SndB a b = SndB { runSndB :: b } 
-
-instance Bifunctor SndB where
-	bimap _ g = SndB . g . runSndB 
-
-instance Functor (SndB a) where
-	fmap = bimap id
rmfile ./src/Control/Bifunctor/Constant.hs
hunk ./src/Control/Bifunctor/Either.hs 1
-{-# OPTIONS_GHC -fglasgow-exts #-}
------------------------------------------------------------------------------
--- |
--- Module      :  Control.Bifunctor.Either
--- Copyright   :  (C) 2008 Edward Kmett
--- License     :  BSD-style (see the file LICENSE)
---
--- Maintainer  :  Edward Kmett <ekmett@gmail.com>
--- Stability   :  experimental
--- Portability :  portable
---
-----------------------------------------------------------------------------
-module Control.Bifunctor.Either where
-
-import Control.Bifunctor
-import Control.Bifunctor.Associative
-import Control.Bifunctor.Monoidal
-import Control.Bifunctor.Braided
-import Data.Void
-import Control.Arrow ((***), (+++))
-
-instance Bifunctor Either where
-	bimap = (+++)
-
-instance Associative Either where
-	associate (Left (Left a)) = Left a
-	associate (Left (Right b)) = Right (Left b)
-	associate (Right c) = Right (Right c)
-
-instance Coassociative Either where
-	coassociate (Left a) = Left (Left a)
-	coassociate (Right (Left b)) = Left (Right b)
-	coassociate (Right (Right c)) = Right c
-
-instance Braided Either where
-	braid (Left a) = Right a
-	braid (Right b) = Left b
-
-instance Symmetric Either
rmfile ./src/Control/Bifunctor/Either.hs
hunk ./src/Control/Bifunctor/Fix.hs 1
--------------------------------------------------------------------------------------------
--- |
--- Module	: Control.Bifunctor.Fix
--- Copyright 	: 2008 Edward Kmett
--- License	: BSD
---
--- Maintainer	: Edward Kmett <ekmett@gmail.com>
--- Stability	: experimental
--- Portability	: portable
---
--------------------------------------------------------------------------------------------
-module Control.Bifunctor.Fix 
-	( FixB(..)
-	, paugment
-	, pcoaugment
-	) where
-
-import Control.Monad.Parameterized
-import Control.Comonad.Parameterized
-import Control.Comonad
-import Control.Morphism.Hylo
-
-newtype FixB s a = InB { outB :: s a (FixB s a) }
-
-instance Bifunctor s => Functor (FixB s) where
-        fmap f = InB . bimap f (fmap f) . outB
-
-instance PCopointed f => Copointed (FixB f) where
-        extract = pextract . outB
-
-instance PPointed f => Pointed (FixB f) where
-        point = InB . preturn
-
-instance PComonad f => Comonad (FixB f) where
-        extend k w = pcoaugment (\g -> bihylo InB id g w) k
-
-instance PMonad f => Monad (FixB f) where
-        return = InB . preturn
-        m >>= k = paugment (\f -> bihylo f id outB m) k
-
-paugment :: PMonad f => (forall c. (f a c -> c) -> c) -> (a -> FixB f b) -> FixB f b
-paugment g k = g (InB . pbind (outB . k))
-
-pcoaugment :: PComonad f => ((FixB f a -> f b (FixB f a)) -> FixB f b) -> (FixB f a -> b) -> FixB f b
-pcoaugment g k = g (pextend (k . InB) . outB)
rmfile ./src/Control/Bifunctor/Fix.hs
hunk ./src/Control/Bifunctor/Functor.hs 1
--------------------------------------------------------------------------------------------
--- |
--- Module	: Control.Bifunctor.Functor
--- Copyright 	: 2008 Edward Kmett
--- License	: BSD3
---
--- Maintainer	: Edward Kmett <ekmett@gmail.com>
--- Stability	: experimental
--- Portability	: portable
---
--------------------------------------------------------------------------------------------
-
-module Control.Bifunctor.Functor 
-	( module Control.Bifunctor.Monoidal
-	, FunctorB(..)
-	, liftFunctorB
-	) where
-
-import Control.Bifunctor.Monoidal
-
--- a functor composed around a bifunctor
-
-newtype FunctorB f p a b = FunctorB { runFunctorB :: f (p a b) } 
-
-liftFunctorB :: Functor f => (p a b -> p c d) -> FunctorB f p a b -> FunctorB f p c d
-liftFunctorB f = FunctorB . fmap f . runFunctorB
-
-instance (Functor f, Bifunctor p) => Bifunctor (FunctorB f p) where
-	bimap f g = liftFunctorB (bimap f g)
-
-instance (Functor f, Braided p) => Braided (FunctorB f p) where
-	braid = liftFunctorB braid
-
-instance (Functor f, Symmetric p) => Symmetric (FunctorB f p) 
-
-instance (Functor f, Bifunctor p) => Functor (FunctorB f p a) where
-	fmap = bimap id
-
rmfile ./src/Control/Bifunctor/Functor.hs
hunk ./src/Control/Bifunctor/Pointed.hs 1
--------------------------------------------------------------------------------------------
--- |
--- Module	: Control.Bifunctor.Pointed
--- Copyright 	: 2008 Edward Kmett
--- License	: BSD
---
--- Maintainer	: Edward Kmett <ekmett@gmail.com>
--- Stability	: experimental
--- Portability	: non-portable (functional-dependencies)
---
--------------------------------------------------------------------------------------------
-
-module Control.Bifunctor.Pointed
-	( PPointed(..)
-	, PCopointed(..)
-	) where
-
-import Control.Bifunctor
-
-class Bifunctor f => PPointed f where
-        preturn :: a -> f a c 
-
-class Bifunctor f => PCopointed f where
-	pextract :: f a c -> a
-
-{-# RULES
-"bimap id g . preturn"     	forall g. bimap id g . preturn = preturn
-"pextract . bimap id g"    	forall g. pextract . bimap id g = pextract
-"preturn/pextract" 		preturn . pextract = id
-"pextract/preturn" 		pextract. preturn = id
- #-}
-
rmfile ./src/Control/Bifunctor/Pointed.hs
hunk ./src/Control/Bifunctor/Swap.hs 1
--------------------------------------------------------------------------------------------
--- |
--- Module	: Control.Bifunctor.Composition
--- Copyright 	: 2008 Edward Kmett
--- License	: BSD3
---
--- Maintainer	: Edward Kmett <ekmett@gmail.com>
--- Stability	: experimental
--- Portability	: portable
---
--------------------------------------------------------------------------------------------
-
-module Control.Bifunctor.Swap 
-	( module Control.Bifunctor.Monoidal
-	, SwapB(..)
-	, liftSwapB
-	) where
-
-import Control.Bifunctor.Monoidal
-
-newtype SwapB p a b = SwapB { runSwapB :: p b a } 
-
-liftSwapB :: Bifunctor p => (p a b -> p c d) -> SwapB p b a -> SwapB p d c
-liftSwapB f = SwapB . f . runSwapB
-
-instance Bifunctor p => Bifunctor (SwapB p) where
-	bimap f g = liftSwapB (bimap g f)
-
-instance Braided p => Braided (SwapB p) where
-	braid = liftSwapB braid
-
-instance Symmetric p => Symmetric (SwapB p)
-
-instance Bifunctor p => Functor (SwapB p a) where
-	fmap = bimap id
-
rmfile ./src/Control/Bifunctor/Swap.hs
hunk ./src/Control/Bifunctor/Tuple.hs 1
-{-# OPTIONS_GHC -fglasgow-exts #-}
------------------------------------------------------------------------------
--- |
--- Module      :  Control.Bifunctor.Pair
--- Copyright   :  (C) 2008 Edward Kmett
--- License     :  BSD-style (see the file LICENSE)
---
--- Maintainer  :  Edward Kmett <ekmett@gmail.com>
--- Stability   :  experimental
--- Portability :  portable
---
-----------------------------------------------------------------------------
-module Control.Bifunctor.Pair where
-
-import Control.Bifunctor
-import Control.Bifunctor.Associative
-import Control.Bifunctor.Monoidal
-import Control.Bifunctor.Braided
-import Data.Void
-import Control.Arrow ((***), (+++))
-
-instance Bifunctor (,) where
-        bimap = (***)
-
-instance Associative (,) where
-	associate ((a,b),c) = (a,(b,c))
-
-instance Coassociative (,) where
-	coassociate (a,(b,c)) = ((a,b),c)
-
-instance HasIdentity (,) Void
-
-instance Monoidal (,) Void where
-	idl = snd
-	idr = fst
-
-instance Braided (,) where
-	braid ~(a,b) = (b,a)
-
-instance Symmetric (,)
-
rmfile ./src/Control/Bifunctor/Tuple.hs
rmdir ./src/Control/Bifunctor
hunk ./src/Control/Bifunctor.hs 1
--------------------------------------------------------------------------------------------
--- |
--- Module	: Control.Bifunctor
--- Copyright 	: 2008 Edward Kmett
--- License	: BSD3
---
--- Maintainer	: Edward Kmett <ekmett@gmail.com>
--- Stability	: experimental
--- Portability	: non-portable (functional-dependencies)
---
--------------------------------------------------------------------------------------------
-module Control.Bifunctor 
-	( Bifunctor(..) 
-	) where
-
-import Control.Arrow ((+++), (***))
-
-class Bifunctor f where
-	bimap :: (a -> c) -> (b -> d) -> f a b -> f c d
-	first :: (a -> c) -> f a b -> f c b
-	first f = bimap f id
-	second :: (b -> d) -> f a b -> f a d
-	second = bimap id
-
-instance Bifunctor Either where
-        bimap = (+++)
-
-instance Bifunctor (,) where
-	bimap = (***)
rmfile ./src/Control/Bifunctor.hs
hunk ./src/Control/Category/Associative.hs 4
--- Module	: Control.Bifunctor.Associative
+-- Module	: Control.Category.Associative
hunk ./src/Control/Category/Associative.hs 10
--- Portability	: non-portable (class-associated types)
+-- Portability	: portable
hunk ./src/Control/Category/Associative.hs 16
-module Control.Bifunctor.Associative 
-	( module Control.Bifunctor
-	, Associative(..)
+module Control.Category.Associative 
+	( Associative(..)
hunk ./src/Control/Category/Associative.hs 21
-import Control.Bifunctor
+import Control.Functor
+import Control.Category.Hask
hunk ./src/Control/Category/Associative.hs 28
-class Bifunctor p => Associative p where
-	associate :: p (p a b) c -> p a (p b c)
+class Bifunctor p k k k => Associative p k where
+	associate :: k (p (p a b) c) (p a (p b c))
hunk ./src/Control/Category/Associative.hs 35
-class Bifunctor s => Coassociative s where
-	coassociate :: s a (s b c) -> s (s a b) c
+class Bifunctor s k k k => Coassociative s k where
+	coassociate :: k (s a (s b c)) (s (s a b) c)
hunk ./src/Control/Category/Associative.hs 43
-instance Associative (,) where
+instance Associative (,) Hask where
hunk ./src/Control/Category/Associative.hs 46
-instance Coassociative (,) where
+instance Coassociative (,) Hask where
hunk ./src/Control/Category/Associative.hs 49
-instance Associative Either where
+instance Associative Either Hask where
hunk ./src/Control/Category/Associative.hs 54
-instance Coassociative Either where
+instance Coassociative Either Hask where
hunk ./src/Control/Category/Braided.hs 3
--- Module	: Control.Bifunctor.Braided
+-- Module	: Control.Category.Braided
hunk ./src/Control/Category/Braided.hs 12
-module Control.Bifunctor.Braided 
-	( module Control.Bifunctor.Associative
-	, Braided(..)
+module Control.Category.Braided 
+	( Braided(..)
hunk ./src/Control/Category/Braided.hs 18
-import Control.Bifunctor.Associative
+import Control.Functor
+import Control.Category.Associative
+import Control.Category.Hask
hunk ./src/Control/Category/Braided.hs 33
-class Bifunctor p => Braided p where
-	braid :: p a b -> p b a
+class Braided p k where
+	braid :: k (p a b) (p b a)
hunk ./src/Control/Category/Braided.hs 41
-class Braided p => Symmetric p
+class Braided p k => Symmetric p k
hunk ./src/Control/Category/Braided.hs 43
-swap :: Symmetric p => p a b -> p b a
+swap :: Symmetric p k => k (p a b) (p b a)
hunk ./src/Control/Category/Braided.hs 52
-
-instance Braided Either where
+instance Braided Either Hask where
hunk ./src/Control/Category/Braided.hs 56
-instance Symmetric Either
-
+instance Symmetric Either Hask
hunk ./src/Control/Category/Braided.hs 58
-instance Braided (,) where
+instance Braided (,) Hask where
hunk ./src/Control/Category/Braided.hs 61
-instance Symmetric (,)
+instance Symmetric (,) Hask
addfile ./src/Control/Category/Cartesian.hs
hunk ./src/Control/Category/Cartesian.hs 1
+{-# OPTIONS -fglasgow-exts #-}
+-------------------------------------------------------------------------------------------
+-- |
+-- Module	: Control.Category.Cartesian
+-- Copyright 	: 2008 Edward Kmett
+-- License	: BSD
+--
+-- Maintainer	: Edward Kmett <ekmett@gmail.com>
+-- Stability	: experimental
+-- Portability	: non-portable (class-associated types)
+--
+-------------------------------------------------------------------------------------------
+module Control.Category.Cartesian
+	( module Control.Category.Associative
+	, module Control.Category.Monoidal
+	-- * Pre-(Co)Cartesian categories
+	, PreCartesian(..)
+	, bimapPreCartesian, braidPreCartesian, associatePreCartesian, coassociatePreCartesian
+	, PreCoCartesian(..)
+	, bimapPreCoCartesian, braidPreCoCartesian, associatePreCoCartesian, coassociatePreCoCartesian
+	-- * (Co)Cartesian categories
+	, Cartesian
+	, CoCartesian
+	) where
+
+import Prelude hiding (Functor, map, (.), id, fst, snd, curry, uncurry)
+import qualified Prelude
+
+import Control.Functor
+import Control.Category
+import Control.Category.Associative
+import Control.Category.Monoidal
+
+infixr 3 &&&
+infixr 2 |||
+
+{- |
+NB: This is weaker than traditional category with products! That is Cartesian, below.
+The problem is @(->)@ lacks an initial object, since every type is inhabited in Haskell.
+Consequently its coproduct is merely a semigroup, not a monoid as it has no identity, and 
+since we want to be able to describe its dual category, which has this non-traditional 
+form being built over a category with an associative bifunctor rather than as a monoidal category
+for the product monoid.
+
+Minimum definition: 
+
+> fst, snd, diag 
+> fst, snd, (&&&)
+-}
+class (Associative (Prod k) k, Coassociative (Prod k) k, Braided (Prod k) k) => PreCartesian k where
+	type Prod k :: * -> * -> *
+	fst :: k (Prod k a b) a
+	snd :: k (Prod k a b) b
+	diag :: k a (Prod k a a)
+	(&&&) :: k a b -> k a c -> k a (Prod k b c)
+
+	diag = id &&& id
+	f &&& g = bimap f g . diag
+
+
+{-# RULES
+"fst . diag"  	fst . diag = id
+"snd . diag"	snd . diag = id
+"fst . f &&& g" forall f g. fst . (f &&& g) = f
+"snd . f &&& g" forall f g. snd . (f &&& g) = g
+ #-}
+
+instance PreCartesian (->) where
+	type Prod (->) = (,)
+	fst = Prelude.fst
+	snd = Prelude.snd
+	diag a = (a,a)
+	(f &&& g) a = (f a, g a)
+
+-- alias
+class (Monoidal (Prod k) k, PreCartesian k) => Cartesian k
+instance (Monoidal (Prod k) k, PreCartesian k) => Cartesian k
+
+-- | free construction of 'Bifunctor' for the product 'Bifunctor' @Prod k@ if @(&&&)@ is known
+bimapPreCartesian :: PreCartesian k => k a c -> k b d -> k (Prod k a b) (Prod k c d)
+bimapPreCartesian f g = (f . fst) &&& (g . snd)
+	
+-- | free construction of 'Braided' for the product 'Bifunctor' @Prod k@
+braidPreCartesian :: PreCartesian k => k (Prod k a b) (Prod k b a)
+braidPreCartesian = snd &&& fst
+
+-- | free construction of 'Associative' for the product 'Bifunctor' @Prod k@
+associatePreCartesian :: PreCartesian k => k (Prod k (Prod k a b) c) (Prod k a (Prod k b c))
+associatePreCartesian = (fst . fst) &&& first snd
+
+-- | free construction of 'Coassociative' for the product 'Bifunctor' @Prod k@
+coassociatePreCartesian :: PreCartesian k => k (Prod k a (Prod k b c)) (Prod k (Prod k a b) c)
+coassociatePreCartesian = braid . second braid . associatePreCartesian . first braid . braid 
+
+-- * Co-PreCartesian categories
+
+-- a category that has finite coproducts, weakened the same way as PreCartesian above was weakened
+class (Associative (Sum k) k, Coassociative (Sum k) k, Braided (Sum k) k) => PreCoCartesian k where
+#ifndef __HADDOCK__
+	type Sum k :: * -> * -> *
+#endif
+	inl :: k a (Sum k a b)
+	inr :: k b (Sum k a b)
+	codiag :: k (Sum k a a) a
+	(|||) :: k a c -> k b c -> k (Sum k a b) c
+
+	codiag = id ||| id
+	f ||| g = codiag . bimap f g
+
+{-# RULES
+"codiag . inl"  codiag . inl = id
+"codiag . inr"	codiag . inr = id
+"(f ||| g) . inl" forall f g. (f ||| g) . inl = f
+"(f ||| g) . inr" forall f g. (f ||| g) . inr = g
+ #-}
+
+instance PreCoCartesian (->) where
+	type Sum (->) = Either
+	inl = Left
+	inr = Right
+	codiag (Left a) = a
+	codiag (Right a) = a
+	(f ||| _) (Left a) = f a 
+	(_ ||| g) (Right a) = g a
+
+-- | free construction of 'Bifunctor' for the coproduct 'Bifunctor' @Sum k@ if @(|||)@ is known
+bimapPreCoCartesian :: PreCoCartesian k => k a c -> k b d -> k (Sum k a b) (Sum k c d)
+bimapPreCoCartesian f g = (inl . f) ||| (inr . g)
+
+-- | free construction of 'Braided' for the coproduct 'Bifunctor' @Sum k@
+braidPreCoCartesian :: PreCoCartesian k => k (Sum k a b) (Sum k b a)
+braidPreCoCartesian = inr ||| inl
+
+-- | free construction of 'Associative' for the coproduct 'Bifunctor' @Sum k@
+associatePreCoCartesian :: PreCoCartesian k => k (Sum k (Sum k a b) c) (Sum k a (Sum k b c))
+associatePreCoCartesian = braid . first braid . coassociatePreCoCartesian . second braid . braid
+
+-- | free construction of 'Coassociative' for the coproduct 'Bifunctor' @Sum k@
+coassociatePreCoCartesian :: PreCoCartesian k => k (Sum k a (Sum k b c)) (Sum k (Sum k a b) c)
+coassociatePreCoCartesian = (inl . inl) ||| first inr
+
+class (Comonoidal (Sum k) k, PreCoCartesian k) => CoCartesian k
+instance (Comonoidal (Sum k) k, PreCoCartesian k) => CoCartesian k
addfile ./src/Control/Category/Cartesian/Closed.hs
hunk ./src/Control/Category/Cartesian/Closed.hs 1
+{-# OPTIONS -fglasgow-exts #-}
+-------------------------------------------------------------------------------------------
+-- |
+-- Module	: Control.Category.Cartesian.Closed
+-- Copyright 	: 2008 Edward Kmett
+-- License	: BSD
+--
+-- Maintainer	: Edward Kmett <ekmett@gmail.com>
+-- Stability	: experimental
+-- Portability	: non-portable (class-associated types)
+--
+-- NB: Some rewrite rules are disabled pending resolution of:
+-- <http://hackage.haskell.org/trac/ghc/ticket/2291>
+-------------------------------------------------------------------------------------------
+module Control.Category.Cartesian.Closed
+	( 
+	-- * Cartesian Closed Category
+	  CCC(..)
+	, unitCCC, counitCCC
+	-- * Co-(Cartesian Closed Category)
+	, CoCCC(..)
+	, unitCoCCC, counitCoCCC
+	) where
+
+import Prelude hiding ((.), id, fst, snd, curry, uncurry)
+
+import Control.Category
+import Control.Category.Cartesian
+import Control.Category.Monoidal
+
+-- * Closed Cartesian Category 
+
+-- | A 'CCC' has full-fledged monoidal finite products and exponentials
+
+-- Ideally you also want an instance for @'Bifunctor' ('Exp' k) ('Dual' k) k k@.
+-- or at least @'Functor' ('Exp' k a) k k@, which cannot be expressed in the constraints here.
+
+class (Monoidal (Prod k) k, Cartesian k) => CCC k where
+#ifndef __HADDOCK__
+	type Exp k :: * -> * -> *
+#endif
+	apply :: k (Prod k (Exp k a b) a) b
+	curry :: k (Prod k a b) c -> k a (Exp k b c)
+	uncurry :: k a (Exp k b c) -> k (Prod k a b) c
+
+{-# RULES
+"curry apply" 		curry apply = id
+-- "curry . uncurry" 	curry . uncurry = id :: CCC k => k a (Exp k b c) -> k a (Exp k b c)
+-- "uncurry . curry" 	uncurry . curry = id :: CCC k => k (Prod k a b) c -> k (Prod k a b) c
+ #-}
+
+-- * Free 'Adjunction' (Prod k a) (Exp k a) k k 
+
+unitCCC :: CCC k => k a (Exp k b (Prod k b a))
+unitCCC = curry braid
+
+counitCCC :: CCC k => k (Prod k b (Exp k b a)) a
+counitCCC = apply . braid
+
+-- * A Co-(Closed Cartesian Category) 
+
+-- | A Co-CCC has full-fledged comonoidal finite coproducts and coexponentials
+
+-- You probably also want an instance for @'Bifunctor' ('Coexp' k) ('Dual' k) k k@.
+
+class (Comonoidal (Sum k) k, CoCartesian k) => CoCCC k where
+#ifndef __HADDOCK__
+	type Coexp k :: * -> * -> *
+#endif
+	coapply :: k b (Sum k (Coexp k a b) a)
+	cocurry :: k c (Sum k a b) -> k (Coexp k b c) a
+	uncocurry :: k (Coexp k b c) a -> k c (Sum k a b)
+
+{-# RULES
+"cocurry coapply" 	cocurry coapply = id
+-- "cocurry . uncocurry"	cocurry . uncocurry = id
+-- "uncocurry . cocurry"   uncocurry . cocurry = id
+ #-}
+
+-- * Free 'Adjunction' (Coexp k a) (Sum k a) k k 
+
+unitCoCCC :: CoCCC k => k a (Sum k b (Coexp k b a))
+unitCoCCC = braid . coapply
+
+counitCoCCC :: CoCCC k => k (Coexp k b (Sum k b a)) a
+counitCoCCC = cocurry braid
addfile ./src/Control/Category/Distributive.hs
hunk ./src/Control/Category/Distributive.hs 1
+-------------------------------------------------------------------------------------------
+-- |
+-- Module	: Control.Category.Distributive
+-- Copyright 	: 2008 Edward Kmett
+-- License	: BSD
+--
+-- Maintainer	: Edward Kmett <ekmett@gmail.com>
+-- Stability	: experimental
+-- Portability	: non-portable (class-associated types)
+--
+-------------------------------------------------------------------------------------------
+module Control.Category.Distributive
+	( 
+	-- * Distributive Categories
+	  factor
+	, Distributive(..)
+	) where
+
+import Prelude hiding (Functor, map, (.), id, fst, snd, curry, uncurry)
+import Control.Functor
+import Control.Category
+import Control.Category.Cartesian
+
+-- | the canonical factoring morphism 
+factor :: (Cartesian k, CoCartesian k) => k (Sum k (Prod k a b) (Prod k a c)) (Prod k a (Sum k b c))
+factor = second inl ||| second inr
+
+-- | A category in which 'factor' is an isomorphism
+class (Cartesian k, CoCartesian k) => Distributive k where
+	distribute :: k (Prod k a (Sum k b c)) (Sum k (Prod k a b) (Prod k a c))
+
+{-# RULES
+"factor . distribute"	 factor . distribute = id
+"distribute . factor"    distribute . factor = id
+ #-}
addfile ./src/Control/Category/Dual.hs
hunk ./src/Control/Category/Dual.hs 1
+-------------------------------------------------------------------------------------------
+-- |
+-- Module	: Control.Category.Dual
+-- Copyright 	: 2008 Edward Kmett
+-- License	: BSD
+--
+-- Maintainer	: Edward Kmett <ekmett@gmail.com>
+-- Stability	: experimental
+-- Portability	: semi-portable (optional class-associated types)
+--
+-------------------------------------------------------------------------------------------
+module Control.Category.Dual
+	( Dual(..)
+	) where
+
+import Prelude hiding ((.), id)
+import Control.Category
+
+data Dual k a b = Dual { runDual :: k b a } 
+
+instance Category k => Category (Dual k) where
+	id = Dual id
+	Dual f . Dual g = Dual (g . f)
addfile ./src/Control/Category/Hask.hs
hunk ./src/Control/Category/Hask.hs 1
+-------------------------------------------------------------------------------------------
+-- |
+-- Module	: Control.Category.Hask
+-- Copyright 	: 2008 Edward Kmett
+-- License	: BSD
+--
+-- Maintainer	: Edward Kmett <ekmett@gmail.com>
+-- Stability	: experimental
+-- Portability	: portable
+--
+-------------------------------------------------------------------------------------------
+module Control.Category.Hask
+	( Hask
+	) where
+
+type Hask = (->) 
hunk ./src/Control/Category/Monoidal.hs 1
+{-# OPTIONS_GHC -fglasgow-exts #-}
hunk ./src/Control/Category/Monoidal.hs 4
--- Module	: Control.Bifunctor.Monoidal
+-- Module	: Control.Category.Monoidal
hunk ./src/Control/Category/Monoidal.hs 19
+
+-- The use of class associated types here makes Control.Category.Cartesian FAR more palatable
hunk ./src/Control/Category/Monoidal.hs 23
-module Control.Bifunctor.Monoidal 
-	( module Control.Bifunctor.Braided
-	, module Data.Void
-	, HasIdentity
+module Control.Category.Monoidal 
+	( module Control.Category.Braided
+	, Void
+	, HasIdentity(..)
hunk ./src/Control/Category/Monoidal.hs 31
-import Control.Bifunctor.Braided
+import Control.Category.Hask
+import Control.Category.Associative
+import Control.Category.Braided
+import Control.Functor
hunk ./src/Control/Category/Monoidal.hs 39
-class Bifunctor p => HasIdentity p i | p -> i 
+class Bifunctor p k k k => HasIdentity p k where
+	type Id p k :: *
hunk ./src/Control/Category/Monoidal.hs 49
-class (Associative p, HasIdentity p i) => Monoidal p i | p -> i where
-	idl :: p i a -> a
-	idr :: p a i -> a
+class (Associative p k , HasIdentity p k) => Monoidal p k where
+	idl :: k (p (Id p k) a) a
+	idr :: k (p a (Id p k)) a
hunk ./src/Control/Category/Monoidal.hs 67
-class (Coassociative p, HasIdentity p i) => Comonoidal p i | p -> i where
-	coidl :: a -> p i a
-	coidr :: a -> p a i
+class (Coassociative p k, HasIdentity p k) => Comonoidal p k where
+	coidl :: k a (p (Id p k) a)
+	coidr :: k a (p a (Id p k))
hunk ./src/Control/Category/Monoidal.hs 86
-instance HasIdentity (,) Void
+instance HasIdentity (,) Hask where
+	type Id (,) Hask = Void
hunk ./src/Control/Category/Monoidal.hs 89
-instance Monoidal (,) Void where
+instance Monoidal (,) Hask where
hunk ./src/Control/Category/Monoidal.hs 93
-
addfile ./src/Control/Category/Object.hs
hunk ./src/Control/Category/Object.hs 1
+{-# OPTIONS -fglasgow-exts #-}
+-------------------------------------------------------------------------------------------
+-- |
+-- Module	: Control.Category.Object
+-- Copyright 	: 2008 Edward Kmett
+-- License	: BSD
+--
+-- Maintainer	: Edward Kmett <ekmett@gmail.com>
+-- Stability	: experimental
+-- Portability	: non-portable (either class-associated types or MPTCs with fundeps)
+--
+-- This module declares the 'HasTerminalObject' and 'HasInitialObject' classes.
+-- These are defined in terms of class-associated types rather than functional dependencies
+-- because most of the time when you are manipulating a category you don't care about them;
+-- this gets them out of the signature of most functions that use the category.
+-- Both of these are special cases of the idea of a (co)limit.
+-------------------------------------------------------------------------------------------
+
+module Control.Category.Object 
+	( HasTerminalObject(..)
+	, HasInitialObject(..)
+	) where
+
+import Control.Category
+
+-- | The @Category k@ has a terminal object @Terminal k@ such that for all objects @a@ in @k@, 
+-- there exists a unique morphism from @a@ to @Terminal k@.
+#ifdef USE_TYPE_FAMILIES
+class Category k => HasTerminalObject k where
+	type Terminal k :: *
+	terminate :: k a (Terminal k)
+#else 
+class Category k => HasTerminalObject k t | k -> t where
+	terminate :: k a t
+#endif
+
+-- | The @Category k@ has an initial (coterminal) object @Initial k@ such that for all objects 
+-- @a@ in @k@, there exists a unique morphism from @Initial k @ to @a@.
+
+#ifdef USE_TYPE_FAMILIES
+class Category k => HasInitialObject k where
+	type Initial k :: *
+	initiate :: k (Initial k) a
+#else
+class Category k => HasInitialObject k i | k -> i where
+	initiate :: k i a
+#endif
addfile ./src/Control/Category/Small.hs
hunk ./src/Control/Category/Small.hs 1
+{-# OPTIONS_GHC -fglasgow-exts #-}
+module Small where
+
+import Prelude hiding (curry,uncurry)
+
+class CCC k where
+        type Exp k :: * -> * -> *
+	type Prod k :: * -> * -> *
+        apply :: k (Prod k (Exp k a b) a) b 
+        curry :: k (Prod k a b) c -> k a (Exp k b c)
+        uncurry :: k a (Exp k b c) -> k (Prod k a b) c
+
+instance CCC (->) where
+	type Exp (->) = (->)
+	type Prod (->) = (,)
+	apply ~(f,x) = f x 
+	curry f x y = f (x,y)
+	uncurry f ~(x,y) = f x y 
+
+{-
+{-# RULES
+"curry apply" curry apply = id
+"curry . uncurry" curry . uncurry = id
+"uncurry . curry" uncurry . curry = id
+ #-}
+-}
+
+{-
+class CoCCC k where
+        data Coexp k :: * -> * -> *
+	data Sum k :: * -> * -> *
+        coapply :: k b (Sum k (Coexp k a b) a)
+        cocurry :: k c (Sum k a b) -> k (Coexp k b c) a
+        uncocurry :: k (Coexp k b c) a -> k c (Sum k a b)
+
+{-# RULES
+"cocurry coapply"       	cocurry coapply = id
+"cocurry . uncocurry"        	cocurry . uncocurry = id
+"uncocurry . cocurry"   	uncocurry . cocurry = id
+ #-}
+-}
hunk ./src/Control/Comonad/Cofree.hs 14
-	( BiffB(..)
-	, FixB(..)
-	, PCopointed(..)
-	, PComonad(..)
-	, Identity(..)
-	, CofreeB
-	, Cofree
+	( Cofree
hunk ./src/Control/Comonad/Cofree.hs 19
-import Control.Bifunctor.Fix
-import Control.Bifunctor.Biff
-import Control.Comonad.Parameterized
+import Control.Functor.Fix
+import Control.Functor.Combinators.Biff
hunk ./src/Control/Comonad/Cofree.hs 22
-import Control.Monad.Parameterized
hunk ./src/Control/Comonad/Cofree.hs 23
-type CofreeB f a b = BiffB (,) Identity f a b
-type Cofree f a = FixB (BiffB (,) Identity f) a
+type Cofree f = FixB (PCofree f)
hunk ./src/Control/Comonad/Cofree.hs 26
-outCofree = snd . runBiffB . outB
+outCofree = snd . runCofree
hunk ./src/Control/Comonad/Cofree.hs 29
-runCofree = first runIdentity . runBiffB . outB
+runCofree = runPCofree . outB
hunk ./src/Control/Comonad/Cofree.hs 32
-anaCofree h t = InB . BiffB . (Identity . h &&& fmap (anaCofree h t) . t)
+anaCofree h t = InB . Biff . (Identity . h &&& fmap (anaCofree h t) . t)
hunk ./src/Control/Comonad/Cofree.hs 35
-cofree a as = InB $ BiffB (Identity a,as)
+cofree a as = InB $ Biff (Identity a,as)
addfile ./src/Control/Comonad/Coideal.hs
hunk ./src/Control/Comonad/Coideal.hs 1
+-----------------------------------------------------------------------------
+-- |
+-- Module      :  Control.Comonad.Coideal
+-- Copyright   :  (C) 2008 Edward Kmett
+-- License     :  BSD-style (see the file LICENSE)
+--
+-- Maintainer  :  Edward Kmett <ekmett@gmail.com>
+-- Stability   :  experimental
+-- Portability :  portable
+--
+----------------------------------------------------------------------------
+module Control.Comonad.Coideal
+	( module Control.Monad.Ideal
+	) where
+
+import Control.Monad.Ideal
+
hunk ./src/Control/Comonad/Context.hs 12
--- The state-in-context comonad and comonad transformer
+-- The Context Comonad Transformer is related to the left Kan Extension 'Lan' of 
+-- a comonad along itself, except the type of the context is fixed, and 
+-- not existentially quantified.
+
+-- The context comonad can more traditionally be derived from the 'hom-prod' 
+-- adjunction between (->) and (,)
hunk ./src/Control/Comonad/Context.hs 29
-import Control.Bifunctor (first)
+import Control.Functor (first)
hunk ./src/Control/Comonad/Parameterized.hs 14
-	( Bifunctor(..)
-	, PCopointed(..)
+	( PCopointed(..)
hunk ./src/Control/Comonad/Parameterized.hs 18
-import Control.Bifunctor
-import Control.Bifunctor.Pointed
+import Control.Functor
+import Control.Functor.Pointed
hunk ./src/Control/Comonad/Parameterized.hs 40
-	
-
hunk ./src/Control/Comonad/Reader.hs 12
+-- If you look at the reader arrow:
+-- @(e, a) -> a@ you can see that all the interesting bits are bunched
+-- on the left. This is that comonad. Flipping the pair and currying the 
+-- arguments yields @a -> (e -> a)@, and you can recognize the (e -> a) as 
+-- the reader monad. In more technical language the Reader comonad is 
+-- left adjoint to the Reader monad.
hunk ./src/Control/Comonad/Reader.hs 20
-	( module Control.Bifunctor
-	, module Control.Comonad
-	, ReaderC(..)
-	, runReaderC
-	, ReaderCT(..)
+	( Coreader(..)
+	, runCoreader
+	, CoreaderT(..)
hunk ./src/Control/Comonad/Reader.hs 27
-import Control.Bifunctor
+import Control.Functor
+import Control.Category.Hask
hunk ./src/Control/Comonad/Reader.hs 35
-data ReaderC r a = ReaderC r a 
+data Coreader r a = Coreader r a 
hunk ./src/Control/Comonad/Reader.hs 37
-runReaderC :: ReaderC r a -> (r, a)
-runReaderC (ReaderC r a) = (r,a)
+runCoreader :: Coreader r a -> (r, a)
+runCoreader (Coreader r a) = (r,a)
hunk ./src/Control/Comonad/Reader.hs 40
-instance ComonadReader r (ReaderC r) where
-	askC (ReaderC r _) = r
+instance ComonadReader r (Coreader r) where
+	askC (Coreader r _) = r
hunk ./src/Control/Comonad/Reader.hs 43
-instance Functor (ReaderC r) where
-	fmap f = uncurry ReaderC . second f . runReaderC
+instance Functor (Coreader r) where
+	fmap f = uncurry Coreader . second f . runCoreader
hunk ./src/Control/Comonad/Reader.hs 46
-instance Copointed (ReaderC r) where
-	extract (ReaderC _ a) = a
+instance Copointed (Coreader r) where
+	extract (Coreader _ a) = a
hunk ./src/Control/Comonad/Reader.hs 49
-instance Comonad (ReaderC r) where
-	duplicate (ReaderC e a) = ReaderC e (ReaderC e a)
+instance Comonad (Coreader r) where
+	duplicate (Coreader e a) = Coreader e (Coreader e a)
hunk ./src/Control/Comonad/Reader.hs 52
-instance Bifunctor ReaderC where
-	bimap f g = uncurry ReaderC . bimap f g . runReaderC
+instance PFunctor Coreader Hask Hask where
+	first = first'
hunk ./src/Control/Comonad/Reader.hs 55
+instance QFunctor Coreader Hask Hask where
+	second = second'
hunk ./src/Control/Comonad/Reader.hs 58
-newtype ReaderCT w r a = ReaderCT { runReaderCT :: w (r, a) }
+instance Bifunctor Coreader Hask Hask Hask where
+	bimap f g = uncurry Coreader . bimap f g . runCoreader
hunk ./src/Control/Comonad/Reader.hs 61
-instance Comonad w => ComonadReader r (ReaderCT w r) where
-	askC = fst . extract . runReaderCT
hunk ./src/Control/Comonad/Reader.hs 62
-instance Functor f => Functor (ReaderCT f b) where
-        fmap f = ReaderCT . fmap (fmap f) . runReaderCT
+newtype CoreaderT w r a = CoreaderT { runCoreaderT :: w (r, a) }
hunk ./src/Control/Comonad/Reader.hs 64
-instance Copointed w => Copointed (ReaderCT w b) where
-        extract = snd . extract . runReaderCT
+instance Comonad w => ComonadReader r (CoreaderT w r) where
+	askC = fst . extract . runCoreaderT
hunk ./src/Control/Comonad/Reader.hs 67
-instance Comonad w => Comonad (ReaderCT w b) where
-        duplicate = ReaderCT . liftW (fst . extract &&& ReaderCT) . duplicate . runReaderCT
+instance Functor f => Functor (CoreaderT f b) where
+        fmap f = CoreaderT . fmap (fmap f) . runCoreaderT
hunk ./src/Control/Comonad/Reader.hs 70
-instance Functor f => Bifunctor (ReaderCT f) where
-	bimap f g = ReaderCT . fmap (bimap f g) . runReaderCT
+instance Copointed w => Copointed (CoreaderT w b) where
+        extract = snd . extract . runCoreaderT
hunk ./src/Control/Comonad/Reader.hs 73
+instance Comonad w => Comonad (CoreaderT w b) where
+        duplicate = CoreaderT . liftW (fst . extract &&& CoreaderT) . duplicate . runCoreaderT
+
+instance Functor f => PFunctor (CoreaderT f) Hask Hask where
+	first = first'
+
+instance Functor f => QFunctor (CoreaderT f) Hask Hask where
+	second = second'
+
+instance Functor f => Bifunctor (CoreaderT f) Hask Hask Hask where
+	bimap f g = CoreaderT . fmap (bimap f g) . runCoreaderT
addfile ./src/Control/Functor.hs
hunk ./src/Control/Functor.hs 1
+-------------------------------------------------------------------------------------------
+-- |
+-- Module	: Control.Functor
+-- Copyright 	: 2008 Edward Kmett
+-- License	: BSD3
+--
+-- Maintainer	: Edward Kmett <ekmett@gmail.com>
+-- Stability	: experimental
+-- Portability	: non-portable (functional-dependencies)
+--
+-- A more categorical definition of Functor than endofunctors in the category Hask
+-------------------------------------------------------------------------------------------
+module Control.Functor
+	( CFunctor (cmap)
+	, PFunctor (first), first'
+	, QFunctor (second), second'
+	, Bifunctor (bimap)
+	) where
+
+import Prelude hiding (id,(.))
+import Control.Category
+import Control.Category.Hask
+import Control.Monad.Identity
+import Control.Monad.Reader
+import Control.Monad.List
+import Control.Monad.Cont
+import Control.Monad.Writer.Strict as SW
+import Control.Monad.Writer.Lazy as LW
+import Control.Monad.State.Strict as SS
+import Control.Monad.State.Lazy as LS
+import Control.Monad.RWS.Strict as SRWS
+import Control.Monad.RWS.Lazy as LRWS
+
+
+class (Category r, Category t) => PFunctor p r t | p r -> t, p t -> r where
+	first :: r a b -> t (p a c) (p b c)
+
+{-# INLINE first' #-}
+first' :: Bifunctor p r s t => r a b -> t (p a c) (p b c)
+first' f = bimap f id
+
+class (Category s, Category t) => QFunctor q s t | q s -> t, q t -> s where
+	second :: s a b -> t (q c a) (q c b)
+
+{-# INLINE second' #-}
+second' :: Bifunctor p r s t => s a b -> t (p c a) (p c b)
+second' = bimap id
+
+instance PFunctor Either Hask Hask where
+	first = first'
+
+instance QFunctor Either Hask Hask where
+	second = second'
+
+instance Bifunctor Either Hask Hask Hask where
+        bimap f _ (Left a) = Left (f a)
+	bimap _ g (Right a) = Right (g a)
+
+instance QFunctor (->) Hask Hask where
+	second = (.)
+
+instance PFunctor (,) Hask Hask where
+	first = first'
+
+instance QFunctor (,) Hask Hask where
+	second = second'
+
+instance Bifunctor (,) Hask Hask Hask where
+        bimap f g ~(a,b)= (f a, g b)
+
+class (PFunctor p r t, QFunctor p s t) => Bifunctor p r s t | p r -> s t, p s -> r t, p t -> r s where
+	bimap :: r a b -> s c d -> t (p a c) (p b d)
+
+class (Category r, Category s) => CFunctor f r s | f r -> s,  f s -> r where
+	cmap :: r a b -> s (f a) (f b)
+
+instance CFunctor ([]) Hask Hask where cmap = fmap 
+instance CFunctor Maybe Hask Hask where cmap = fmap
+instance CFunctor (Either a) Hask Hask where cmap = fmap 
+instance CFunctor Identity Hask Hask where cmap = fmap
+instance CFunctor ((,)e) Hask Hask where cmap = fmap
+instance CFunctor (Reader e) Hask Hask where cmap = fmap
+instance CFunctor (LW.Writer e) Hask Hask where cmap = fmap
+instance CFunctor (SW.Writer e) Hask Hask where cmap = fmap
+instance CFunctor (LS.State s) Hask Hask where cmap = fmap
+instance CFunctor (SS.State s) Hask Hask where cmap = fmap
+instance CFunctor (Cont e) Hask Hask where cmap = fmap
+instance CFunctor (SRWS.RWS r w s) Hask Hask where cmap = fmap
+instance CFunctor (LRWS.RWS r w s) Hask Hask where cmap = fmap
+instance CFunctor IO Hask Hask where cmap = fmap
+
+instance Monad m => CFunctor (ReaderT e m) Hask Hask where cmap = fmap
+instance Monad m => CFunctor (LW.WriterT e m) Hask Hask where cmap = fmap
+instance Monad m => CFunctor (LS.StateT e m) Hask Hask where cmap = fmap
+instance Monad m => CFunctor (ContT r m) Hask Hask where cmap = fmap
+instance Monad m => CFunctor (ListT m) Hask Hask where cmap = fmap
+instance Monad m => CFunctor (LRWS.RWST r w s m) Hask Hask where cmap = fmap
+instance Monad m => CFunctor (SW.WriterT w m) Hask Hask where cmap = fmap
+instance Monad m => CFunctor (SS.StateT s m) Hask Hask where cmap = fmap
+instance Monad m => CFunctor (SRWS.RWST r w s m) Hask Hask where cmap = fmap
+
addfile ./src/Control/Functor/Abides.hs
hunk ./src/Control/Functor/Abides.hs 1
+-------------------------------------------------------------------------------------------
+-- |
+-- Module	: Control.Functor.Abides
+-- Copyright 	: 2008 Edward Kmett
+-- License	: BSD3
+--
+-- Maintainer	: Edward Kmett <ekmett@gmail.com>
+-- Stability	: experimental
+-- Portability	: portable
+--
+-- See p20 of <http://dbappl.cs.utwente.nl/Publications/PaperStore/db-utwente-404F4540.pdf>
+-- TODO: Encode the Eckmann-Hilton argument
+-------------------------------------------------------------------------------------------
+
+module Control.Functor.Abides
+	( Abides(..)
+	) where
+
+import Control.Functor
+
+-- Given p = (-) and q = (|), p and q abide (per Bird) when:
+
+-- a | b   a | b
+-- ----- = - | - 
+-- c | d   c | d
+
+
+class Abides p q where
+	abide :: q (p a b) (p c d) -> p (q a c) (p b d)
+	unabide :: p (q a c) (p b d) -> q (p a b) (p c d)
+
+instance Abides (,) (,) where
+	abide ((a,b),(c,d)) = ((a,c),(b,d))
+	unabide = abide
+
+instance Abides Either Either where
+	abide (Left (Left a)) 	= Left (Left a)
+	abide (Left (Right b)) 	= Right (Left b)
+	abide (Right (Left c)) 	= Left (Right c)
+	abide (Right (Right d)) = Right (Right d)
hunk ./src/Control/Functor/Adjunction.hs 16
-import Control.Comonad
hunk ./src/Control/Functor/Adjunction.hs 19
-import Control.Functor.Pointed
-import Control.Monad
hunk ./src/Control/Functor/Adjunction.hs 20
+import Control.Monad.Reader
+import Control.Monad.Instances
+import Control.Comonad
+import Control.Comonad.Reader
hunk ./src/Control/Functor/Adjunction.hs 65
+instance Adjunction ((,)e) ((->)e) where
+	unit a e = (e,a)
+	counit (x,f) = f x
+
+instance Adjunction (Coreader e) (Reader e) where
+	unit a = Reader (\e -> Coreader e a)
+	counit (Coreader x f) = runReader f x
+
+-- instance Adjunction f g => Adjunction (CoreaderT e f) (ReaderT e g) where
+
addfile ./src/Control/Functor/Combinators.hs
hunk ./src/Control/Functor/Combinators.hs 1
+{-# OPTIONS_GHC -cpp -fglasgow-exts #-}
+-------------------------------------------------------------------------------------------
+-- |
+-- Module	: Control.Functor.Combinators
+-- Copyright 	: 2008 Edward Kmett
+-- License	: BSD
+--
+-- Maintainer	: Edward Kmett <ekmett@gmail.com>
+-- Stability	: experimental
+-- Portability	: portable
+--
+-- Generalized functor combinators. The names are indicative of term-level combinators
+-- where possible to aid intuition
+-------------------------------------------------------------------------------------------
+
+module Control.Functor.Combinators
+	( module Control.Functor.Combinators.Biff
+	, module Control.Functor.Combinators.Const
+	, module Control.Functor.Combinators.Join
+	, module Control.Functor.Combinators.Lift
+	, module Control.Functor.Combinators.Of
+	) where
+
+import Control.Functor.Combinators.Biff
+import Control.Functor.Combinators.Const
+import Control.Functor.Combinators.Join
+import Control.Functor.Combinators.Lift
+import Control.Functor.Combinators.Of
hunk ./src/Control/Functor/Combinators/Biff.hs 3
--- Module	: Control.Bifunctor.Biff
+-- Module	: Control.Functor.Combinators.Biff
hunk ./src/Control/Functor/Combinators/Biff.hs 13
-module Control.Bifunctor.Biff 
-	( BiffB(..)
+module Control.Functor.Combinators.Biff 
+	( Biff(..)
+	-- Parameterized Type level 'On'
+	, On, runOn, mkOn
+	-- Parameterized Type Level 'Ap'
+	, PAp, runPAp, mkPAp
+	-- Parameterized Cofree Comonad
+	, PCofree, runPCofree, pcofree
+	-- Parameterized Free Monad
+	, PFree, runPFree, pfree
hunk ./src/Control/Functor/Combinators/Biff.hs 25
+import Control.Category.Hask
hunk ./src/Control/Functor/Combinators/Biff.hs 28
-import Control.Bifunctor.Monoidal
+import Control.Category.Monoidal
+import Control.Functor
hunk ./src/Control/Functor/Combinators/Biff.hs 34
-newtype BiffB p f g a b = BiffB { runBiffB :: p (f a) (g b) } 
+newtype Biff p f g a b = Biff { runBiff :: p (f a) (g b) } 
hunk ./src/Control/Functor/Combinators/Biff.hs 36
-instance (Functor f, Bifunctor p, Functor g) => Bifunctor (BiffB p f g) where
-	bimap f g = BiffB . bimap (fmap f) (fmap g) . runBiffB
+type PAp p = Biff p Identity
hunk ./src/Control/Functor/Combinators/Biff.hs 38
-instance (Functor f, Braided p) => Braided (BiffB p f f) where
-	braid = BiffB . braid . runBiffB
+runPAp :: PFunctor p Hask Hask => PAp p f a b -> p a (f b)
+runPAp = first runIdentity . runBiff
hunk ./src/Control/Functor/Combinators/Biff.hs 41
-instance (Functor f, Symmetric p) => Symmetric (BiffB p f f) 
+mkPAp :: PFunctor p Hask Hask => p a (f b) -> PAp p f a b
+mkPAp = Biff . first Identity
+ 
+type PFree = PAp Either
hunk ./src/Control/Functor/Combinators/Biff.hs 46
-instance (Functor f, Bifunctor p, Functor g) => Functor (BiffB p f g a) where
+pfree :: Either a (f b) -> PFree f a b
+pfree = mkPAp
+
+runPFree :: PFree f a b -> Either a (f b)
+runPFree = runPAp
+
+type PCofree = PAp (,)
+
+runPCofree :: PCofree f a b -> (a, f b)
+runPCofree = runPAp
+
+pcofree :: (a, f b) -> PCofree f a b
+pcofree = mkPAp
+
+type On p f = Biff p f f
+
+runOn :: On p f a b -> p (f a) (f b)
+runOn = runBiff
+
+mkOn :: p (f a) (f b) -> On p f a b
+mkOn = Biff
+
+{-
+type Joker = Biff (,) VoidF
+type Clown f = Biff (,) f VoidF
+type Fst = Biff (,) VoidF Identity
+type Snd = Biff (,) Identity VoidF
+-}
+
+instance (Functor f, PFunctor p Hask Hask) => PFunctor (Biff p f g) Hask Hask where
+	first f = Biff . first (fmap f) . runBiff
+
+instance (QFunctor q Hask Hask, Functor g) => QFunctor (Biff q f g) Hask Hask where
+	second g = Biff . second (fmap g) . runBiff
+
+instance (Functor f, Bifunctor p Hask Hask Hask, Functor g) => Bifunctor (Biff p f g) Hask Hask Hask where
+	bimap f g = Biff . bimap (fmap f) (fmap g) . runBiff
+
+instance (Functor f, Braided p Hask) => Braided (Biff p f f) Hask where
+	braid = Biff . braid . runBiff
+
+instance (Functor f, Symmetric p Hask) => Symmetric (Biff p f f) Hask
+
+instance (Functor f, Bifunctor p Hask Hask Hask, Functor g) => Functor (Biff p f g a) where
hunk ./src/Control/Functor/Combinators/Biff.hs 92
-instance FunctorPlus f => PPointed (BiffB (,) Identity f) where
-        preturn a = BiffB (Identity a,fzero)
+instance FunctorPlus f => PPointed (PCofree f) where
+        preturn a = Biff (Identity a,fzero)
hunk ./src/Control/Functor/Combinators/Biff.hs 95
-instance Functor f => PPointed (BiffB Either Identity f) where
-        preturn = BiffB . Left . Identity
+instance Functor f => PPointed (PFree f) where
+        preturn = Biff . Left . Identity
hunk ./src/Control/Functor/Combinators/Biff.hs 98
-instance Functor f => PCopointed (BiffB (,) Identity f) where
-        pextract = runIdentity . fst . runBiffB
+instance Functor f => PCopointed (PCofree f) where
+        pextract = runIdentity . fst . runBiff
hunk ./src/Control/Functor/Combinators/Biff.hs 101
-instance Functor f => PApplicative (BiffB Either Identity f) where
+instance Functor f => PApplicative (PFree f) where
hunk ./src/Control/Functor/Combinators/Biff.hs 104
-instance Functor f => PMonad (BiffB Either Identity f) where
-        pbind k = (k . runIdentity ||| BiffB . Right) . runBiffB
+instance Functor f => PMonad (PFree f) where
+        pbind k = (k . runIdentity ||| Biff . Right) . runBiff
hunk ./src/Control/Functor/Combinators/Biff.hs 107
-instance FunctorPlus f => PApplicative (BiffB (,) Identity f) where
+instance FunctorPlus f => PApplicative (PCofree f) where
hunk ./src/Control/Functor/Combinators/Biff.hs 110
-instance FunctorPlus f => PMonad (BiffB (,) Identity f) where
-        pbind k (BiffB ~(Identity a,as)) = BiffB (ib, fplus as bs) where BiffB (ib,bs) = k a
+instance FunctorPlus f => PMonad (PCofree f) where
+        pbind k (Biff ~(Identity a,as)) = Biff (ib, fplus as bs) where Biff (ib,bs) = k a
hunk ./src/Control/Functor/Combinators/Biff.hs 113
-instance Functor f => PComonad (BiffB (,) Identity f) where
-        pextend f = BiffB . (Identity . f &&& snd . runBiffB)
+instance Functor f => PComonad (PCofree f) where
+        pextend f = Biff . (Identity . f &&& snd . runBiff)
addfile ./src/Control/Functor/Combinators/Const.hs
hunk ./src/Control/Functor/Combinators/Const.hs 1
+-------------------------------------------------------------------------------------------
+-- |
+-- Module	: Control.Functor.Combinators.Const
+-- Copyright 	: 2008 Edward Kmett
+-- License	: BSD3
+--
+-- Maintainer	: Edward Kmett <ekmett@gmail.com>
+-- Stability	: experimental
+-- Portability	: portable
+--
+-------------------------------------------------------------------------------------------
+
+module Control.Functor.Combinators.Const
+	( Const2(Const2,runConst2)
+	) where
+
+import Data.Monoid
+import Control.Applicative
+import Control.Applicative.Parameterized ()
+import Control.Monad
+import Control.Category.Hask
+import Control.Category.Associative
+import Control.Category.Braided
+import Control.Functor
+import Control.Functor.Exponential
+import Control.Functor.Contra
+import Control.Functor.Zip
+import Control.Functor.Pointed
+import Control.Monad.Parameterized
+import Control.Comonad.Parameterized ()
+
+newtype Const2 t a b = Const2 { runConst2 :: t } 
+
+instance QFunctor (Const2 t) Hask Hask where
+	second _ = Const2 . runConst2
+
+instance PFunctor (Const2 t) Hask Hask where
+	first _ = Const2 . runConst2
+
+instance Bifunctor (Const2 t) Hask Hask Hask where
+	bimap _ _ = Const2 . runConst2
+
+instance Associative (Const2 t) Hask where
+	associate = Const2 . runConst2
+
+instance Coassociative (Const2 t) Hask where
+	coassociate = Const2 . runConst2
+
+instance Braided (Const2 t) Hask where
+	braid = Const2 . runConst2
+
+instance Symmetric (Const2 t) Hask
+
+instance Monoid t => Zip (Const2 t a) where
+	fzipWith _ a b = Const2 (runConst2 a `mappend` runConst2 b)
+
+instance Monoid t => Bizip (Const2 t) where
+	bizipWith _ _ a b = Const2 (runConst2 a `mappend` runConst2 b)
+
+instance Functor (Const2 t a) where
+	fmap _ = Const2 . runConst2
+
+instance ContraFunctor (Const2 t a) where
+	contramap _ = Const2 . runConst2
+
+instance ExpFunctor (Const2 t a) where
+	xmap _ _ = Const2 . runConst2
+
+instance Monoid t => Pointed (Const2 t a) where
+	point _ = Const2 mempty
+
+instance Monoid t => PPointed (Const2 t) where
+	preturn _ = Const2 mempty
+
+instance Monoid t => Applicative (Const2 t a) where
+	pure _ = Const2 mempty
+	f <*> a = Const2 (runConst2 f `mappend` runConst2 a)
+
+instance Monoid t => PApplicative (Const2 t) where
+	pap f a = Const2 (runConst2 f `mappend` runConst2 a)
+
+instance Monoid t => Monad (Const2 t a) where
+	return _ = Const2 mempty
+	m >>= _ = Const2 $ runConst2 m 
+
+instance Monoid t => PMonad (Const2 t) where
+	pbind _ = Const2 . runConst2
+
+instance Monoid t => Monoid (Const2 t a b) where
+	mempty = Const2 mempty
+	mappend a b = Const2 (runConst2 a `mappend` runConst2 b)
+
+instance Monoid t => MonadPlus (Const2 t a) where
+	mzero = Const2 mempty
+	mplus a b = Const2 (runConst2 a `mappend` runConst2 b)
addfile ./src/Control/Functor/Combinators/Flip.hs
hunk ./src/Control/Functor/Combinators/Flip.hs 1
+{-# LANGUAGE TypeFamilies #-}
+-------------------------------------------------------------------------------------------
+-- |
+-- Module	: Control.Functor.Combinators.Flip
+-- Copyright 	: 2008 Edward Kmett
+-- License	: BSD3
+--
+-- Maintainer	: Edward Kmett <ekmett@gmail.com>
+-- Stability	: experimental
+-- Portability	: portable
+--
+-------------------------------------------------------------------------------------------
+
+module Control.Functor.Combinators.Flip
+	( Flip(..)
+	, liftFlip
+	) where
+
+import Control.Monad.Identity
+import Control.Functor
+import Control.Category.Hask
+import Control.Category.Associative
+import Control.Category.Monoidal
+
+newtype Flip p a b = Flip { runFlip :: p b a } 
+
+liftFlip :: (p a b -> p c d) -> Flip p b a -> Flip p d c
+liftFlip f = Flip . f . runFlip
+
+instance PFunctor p Hask Hask => QFunctor (Flip p) Hask Hask where
+	second g = liftFlip (first g)
+
+instance QFunctor p Hask Hask => PFunctor (Flip p) Hask Hask where
+	first f = liftFlip (second f)
+
+instance Bifunctor p Hask Hask Hask => Bifunctor (Flip p) Hask Hask Hask where
+	bimap f g = liftFlip (bimap g f)
+
+instance Braided p Hask => Braided (Flip p) Hask where
+	braid = liftFlip braid
+
+instance Symmetric p Hask => Symmetric (Flip p) Hask
+
+instance Bifunctor p Hask Hask Hask => Functor (Flip p a) where
+	fmap = bimap id
+
+instance HasIdentity p Hask => HasIdentity (Flip p) Hask where
+	type Id (Flip p) Hask = Id p Hask
+
+instance Associative p Hask => Coassociative (Flip p) Hask where
+	coassociate = Flip . second Flip . associate . first runFlip . runFlip 
+	-- Flip p a (Flip p b c) 	>- runFlip ->
+	-- p (Flip p b c) a 		>- first runFlip ->
+	-- p (p c b) a 			>- associate ->
+	-- p c (p b a)			>- second Flip -> 
+	-- p c (Flip p a b) 		>- Flip ->
+	-- Flip p (Flip p a b) c
+	
+instance Coassociative p Hask => Associative (Flip p) Hask where
+	associate = Flip . first Flip . coassociate . second runFlip . runFlip
+
+instance (Coassociative p Hask, Monoidal p Hask) => Monoidal (Flip p) Hask where
+	idl = idr . runFlip 
+	idr = idl . runFlip
+
+instance (Associative p Hask, Comonoidal p Hask) => Comonoidal (Flip p) Hask where
+	coidl = Flip . coidr
+	coidr = Flip . coidl
addfile ./src/Control/Functor/Combinators/Join.hs
hunk ./src/Control/Functor/Combinators/Join.hs 1
+{-# OPTIONS_GHC -fglasgow-exts #-}
+-----------------------------------------------------------------------------
+-- |
+-- Module      :  Control.Functor.Combinators.Join
+-- Copyright   :  (C) 2008 Edward Kmett
+-- License     :  BSD-style (see the file LICENSE)
+--
+-- Maintainer  :  Edward Kmett <ekmett@gmail.com>
+-- Stability   :  experimental
+-- Portability :  portable
+--
+----------------------------------------------------------------------------
+module Control.Functor.Combinators.Join
+	( Join(..)
+	) where
+
+import Control.Functor
+import Control.Category.Hask
+
+newtype Join p a = Join { runJoin :: p a a } 
+
+instance Bifunctor p Hask Hask Hask => Functor (Join p) where
+	fmap f = Join . bimap f f . runJoin
addfile ./src/Control/Functor/Combinators/Lift.hs
hunk ./src/Control/Functor/Combinators/Lift.hs 1
+{-# OPTIONS_GHC -cpp -fglasgow-exts -fallow-undecidable-instances #-}
+-------------------------------------------------------------------------------------------
+-- |
+-- Module	: Control.Functor.Combinators.Lift
+-- Copyright 	: 2008 Edward Kmett
+-- License	: BSD
+--
+-- Maintainer	: Edward Kmett <ekmett@gmail.com>
+-- Stability	: experimental
+-- Portability	: non-portable (functional-dependencies)
+--
+-- transform a pair of functors with a bifunctor deriving a new functor.
+-- this subsumes functor product and functor coproduct
+-------------------------------------------------------------------------------------------
+
+module Control.Functor.Combinators.Lift 
+	( Lift(Lift,runLift)
+	, (:*:), runProductF
+	, (:+:), runCoproductF 
+	, Ap, runAp, mkAp
+	) where
+
+import Control.Category.Hask
+import Control.Functor
+import Control.Functor.Contra
+import Control.Functor.Exponential
+import Control.Functor.Full
+import Control.Monad.Identity
+import Control.Functor.Pointed
+import Control.Arrow ((&&&),(|||))
+
+-- * Bifunctor functor transformer
+
+-- type-level LiftA2 
+newtype Lift p f g a = Lift { runLift :: p (f a) (g a) }
+type Ap p = Lift p Identity
+
+runAp :: Bifunctor p Hask Hask Hask => Ap p f a -> p a (f a)
+runAp = first runIdentity . runLift
+
+mkAp :: Bifunctor p Hask Hask Hask => p a (f a) -> Ap p f a 
+mkAp = Lift . first Identity
+
+instance (Bifunctor p Hask Hask Hask, Functor f ,Functor g) => Functor (Lift p f g) where
+        fmap f = Lift . bimap (fmap f) (fmap f) . runLift
+
+instance (Bifunctor p Hask Hask Hask, ContraFunctor f ,ContraFunctor g) => ContraFunctor (Lift p f g) where
+        contramap f = Lift . bimap (contramap f) (contramap f) . runLift
+
+instance (Bifunctor p Hask Hask Hask, ExpFunctor f ,ExpFunctor g) => ExpFunctor (Lift p f g) where
+        xmap f g = Lift . bimap (xmap f g) (xmap f g) . runLift
+
+type (f :*: g) = Lift (,) f g
+
+runProductF :: (f :*: g) a -> (f a, g a)
+runProductF = runLift
+
+instance (Pointed f, Pointed g) => Pointed (f :*: g) where
+        point = Lift . (point &&& point)
+
+instance (Faithful f, Faithful g) => Faithful (f :*: g)
+
+type (f :+: g) = Lift Either f g
+
+runCoproductF :: (f :+: g) a -> Either (f a) (g a)
+runCoproductF = runLift
+
+instance (Copointed f, Copointed g) => Copointed (f :+: g) where
+        extract = (extract ||| extract) . runLift
addfile ./src/Control/Functor/Combinators/Of.hs
hunk ./src/Control/Functor/Combinators/Of.hs 1
+{-# OPTIONS_GHC -fglasgow-exts #-}
+-----------------------------------------------------------------------------
+-- |
+-- Module      :  Control.Functor.Combinators.Of
+-- Copyright   :  (C) 2008 Edward Kmett
+-- License     :  BSD-style (see the file LICENSE)
+--
+-- Maintainer  :  Edward Kmett <ekmett@gmail.com>
+-- Stability   :  experimental
+-- Portability :  portable
+--
+----------------------------------------------------------------------------
+module Control.Functor.Combinators.Of
+	( Of(Of,runOf), liftOf
+	) where
+
+import Prelude hiding ((.),id)
+import Control.Category
+import Control.Category.Hask
+import Control.Category.Braided
+import Control.Functor
+import Control.Functor.Pointed
+-- import Control.Functor.Zip
+-- import Control.Functor.Zap
+
+newtype Of f p a b = Of { runOf :: f (p a b) }
+
+liftOf :: Functor f => (p a b -> p c d) -> Of f p a b -> Of f p c d
+liftOf f = Of . fmap f . runOf
+
+instance (Functor f, PFunctor p Hask Hask) => PFunctor (f `Of` p) Hask Hask where
+        first f = liftOf (first f)
+instance (Functor f, QFunctor p Hask Hask) => QFunctor (f `Of` p) Hask Hask where
+        second g = liftOf (second g)
+instance (Functor f, Bifunctor p Hask Hask Hask) => Bifunctor (f `Of` p) Hask Hask Hask where
+        bimap f g = liftOf (bimap f g)
+
+instance (Functor f, Braided p Hask) => Braided (f `Of` p) Hask where
+        braid = liftOf braid
+
+instance (Functor f, Symmetric p Hask) => Symmetric (f `Of` p) Hask
+
+instance (Functor f, Functor (p a)) => Functor (Of f p a) where
+        fmap f = Of . fmap (fmap f) . runOf
+
+instance (Pointed f, PPointed p) => PPointed (f `Of` p) where
+	preturn = Of . point . preturn
+
+instance (Copointed f, PCopointed p) => PCopointed (f `Of` p) where
+	pextract = pextract . extract . runOf
+
+instance (Pointed f, Pointed (p a)) => Pointed (Of f p a) where
+	point = Of . point . point
+
+instance (Copointed f, Copointed (p a)) => Copointed (Of f p a) where
+	extract = extract . extract . runOf
+
+{-
+instance (Zip f, Bizip p) => Bizip (f `Of` p) where
+	bizipWith f g = Of . fzipWith (bizipWith f g) . runOf 
+
+instance (Zip f, Zip (p a)) => Zip (Of f p a) where
+	fzipWith f = Of . fzipWith (fzipWith f) . runOf
+
+instance (Bizap p q, Zap f g) => Bizap (f `Of` p) (g `Of` q) where
+	bizapWith f g = Of . zapWith (bizapWith f g) . runOf
+-}
hunk ./src/Control/Functor/Composition.hs 18
-	, associateComp
-	, coassociateComp
+	, associateComposition
+	, coassociateComposition
hunk ./src/Control/Functor/Composition.hs 21
+	, Comp
+	, (:++:)
+	, (:**:)
+	, liftComp
hunk ./src/Control/Functor/Composition.hs 27
+import Control.Functor
hunk ./src/Control/Functor/Composition.hs 30
+import Control.Category.Hask
+import Control.Category.Braided
hunk ./src/Control/Functor/Composition.hs 43
-type (f :.: g) a = CompF f g a
+type (:.:) = CompF
hunk ./src/Control/Functor/Composition.hs 55
-associateComp :: (Functor f, Composition c) => c (c f g) h a -> c f (c g h) a
-associateComp = compose . fmap compose . decompose . decompose
+associateComposition :: (Functor f, Composition c) => c (c f g) h a -> c f (c g h) a
+associateComposition = compose . fmap compose . decompose . decompose
hunk ./src/Control/Functor/Composition.hs 58
-coassociateComp :: (Functor f, Composition c) => c f (c g h) a -> c (c f g) h a
-coassociateComp = compose . compose . fmap decompose . decompose
+coassociateComposition :: (Functor f, Composition c) => c f (c g h) a -> c (c f g) h a
+coassociateComposition = compose . compose . fmap decompose . decompose
hunk ./src/Control/Functor/Composition.hs 61
+newtype Comp p f g a b = Comp { runComp :: p (f a b) (g a b) }
+type (:++:) = Comp Either
+type (:**:) = Comp (,)
hunk ./src/Control/Functor/Composition.hs 65
+instance (Bifunctor p c d Hask, PFunctor f a c, PFunctor g a d) => PFunctor (Comp p f g) a Hask where
+	first f = Comp . bimap (first f) (first f) . runComp
+
+instance (Bifunctor p c d Hask, QFunctor f b c, QFunctor g b d) => QFunctor (Comp p f g) b Hask where
+	second g = Comp . bimap (second g) (second g) . runComp
+
+instance (Bifunctor p c d Hask, Bifunctor f a b c, Bifunctor g a b d) => Bifunctor (Comp p f g) a b Hask where
+	bimap f g = Comp . bimap (bimap f g) (bimap f g) . runComp
+
+liftComp :: Bifunctor p r s Hask => r (f a b) (f c d) -> s (g a b) (g c d) -> Comp p f g a b -> Comp p f g c d 
+liftComp f g = Comp . bimap f g . runComp
+
+instance (Bifunctor p Hask Hask Hask, Braided f Hask, Braided g Hask) => Braided (Comp p f g) Hask where
+	braid = liftComp braid braid
+
+instance (Bifunctor p Hask Hask Hask, Symmetric f Hask, Symmetric g Hask) => Symmetric (Comp p f g) Hask
+
+instance (Bifunctor p Hask Hask Hask, Bifunctor f Hask Hask Hask, Bifunctor g Hask Hask Hask) => Functor (Comp p f g a) where
+	fmap = bimap id
hunk ./src/Control/Functor/Constant.hs 1
-{-# OPTIONS_GHC -fglasgow-exts -fallow-undecidable-instances #-}
--------------------------------------------------------------------------------------------
--- |
--- Module	: Control.Functor.Constant
--- Copyright 	: 2008 Edward Kmett
--- License	: BSD
---
--- Maintainer	: Edward Kmett <ekmett@gmail.com>
--- Stability	: experimental
--- Portability	: non-portable (functional-dependencies)
---
--------------------------------------------------------------------------------------------
-
-module Control.Functor.Constant where
-
-import Control.Functor.Exponential
-import Control.Functor.Contravariant
-import Data.Void
-
--- this is also the 'Fst' bifunctor
-
-newtype ConstantF a b = ConstantF a
-
-instance Functor (ConstantF a) where
-	fmap _ (ConstantF a) = ConstantF a
-
-instance ContravariantFunctor (ConstantF a) where
-	contramap _ (ConstantF a) = ConstantF a
-
-instance ExpFunctor (ConstantF a) where
-	xmap _ _ (ConstantF a) = ConstantF a
-
-type VoidF a = ConstantF Void a
rmfile ./src/Control/Functor/Constant.hs
addfile ./src/Control/Functor/Contra.hs
hunk ./src/Control/Functor/Contra.hs 1
+-------------------------------------------------------------------------------------------
+-- |
+-- Module	: Control.Functor.Contra
+-- Copyright 	: 2008 Edward Kmett
+-- License	: BSD
+--
+-- Maintainer	: Edward Kmett <ekmett@gmail.com>
+-- Stability	: experimental
+-- Portability	: portable
+--
+-------------------------------------------------------------------------------------------
+
+module Control.Functor.Contra
+	( ContraFunctor(..)
+	, ContraF(..)
+	) where
+
+import Control.Applicative 
+
+class ContraFunctor f where
+	contramap :: (a -> b)  -> f b -> f a
+
+newtype ContraF a b = ContraF { runContraF :: b -> a }
+
+instance ContraFunctor (ContraF a) where
+        contramap g (ContraF f) = ContraF (f . g)
+
+instance ContraFunctor (Const a) where
+        contramap _ (Const a) = Const a
hunk ./src/Control/Functor/Contravariant.hs 1
-{-# OPTIONS_GHC -fglasgow-exts #-}
--------------------------------------------------------------------------------------------
--- |
--- Module	: Control.Functor.Contravariant
--- Copyright 	: 2008 Edward Kmett
--- License	: BSD
---
--- Maintainer	: Edward Kmett <ekmett@gmail.com>
--- Stability	: experimental
--- Portability	: non-portable (class-associated types)
---
--------------------------------------------------------------------------------------------
-
-module Control.Functor.Contravariant where
-
-class ContravariantFunctor f where
-	contramap :: (a -> b)  -> f b -> f a
-
-newtype ContraF a b = ContraF { runContraF :: b -> a }
-
-instance ContravariantFunctor (ContraF a) where
-        contramap g (ContraF f) = ContraF (f . g)
rmfile ./src/Control/Functor/Contravariant.hs
hunk ./src/Control/Functor/Exponential.hs 15
-module Control.Functor.Exponential where
+module Control.Functor.Exponential 
+	( ExpFunctor(xmap)
+	) where
+
+import Control.Applicative (Const(..))
hunk ./src/Control/Functor/Exponential.hs 24
+instance ExpFunctor (Const a) where
+        xmap _ _ (Const a) = Const a
hunk ./src/Control/Functor/Fix.hs 12
-module Control.Functor.Fix where
+module Control.Functor.Fix 
+	( Fix(InF,outF)
+	, outM, inW
+	, FixB(InB,outB)
+	, paugment, pcoaugment
+	) where
hunk ./src/Control/Functor/Fix.hs 22
+import Control.Monad.Parameterized
+import Control.Comonad.Parameterized
+import Control.Comonad
+import Control.Category.Hask
+import Control.Morphism.Hylo
hunk ./src/Control/Functor/Fix.hs 36
+-- * Fixpoint of a bifunctor
+
+newtype FixB s a = InB { outB :: s a (FixB s a) }
+
+instance Bifunctor s Hask Hask Hask => Functor (FixB s) where
+        fmap f = InB . bimap f (fmap f) . outB
+
+instance (Bifunctor f Hask Hask Hask, PCopointed f) => Copointed (FixB f) where
+        extract = pextract . outB
+
+instance (Bifunctor f Hask Hask Hask, PPointed f) => Pointed (FixB f) where
+        point = InB . preturn
+
+instance (Bifunctor f Hask Hask Hask, PComonad f) => Comonad (FixB f) where
+        extend k w = pcoaugment (\g -> bihylo InB id g w) k
+
+instance (Bifunctor f Hask Hask Hask, PMonad f) => Monad (FixB f) where
+        return = InB . preturn
+        m >>= k = paugment (\f -> bihylo f id outB m) k
+
+paugment :: PMonad f => (forall c. (f a c -> c) -> c) -> (a -> FixB f b) -> FixB f b
+paugment g k = g (InB . pbind (outB . k))
+
+pcoaugment :: PComonad f => ((FixB f a -> f b (FixB f a)) -> FixB f b) -> (FixB f a -> b) -> FixB f b
+pcoaugment g k = g (pextend (k . InB) . outB)
hunk ./src/Control/Functor/HigherOrder.hs 38
-	hreturn  :: Functor f => Natural f (m f)
+	hreturn  :: Functor f => f a -> m f a
hunk ./src/Control/Functor/HigherOrder.hs 41
-	hextract :: Functor f => Natural (w f) f
+	hextract :: Functor f => w f a -> f a
hunk ./src/Control/Functor/HigherOrder/Composition.hs 43
+
+instance (HFunctor f, HFunctor g, Functor h) => Functor (CompH f g h) where
+	fmap = ffmap
addfile ./src/Control/Functor/Ideal.hs
hunk ./src/Control/Functor/Ideal.hs 1
+{-# OPTIONS_GHC -fglasgow-exts #-}
+-----------------------------------------------------------------------------
+-- |
+-- Module      :  Control.Functor.Ideal
+-- Copyright   :  (C) 2008 Edward Kmett
+-- License     :  BSD-style (see the file LICENSE)
+--
+-- Maintainer  :  Edward Kmett <ekmett@gmail.com>
+-- Stability   :  experimental
+-- Portability :  portable
+--
+----------------------------------------------------------------------------
+module Control.Functor.Ideal
+	( Ideal(..)
+	, Coideal(..)
+	, LiftI2(..)
+	, toI2 
+	, fromI2
+	) where
+
+import Control.Arrow ((|||),(&&&))
+import Control.Bifunctor
+-- import Control.Bifunctor.Biff
+import Control.Functor.Bifunctor
+import Control.Functor.Constant
+-- import Control.Bifunctor.Fix
+import Control.Monad.Identity
+import Control.Applicative
+import Control.Comonad
+
+
+
+
+newtype LiftI2 p m n a = LiftI2 { lowerI2 :: LiftF2 p (M p m n) (N p m n) a } deriving (Functor)
+
+fromI2 :: LiftI2 p m n a -> p (M p m n a) (N p m n a)
+fromI2 = lowerF2 . lowerI2
+
+toI2 :: p (M p m n a) (N p m n a) -> LiftI2 p m n a 
+toI2 = LiftI2 . LiftF2 
+
+data M p m n a = M { runM :: m (p a (N p m n a)) } 
+data N p m n a = N { runN :: n (p a (M p m n a)) }
+
+-- | Ideal Monads
+newtype Ap p f a = Ap { runAp :: p a (f a) } 
+
+instance (Bifunctor p, Functor f) => Functor (Ap p f) where
+	fmap f = Ap . bimap f (fmap f) . runAp
+
+instance Functor f => Pointed (Ap Either f) where
+	point = Ap . Left
+
+
+-- this only really needs 'ap' but there is no 'unpointed/pre- applicative'
+instance Applicative f => Applicative (Ap Either f) where
+	pure = point
+	Ap (Left f) <*> Ap (Left a) = Ap $ Left (f a)
+	Ap (Left f) <*> Ap (Right bs) = Ap $ Right (fmap f bs)
+	Ap (Right fs) <*> Ap (Left a) = Ap $ Right (fmap ($a) fs)
+	Ap (Right fs) <*> Ap (Right bs) = Ap $ Right (fs <*> bs)
+
+instance (Bifunctor p, Functor m, Functor n) => Functor (M p m n) where
+	fmap f = M . fmap (bimap f (fmap f)) . runM
+
+instance (Bifunctor p, Functor m, Functor n) => Functor (N p m n) where
+	fmap f = N . fmap (bimap f (fmap f)) . runN
+
+newtype Ideal f a = Ideal { runIdeal ::  Either a (f a) }
+newtype Coideal f a = Coideal { runCoideal :: (a, f a) }
+
+class Functor w => ComonadCoideal w where
+	coidealize :: w a -> w (a, w a)
+
+instance Functor f => Functor (Coideal f) where
+	fmap f = Coideal . bimap f (fmap f) . runCoideal
+
+instance Functor f => Copointed (Coideal f) where
+	extract = fst . runCoideal
+
+instance ComonadCoideal w => Comonad (Coideal w) where
+	extend f = fmap (f . Coideal) . Coideal . (id &&& coidealize . snd) . runCoideal
+
+instance (ComonadCoideal w, ComonadCoideal v) => ComonadCoideal (LiftI2 (,) w v) where
+	coidealize = undefined
+
+{-
+instance (ComonadCoideal w, ComonadCoideal v) => ComonadCoideal (LiftI2 (,) w v) where
+	-- coidealize :: CoidealProduct w v a -> CoidealProduct w v (a , CoidealProduct w v a)
+	coidealize = undefined
+-}
+
+-- Coideal (ConstantF k) rederives the reader comonad
+instance ComonadCoideal (ConstantF k) where
+	coidealize (ConstantF k) = ConstantF k
hunk ./src/Control/Functor/KanExtension.hs 11
+-- Left and right Kan extensions, expressed as higher order functors
+--
+-- Some reference for the Ran monad/Lan comonad below would be nice, as I 
+-- constructed them from first principles, but haven't seen them in 
+-- literature.
hunk ./src/Control/Functor/KanExtension.hs 26
+import Control.Functor.Pointed ()
+import Control.Functor.HigherOrder
+import Control.Comonad
+import Control.Monad.Cont
hunk ./src/Control/Functor/KanExtension.hs 40
+instance HFunctor (Ran g) where
+	hfmap f (Ran m) = Ran (f . m)
+	ffmap f m = Ran (\k -> runRan m (k . f))
+
+instance Functor (Ran g h) where
+	fmap f m = Ran (\k -> runRan m (k . f))
+
+instance Pointed (Ran f f) where
+	point x = Ran (\k -> k x)
+
+instance Monad (Ran f f) where
+	return = point
+	m >>= k = Ran (\c -> runRan m (\a -> runRan (k a) c))
+
hunk ./src/Control/Functor/KanExtension.hs 61
-fromLan s t = compose . s $ Lan id t
+fromLan s = compose . s . Lan id
+
+instance Functor g => HFunctor (Lan g) where
+	ffmap f (Lan g h) = Lan (f . g) h
+	hfmap f (Lan g h) = Lan g (f h)
+
+instance Functor (Lan f g) where
+	fmap f (Lan g h) = Lan (f . g) h 
+
+instance Copointed (Lan f f) where
+	extract (Lan f a) = f a
+
+instance Comonad (Lan f f) where
+	duplicate (Lan f ws) = Lan (Lan f) ws
hunk ./src/Control/Functor/Lift.hs 1
-{-# OPTIONS_GHC -cpp -fglasgow-exts -fallow-undecidable-instances #-}
--------------------------------------------------------------------------------------------
--- |
--- Module	: Control.Functor.Bifunctor
--- Copyright 	: 2008 Edward Kmett
--- License	: BSD
---
--- Maintainer	: Edward Kmett <ekmett@gmail.com>
--- Stability	: experimental
--- Portability	: non-portable (functional-dependencies)
---
--- transform a pair of functors with a bifunctor deriving a new functor.
--- this subsumes functor product and functor coproduct
--------------------------------------------------------------------------------------------
-
-module Control.Functor.Bifunctor where
-
-import Control.Bifunctor
-import Control.Functor.Contravariant
-import Control.Functor.Exponential
-import Control.Functor.Full
-import Control.Functor.Pointed
-import Control.Arrow ((&&&),(|||))
-
--- * Bifunctor functor transformer
-
-newtype BifunctorF p f g a = BifunctorF { runBifunctorF :: p (f a) (g a) }
-
-instance (Bifunctor p, Functor f ,Functor g) => Functor (BifunctorF p f g) where
-        fmap f = BifunctorF . bimap (fmap f) (fmap f) . runBifunctorF
-
-instance (Bifunctor p, ContravariantFunctor f ,ContravariantFunctor g) => ContravariantFunctor (BifunctorF p f g) where
-        contramap f = BifunctorF . bimap (contramap f) (contramap f) . runBifunctorF
-
-instance (Bifunctor p, ExpFunctor f ,ExpFunctor g) => ExpFunctor (BifunctorF p f g) where
-        xmap f g = BifunctorF . bimap (xmap f g) (xmap f g) . runBifunctorF
-
-
-
-#ifndef __HADDOCK__
-type (f :*: g) a = BifunctorF (,) f g a
-#endif
-
-
-runProductF :: BifunctorF (,) f g a -> (f a, g a)
-runProductF = runBifunctorF
-
-instance (Pointed f, Pointed g) => Pointed (BifunctorF (,) f g) where
-        point = BifunctorF . (point &&& point)
-
-instance (Faithful f, Faithful g) => Faithful (BifunctorF (,) f g)
-
-#ifndef __HADDOCK__
-type (f :+: g) a = BifunctorF Either f g a
-#endif
-
-
-runCoproductF :: BifunctorF Either f g a -> Either (f a) (g a)
-runCoproductF = runBifunctorF
-
-instance (Copointed f, Copointed g) => Copointed (BifunctorF Either f g) where
-        extract = (extract ||| extract) . runBifunctorF
-
rmfile ./src/Control/Functor/Lift.hs
hunk ./src/Control/Functor/Pointed.hs 16
+	, PPointed(..)
+	, PCopointed(..)
hunk ./src/Control/Functor/Pointed.hs 20
+import Control.Functor
+import Control.Category
+import Control.Category.Hask
hunk ./src/Control/Functor/Pointed.hs 24
+import Prelude hiding ((.),id)
hunk ./src/Control/Functor/Pointed.hs 55
+class PFunctor f Hask Hask => PPointed f where
+        preturn :: a -> f a c
+        -- preturn :: k a (f a c)
+
+class PFunctor f Hask Hask => PCopointed f where
+	pextract :: f a c -> a
+	-- pextract :: k (f a c) a
+
+{-# RULES
+"bimap id g . preturn"     	forall g. bimap id g . preturn = preturn
+"pextract . bimap id g"    	forall g. pextract . bimap id g = pextract
+"preturn/pextract" 		preturn . pextract = id
+"pextract/preturn" 		pextract. preturn = id
+ #-}
+
hunk ./src/Control/Functor/Zap.hs 12
--- Dual Functors
+-- Dual (bi)Functors
hunk ./src/Control/Functor/Zap.hs 15
-module Control.Functor.Zap where
+module Control.Functor.Zap 
+	( Zap(..), (>$<)
+	, Bizap(..), (>>$<<)
+	) where
hunk ./src/Control/Functor/Zap.hs 20
-import Control.Comonad.Cofree
+import Control.Functor.Combinators.Biff
hunk ./src/Control/Functor/Zap.hs 39
-class BiZap p q | p -> q, q -> p where
+class Bizap p q | p -> q, q -> p where
hunk ./src/Control/Functor/Zap.hs 45
-(>>$<<) :: BiZap p q => p (a -> c) (b -> c) -> q a b -> c
+(>>$<<) :: Bizap p q => p (a -> c) (b -> c) -> q a b -> c
hunk ./src/Control/Functor/Zap.hs 48
-instance BiZap (,) Either where
+instance Bizap (,) Either where
hunk ./src/Control/Functor/Zap.hs 52
-instance BiZap Either (,) where
+instance Bizap Either (,) where
hunk ./src/Control/Functor/Zap.hs 56
--- instance (Functor f, Functor g, Zap f g) => BiZap (CofreeB f) (FreeB g) where
---	bizapWith l r (CofreeB fs) (FreeB as) = bizapWith l (zapWith r) fs as
-
--- instance (Functor f, Functor g, Zap f g) => BiZap (FreeB f) (CofreeB g) where
---	bizapWith l r (FreeB fs) (CofreeB as) = bizapWith l (zapWith r) fs as
-
-instance (BiZap p q, Zap f g, Zap i j) => BiZap (BiffB p f i) (BiffB q g j) where
-	bizapWith l r fs as = bizapWith (zapWith l) (zapWith r) (runBiffB fs) (runBiffB as)
+instance (Bizap p q, Zap f g, Zap i j) => Bizap (Biff p f i) (Biff q g j) where
+	bizapWith l r fs as = bizapWith (zapWith l) (zapWith r) (runBiff fs) (runBiff as)
hunk ./src/Control/Functor/Zip.hs 23
-import Control.Arrow ((&&&),(|||))
-import Control.Bifunctor.Functor
-import Control.Comonad.Cofree
-import Control.Monad.Free
+import Prelude hiding ((.),id,fst,snd)
+import Control.Category
+import Control.Category.Hask
+import Control.Category.Cartesian
+import Control.Functor
+import Control.Functor.Fix
+import Control.Functor.Combinators.Biff
hunk ./src/Control/Functor/Zip.hs 31
-import Data.Monoid
+import Data.Monoid (Monoid(..))
hunk ./src/Control/Functor/Zip.hs 36
-unbizip :: Bifunctor p => p (a, c) (b, d) -> (p a b, p c d)
+unbizip :: (PreCartesian r, PreCartesian s, PreCartesian t, Bifunctor p r s t) => 
+	t (p (Prod r a c) (Prod s b d)) 
+	  (Prod t (p a b) (p c d))
hunk ./src/Control/Functor/Zip.hs 63
-class Bifunctor p => Bizip p where
+class Bifunctor p Hask Hask Hask => Bizip p where
hunk ./src/Control/Functor/Zip.hs 86
--- comes for free with BiffB
--- instance Zip f => Bizip (CofreeB f) where
---	bizipWith f g (CofreeB as) (CofreeB bs) = CofreeB $ bizipWith f (fzipWith g) as bs
-
-instance (Bizip p, Zip f, Zip g) => Bizip (BiffB p f g) where
-	bizipWith f g as bs = BiffB $ bizipWith (fzipWith f) (fzipWith g) (runBiffB as) (runBiffB bs)
-
-instance (Zip f, Bizip p) => Bizip (FunctorB f p) where
-	bizipWith f g as bs = FunctorB $ fzipWith (bizipWith f g) (runFunctorB as) (runFunctorB bs)
+instance (Bizip p, Zip f, Zip g) => Bizip (Biff p f g) where
+	bizipWith f g as bs = Biff $ bizipWith (fzipWith f) (fzipWith g) (runBiff as) (runBiff bs)
hunk ./src/Control/Functor/Zip.hs 107
-counbizip :: Bifunctor f => Either (f a c) (f b d) -> f (Either a b) (Either c d)
-counbizip = bimap Left Left ||| bimap Right Right
+counbizip :: (PreCoCartesian r, PreCoCartesian s, PreCoCartesian t, Bifunctor q r s t) => 
+	t (Sum t (q a c) (q b d)) (q (Sum r a b) (Sum s c d))
+counbizip = bimap inl inl ||| bimap inr inr
hunk ./src/Control/Monad/Composition.hs 1
--------------------------------------------------------------------------------------------
--- |
--- Module	: Control.Monad.Composition
--- Copyright 	: 2008 Edward Kmett
--- License	: BSD
---
--- Maintainer	: Edward Kmett <ekmett@gmail.com>
--- Stability	: experimental
--- Portability	: non-portable (functional-dependencies)
---
--------------------------------------------------------------------------------------------
-
-module Control.Monad.Composition where
-
-import Control.Monad
--- import Control.Functor.Composition
-import Control.Functor.Composition.Class
-import Control.Functor.Extras
-import Control.Functor.Pointed
-import Control.Functor.Pointed.Composition
-
-postJoin :: (Monad m, PostFold m f) => m (f (m (f a))) -> m (f a)
-postJoin = join . liftM postFold
-
-instance (Monad m, Pointed f, PostFold m f) => Monad (PostCompF m f) where
-        return = compose . return . point
-	m >>= k = undefined -- TODO: dualize the comonad version
-
-preJoin :: (Monad m, Functor f, PreFold f m) => f (m (f (m a))) -> f (m a)
-preJoin = fmap join . preFold
-
-instance (Pointed f, Monad m, PreFold f m) => Monad (PreCompF f m) where
-	return = compose . point . return
-	m >>= k = undefined
-
-
-instance (Monad m, Monad n, Distributes m n) => Monad (DistCompF m n) where
-	return = compose . return . return
-	m >>= k = undefined
-
-
-
rmfile ./src/Control/Monad/Composition.hs
hunk ./src/Control/Monad/Free.hs 15
-	, module Control.Monad.Identity
-	, FreeB
+	, PFree
hunk ./src/Control/Monad/Free.hs 23
-import Control.Arrow ((|||))
-import Control.Bifunctor.Biff
-import Control.Bifunctor.Fix
+import Prelude hiding ((.),id)
+import Control.Category
+import Control.Category.Cartesian
+import Control.Functor
+import Control.Functor.Combinators.Biff
+import Control.Functor.Fix
hunk ./src/Control/Monad/Free.hs 32
-type FreeB f a b = BiffB Either Identity f a b
-type Free f a = FixB (BiffB Either Identity f) a
+
+type Free f a = FixB (PFree f) a
hunk ./src/Control/Monad/Free.hs 36
-inFree = InB . BiffB . Right
+inFree = InB . Biff . Right
hunk ./src/Control/Monad/Free.hs 39
-runFree = first runIdentity . runBiffB . outB
+runFree = first runIdentity . runBiff . outB
hunk ./src/Control/Monad/Free.hs 42
-cataFree l r = (l . runIdentity ||| r . fmap (cataFree l r)) . runBiffB . outB
+cataFree l r = (l . runIdentity ||| r . fmap (cataFree l r)) . runBiff . outB
hunk ./src/Control/Monad/Free.hs 45
-free = InB . BiffB . first Identity
+free = InB . Biff . first Identity
hunk ./src/Control/Monad/Hyper.hs 16
-	( ContravariantFunctor(..)
+	( ContraFunctor(..)
hunk ./src/Control/Monad/Hyper.hs 22
-import Control.Bifunctor.Fix
-import Control.Monad.Parameterized
-import Control.Functor.Contravariant
+import Control.Category.Hask
+import Control.Functor
+import Control.Functor.Fix
+import Control.Functor.Contra
hunk ./src/Control/Monad/Hyper.hs 27
+import Control.Monad.Parameterized
hunk ./src/Control/Monad/Hyper.hs 31
-instance ContravariantFunctor h => Bifunctor (HyperB h) where
+instance PFunctor (HyperB h) Hask Hask where
+	first f h = HyperB (f . runHyperB h)
+
+instance ContraFunctor h => QFunctor (HyperB h) Hask Hask where
+	second g h = HyperB (runHyperB h . contramap g)
+
+instance ContraFunctor h => Bifunctor (HyperB h) Hask Hask Hask where
hunk ./src/Control/Monad/Hyper.hs 40
-instance ContravariantFunctor h => PPointed (HyperB h) where
+instance ContraFunctor h => PPointed (HyperB h) where
hunk ./src/Control/Monad/Hyper.hs 43
-instance ContravariantFunctor h => PApplicative (HyperB h) where
+instance ContraFunctor h => PApplicative (HyperB h) where
hunk ./src/Control/Monad/Hyper.hs 46
-instance ContravariantFunctor h => PMonad (HyperB h) where
+instance ContraFunctor h => PMonad (HyperB h) where
addfile ./src/Control/Monad/Ideal.hs
hunk ./src/Control/Monad/Ideal.hs 1
+{-# OPTIONS_GHC -fglasgow-exts #-}
+-----------------------------------------------------------------------------
+-- |
+-- Module      :  Control.Monad.Ideal
+-- Copyright   :  (C) 2008 Edward Kmett
+-- License     :  BSD-style (see the file LICENSE)
+--
+-- Maintainer  :  Edward Kmett <ekmett@gmail.com>
+-- Stability   :  experimental
+-- Portability :  portable
+--
+----------------------------------------------------------------------------
+module Control.Monad.Ideal
+	( 
+	-- * Ideal Monads
+	  MonadIdeal(..)
+	, Ideal
+	, ideal
+	-- * Coideal Comonads
+	, ComonadCoideal(..)
+	, Coideal
+	, coideal
+	-- * Mutual recursion for (co)ideal (co)monad (co)products
+	, Mutual(..)
+	-- * Coideal Comonad Product
+	, (:*)
+	-- * Ideal Monad Coproduct
+	, (:+)
+	) where
+
+import Prelude hiding (fst, snd)
+import Control.Category.Cartesian 
+import Control.Category.Hask
+import Control.Comonad
+import Control.Functor
+import Control.Functor.Combinators.Lift
+import Control.Monad.Identity
+-- Control.Arrow ((|||),(&&&))
+-- import Control.Functor.Combinators.Biff
+-- import Control.Functor.Combinators.Join
+-- import Control.Applicative
+
+type Ideal = Ap Either 
+-- type Ideal f = Join (PFree f)
+type Coideal = Ap (,)
+-- type Coideal f = Join (PCofree f)
+
+ideal :: Either a (f a) -> Ideal f a
+ideal = mkAp
+
+coideal :: (a, f a) -> Coideal f a 
+coideal = mkAp
+
+runIdeal :: Ideal f a -> Either a (f a)
+runIdeal = runAp
+
+runCoideal :: Coideal f a -> (a, f a)
+runCoideal = runAp
+
+class Functor m => MonadIdeal m where
+	idealize :: m (Either a (m a)) -> m a
+
+instance Functor f => Pointed (Ideal f) where
+	point = Lift . Left . Identity
+
+-- this only really needs 'ap' but there is no 'unpointed/pre- applicative'
+{-
+instance Applicative f => Applicative (Ideal f) where
+	pure = point
+	Ideal (Left f) <*> Ideal (Left a) = Ideal $ Left (f a)
+	Ideal (Left f) <*> Ideal (Right bs) = Ideal $ Right (fmap f bs)
+	Ideal (Right fs) <*> Ideal (Left a) = Ideal $ Right (fmap ($a) fs)
+	Ideal (Right fs) <*> Ideal (Right bs) = Ideal $ Right (fs <*> bs)
+-}
+
+instance MonadIdeal m => Monad (Ideal m) where
+	return = point
+	m >>= f = ideal . (id ||| Right . idealize) . runIdeal $ fmap (runIdeal . f) m
+
+
+
+-- instance MonadIdeal (Fst k) where
+--	idealize = mkFst . runFst
+
+class Functor w => ComonadCoideal w where
+	coidealize :: w a -> w (a, w a)
+
+instance Functor f => Copointed (Coideal f) where
+	extract = runIdentity . fst . runLift
+
+instance ComonadCoideal w => Comonad (Coideal w) where
+	extend f = fmap (f . coideal) . coideal . (id &&& coidealize . snd) . runCoideal
+
+-- instance ComonadCoideal (Fst k) where
+--	coidealize = mkFst . runFst
+
+-- * (Co)ideal (Co)products
+
+newtype Mutual p m n a = Mutual { runMutual :: m (p a (Mutual p n m a)) } 
+type Mutual' p m n = Lift p (Mutual p m n) (Mutual p n m)
+type (m :+ n) = Mutual' Either m n
+type (m :* n) = Mutual' (,) m n
+
+instance (Bifunctor p Hask Hask Hask, Functor m, Functor n) => Functor (Mutual p m n) where
+	fmap f = Mutual . fmap (bimap f (fmap f)) . runMutual
+
+{-
+instance (MonadIdeal m, MonadIdeal n) => MonadIdeal (m :+ n) where
+	idealize = undefined
+-}
+
+{-
+instance (ComonadCoideal w, ComonadCoideal v) => ComonadCoideal (w :* v) where
+	coidealize = undefined
+-}
hunk ./src/Control/Monad/Indexed.hs 17
+	, IxMonadZero(..)
+	, IxMonadPlus(..)
hunk ./src/Control/Monad/Indexed.hs 43
+class IxMonad m => IxMonadZero m where
+	imzero :: m i j a
+
+class IxMonadZero m => IxMonadPlus m where
+	implus :: m i j a -> m i j a -> m i j a
+
hunk ./src/Control/Monad/Indexed/Cont.hs 16
+import Control.Applicative
+import Control.Functor.Pointed
+import Control.Monad.Trans
hunk ./src/Control/Monad/Indexed/Cont.hs 21
+import Control.Monad.Cont.Class
+import Control.Monad.State.Class
+import Control.Monad.Reader.Class
+import Control.Monad.Indexed.Trans
hunk ./src/Control/Monad/Indexed/Cont.hs 51
+instance Monad m => Functor (IxContT m i j) where
+	fmap = imap
+
+instance Monad m => Pointed (IxContT m i i) where
+	point = ireturn
+
+instance Monad m => Applicative (IxContT m i i) where
+	pure = ireturn
+	(<*>) = iap
+
+instance Monad m => Monad (IxContT m i i) where
+	return = ireturn
+	m >>= k = ibind k m
+
+instance Monad m => MonadCont (IxContT m i i) where 
+	callCC = undefined -- shift (\k -> f k >>= k)
+
+instance IxMonadTrans IxContT where
+	ilift m = IxContT (m >>=)
+
+instance MonadReader e m => MonadReader e (IxContT m i i) where
+	ask = ilift ask
+	local f m = IxContT $ \c -> do
+		r <- ask
+		local f (runIxContT m (local (const r) . c))
+
+instance MonadState e m => MonadState e (IxContT m i i) where
+	get = ilift get
+	put = ilift . put
+
+instance MonadIO m => MonadIO (IxContT m i i) where
+	liftIO = ilift . liftIO 
+
hunk ./src/Control/Monad/Indexed/Cont.hs 87
+
hunk ./src/Control/Monad/Indexed/Cont.hs 94
+instance MonadCont (IxCont i i) where 
+	callCC = undefined -- shift (\k -> f k >>= k)
+
+instance Functor (IxCont i j) where
+	fmap = imap
+
+instance Pointed (IxCont i i) where
+	point = ireturn
+
+instance Applicative (IxCont i i) where
+	pure = ireturn
+	(<*>) = iap
+
+instance Monad (IxCont i i) where
+	return = ireturn
+	m >>= k = ibind k m
+
+
addfile ./src/Control/Monad/Indexed/Fix.hs
hunk ./src/Control/Monad/Indexed/Fix.hs 1
+-----------------------------------------------------------------------------
+-- |
+-- Module      :  Control.Monad.Indexed.Fix
+-- Copyright   :  (C) 2008 Edward Kmett
+-- License     :  BSD-style (see the file LICENSE)
+--
+-- Maintainer  :  Edward Kmett <ekmett@gmail.com>
+-- Stability   :  experimental
+-- Portability :  portable
+--
+----------------------------------------------------------------------------
+module Control.Monad.Indexed.Fix
+	( IxMonadFix(..)
+	) where
+
+import Control.Monad.Indexed
+
+class IxMonad m => IxMonadFix m where
+	imfix :: (a -> m i i a) -> m i i a
+
hunk ./src/Control/Monad/Indexed/State.hs 1
+{-# OPTIONS_GHC -fallow-undecidable-instances #-}
hunk ./src/Control/Monad/Indexed/State.hs 9
--- Stability   :  experimental
--- Portability :  non-portable (rank-2 polymorphism)
+-- Stability   :  experimental 
+-- Portability :  portable (although the MTL instances aren't!)
hunk ./src/Control/Monad/Indexed/State.hs 13
-module Control.Monad.Indexed.State where
+module Control.Monad.Indexed.State 
+	( IxMonadState(..)
+	, imodify
+	, igets
+	, IxStateT(..)
+	, IxState(..)
+	) where
hunk ./src/Control/Monad/Indexed/State.hs 21
-import Control.Arrow ((***))
-import Control.Bifunctor (Bifunctor(bimap), first)
-import Control.Monad
+import Control.Applicative
+import Control.Category.Hask
+-- import Control.Category.Cartesian
+import Control.Functor
hunk ./src/Control/Monad/Indexed/State.hs 26
+import Control.Monad.Indexed.Trans
+import Control.Monad.Indexed.Fix
+import Control.Monad.State
+import Control.Monad.Writer.Class
+import Control.Monad.Reader.Class
+import Control.Monad.Cont.Class
+import Control.Monad.Error.Class
+
hunk ./src/Control/Monad/Indexed/State.hs 44
+
+-- Indexed State Monad
hunk ./src/Control/Monad/Indexed/State.hs 68
-instance Bifunctor (IxState i) where 
-	bimap f g m = IxState $ (g *** f) . runIxState m
+instance PFunctor (IxState i) Hask Hask where
+	first = first'
+
+instance QFunctor (IxState i) Hask Hask where
+	second = second'
+
+instance Bifunctor (IxState i) Hask Hask Hask where 
+	bimap f g m = IxState $ bimap g f . runIxState m
+
+instance Monad (IxState i i) where
+	return = ireturn
+	m >>= k = ibind k m 
+
+instance Applicative (IxState i i) where
+	pure = ireturn
+	(<*>) = iap
+
+instance MonadState i (IxState i i) where
+	get = iget
+	put = iput
+
+instance MonadFix (IxState i i) where
+    mfix = imfix
+
+instance IxMonadFix IxState where
+    imfix f = IxState $ \s -> let (a, s') = runIxState (f a) s in (a, s')
+
+
+-- Indexed State Monad Transformer
hunk ./src/Control/Monad/Indexed/State.hs 115
-instance Monad m => Bifunctor (IxStateT m i) where
-	bimap f g m = IxStateT $ liftM (g *** f) . runIxStateT m
+instance Monad m => PFunctor (IxStateT m i) Hask Hask where
+	first = first'
+
+instance Monad m => QFunctor (IxStateT m i) Hask Hask where
+	second = second'
+
+instance Monad m => Bifunctor (IxStateT m i) Hask Hask Hask where
+	bimap f g m = IxStateT $ liftM (bimap g f) . runIxStateT m
hunk ./src/Control/Monad/Indexed/State.hs 128
-{-
+instance MonadPlus m => IxMonadZero (IxStateT m) where
+	imzero = IxStateT $ const mzero
+
hunk ./src/Control/Monad/Indexed/State.hs 132
-    izero       = IxStateT $ \_ -> mzero
-    m `iplus` n = IxStateT $ \s -> runIxStateT m s `mplus` runIxStateT n s
+	m `implus` n = IxStateT $ \s -> runIxStateT m s `mplus` runIxStateT n s
hunk ./src/Control/Monad/Indexed/State.hs 135
-    ifix f = StateT $ \s -> mfix $ \ ~(a, _) -> runStateT (f a) s
--}
+	imfix f = IxStateT $ \s -> mfix $ \ ~(a, _) -> runIxStateT (f a) s
+
+instance MonadFix m => MonadFix (IxStateT m i i) where
+	mfix = imfix
+
+instance Monad m => Monad (IxStateT m i i) where
+	return = ireturn
+	m >>= k = ibind k m 
+
+instance Monad m => Applicative (IxStateT m i i) where
+	pure = ireturn
+	(<*>) = iap
+
+instance Monad m => MonadState i (IxStateT m i i) where
+	get = iget
+	put = iput
+
+instance IxMonadTrans IxStateT where
+	ilift m = IxStateT $ \s -> m >>= \a -> return (a, s)
+
+instance MonadIO m => MonadIO (IxStateT m i i) where
+	liftIO = ilift . liftIO
+
+instance MonadReader r m => MonadReader r (IxStateT m i i) where
+	ask = ilift ask
+	local f m = IxStateT (local f . runIxStateT m)
+
+instance MonadCont m => MonadCont (IxStateT m i i) where
+	callCC f = IxStateT $ \s -> callCC $ \k -> runIxStateT (f (\a -> IxStateT $ \s' -> k (a,s'))) s
+
+instance MonadError e m => MonadError e (IxStateT m i i) where
+	throwError = ilift . throwError
+	m `catchError` h = IxStateT $ \s -> runIxStateT m s `catchError` \e -> runIxStateT (h e) s
+
+instance MonadWriter w m => MonadWriter w (IxStateT m i i) where
+	tell = ilift . tell
+	listen m = IxStateT $ \s -> do 
+		~((a,s'),w) <- listen (runIxStateT m s)
+		return ((a,w),s')
+	pass m = IxStateT $ \s -> pass $ do
+		~((a,f),s') <- runIxStateT m s
+		return ((a,s'),f)
addfile ./src/Control/Monad/Indexed/Trans.hs
hunk ./src/Control/Monad/Indexed/Trans.hs 1
+-----------------------------------------------------------------------------
+-- |
+-- Module      :  Control.Monad.Indexed.Trans
+-- Copyright   :  (C) 2008 Edward Kmett
+-- License     :  BSD-style (see the file LICENSE)
+--
+-- Maintainer  :  Edward Kmett <ekmett@gmail.com>
+-- Stability   :  experimental 
+-- Portability :  portable (indexed monad transfomers)
+--
+-- TODO: figure out a meaningful way for indexed monads to transform indexed 
+-- monads
+----------------------------------------------------------------------------
+module Control.Monad.Indexed.Trans where
+
+class IxMonadTrans t where
+	ilift :: Monad m => m a -> t m i i a 
+
hunk ./src/Control/Monad/Parameterized.hs 22
-import Control.Bifunctor
+import Control.Functor
hunk ./src/Control/Monad/Parameterized.hs 30
-	pbind f = pjoin . bimap f id
+	pbind f = pjoin . first f
hunk ./src/Control/Morphism/Ana.hs 15
+import Control.Category.Hask
+import Control.Functor
hunk ./src/Control/Morphism/Ana.hs 21
-import Control.Bifunctor
-import Control.Bifunctor.Fix
hunk ./src/Control/Morphism/Ana.hs 38
-biana :: Bifunctor f => CoAlg (f b) a -> a -> FixB f b
+biana :: Bifunctor f Hask Hask Hask => CoAlg (f b) a -> a -> FixB f b
hunk ./src/Control/Morphism/Ana.hs 41
-g_biana :: (Bifunctor f, Monad m) => Dist m (f b) -> CoAlgM (f b) m a -> a -> FixB f b
+g_biana :: (Bifunctor f Hask Hask Hask, Monad m) => Dist m (f b) -> CoAlgM (f b) m a -> a -> FixB f b
hunk ./src/Control/Morphism/Cata.hs 15
-import Control.Bifunctor
-import Control.Bifunctor.Fix
hunk ./src/Control/Morphism/Cata.hs 16
+import Control.Category.Hask
+import Control.Functor
hunk ./src/Control/Morphism/Cata.hs 36
-bicata :: Bifunctor f => Alg (f b) a -> FixB f b -> a
+bicata :: Bifunctor f Hask Hask Hask => Alg (f b) a -> FixB f b -> a
hunk ./src/Control/Morphism/Cata.hs 39
-g_bicata :: (Bifunctor f, Comonad w) => Dist (f b) w -> AlgW (f b) w a -> FixB f b -> a
+g_bicata :: (Bifunctor f Hask Hask Hask, Comonad w) => Dist (f b) w -> AlgW (f b) w a -> FixB f b -> a
hunk ./src/Control/Morphism/Hylo.hs 16
-import Control.Bifunctor
+import Control.Functor
+import Control.Category
+import Control.Category.Hask
+import Prelude hiding ((.),id)
hunk ./src/Control/Morphism/Hylo.hs 33
+-- The Jeremy Gibbons-style bifunctor-based version has the same expressive power, but may fuse with bimaps better
hunk ./src/Control/Morphism/Hylo.hs 35
--- A more "Jeremy Gibbons"-style bifunctor-based version has the same expressive power 
+bihylo :: (QFunctor f Hask Hask) => Alg (g d) b -> Natural (f c) (g d) -> CoAlg (f c) a -> a -> b
+bihylo f e g = f . e . second (bihylo f e g). g 
hunk ./src/Control/Morphism/Hylo.hs 38
-bihylo :: (Bifunctor f, Bifunctor g) => Alg (g d) b -> Natural (f c) (g d) -> CoAlg (f c) a -> a -> b
-bihylo f e g = f . e . bimap id (bihylo f e g). g 
-
-g_bihylo :: (Comonad w, Bifunctor f, Monad m) =>
+g_bihylo :: (Comonad w, QFunctor f Hask Hask, Monad m) =>
hunk ./src/Control/Morphism/Hylo.hs 40
-g_bihylo w m f e g = extract . h . return where h = liftW f . w . e . bimap id (duplicate . h . join) . m . liftM g
-
+g_bihylo w m f e g = extract . h . return where h = liftW f . w . e . second (duplicate . h . join) . m . liftM g
hunk ./src/Control/Morphism/Para.hs 15
+import Control.Comonad
hunk ./src/Control/Morphism/Para.hs 32
-type ParaT w f a 	= ReaderCT w (Fix f) a
+type ParaT w f a 	= CoreaderT w (Fix f) a
hunk ./src/Control/Morphism/Zygo.hs 16
+import Control.Comonad
hunk ./src/Control/Morphism/Zygo.hs 28
-g_zygo :: (Functor f, Comonad w) => AlgW f w b -> Dist f w -> AlgW f (ReaderCT w b) a -> Fix f -> a
+g_zygo :: (Functor f, Comonad w) => AlgW f w b -> Dist f w -> AlgW f (CoreaderT w b) a -> Fix f -> a
hunk ./src/Control/Morphism/Zygo.hs 36
-distZygoT :: (Functor f, Comonad w) => AlgW f w b -> Dist f w -> Dist f (ReaderCT w b)
-distZygoT g k = ReaderCT . liftW (g . fmap (liftW fst) &&& fmap (snd . extract)) . k . fmap (duplicate . runReaderCT)
+distZygoT :: (Functor f, Comonad w) => AlgW f w b -> Dist f w -> Dist f (CoreaderT w b)
+distZygoT g k = CoreaderT . liftW (g . fmap (liftW fst) &&& fmap (snd . extract)) . k . fmap (duplicate . runCoreaderT)
}
