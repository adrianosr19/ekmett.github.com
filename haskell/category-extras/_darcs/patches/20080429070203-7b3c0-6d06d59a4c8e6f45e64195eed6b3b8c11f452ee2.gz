[work in progress
ekmett@gmail.com**20080429070203] {
hunk ./ctl.cabal 6
-build-depends:		base -any, mtl -any
+build-depends:		base -any, mtl -any, array -any
hunk ./ctl.cabal 13
-description: 		Defines comonads, a few missing monads and constructive algorithmic morphisms
+description: 		Defines comonads, a few missing monads and a bunch of constructive algorithmic morphisms
hunk ./ctl.cabal 40
+	Control.Comonad.Composition,
hunk ./ctl.cabal 43
-	Control.Comonad.State,
-	Control.Comonad.State.Class,
+	Control.Comonad.Context,
+	Control.Comonad.Context.Class,
+	Control.Comonad.Pointer,
hunk ./ctl.cabal 50
+	Control.Functor.Bifunctor,
hunk ./ctl.cabal 52
+	Control.Functor.Composition.Class
+	Control.Functor.Contravariant,
+	Control.Functor.Constant,
+	Control.Functor.Derivative,
hunk ./ctl.cabal 57
+	Control.Functor.Exponential,
hunk ./ctl.cabal 61
+	Control.Functor.Pointed.Composition,
hunk ./ctl.cabal 63
+	Control.Monad.Composition,
hunk ./src/Control/Bifunctor/Composition.hs 3
-newtype FunctorBT f p a b = FunctorBT { runFunctorBT :: f (p a b) } 
-newtype SwapBT p a b = SwapB { runSwapBT :: p b a } 
-newtype CompBT p f g a b = CompBT { runCompBT :: p (f a b) (g a b) }
-newtype ArrowBT f g a b = ArrowBT { runArrowBT :: f a b -> g a b }
+import Control.Comonad
+import Control.Bifunctor
+import Control.Bifunctor.Associative
+import Control.Bifunctor.Braided
+import Control.Bifunctor.Monoidal
+import Control.Functor.Pointed
+import Control.Functor.Exponential
+import Control.Functor.Contravariant
+
+newtype ArrowB f g a b = ArrowB { runArrowB :: f a b -> g a b }
+
+
+
+newtype ConstB t a b = ConstB { runConstB :: t } 
+
+instance Bifunctor (ConstB t) where
+	bimap f g = ConstB . runConstB
+instance Functor (ConstB t a) where
+	fmap f = ConstB . runConstB
+
+
+
+
+newtype FstB a b = FstB { runFstB :: a } 
+
+instance Bifunctor FstB where
+	bimap f g = FstB . f . runFstB 
+
+instance Associative FstB where
+	associate = FstB . runFstB . runFstB
+
+instance Functor (FstB a) where
+        fmap f (FstB a) = FstB a
+
+instance ContravariantFunctor (FstB a) where
+        contramap f (FstB a) = FstB a
+
+instance ExpFunctor (FstB a) where
+        xmap f g (FstB a) = FstB a
+
+
+newtype SndB a b = SndB { runSndB :: b } 
+
+instance Bifunctor SndB where
+	bimap f g = SndB . g . runSndB 
+
+-- instance Coassociative SndB where
+--	coassociate = SndB . SndB . runSndB
+
+-- as a functor its a family of identity functors with a type-level parameter (a)
+instance Functor (SndB a) where
+	fmap = bimap id
+
+-- bifunctor composition
+
+newtype CompB p f g a b = CompB { runCompB :: p (f a b) (g a b) }
+
+instance (Bifunctor p, Bifunctor f, Bifunctor g) => Bifunctor (CompB p f g) where
+	bimap f g = CompB . bimap (bimap f g) (bimap f g) . runCompB
+
+liftCompB :: Bifunctor p => (f a b -> f c d) -> (g a b -> g c d) -> CompB p f g a b -> CompB p f g c d 
+liftCompB f g = CompB . bimap f g . runCompB
+
+instance (Bifunctor p, Braided f, Braided g) => Braided (CompB p f g) where
+	braid = liftCompB braid braid
+
+instance (Bifunctor p, Symmetric f, Symmetric g) => Symmetric (CompB p f g) 
+
+instance (Bifunctor p, Bifunctor f, Bifunctor g) => Functor (CompB p f g a) where
+	fmap = bimap id
+
+
+
+newtype SwapB p a b = SwapB { runSwapB :: p b a } 
+
+liftSwapB :: Bifunctor p => (p a b -> p c d) -> SwapB p b a -> SwapB p d c
+liftSwapB f = SwapB . f . runSwapB
+
+instance Bifunctor p => Bifunctor (SwapB p) where
+	bimap = liftSwapB . flip bimap 
+
+instance Coassociative p => Associative (SwapB p) where
+	associate = liftSwapB coassociate
+
+instance Associative p => Coassociative (SwapB p) where
+	coassociate = liftSwapB associate
+
+instance Braided p => Braided (SwapB p) where
+	braid = liftSwapB braid
+
+instance Symmetric p => Symmetric (SwapB p)
+
+instance HasIdentity p i => HasIdentity (SwapB p) i
+
+instance Monoidal p i => Monoidal (SwapB p) i where
+	idl = idr . runSwapB
+	idr = idl . runSwapB
+
+instance Comonoidal p i => Comonoidal (SwapB p) i where
+	coidl = SwapB . coidr
+	coidr = SwapB . coidl
+
+instance Bifunctor p => Functor (SwapB p a) where
+	fmap = bimap id
+
+-- a functor composed around a bifunctor
+
+newtype FunctorB f p a b = FunctorB { runFunctorB :: f (p a b) } 
+
+liftFunctorB :: Functor f => (p a b -> p c d) -> FunctorB f p a b -> FunctorB f p c d
+liftFunctorB f = FunctorB . fmap f . runFunctorB
+
+instance (Functor f, Bifunctor p) => Bifunctor (FunctorB f p) where
+	bimap f g = liftFunctorB (bimap f g)
+
+instance (Functor f, Braided p) => Braided (FunctorB f p) where
+	braid = liftFunctorB braid
+
+instance (Functor f, Symmetric p) => Symmetric (FunctorB f p) 
+
+instance (Functor f, Associative p) => Associative (FunctorB f p) where
+	associate = liftFunctorB associate
+
+instance (Functor f, Coassociative p) => Coassociative (FunctorB f p) where
+	coassociate = liftFunctorB coassociate
+
+instance (Functor f, HasIdentity p i) => HasIdentity (FunctorB f p) i
+
+instance (Copointed f, Monoidal p i) => Monoidal (FunctorB f p) i where
+	idr = idr . extract . runFunctorB
+	idl = idl . extract . runFunctorB
+	
+instance (Pointed f, Comonoidal p i) => Comonoidal (FunctorB f p) i where
+	coidr = FunctorB . return . coidr
+	coidl = FunctorB . return . coidl
+
+instance (Functor f, Bifunctor p) => Functor (FunctorB f p a) where
+	fmap = bimap id
hunk ./src/Control/Comonad/Cofree.hs 16
+import Control.Functor.Pointed
+import Control.Functor.Contravariant
+import Control.Functor.Exponential
hunk ./src/Control/Comonad/Cofree.hs 26
+-- instance ContravariantFunctor f => ContravariantFunctor (Cofree f) where
+--       contramap f = Cofree . (f *** contramap (fmap f)) . runCofree
+
+instance ExpFunctor f => ExpFunctor (Cofree f) where
+        xmap f g = Cofree . (f *** xmap (xmap f g) (xmap g f)) . runCofree
+
hunk ./src/Control/Comonad/Cofree.hs 36
+instance Functor f => Copointed (Cofree f) where
+	copoint = extract
+
hunk ./src/Control/Comonad/Pointer.hs 16
+import Control.Functor.Extras
hunk ./src/Control/Comonad/Pointer.hs 23
-data Pointer i a = Pointer { index :: i, array :: Array i e } deriving (Show,Read)
+data Pointer i a = Pointer { index :: i, array :: Array i a } deriving (Show,Read)
hunk ./src/Control/Comonad/Pointer.hs 30
-	extend f (Pointer i a) = Pointer i $ listArray bds (fmap (f . flip Pointer a) (range bds) where
+	extend f (Pointer i a) = Pointer i . listArray bds $ fmap (f . flip Pointer a) (range bds) where
hunk ./src/Control/Comonad/Pointer.hs 33
-distPointer :: (Monad m, Ix i) => Dist m (Pointer i)
+distPointer :: (Monad m, Ix i) => Dist (Pointer i) m 
hunk ./src/Control/Comonad/State/Class.hs 1
-{-# OPTIONS -fglasgow-exts #-}
------------------------------------------------------------------------------
--- |
--- Module      :  Control.Comonad.State.Class
--- Copyright   :  (C) 2008 Edward Kmett
--- License     :  BSD-style (see the file LICENSE)
---
--- Maintainer  :  Edward Kmett <ekmett@gmail.com>
--- Stability   :  experimental
--- Portability :  portable
---
-----------------------------------------------------------------------------
-module Control.Comonad.State.Class where
-
-import Control.Comonad
-
-class Comonad w => ComonadState s w | w -> s where
-	getC :: w a -> w s
-	putC :: s -> w a -> w a
-
--- modifyC :: (s -> s) -> StateC s a -> StateC s a
--- modifyC m (StateC f s) = StateC f (m s)
rmfile ./src/Control/Comonad/State/Class.hs
rmdir ./src/Control/Comonad/State
hunk ./src/Control/Comonad/State.hs 1
-{-# OPTIONS -fglasgow-exts #-}
------------------------------------------------------------------------------
--- |
--- Module      :  Control.Comonad.State
--- Copyright   :  (C) 2008 Edward Kmett
--- License     :  BSD-style (see the file LICENSE)
---
--- Maintainer  :  Edward Kmett <ekmett@gmail.com>
--- Stability   :  experimental
--- Portability :  non-portable (MPTCs)
---
-----------------------------------------------------------------------------
-module Control.Comonad.State where
-
-import Control.Arrow ((&&&), first)
-import Control.Comonad
-import Control.Comonad.State.Class
-
-data StateC s a = StateC (s -> a) s
-runStateC f s = (a b, b) where
-	StateC a b = f (StateC id s)
-
-instance ComonadState s (StateC s) where
-	getC (StateC f s) = StateC id s
-	putC s (StateC f _) = StateC f s
-
-modifyC :: (s -> s) -> StateC s a -> StateC s a
-modifyC m (StateC f s) = StateC f (m s)
-
-instance Functor (StateC r) where
-	fmap f (StateC f' s) = StateC (f . f') s
-
-instance Comonad (StateC s) where
-	extract (StateC f a) = f a
-	extend k (StateC f v) = StateC (\v -> k (StateC f v)) v
-
-newtype StateCT s w a = StateCT { runStateCT :: w (s -> a, s) }
-
-instance Comonad w => ComonadState s (StateCT s w) where
-	-- getC = uncurry id . extract . runStateCT
-	getC = undefined
-	putC = undefined
-
-instance Functor f => Functor (StateCT b f) where
-        fmap f = StateCT . fmap (first (f .)) . runStateCT
-
-instance Comonad w => Comonad (StateCT b w) where
-        extract = uncurry id . extract . runStateCT
-        duplicate = undefined -- StateCT . liftW (fst . extract &&& StateCT) . duplicate . runStateCT
rmfile ./src/Control/Comonad/State.hs
hunk ./src/Control/Comonad.hs 28
+liftCtx :: Comonad w => (a -> b) -> w a -> b
+liftCtx f = extract . fmap f
+
hunk ./src/Control/Functor/Adjunction.hs 16
+import Control.Comonad
+import Control.Functor.Composition
+import Control.Functor.Composition.Class
+import Control.Functor.Exponential
+import Control.Functor.Full
+import Control.Functor.Pointed
+import Control.Monad
+
hunk ./src/Control/Functor/Adjunction.hs 43
+
+
+
+-- adjunction-oriented composition
+newtype ACompF f g a = ACompF (CompF f g a) deriving (Functor, ExpFunctor, Full, Composition)
+
+instance Adjunction f g => Pointed (CompF g f) where
+        point = compose . unit
+
+instance Adjunction f g => Copointed (CompF f g) where
+        copoint = counit . decompose
+
+instance Adjunction f g => Monad (CompF g f) where
+        return = point
+        m >>= f = compose . fmap (rightAdjunct (decompose . f)) $ decompose m
+
+instance Adjunction f g => Comonad (CompF f g) where
+        extract = copoint
+        extend f = compose . fmap (leftAdjunct (f . compose)) . decompose
+
hunk ./src/Control/Functor/Composition.hs 12
--- Generalized functor composition.
+-- Generalized functor composeosition.
hunk ./src/Control/Functor/Composition.hs 17
-import Control.Bifunctor
-import Control.Bifunctor.Instances
-import Control.Functor.Adjunction
-import Control.Functor.Pointed
-import Control.Monad
-import Control.Comonad
+import Control.Functor.Composition.Class
+import Control.Functor.Exponential
hunk ./src/Control/Functor/Composition.hs 20
-import Control.Arrow ((&&&),(|||))
hunk ./src/Control/Functor/Composition.hs 21
-newtype CompF f g a = CompF { deCompF :: f (g a) }
+newtype CompF f g a = CompF { runCompF :: f (g a) }
+
+instance Composition CompF where
+	compose = CompF
+	decompose = runCompF
hunk ./src/Control/Functor/Composition.hs 31
-instance Adjunction f g => Pointed (CompF g f) where
-        point = CompF . unit
-
-instance Adjunction f g => Copointed (CompF f g) where
-        copoint = counit . deCompF
-
-instance Adjunction f g => Monad (CompF g f) where
-	return = point
-        m >>= f = CompF . fmap (rightAdjunct (deCompF . f)) $ deCompF m
-
-instance Adjunction f g => Comonad (CompF f g) where
-	extract = copoint
-        extend f = CompF . fmap (leftAdjunct (f . CompF)) . deCompF
-
+-- common functor composition traits
hunk ./src/Control/Functor/Composition.hs 33
-	fmap f = CompF . fmap (fmap f) . deCompF
-
-instance (Full f, Full g) => Full (CompF f g) where
-        prefmap f = prefmap . prefmap $ deCompF . f . CompF
-
-newtype BifunctorF p f g a = BifunctorF { runBifunctorF :: p (f a) (g a) }
-
-instance (Bifunctor p, Functor f ,Functor g) => Functor (BifunctorF p f g) where
-	fmap f = BifunctorF . bimap (fmap f) (fmap f) . runBifunctorF
-
-#ifndef __HADDOCK__
-type (f :*: g) a = BifunctorF (,) f g a
-#endif
-
--- this would be a type but that causes the following line to freak out
--- because (f :*: g) is a partialy applied type synonym even though it immediately gets filled out
-
-#ifndef __HADDOCK__
-runProductF :: (f :*: g) a -> (f a, g a)
-#else
-runProductF :: Bifunctor (,) f g a -> (f a, g a)
-#endif
-runProductF = runBifunctorF
-
-instance (Pointed f, Pointed g) => Pointed (BifunctorF (,) f g) where
-	point = BifunctorF . (point &&& point)
+	fmap f = compose . fmap (fmap f) . decompose
hunk ./src/Control/Functor/Composition.hs 35
-instance (Faithful f, Faithful g) => Faithful (BifunctorF (,) f g)
+instance (ExpFunctor f, ExpFunctor g) => ExpFunctor (CompF f g) where
+        xmap f g = compose . xmap (xmap f g) (xmap g f) . decompose
hunk ./src/Control/Functor/Composition.hs 38
-#ifndef __HADDOCK__
-type (f :+: g) a = BifunctorF Either f g a
-#endif
+instance (Full f, Full g) => Full (CompF f g) where
+        premap f = premap . premap $ decompose . f . compose
hunk ./src/Control/Functor/Composition.hs 41
-#ifndef __HADDOCK__
-runCoproductF :: (f :+: g) a -> Either (f a) (g a)
-#else
-runCoproductF :: Bifunctor Either f g a -> Either (f a) (g a)
-#endif
-runCoproductF = runBifunctorF 
hunk ./src/Control/Functor/Composition.hs 42
-instance (Copointed f, Copointed g) => Copointed (BifunctorF Either f g) where
-	copoint = (copoint ||| copoint) . runCoproductF
hunk ./src/Control/Functor/Extras.hs 18
+class PostFold m f where
+        postFold :: f (m (f a)) -> m (f a)
+
+class PostUnfold w f where
+        postUnfold :: w (f a) -> f (w (f a))
+
+class PreFold f m where
+        preFold :: f (m (f a)) -> f (m a)
+
+class PreUnfold f w where
+        preUnfold :: f (w a) -> f (w (f a))
+
+class Distributes f g where
+        dist :: f (g a) -> g (f a)
hunk ./src/Control/Functor/Full.hs 15
+
hunk ./src/Control/Functor/Full.hs 21
-> fmap . prefmap = id
+> fmap . premap = id
hunk ./src/Control/Functor/Full.hs 25
-	prefmap :: (f a -> f b) -> a -> b
+	premap :: (f a -> f b) -> a -> b
hunk ./src/Control/Functor/Full.hs 28
-	"fmap/prefmap" 	map . prefmap = id
+	"fmap/premap" 	map . prefmap = id
hunk ./src/Control/Functor/Full.hs 40
-> unfmap . fmap = id
+> unmap . fmap = id
hunk ./src/Control/Functor/Full.hs 43
-unfmap :: (Full f, Faithful f) => (f a -> f b) -> a -> b
-unfmap = prefmap
+unmap :: (Full f, Faithful f) => (f a -> f b) -> a -> b
+unmap = premap
hunk ./src/Control/Functor/Full.hs 47
-	"unfmap/fmap"	unfmap . fmap = id
+	"unmap/fmap"	unmap . fmap = id
hunk ./src/Control/Functor/Full.hs 50
+
+
+
hunk ./src/Control/Functor/Pointed.hs 28
+
hunk ./src/Control/Monad/Free.hs 15
+import Control.Arrow ((|||), (+++))
+import Control.Functor.Exponential
+import Control.Functor.Contravariant
hunk ./src/Control/Monad/Free.hs 19
-import Control.Arrow ((|||), (&&&), (+++), (***))
hunk ./src/Control/Monad/Free.hs 26
+--instance ContravariantFunctor f => ContravariantFunctor (Free f) where
+--        contramap f = Free . (f +++ contramap (fmap f)) . runFree
+
+instance ExpFunctor f => ExpFunctor (Free f) where
+        xmap f g = Free . (f +++ xmap (xmap f g) (xmap g f)) . runFree
+
hunk ./src/Control/Monad/Free.hs 42
+
hunk ./src/Control/Morphism/Cata.hs 15
+import Control.Bifunctor
+import Control.Comonad
+import Control.Comonad.Identity
hunk ./src/Control/Morphism/Cata.hs 21
-import Control.Comonad
hunk ./src/Control/Morphism/Cata.hs 22
-import Control.Comonad.Identity
hunk ./src/Control/Morphism/Cata.hs 34
+cataB :: Bifunctor f => Alg (f b) a -> MuB b f -> a
+cataB f = f . bimap id (cataB f) . outF
+
+g_cataB :: (Bifunctor f, Comonad w) => Dist (f b) w -> AlgW (f b) w a -> MuB b f -> a
+g_cataB k g = extract . c where c = liftW g . k . bimap id (duplicate . c) . outF
+
hunk ./src/Control/Morphism/Hylo.hs 16
+import Control.Bifunctor
hunk ./src/Control/Morphism/Hylo.hs 23
-hylo :: (Functor f, Functor g) => Alg g b -> Natural f g -> CoAlg f a -> a -> b
+hylo :: Functor f => Alg g b -> Natural f g -> CoAlg f a -> a -> b
hunk ./src/Control/Morphism/Hylo.hs 31
+-- A more "Jeremy Gibbons"-style bifunctor-based version has the same expressive power 
+
+hyloB :: (Bifunctor f, Bifunctor g) => Alg (g d) b -> Natural (f c) (g d) -> CoAlg (f c) a -> a -> b
+hyloB f e g = f . e . bimap id (hyloB f e g). g 
+
+g_hyloB :: (Comonad w, Bifunctor f, Monad m) =>
+          Dist (g d) w -> Dist m (f c) -> AlgW (g d) w b -> Natural (f c) (g d) -> CoAlgM (f c) m a -> a -> b
+g_hyloB w m f e g = extract . h . return where h = liftW f . w . e . bimap id (duplicate . h . join) . m . liftM g
+
hunk ./src/Data/Void.hs 17
+void :: Void -> a
+void = undefined
+
}
