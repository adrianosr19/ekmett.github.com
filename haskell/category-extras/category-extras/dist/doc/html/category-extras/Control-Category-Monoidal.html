<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<!--Rendered using the Haskell Html Library v0.2-->
<HTML
><HEAD
><META HTTP-EQUIV="Content-Type" CONTENT="text/html; charset=UTF-8"
><TITLE
>Control.Category.Monoidal</TITLE
><LINK HREF="haddock.css" REL="stylesheet" TYPE="text/css"
><SCRIPT SRC="haddock-util.js" TYPE="text/javascript"
></SCRIPT
></HEAD
><BODY
><TABLE CLASS="vanilla" CELLSPACING="0" CELLPADDING="0"
><TR
><TD CLASS="topbar"
><TABLE CLASS="vanilla" CELLSPACING="0" CELLPADDING="0"
><TR
><TD
><IMG SRC="haskell_icon.gif" WIDTH="16" HEIGHT="16" ALT=" "
></TD
><TD CLASS="title"
>category-extras-0.50.3: Various modules and constructs inspired by category theory</TD
><TD CLASS="topbut"
><A HREF="index.html"
>Contents</A
></TD
><TD CLASS="topbut"
><A HREF="doc-index.html"
>Index</A
></TD
></TR
></TABLE
></TD
></TR
><TR
><TD CLASS="modulebar"
><TABLE CLASS="vanilla" CELLSPACING="0" CELLPADDING="0"
><TR
><TD
><FONT SIZE="6"
>Control.Category.Monoidal</FONT
></TD
><TD ALIGN="right"
><TABLE CLASS="narrow" CELLSPACING="0" CELLPADDING="0"
><TR
><TD CLASS="infohead"
>Portability</TD
><TD CLASS="infoval"
>non-portable (class-associated types)</TD
></TR
><TR
><TD CLASS="infohead"
>Stability</TD
><TD CLASS="infoval"
>experimental</TD
></TR
><TR
><TD CLASS="infohead"
>Maintainer</TD
><TD CLASS="infoval"
>Edward Kmett &lt;ekmett@gmail.com&gt;</TD
></TR
></TABLE
></TD
></TR
></TABLE
></TD
></TR
><TR
><TD CLASS="s15"
></TD
></TR
><TR
><TD CLASS="section1"
>Description</TD
></TR
><TR
><TD CLASS="doc"
>A <TT
><A HREF="Control-Category-Monoidal.html#t%3AMonoidal"
>Monoidal</A
></TT
> category is a category with an associated biendofunctor that has an identity,
 which satisfies Mac Lane''s pentagonal and triangular coherence conditions
 Technically we usually say that category is monoidal, but since
 most interesting categories in our world have multiple candidate bifunctors that you can 
 use to enrich their structure, we choose here to think of the bifunctor as being 
 monoidal. This lets us reuse the same Bifunctor over different categories without 
 painful type annotations.
</TD
></TR
><TR
><TD CLASS="s15"
></TD
></TR
><TR
><TD CLASS="section1"
>Synopsis</TD
></TR
><TR
><TD CLASS="s15"
></TD
></TR
><TR
><TD CLASS="body"
><TABLE CLASS="vanilla" CELLSPACING="0" CELLPADDING="0"
><TR
><TD CLASS="decl"
>module <A HREF="Control-Category-Braided.html"
>Control.Category.Braided</A
></TD
></TR
><TR
><TD CLASS="s8"
></TD
></TR
><TR
><TD CLASS="decl"
><SPAN CLASS="keyword"
>class</SPAN
> <A HREF="Control-Functor.html#t%3ABifunctor"
>Bifunctor</A
> p k k k =&gt; <A HREF="#t%3AHasIdentity"
>HasIdentity</A
> k p i | k p -&gt; i</TD
></TR
><TR
><TD CLASS="s8"
></TD
></TR
><TR
><TD CLASS="decl"
><SPAN CLASS="keyword"
>class</SPAN
> (<A HREF="Control-Category-Associative.html#t%3AAssociative"
>Associative</A
> k p, <A HREF="Control-Category-Monoidal.html#t%3AHasIdentity"
>HasIdentity</A
> k p i) =&gt; <A HREF="#t%3AMonoidal"
>Monoidal</A
> k p i | k p -&gt; i <SPAN CLASS="keyword"
>where</SPAN
></TD
></TR
><TR
><TD CLASS="body"
><TABLE CLASS="vanilla" CELLSPACING="0" CELLPADDING="0"
><TR
><TD CLASS="decl"
><A HREF="#v%3Aidl"
>idl</A
> ::  k (p i a) a</TD
></TR
><TR
><TD CLASS="decl"
><A HREF="#v%3Aidr"
>idr</A
> ::  k (p a i) a</TD
></TR
></TABLE
></TD
></TR
><TR
><TD CLASS="s8"
></TD
></TR
><TR
><TD CLASS="decl"
><SPAN CLASS="keyword"
>class</SPAN
> (<A HREF="Control-Category-Associative.html#t%3ACoassociative"
>Coassociative</A
> k p, <A HREF="Control-Category-Monoidal.html#t%3AHasIdentity"
>HasIdentity</A
> k p i) =&gt; <A HREF="#t%3AComonoidal"
>Comonoidal</A
> k p i | k p -&gt; i <SPAN CLASS="keyword"
>where</SPAN
></TD
></TR
><TR
><TD CLASS="body"
><TABLE CLASS="vanilla" CELLSPACING="0" CELLPADDING="0"
><TR
><TD CLASS="decl"
><A HREF="#v%3Acoidl"
>coidl</A
> ::  k a (p i a)</TD
></TR
><TR
><TD CLASS="decl"
><A HREF="#v%3Acoidr"
>coidr</A
> ::  k a (p a i)</TD
></TR
></TABLE
></TD
></TR
></TABLE
></TD
></TR
><TR
><TD CLASS="s15"
></TD
></TR
><TR
><TD CLASS="section1"
>Documentation</TD
></TR
><TR
><TD CLASS="s15"
></TD
></TR
><TR
><TD CLASS="decl"
>module <A HREF="Control-Category-Braided.html"
>Control.Category.Braided</A
></TD
></TR
><TR
><TD CLASS="s15"
></TD
></TR
><TR
><TD CLASS="decl"
><SPAN CLASS="keyword"
>class</SPAN
> <A HREF="Control-Functor.html#t%3ABifunctor"
>Bifunctor</A
> p k k k =&gt; <A NAME="t%3AHasIdentity"
></A
><B
>HasIdentity</B
> k p i | k p -&gt; i</TD
></TR
><TR
><TD CLASS="body"
><TABLE CLASS="vanilla" CELLSPACING="0" CELLPADDING="0"
><TR
><TD CLASS="ndoc"
>Denotes that we have some reasonable notion of Identity for a particular <TT
><A HREF="Control-Functor.html#t%3ABifunctor"
>Bifunctor</A
></TT
> in this Category. This
 notion is currently used by both <TT
><A HREF="Control-Category-Monoidal.html#t%3AMonoidal"
>Monoidal</A
></TT
> and <TT
><A HREF="Control-Category-Monoidal.html#t%3AComonoidal"
>Comonoidal</A
></TT
>
</TD
></TR
><TR
><TD CLASS="s8"
></TD
></TR
><TR
><TD CLASS="section4"
><IMG SRC="minus.gif" CLASS="coll" ONCLICK="toggle(this,'i:HasIdentity')" ALT="show/hide"
> Instances</TD
></TR
><TR
><TD CLASS="body"
><DIV ID="i:HasIdentity" STYLE="display:block;"
><TABLE CLASS="vanilla" CELLSPACING="1" CELLPADDING="0"
><TR
><TD CLASS="decl"
><A HREF="Control-Category-Monoidal.html#t%3AHasIdentity"
>HasIdentity</A
> <A HREF="Control-Category-Hask.html#t%3AHask"
>Hask</A
> (,) <A HREF="Data-Void.html#t%3AVoid"
>Void</A
></TD
></TR
><TR
><TD CLASS="decl"
><A HREF="Control-Category-Monoidal.html#t%3AHasIdentity"
>HasIdentity</A
> <A HREF="Control-Category-Hask.html#t%3AHask"
>Hask</A
> p i =&gt; <A HREF="Control-Category-Monoidal.html#t%3AHasIdentity"
>HasIdentity</A
> <A HREF="Control-Category-Hask.html#t%3AHask"
>Hask</A
> (<A HREF="Control-Functor-Combinators-Flip.html#t%3AFlip"
>Flip</A
> p) i</TD
></TR
></TABLE
></DIV
></TD
></TR
></TABLE
></TD
></TR
><TR
><TD CLASS="s15"
></TD
></TR
><TR
><TD CLASS="decl"
><SPAN CLASS="keyword"
>class</SPAN
> (<A HREF="Control-Category-Associative.html#t%3AAssociative"
>Associative</A
> k p, <A HREF="Control-Category-Monoidal.html#t%3AHasIdentity"
>HasIdentity</A
> k p i) =&gt; <A NAME="t%3AMonoidal"
></A
><B
>Monoidal</B
> k p i | k p -&gt; i <SPAN CLASS="keyword"
>where</SPAN
></TD
></TR
><TR
><TD CLASS="body"
><TABLE CLASS="vanilla" CELLSPACING="0" CELLPADDING="0"
><TR
><TD CLASS="ndoc"
><P
>A monoidal category. <TT
><A HREF="Control-Category-Monoidal.html#v%3Aidl"
>idl</A
></TT
> and <TT
><A HREF="Control-Category-Monoidal.html#v%3Aidr"
>idr</A
></TT
> are traditionally denoted lambda and rho
 the triangle identity holds:
</P
><PRE
> bimap idr id = bimap id idl . associate 
 bimap id idl = bimap idr id . associate
</PRE
></TD
></TR
><TR
><TD CLASS="s8"
></TD
></TR
><TR
><TD CLASS="section4"
>Methods</TD
></TR
><TR
><TD CLASS="body"
><TABLE CLASS="vanilla" CELLSPACING="0" CELLPADDING="0"
><TR
><TD CLASS="decl"
><A NAME="v%3Aidl"
></A
><B
>idl</B
> ::  k (p i a) a</TD
></TR
><TR
><TD CLASS="s8"
></TD
></TR
><TR
><TD CLASS="decl"
><A NAME="v%3Aidr"
></A
><B
>idr</B
> ::  k (p a i) a</TD
></TR
></TABLE
></TD
></TR
><TR
><TD CLASS="s8"
></TD
></TR
><TR
><TD CLASS="section4"
><IMG SRC="minus.gif" CLASS="coll" ONCLICK="toggle(this,'i:Monoidal')" ALT="show/hide"
> Instances</TD
></TR
><TR
><TD CLASS="body"
><DIV ID="i:Monoidal" STYLE="display:block;"
><TABLE CLASS="vanilla" CELLSPACING="1" CELLPADDING="0"
><TR
><TD CLASS="decl"
><A HREF="Control-Category-Monoidal.html#t%3AMonoidal"
>Monoidal</A
> <A HREF="Control-Category-Hask.html#t%3AHask"
>Hask</A
> (,) <A HREF="Data-Void.html#t%3AVoid"
>Void</A
></TD
></TR
><TR
><TD CLASS="decl"
>(<A HREF="Control-Category-Associative.html#t%3ACoassociative"
>Coassociative</A
> <A HREF="Control-Category-Hask.html#t%3AHask"
>Hask</A
> p, <A HREF="Control-Category-Monoidal.html#t%3AMonoidal"
>Monoidal</A
> <A HREF="Control-Category-Hask.html#t%3AHask"
>Hask</A
> p i) =&gt; <A HREF="Control-Category-Monoidal.html#t%3AMonoidal"
>Monoidal</A
> <A HREF="Control-Category-Hask.html#t%3AHask"
>Hask</A
> (<A HREF="Control-Functor-Combinators-Flip.html#t%3AFlip"
>Flip</A
> p) i</TD
></TR
></TABLE
></DIV
></TD
></TR
></TABLE
></TD
></TR
><TR
><TD CLASS="s15"
></TD
></TR
><TR
><TD CLASS="decl"
><SPAN CLASS="keyword"
>class</SPAN
> (<A HREF="Control-Category-Associative.html#t%3ACoassociative"
>Coassociative</A
> k p, <A HREF="Control-Category-Monoidal.html#t%3AHasIdentity"
>HasIdentity</A
> k p i) =&gt; <A NAME="t%3AComonoidal"
></A
><B
>Comonoidal</B
> k p i | k p -&gt; i <SPAN CLASS="keyword"
>where</SPAN
></TD
></TR
><TR
><TD CLASS="body"
><TABLE CLASS="vanilla" CELLSPACING="0" CELLPADDING="0"
><TR
><TD CLASS="ndoc"
><P
>A comonoidal category satisfies the dual form of the triangle identities
</P
><PRE
> bimap idr id = coassociate . bimap id idl
 bimap id idl = coassociate . bimap idr id
</PRE
><P
>This type class is also (ab)used for the inverse operations needed for a strict (co)monoidal category.
A strict (co)monoidal category is one that is both <TT
><A HREF="Control-Category-Monoidal.html#t%3AMonoidal"
>Monoidal</A
></TT
> and <TT
><A HREF="Control-Category-Monoidal.html#t%3AComonoidal"
>Comonoidal</A
></TT
> and satisfies the following laws:
</P
><PRE
> idr . coidr = id 
 idl . coidl = id 
 coidl . idl = id 
 coidr . idr = id 
</PRE
></TD
></TR
><TR
><TD CLASS="s8"
></TD
></TR
><TR
><TD CLASS="section4"
>Methods</TD
></TR
><TR
><TD CLASS="body"
><TABLE CLASS="vanilla" CELLSPACING="0" CELLPADDING="0"
><TR
><TD CLASS="decl"
><A NAME="v%3Acoidl"
></A
><B
>coidl</B
> ::  k a (p i a)</TD
></TR
><TR
><TD CLASS="s8"
></TD
></TR
><TR
><TD CLASS="decl"
><A NAME="v%3Acoidr"
></A
><B
>coidr</B
> ::  k a (p a i)</TD
></TR
></TABLE
></TD
></TR
><TR
><TD CLASS="s8"
></TD
></TR
><TR
><TD CLASS="section4"
><IMG SRC="minus.gif" CLASS="coll" ONCLICK="toggle(this,'i:Comonoidal')" ALT="show/hide"
> Instances</TD
></TR
><TR
><TD CLASS="body"
><DIV ID="i:Comonoidal" STYLE="display:block;"
><TABLE CLASS="vanilla" CELLSPACING="1" CELLPADDING="0"
><TR
><TD CLASS="decl"
>(<A HREF="Control-Category-Associative.html#t%3AAssociative"
>Associative</A
> <A HREF="Control-Category-Hask.html#t%3AHask"
>Hask</A
> p, <A HREF="Control-Category-Monoidal.html#t%3AComonoidal"
>Comonoidal</A
> <A HREF="Control-Category-Hask.html#t%3AHask"
>Hask</A
> p i) =&gt; <A HREF="Control-Category-Monoidal.html#t%3AComonoidal"
>Comonoidal</A
> <A HREF="Control-Category-Hask.html#t%3AHask"
>Hask</A
> (<A HREF="Control-Functor-Combinators-Flip.html#t%3AFlip"
>Flip</A
> p) i</TD
></TR
></TABLE
></DIV
></TD
></TR
></TABLE
></TD
></TR
><TR
><TD CLASS="s15"
></TD
></TR
><TR
><TD CLASS="botbar"
>Produced by <A HREF="http://www.haskell.org/haddock/"
>Haddock</A
> version 2.1.0</TD
></TR
></TABLE
></BODY
></HTML
>
