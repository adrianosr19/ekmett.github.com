[fussy documentation fixes and adding most of the mtl
ekmett@gmail.com**20070713053346] {
hunk ./Makefile 13
-	runhaskell $(SETUP) haddock
+	# runhaskell $(SETUP) haddock
+	haddock --odir=dist/doc/html --use-package=mtl --use-package=base --html --no-implicit-prelude src/Control/Monad/Parameterized.hs --package=monad-param-0.0.1 --use-package=stm --title="Parameterized Monads"
hunk ./monad-param.cabal 13
+haddock-options: -s http://comonad.com/monad-param/dist/doc/html/ --no-implicit-prelude --use-package mtl --use-package base
hunk ./src/Control/Monad/Parameterized.hs 13
--- avoid having to carry a parameter around for monads that do not need it.
+-- avoid having to carry a parameter around for monads that do not need it, and we can rederive
+-- the normal notion of a parameterized monad from this variation for those that do.
hunk ./src/Control/Monad/Parameterized.hs 16
--- so we restore by defining `returnM` as the unit of the `Identity` monad and `mzeroM` as 
+-- so we restore that by defining `returnM` as the unit of the `Identity` monad and `mzeroM` as 
hunk ./src/Control/Monad/Parameterized.hs 20
--- Caveat: this currently doesn't permit types to vary under the @do@-sugar because of assumptions in GHC
--- about the shape of `>>=`
+-- Caveat: this currently does not permit types to vary under the @do@-sugar because of assumptions in GHC
+-- about the shape of `>>=`.
+-- 
+-- This imports and defines the correct instances for a good portion of the @MTL@, primarily because
+-- it is so awkward to import them all otherwise due to the fact that most of them re-export the 'Control.Monad.Monad' syntax.
+-- Does not export "Control.Monad.ST" or "Control.Monad.Writer" since it is unclear if you want strict or lazy versions in scope
hunk ./src/Control/Monad/Parameterized.hs 47
-	, Identity      (runIdentity)
hunk ./src/Control/Monad/Parameterized.hs 48
+
+	-- * Export common monads in this sugar
+	, module Control.Concurrent.STM
+	, module Control.Monad.Cont
+	, module Control.Monad.Cont.Class
+	, module Control.Monad.Error
+	, module Control.Monad.Error.Class
+	, module Control.Monad.Fix
+	, module Control.Monad.Identity
+	, module Control.Monad.List
+	, module Control.Monad.Reader
+	, module Control.Monad.State
+	, module Control.Monad.Writer.Class
+	-- , module Data.STRef
+	-- , module Data.IORef
+
+	, mapM          -- :: (Monad m) => (a -> m b) -> [a] -> m [b]
+	, mapM_         -- :: (Monad m) => (a -> m b) -> [a] -> m ()
+	, forM          -- :: (Monad m) => [a] -> (a -> m b) -> m [b]
+	, forM_         -- :: (Monad m) => [a] -> (a -> m b) -> m ()
+	, sequence      -- :: (Monad m) => [m a] -> m [a]
+	, sequence_     -- :: (Monad m) => [m a] -> m ()
+	, join          -- :: (Monad m) => m (m a) -> m a
+	, msum          -- :: (MonadPlus m) => [m a] -> m a
+	, filterM       -- :: (Monad m) => (a -> m Bool) -> [a] -> m [a]
+	, mapAndUnzipM  -- :: (Monad m) => (a -> m (b,c)) -> [a] -> m ([b], [c])
+	, zipWithM      -- :: (Monad m) => (a -> b -> m c) -> [a] -> [b] -> m [c]
+	, zipWithM_     -- :: (Monad m) => (a -> b -> m c) -> [a] -> [b] -> m ()
+	, foldM         -- :: (Monad m) => (a -> b -> m a) -> a -> [b] -> m a 
+	, foldM_        -- :: (Monad m) => (a -> b -> m a) -> a -> [b] -> m ()
+	, replicateM    -- :: (Monad m) => Int -> m a -> m [a]
+	, replicateM_   -- :: (Monad m) => Int -> m a -> m ()
+	, guard         -- :: (MonadPlus m) => Bool -> m ()
+	, when          -- :: (Monad m) => Bool -> m () -> m ()
+	, unless        -- :: (Monad m) => Bool -> m () -> m ()
+	, liftM         -- :: (Monad m) => (a -> b) -> (m a -> m b)
+	, liftM2        -- :: (Monad m) => (a -> b -> c) -> (m a -> m b -> m c)
+	, liftM3        -- :: ...
+	, liftM4        -- :: ...
+	, liftM5        -- :: ...
+	, ap            -- :: (Monad m) => m (a -> b) -> m a -> m b
hunk ./src/Control/Monad/Parameterized.hs 91
+import Data.Monoid
hunk ./src/Control/Monad/Parameterized.hs 94
+-- import Data.STRef
+-- import Data.IORef
+
hunk ./src/Control/Monad/Parameterized.hs 98
+import Control.Monad
+	(mapM, mapM_, sequence, sequence_, forM, forM_, join, msum, filterM, mapAndUnzipM, zipWithM, zipWithM_,
+	foldM, foldM_, replicateM, replicateM_, guard, when, unless, liftM, liftM2, liftM3, liftM4, liftM5, ap)
+import Control.Monad.Cont
+	(Cont(..),mapCont, withCont, ContT(..),mapContT,withContT)
+import Control.Monad.Cont.Class 
+	(MonadCont, callCC)
+import Control.Monad.Error 
+	(ErrorT, runErrorT, mapErrorT)
+import Control.Monad.Error.Class 
+	(Error, noMsg, strMsg, MonadError, throwError, catchError)
+import Control.Monad.Fix 
+	(MonadFix, mfix, fix)
hunk ./src/Control/Monad/Parameterized.hs 112
-import Control.Monad.State (State,runState,StateT,runStateT)
-import Control.Monad.Reader (Reader,runReader,ReaderT,runReaderT)
+import Control.Monad.State 
+	(State(..),StateT(..),MonadState
+	,evalState,execState,mapState,withState
+	,evalStateT,execStateT,mapStateT,withStateT)
+import Control.Monad.ST.Strict as StrictST
+	(ST, runST, fixST, RealWorld, stToIO) -- unsafe* should be imported directly
+import Control.Monad.ST.Lazy as LazyST
+	(ST, runST, fixST, RealWorld, stToIO, strictToLazyST,lazyToStrictST) -- unsafe* should be imported directly
+import Control.Monad.Reader 
+	(Reader(..),ReaderT(..)
+	,mapReader,withReader,mapReaderT,withReaderT)
+import qualified Control.Monad.Writer.Lazy as LazyW
+	(Writer,runWriter,execWriter,mapWriter
+	,WriterT,runWriterT,execWriterT,mapWriterT)
+import qualified Control.Monad.Writer.Strict as StrictW
+	(Writer,runWriter,execWriter,mapWriter
+	,WriterT,runWriterT,execWriterT,mapWriterT)
+import Control.Monad.Writer.Class
hunk ./src/Control/Monad/Parameterized.hs 136
-instance Show a => Show (Identity a) where
-	show a = "Identity " ++ show (runIdentity a)
-
-instance Show (MZero a) where
-	show a = "(undefined :: MZero a)"
+-- instance Show a => Show (Identity a) where show a = "Identity " ++ show (runIdentity a)
+-- instance Show (MZero a) where show a = "error \"MZero\""
hunk ./src/Control/Monad/Parameterized.hs 143
--- | Restrict the cases where we allow pattern matching to @fail@. You have to explicitly supply this.
+-- | Restrict the cases where we allow pattern matching to `fail`. You have to explicitly supply this for your `Monad`
hunk ./src/Control/Monad/Parameterized.hs 164
--- | Same trick using with `Identity` to build a canonical `returnM`, here we exploit the `MonadPlus` laws to make a canonical `mzeroM`
+-- | Same trick using with `Identity` to build a canonical `returnM`, here we exploit the `MonadPlus` laws to make a canonical `mzeroM`. Has no members except bottom.
hunk ./src/Control/Monad/Parameterized.hs 166
+-- | An inferable version of `mzero`
hunk ./src/Control/Monad/Parameterized.hs 170
+-- | its trivial to map a function over nothing
hunk ./src/Control/Monad/Parameterized.hs 201
-class Go n m where go :: n a -> m a 
+class Go n m where 
+	-- | Usage: @go (do something)@
+	go :: n a -> m a 
hunk ./src/Control/Monad/Parameterized.hs 216
+instance Fail Maybe where fail = Old.fail
hunk ./src/Control/Monad/Parameterized.hs 222
+instance Fail [] where fail = Old.fail
hunk ./src/Control/Monad/Parameterized.hs 228
+instance Fail STM where fail = Old.fail
hunk ./src/Control/Monad/Parameterized.hs 232
+instance Fail IO where fail = Old.fail
hunk ./src/Control/Monad/Parameterized.hs 236
+instance Fail (State s) where fail = Old.fail
hunk ./src/Control/Monad/Parameterized.hs 240
+instance Fail (Reader e) where fail = Old.fail
hunk ./src/Control/Monad/Parameterized.hs 243
+instance Return (Cont r) where return = Old.return
+instance Fail (Cont r) where fail = Old.fail
+instance Bind (Cont r) (Cont r) (Cont r) where (>>=) = (Old.>>=)
+
+instance Return (StrictST.ST s) where return = Old.return
+instance Fail (StrictST.ST s) where fail = Old.fail
+instance Bind (StrictST.ST s) (StrictST.ST s) (StrictST.ST s) where (>>=) = (Old.>>=)
+
+instance Return (LazyST.ST s) where return = Old.return
+instance Fail (LazyST.ST s) where fail = Old.fail
+instance Bind (LazyST.ST s) (LazyST.ST s) (LazyST.ST s) where (>>=) = (Old.>>=)
+
+instance Monoid w => Return (LazyW.Writer w) where return = Old.return
+instance Monoid w => Fail (LazyW.Writer w) where fail = Old.fail
+instance Monoid w => Bind (LazyW.Writer w) (LazyW.Writer w) (LazyW.Writer w) where (>>=) = (Old.>>=)
+
+instance Monoid w => Return (StrictW.Writer w) where return = Old.return
+instance Monoid w => Fail (StrictW.Writer w) where fail = Old.fail
+instance Monoid w => Bind (StrictW.Writer w) (StrictW.Writer w) (StrictW.Writer w) where (>>=) = (Old.>>=)
+
+instance Old.Monad m => Return (ListT m) where return = Old.return
+instance Old.Monad m => Fail (ListT m) where fail = Old.fail
+instance Old.Monad m => Bind (ListT m) (ListT m) (ListT m) where (>>=) = (Old.>>=)
+instance Old.Monad m => MonadZero (ListT m) where mzero = Old.mzero
+instance Old.Monad m => MPlus (ListT m) (ListT m) (ListT m) where mplus = Old.mplus
+
+instance Old.Monad m => Return (StateT s m) where return = Old.return
+instance Old.Monad m => Fail (StateT s m) where fail = Old.fail
+instance Old.Monad m => Bind (StateT s m) (StateT s m) (StateT s m) where (>>=) = (Old.>>=)
+
+instance Old.Monad m => Return (ReaderT e m) where return = Old.return
+instance Old.Monad m => Fail (ReaderT e m) where fail = Old.fail
+instance Old.Monad m => Bind (ReaderT e m) (ReaderT e m) (ReaderT e m) where (>>=) = (Old.>>=)
+
+instance (Old.Monad m, Monoid w) => Return (LazyW.WriterT w m) where return = Old.return
+instance (Old.Monad m, Monoid w) => Fail (LazyW.WriterT w m) where fail = Old.fail
+instance (Old.Monad m, Monoid w) => Bind (LazyW.WriterT w m) (LazyW.WriterT w m) (LazyW.WriterT w m) where (>>=) = (Old.>>=)
+
+instance (Old.Monad m, Monoid w) => Return (StrictW.WriterT w m) where return = Old.return
+instance (Old.Monad m, Monoid w) => Fail (StrictW.WriterT w m) where fail = Old.fail
+instance (Old.Monad m, Monoid w) => Bind (StrictW.WriterT w m) (StrictW.WriterT w m) (StrictW.WriterT w m) where (>>=) = (Old.>>=)
+
+instance (Old.Monad m, Error e) => Return (ErrorT e m) where return = Old.return
+instance (Old.Monad m, Error e) => Fail (ErrorT e m) where fail = Old.fail
+instance (Old.Monad m, Error e) => Bind (ErrorT e m) (ErrorT e m) (ErrorT e m) where (>>=) = (Old.>>=)
+instance (Old.Monad m, Error e) => MonadZero (ErrorT e m) where mzero = Old.mzero
+instance (Old.Monad m, Error e) => MPlus (ErrorT e m) (ErrorT e m) (ErrorT e m) where mplus = Old.mplus
+
+instance Old.Monad m => Return (ContT r m) where return = Old.return
+instance Old.Monad m => Fail (ContT r m) where fail = Old.fail
+instance Old.Monad m => Bind (ContT r m) (ContT r m) (ContT r m) where (>>=) = (Old.>>=)
+
}
