[flopped arguments
ekmett@gmail.com**20090504034222
 Ignore-this: 8cf26cc0550bdebaf90f4ec8260d83e8
] {
hunk ./Text/Parsimony/Parsec.hs 29
-    Name _ n    -> eval n
-    Labels ls l -> Parsec.labels (eval l) ls
+    Name n _    -> eval n
+    Labels l ls -> Parsec.labels (eval l) ls
hunk ./Text/Parsimony/Parsec.hs 33
-eval_ :: Parsec.Stream s m Char => Parser Recognizing Char e -> Parsec.ParsecT s u m ()
+eval_ :: (Mode mode, Parsec.Stream s m Char) => Parser mode Char e -> Parsec.ParsecT s u m ()
hunk ./Text/Parsimony/Parsec.hs 35
-    App f x     -> eval_ f *> eval_ x
+    App f x     -> eval_ f >> eval_ x
hunk ./Text/Parsimony/Parsec.hs 40
-    Name _ n    -> eval_ n
-    Labels ls l -> Parsec.labels (eval_ l) ls
-    Skip s      -> eval_ s -- unexpected Skip in Skip
+    Name p _    -> eval_ p
+    Labels p ls -> Parsec.labels (eval_ p) ls
+    Skip p      -> eval_ p -- unexpected Skip in Skip
hunk ./Text/Parsimony/Prim.hs 21
-    , fmapParser, pureParser, appParser, satisfy, skip 
+    -- , fmapParser, pureParser, appParser
+    , satisfy, skip 
hunk ./Text/Parsimony/Prim.hs 24
-    , name
+    , named
+    , recognizing
hunk ./Text/Parsimony/Prim.hs 31
+    , epsilon
hunk ./Text/Parsimony/Prim.hs 45
--- parsing modes
+-- | This parser is capable of parsing a token stream and obtaining an answer
hunk ./Text/Parsimony/Prim.hs 47
-data Recognizing
-
--- Parser t a requires Mode t
-
--- invariants enforced by smart constructors:
hunk ./Text/Parsimony/Prim.hs 48
--- a Name never contains a Name directly
--- a Labels never contain Labels directly
--- an Alt never contains an Alt directly
--- a Greedy never contains a Greedy directly
--- a Skip never contains a Skip transitively
+-- | This parser may only be used to recognize a token stream as belonging to a context-free language
+data Recognizing
hunk ./Text/Parsimony/Prim.hs 51
--- unenforceable invariants required for the parallel parser
--- The parse tree is finite
+-- | 'Parser' invariants provided by smart constructors:
+--
+-- (1) a Name never contains a Name directly
+--  2  Labels never contain Labels directly
+--  3  an Alt never contains an Alt directly
+--  4  a Greedy never contains a Greedy directly
+--  5  a Skip never contains a Skip transitively
+--
+-- Unenforceable invariants required for the parallel parser: 
+--
+-- (1) The parse tree is finite
hunk ./Text/Parsimony/Prim.hs 70
-    Name    :: String -> Parser m t a -> Parser m t a 
-    Labels  :: [String] -> Parser m t a -> Parser m t a
+    Name    :: Parser m t a -> String -> Parser m t a 
+    Labels  :: Parser m t a -> [String] -> Parser m t a
hunk ./Text/Parsimony/Prim.hs 73
+-- | A parser mode defines what optimizations are possible, and how much information must be retained
hunk ./Text/Parsimony/Prim.hs 89
-    fmapParser g (Name s p)    = Name s (g <$> p)
-    fmapParser g (Labels s p)  = Labels s (g <$> p)
+    fmapParser g (Name p s)    = Name (g <$> p) s
+    fmapParser g (Labels p ss) = Labels (g <$> p) ss
hunk ./Text/Parsimony/Prim.hs 96
+-- | Generate a parser that recognizes a single token using a predicate
hunk ./Text/Parsimony/Prim.hs 100
--- a parser mode that actually parses and retains intermediate results
+-- | treat a non-recognizing parser as a recognizing one to reduce redundant rules
+recognizing :: Mode m => Parser m t a -> Parser Recognizing t a
+recognizing = unsafeCoerce
+
+-- | a parser mode that actually parses and retains intermediate results
hunk ./Text/Parsimony/Prim.hs 113
--- the unsafeCoerces below let us retain sharing in a recognizer that we cannot retain in a general parser!
+-- | unsafeCoerces parsers to gain additional sharing that cannot be obtained in a general parser
hunk ./Text/Parsimony/Prim.hs 125
-    pureParser _ = unsafeCoerce epsilon where
-        -- force sharing of all epsilon 
-        epsilon :: Parser Recognizing Magic ()
-        epsilon = Pure undefined
+    pureParser _ = unsafeCoerce epsilon
+
+-- | parser that accepts the empty string used by Recognizing parsers where necessary
+epsilon :: Parser Recognizing Magic ()
+epsilon = Pure undefined `named` "epsilon"
hunk ./Text/Parsimony/Prim.hs 142
-    a      <|> Alt bs = Alt (a : bs)
+    a      <|> Alt bs = Alt (a:bs)
hunk ./Text/Parsimony/Prim.hs 146
-
hunk ./Text/Parsimony/Prim.hs 153
--- | optimized version of '(<<*)'
+-- | optimized version of '(<*)'
hunk ./Text/Parsimony/Prim.hs 157
--- smart constructors fuse away trivial local optimizations
-name :: String -> Parser m t a -> Parser m t a
-name s (Name _ p) = Name s p
-name s p = Name s p
+-- | smart constructor for naming parsers for purposes of displaying the grammar
+named :: Parser m t a -> String -> Parser m t a
+named (Name p _) = Name p
+named p          = Name p
hunk ./Text/Parsimony/Prim.hs 162
-labels :: [String] -> Parser m t a -> Parser m t a 
-labels s (Labels _ p) = Labels s p
-labels s p = Labels s p 
+-- | smart constructor for labeling the grammar ala Parsec
+labels :: Parser m t a -> [String] -> Parser m t a 
+labels (Labels p _) = Labels p
+labels p            = Labels p 
hunk ./Text/Parsimony/Prim.hs 167
+-- | Annotate a parser with what it should say was expected if the first character in it is unconsumed
hunk ./Text/Parsimony/Prim.hs 169
-p <?> s = labels [s] p
+p <?> s = labels p [s]
hunk ./Text/Parsimony/Prim.hs 171
+-- | Multiple parsers returning multiple answers
hunk ./Text/Parsimony/Prim.hs 177
+-- | Prefers the result from the left when present. Only accepts parses from the right hand parser
+--   when the left hand parser fails.
hunk ./Text/Parsimony/Prim.hs 185
+-- | Multiple parsers returning the results from the left-most parser that matches anything
hunk ./Text/Parsimony/Prim.hs 191
+-- | Here rather than in Text.Parsimony.Char to avoid an orphan instance
hunk ./Text/Parsimony/Prim.hs 196
-
}
