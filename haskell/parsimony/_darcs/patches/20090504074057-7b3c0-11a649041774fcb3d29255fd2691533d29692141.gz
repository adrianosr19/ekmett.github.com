[added combinators
ekmett@gmail.com**20090504074057
 Ignore-this: f634a4a747ffcd671e2837abc4f63930
] {
hunk ./Text/Parsimony/Combinators.hs 7
+    , count
+    , many1
+    , endBy
+    , endBy1
+    , sepBy
+    , sepBy1
+    , sepEndBy
+    , sepEndBy1
+    , skipMany
+    , skipMany1
+    , between 
hunk ./Text/Parsimony/Combinators.hs 22
+import Data.Traversable
hunk ./Text/Parsimony/Combinators.hs 30
+many1 :: Alternative f => f a -> f [a]
+many1 = some
+
hunk ./Text/Parsimony/Combinators.hs 36
-option :: Mode m => a -> Parser m t a -> Parser m t a
+option :: Alternative f => a -> f a -> f a
hunk ./Text/Parsimony/Combinators.hs 38
+
+count :: Applicative f => Int -> f a -> f [a]
+count n p 
+    | n <= 0 = pure []
+    | otherwise = sequenceA (replicate n p)
+
+endBy :: Mode m => Parser m t a -> Parser Recognizing t sep -> Parser m t [a]
+endBy p sep = many (p <<* sep) 
+
+endBy1 :: Mode m => Parser m t a -> Parser Recognizing t sep -> Parser m t [a]
+endBy1 p sep = some (p <<* sep)
+
+sepBy :: Mode m => Parser m t a -> Parser Recognizing t sep -> Parser m t [a]
+sepBy p sep = option [] (sepBy1 p sep)
+
+sepBy1 :: Mode m => Parser m t a -> Parser Recognizing t sep -> Parser m t [a]
+sepBy1 p sep = (:) <$> p <*> many (sep *>> p) 
+
+skipMany1 :: Mode m => Parser Recognizing t a -> Parser m t ()
+skipMany1 p = skip (many1 p)
+
+skipMany :: Mode m => Parser Recognizing t a -> Parser m t ()
+skipMany p = skip (many p)
+
+between :: Mode m => Parser Recognizing t open -> Parser Recognizing t close -> Parser m t a -> Parser m t a
+between open close p = open *>> p <<* close 
+
+sepEndBy :: Mode m => Parser m t a -> Parser Recognizing t sep -> Parser m t [a]
+sepEndBy p sep = go0 where
+    go0 = option [] go1
+    go1 = (:) <$> p <*> option [] (sep *>> go0)
+
+sepEndBy1 :: Mode m => Parser m t a -> Parser Recognizing t sep -> Parser m t [a]
+sepEndBy1 p sep = go1 where
+    go0 = option [] go1
+    go1 = (:) <$> p <*> option [] (sep *>> go0)
hunk ./Text/Parsimony/Prim.hs 65
--- (1) The parse tree is finite
+-- (1) The set of non-terminals used by the parser is finite
hunk ./Text/Parsimony/StableMap.hs 6
+    , update
hunk ./Text/Parsimony/StableMap.hs 34
+
+update :: StableName a -> f a -> StableMap f -> StableMap f
+update k v = StableMap . IntMap.adjust update' (hashStableName k) . getStableMap where
+    k' :: StableName Magic
+    k' = unsafeCoerce k
+
+    v' :: f Magic
+    v' = unsafeCoerce v
+
+    update' :: [(StableName Magic, f Magic)] -> [(StableName Magic, f Magic)] 
+    update' ((k'',v''):ks) 
+        | k' == k''  = (k'',v'):ks
+        | otherwise = (k'',v''):update' ks
+    update' [] = []
}
