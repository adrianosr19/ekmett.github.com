LocalBuildInfo {installDirTemplates = InstallDirs {prefix = "/usr/local", bindir = "$prefix/bin", libdir = "$prefix/lib", libsubdir = "$pkgid/$compiler", dynlibdir = "$libdir", libexecdir = "$prefix/libexec", progdir = "$libdir/hugs/programs", includedir = "$libdir/$libsubdir/include", datadir = "$prefix/share", datasubdir = "$pkgid", docdir = "$datadir/doc/$pkgid", mandir = "$datadir/man", htmldir = "$docdir/html", haddockdir = "$htmldir"}, compiler = Compiler {compilerFlavor = GHC, compilerId = PackageIdentifier {pkgName = "ghc", pkgVersion = Version {versionBranch = [6,9,20080401], versionTags = []}}, compilerExtensions = [(CPP,"-XCPP"),(PatternGuards,"-XPatternGuards"),(UnicodeSyntax,"-XUnicodeSyntax"),(MagicHash,"-XMagicHash"),(PolymorphicComponents,"-XPolymorphicComponents"),(ExistentialQuantification,"-XExistentialQuantification"),(KindSignatures,"-XKindSignatures"),(PatternSignatures,"-XPatternSignatures"),(EmptyDataDecls,"-XEmptyDataDecls"),(ParallelListComp,"-XParallelListComp"),(ForeignFunctionInterface,"-XForeignFunctionInterface"),(UnliftedFFITypes,"-XUnliftedFFITypes"),(LiberalTypeSynonyms,"-XLiberalTypeSynonyms"),(Rank2Types,"-XRank2Types"),(RankNTypes,"-XRankNTypes"),(TypeOperators,"-XTypeOperators"),(RecursiveDo,"-XRecursiveDo"),(Arrows,"-XArrows"),(TemplateHaskell,"-XTemplateHaskell"),(Generics,"-XGenerics"),(NoImplicitPrelude,"-XNoImplicitPrelude"),(RecordWildCards,"-XRecordWildCards"),(RecordPuns,"-XRecordPuns"),(DisambiguateRecordFields,"-XDisambiguateRecordFields"),(OverloadedStrings,"-XOverloadedStrings"),(GADTs,"-XGADTs"),(TypeFamilies,"-XTypeFamilies"),(BangPatterns,"-XBangPatterns"),(NoMonomorphismRestriction,"-XNoMonomorphismRestriction"),(NoMonoPatBinds,"-XNoMonoPatBinds"),(RelaxedPolyRec,"-XRelaxedPolyRec"),(ExtendedDefaultRules,"-XExtendedDefaultRules"),(ImplicitParams,"-XImplicitParams"),(ScopedTypeVariables,"-XScopedTypeVariables"),(UnboxedTuples,"-XUnboxedTuples"),(StandaloneDeriving,"-XStandaloneDeriving"),(DeriveDataTypeable,"-XDeriveDataTypeable"),(TypeSynonymInstances,"-XTypeSynonymInstances"),(FlexibleContexts,"-XFlexibleContexts"),(FlexibleInstances,"-XFlexibleInstances"),(ConstrainedClassMethods,"-XConstrainedClassMethods"),(MultiParamTypeClasses,"-XMultiParamTypeClasses"),(FunctionalDependencies,"-XFunctionalDependencies"),(GeneralizedNewtypeDeriving,"-XGeneralizedNewtypeDeriving"),(OverlappingInstances,"-XOverlappingInstances"),(UndecidableInstances,"-XUndecidableInstances"),(IncoherentInstances,"-XIncoherentInstances")]}, buildDir = "dist/build", scratchDir = "dist/scratch", packageDeps = [PackageIdentifier {pkgName = "base", pkgVersion = Version {versionBranch = [3,0], versionTags = []}}], pkgDescrFile = Just "categories.cabal", localPkgDescr = PackageDescription {package = PackageIdentifier {pkgName = "categories", pkgVersion = Version {versionBranch = [0,3], versionTags = []}}, license = BSD3, licenseFile = "LICENSE", copyright = "Copyright (C) 2008 Edward A. Kmett", maintainer = "ekmett@gmail.com", author = "Edward A. Kmett", stability = "experimental", testedWith = [], homepage = "http://comonad.com/", pkgUrl = "", synopsis = "Category Library", description = "Defines functors, monads, etc over arbitrary categories rather than just endofunctors on\nthe category of types. Also introduces the notion of a category transformer, which\ngeneralizes the notion of an Arrow transformer. Using categories in this fashion we can\nreconstruct BiArrows correctly without any flotsam in the type, and we can similarly\nconstruct a number of other useful notions from category theory that do not form Arrows.", category = "Control, Monads", buildDepends = [Dependency "base" AnyVersion], descCabalVersion = AnyVersion, buildType = Custom, library = Just (Library {exposedModules = ["Control.Category.Classes","Control.Category.Arrow","Control.Category.Arrow.Dual","Control.Category.Based","Control.Category.Bifunctor","Control.Category.Bifunctor.Associative","Control.Category.Bifunctor.Braided","Control.Category.Bifunctor.Monoidal","Control.Category.Cartesian","Control.Category.Cartesian.Closed","Control.Category.Distributive","Control.Category.Functor","Control.Category.Functor.Adjunction","Control.Category.Functor.Algebra","Control.Category.Functor.Applicative","Control.Category.Functor.Composition","Control.Category.Functor.Full","Control.Category.Functor.Identity","Control.Category.Functor.Native","Control.Category.Functor.Pointed","Control.Category.Functor.Representable","Control.Category.Monad","Control.Category.Morphism","Control.Category.Comonad","Control.Category.Comonad.Reader","Control.Category.Groupoid","Control.Category.Loop","Control.Category.Object","Control.Category.Transformer","Control.Category.Transformer.Reader","Control.Category.Functor.Instances","Control.Category.Dual","Control.Category.Comma","Control.Category.Hask","Control.Category.Kleisli"], libBuildInfo = BuildInfo {buildable = True, buildTools = [], cppOptions = [], ccOptions = [], ldOptions = [], pkgconfigDepends = [], frameworks = [], cSources = [], hsSourceDirs = ["src"], otherModules = [], extensions = [CPP,EmptyDataDecls,FlexibleContexts,FlexibleInstances,FunctionalDependencies,MultiParamTypeClasses,TypeFamilies,TypeSynonymInstances,TypeOperators,UndecidableInstances,GADTs], extraLibs = [], extraLibDirs = [], includeDirs = [], includes = [], installIncludes = [], options = [(GHC,["-O2","-funbox-strict-fields"])], ghcProfOptions = [], ghcSharedOptions = []}}), executables = [], dataFiles = [], extraSrcFiles = [], extraTmpFiles = []}, withPrograms = [("alex",ConfiguredProgram {programId = "alex", programVersion = Just (Version {versionBranch = [2,0,1], versionTags = []}), programArgs = [], programLocation = FoundOnSystem {locationPath = "/usr/local/bin/alex"}}),("ar",ConfiguredProgram {programId = "ar", programVersion = Nothing, programArgs = [], programLocation = FoundOnSystem {locationPath = "/usr/bin/ar"}}),("c2hs",ConfiguredProgram {programId = "c2hs", programVersion = Nothing, programArgs = [], programLocation = FoundOnSystem {locationPath = "/usr/local/bin/c2hs"}}),("ffihugs",ConfiguredProgram {programId = "ffihugs", programVersion = Nothing, programArgs = [], programLocation = FoundOnSystem {locationPath = "/usr/local/bin/ffihugs"}}),("ghc",ConfiguredProgram {programId = "ghc", programVersion = Just (Version {versionBranch = [6,9,20080401], versionTags = []}), programArgs = [], programLocation = FoundOnSystem {locationPath = "/usr/local/bin/ghc"}}),("ghc-pkg",ConfiguredProgram {programId = "ghc-pkg", programVersion = Just (Version {versionBranch = [6,9,20080401], versionTags = []}), programArgs = [], programLocation = FoundOnSystem {locationPath = "/usr/local/bin/ghc-pkg"}}),("haddock",ConfiguredProgram {programId = "haddock", programVersion = Just (Version {versionBranch = [0,8], versionTags = []}), programArgs = [], programLocation = FoundOnSystem {locationPath = "/usr/local/bin/haddock"}}),("happy",ConfiguredProgram {programId = "happy", programVersion = Just (Version {versionBranch = [1,15], versionTags = []}), programArgs = [], programLocation = FoundOnSystem {locationPath = "/usr/local/bin/happy"}}),("hsc2hs",ConfiguredProgram {programId = "hsc2hs", programVersion = Just (Version {versionBranch = [0,66], versionTags = ["ghc"]}), programArgs = [], programLocation = FoundOnSystem {locationPath = "/usr/local/bin/hsc2hs"}}),("hugs",ConfiguredProgram {programId = "hugs", programVersion = Nothing, programArgs = [], programLocation = FoundOnSystem {locationPath = "/usr/local/bin/hugs"}}),("jhc",ConfiguredProgram {programId = "jhc", programVersion = Just (Version {versionBranch = [0,1], versionTags = []}), programArgs = [], programLocation = FoundOnSystem {locationPath = "/usr/local/bin/jhc"}}),("ld",ConfiguredProgram {programId = "ld", programVersion = Nothing, programArgs = ["-x"], programLocation = FoundOnSystem {locationPath = "/usr/bin/ld"}}),("pkg-config",ConfiguredProgram {programId = "pkg-config", programVersion = Just (Version {versionBranch = [0,15,0], versionTags = []}), programArgs = [], programLocation = FoundOnSystem {locationPath = "/usr/bin/pkg-config"}}),("ranlib",ConfiguredProgram {programId = "ranlib", programVersion = Nothing, programArgs = [], programLocation = FoundOnSystem {locationPath = "/usr/bin/ranlib"}}),("tar",ConfiguredProgram {programId = "tar", programVersion = Nothing, programArgs = [], programLocation = FoundOnSystem {locationPath = "/bin/tar"}})], withPackageDB = GlobalPackageDB, withVanillaLib = True, withProfLib = False, withSharedLib = False, withProfExe = False, withOptimization = True, withGHCiLib = True, splitObjs = False}
<!-- Localized -->