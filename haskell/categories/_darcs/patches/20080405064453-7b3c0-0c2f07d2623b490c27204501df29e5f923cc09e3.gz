[woops
ekmett@gmail.com**20080405064453] {
addfile ./src/Control/Category/Bifunctor/Monoidal.hs
hunk ./src/Control/Category/Bifunctor/Monoidal.hs 1
+-------------------------------------------------------------------------------------------
+-- |
+-- Module	: Control.Category.Bifunctor.Monoidal
+-- Copyright 	: 2008 Edward Kmett
+-- License	: BSD
+--
+-- Maintainer	: Edward Kmett <ekmett@gmail.com>
+-- Stability	: experimental
+-- Portability	: non-portable (class-associated types)
+--
+-- A monoidal category is a category with an associated biendofunctor that has an identity.
+-- which satisfies Mac Lane''s 'Pentagonal' coherence law and the triangular coherence law
+-- that is included in 'Monoidal'. Technically we say that category is 'monoidal' but since
+-- most interesting categories in our world have multiple candidate bifunctors that you can 
+-- use to enrich their structure, we choose here to think of the bifunctor as being 
+-- monoidal. This lets us reuse the same Bifunctor over different categories without 
+-- newtyping, just as we do with Functor
+-------------------------------------------------------------------------------------------
+module Control.Category.Bifunctor.Monoidal where
+
+import Prelude hiding ((.), id, fst, snd)
+import Control.Category
+import Control.Category.Bifunctor
+import Control.Category.Bifunctor.Pentagonal
+
+-- | Denotes that we have some reasonable notion of 'Identity' for a particular 'Bifunctor' in this 'Category'. This
+-- notion is currently used by both 'Monoidal' and 'Comonoidal'
+class Bifunctor p k k k => HasIdentity p k
+#ifndef __HADDOCK__
+ 	where type Identity k p :: * 
+#endif
+
+{- | A monoidal category. 'idl' and 'idr' are traditionally denoted lambda and rho
+ the triangle identity holds:
+
+> first idr = second idl . associate 
+> second idl = first idl . associate
+
+-}
+
+class (Pentagonal p k, HasIdentity p k) => Monoidal p k where
+	idl :: k (p (Identity k p) a) a
+	idr :: k (p a (Identity k p)) a
+
+{- | A comonoidal category satisfies the dual form of the triangle identities
+
+> first idr = coassociate . second idl
+> second idl = coassociate . first idl
+
+This type class is also (ab)used for the inverse operations needed for a strict (co)monoidal category.
+A strict (co)monoidal category is one that is both 'Monoidal' and 'Comonoidal' and satisfies the following laws:
+
+> idr . coidr = id 
+> idl . coidl = id 
+> coidl . idl = id 
+> coidr . idr = id 
+
+-}
+class (Copentagonal p k, HasIdentity p k) => Comonoidal p k where
+	coidl :: k a (p (Identity k p) a)
+	coidr :: k a (p a (Identity k p))
addfile ./src/Control/Category/Bifunctor/Pentagonal.hs
hunk ./src/Control/Category/Bifunctor/Pentagonal.hs 1
+-- {-# OPTIONS -fglasgow-exts -fallow-undecidable-instances #-}
+-------------------------------------------------------------------------------------------
+-- |
+-- Module	: Control.Category.Bifunctor.Pentagonal
+-- Copyright 	: 2008 Edward Kmett
+-- License	: BSD
+--
+-- Maintainer	: Edward Kmett <ekmett@gmail.com>
+-- Stability	: experimental
+-- Portability	: non-portable (class-associated types)
+--
+-- In order to appropriately represent the category of Haskell types and its dual, we need
+-- a 'near-monoidal' category that lacks an identity (since there is no initial object in
+-- the category Hask, but it also has a 'coproduct' in the form of 'Either'.
+-------------------------------------------------------------------------------------------
+module Control.Category.Bifunctor.Pentagonal where
+
+import Control.Category.Bifunctor
+
+{- | A category with an associative bifunctor satisfying Mac Lane\'s pentagonal coherence identity law:
+
+> second associate . associate . first associate = associate . associate
+-}
+class Bifunctor p k k k => Pentagonal p k where
+	associate :: k (p (p a b) c) (p a (p b c))
+
+{- | A category with a coassociative bifunctor satisyfing the dual of Mac Lane's pentagonal coherence identity law:
+
+> first coassociate . coassociate . second coassociate = coassociate . coassociate
+-}
+class Bifunctor s k k k => Copentagonal s k where
+	coassociate :: k (s a (s b c)) (s (s a b) c)
addfile ./src/Control/Category/Cartesian.hs
hunk ./src/Control/Category/Cartesian.hs 1
+-------------------------------------------------------------------------------------------
+-- |
+-- Module	: Control.Category.Cartesian
+-- Copyright 	: 2008 Edward Kmett
+-- License	: BSD
+--
+-- Maintainer	: Edward Kmett <ekmett@gmail.com>
+-- Stability	: experimental
+-- Portability	: non-portable (class-associated types)
+--
+-------------------------------------------------------------------------------------------
+module Control.Category.Cartesian
+	( 
+	-- * Products
+	  HasProducts(..)
+	, bimapProduct, braidProduct, associateProduct, coassociateProduct
+	-- * Coproducts 
+	, HasCoproducts(..)
+	, bimapCoproduct, braidCoproduct, associateCoproduct, coassociateCoproduct
+	-- * Distributivity
+	, factor
+	, Distributive(..)
+	-- * Cartesian Closed Category
+	, CCC(..)
+	, unitCCC, counitCCC
+	-- * Co-(Cartesian Closed Category)
+	, CoCCC(..)
+	, unitCoCCC, counitCoCCC
+	) where
+
+import Prelude hiding (Functor, fmap, (.), id, fst, snd, curry, uncurry)
+
+import Control.Category
+import Control.Category.Functor.Adjunction
+import Control.Category.Bifunctor
+import Control.Category.Bifunctor.Braided
+import Control.Category.Bifunctor.Monoidal
+import Control.Category.Bifunctor.Pentagonal
+
+{- |
+NB: This is weaker than traditional category with products! That would have to look like
+@class (Monoidal k (Prod k), Braided k (Prod k)) => HasProducts k where ...@
+the problem is @(->)@ lacks an initial object, since every type is inhabited in Haskell.
+Consequently its coproduct 'monoid' has no identity and we want to be able to
+describe its dual category, which has this non-traditional form being built
+over a category with an associative bifunctor rather than as a monoidal category
+for the product monoid.
+
+Minimum definition: 
+
+> fst, snd, diag 
+> fst, snd, (&&&)
+-}
+class (Pentagonal (Prod k) k, Copentagonal (Prod k) k, Braided (Prod k) k) => HasProducts k where
+#ifndef __HADDOCK__
+	type Prod k :: * -> * -> *
+#endif
+	fst :: k (Prod k a b) a
+	snd :: k (Prod k a b) b
+	diag :: k a (Prod k a a)
+	(&&&) :: k a b -> k a c -> k a (Prod k b c)
+
+	diag = id &&& id
+	f &&& g = diag >>> bimap f g 
+
+-- | free construction of 'Bifunctor' for the product 'Bifunctor' @Prod k@ if @(&&&)@ is known
+bimapProduct :: HasProducts k => k a c -> k b d -> k (Prod k a b) (Prod k c d)
+bimapProduct f g = (f . fst) &&& (g . snd)
+	
+-- | free construction of 'Braided' for the product 'Bifunctor' @Prod k@
+braidProduct :: HasProducts k => k (Prod k a b) (Prod k b a)
+braidProduct = snd &&& fst
+
+-- | free construction of 'Pentagonal' for the product 'Bifunctor' @Prod k@
+associateProduct :: HasProducts k => k (Prod k (Prod k a b) c) (Prod k a (Prod k b c))
+associateProduct = (fst . fst) &&& first snd
+
+-- | free construction of 'Copentagonal' for the product 'Bifunctor' @Prod k@
+coassociateProduct :: HasProducts k => k (Prod k a (Prod k b c)) (Prod k (Prod k a b) c)
+coassociateProduct = braid . second braid . associateProduct . first braid . braid 
+
+-- * Coproducts
+
+-- a category that has finite coproducts, weakened the same way as HasProducts above was weakened
+class (Pentagonal (Sum k) k, Copentagonal (Sum k) k, Braided (Sum k) k) => HasCoproducts k where
+#ifndef __HADDOCK__
+	type Sum k :: * -> * -> *
+#endif
+	inl :: k a (Sum k a b)
+	inr :: k b (Sum k a b)
+	codiag :: k (Sum k a a) a
+	(|||) :: k a c -> k b c -> k (Sum k a b) c
+
+	codiag = id ||| id
+	f ||| g = bimap f g >>> codiag 
+
+-- | free construction of 'Bifunctor' for the coproduct 'Bifunctor' @Sum k@ if @(|||)@ is known
+bimapCoproduct :: HasCoproducts k => k a c -> k b d -> k (Sum k a b) (Sum k c d)
+bimapCoproduct f g = (inl . f) ||| (inr . g)
+
+-- | free construction of 'Braided' for the coproduct 'Bifunctor' @Sum k@
+braidCoproduct :: HasCoproducts k => k (Sum k a b) (Sum k b a)
+braidCoproduct = inr ||| inl
+
+-- | free construction of 'Pentagonal' for the coproduct 'Bifunctor' @Sum k@
+associateCoproduct :: HasCoproducts k => k (Sum k (Sum k a b) c) (Sum k a (Sum k b c))
+associateCoproduct = braid . first braid . coassociateCoproduct . second braid . braid
+
+-- | free construction of 'Copentagonal' for the coproduct 'Bifunctor' @Sum k@
+coassociateCoproduct :: HasCoproducts k => k (Sum k a (Sum k b c)) (Sum k (Sum k a b) c)
+coassociateCoproduct = (inl . inl) ||| first inr
+
+-- | the canonical morphism usually known as delta
+factor :: (HasProducts k, HasCoproducts k) => k (Sum k (Prod k a b) (Prod k a c)) (Prod k a (Sum k b c))
+factor = second inl ||| second inr
+
+class (HasProducts k, HasCoproducts k) => Distributive k where
+	distribute :: k (Prod k a (Sum k b c)) (Sum k (Prod k a b) (Prod k a c))
+
+-- * Closed Cartesian Category 
+
+-- | A 'CCC' has full-fledged monoidal finite products and exponentials
+
+-- You probably also want an instance for @'Bifunctor' ('Exp' k) ('Dual' k) k k@.
+
+class (Monoidal (Prod k) k, HasProducts k) => CCC k where
+#ifndef __HADDOCK__
+	type Exp k :: * -> * -> *
+#endif
+	apply :: k (Prod k (Exp k a b) a) b
+	curry :: k (Prod k a b) c -> k a (Exp k b c)
+	uncurry :: k a (Exp k b c) -> k (Prod k a b) c
+
+-- * Free 'Adjunction' (Prod k a) (Exp k a) k k 
+
+unitCCC :: CCC k => k a (Exp k b (Prod k b a))
+unitCCC = curry braid
+
+counitCCC :: CCC k => k (Prod k b (Exp k b a)) a
+counitCCC = apply . braid
+
+-- * A Co-(Closed Cartesian Category) 
+
+-- | A Co-CCC has full-fledged comonoidal finite coproducts and coexponentials
+
+-- You probably also want an instance for @'Bifunctor' ('Coexp' k) ('Dual' k) k k@.
+
+class (Comonoidal (Sum k) k, HasCoproducts k) => CoCCC k where
+#ifndef __HADDOCK__
+	type Coexp k :: * -> * -> *
+#endif
+	coapply :: k b (Sum k (Coexp k a b) a)
+	cocurry :: k c (Sum k a b) -> k (Coexp k b c) a
+	uncocurry :: k (Coexp k b c) a -> k c (Sum k a b)
+
+-- * Free 'Adjunction' (Coexp k a) (Sum k a) k k 
+
+unitCoCCC :: CoCCC k => k a (Sum k b (Coexp k b a))
+unitCoCCC = braid . coapply
+
+counitCoCCC :: CoCCC k => k (Coexp k b (Sum k b a)) a
+counitCoCCC = cocurry braid
+
+
addfile ./src/Control/Category/Comma.hs
hunk ./src/Control/Category/Comma.hs 1
+-------------------------------------------------------------------------------------------
+-- |
+-- Module	: Control.Category.Comma
+-- Copyright 	: 2008 Edward Kmett
+-- License	: BSD
+--
+-- Maintainer	: Edward Kmett <ekmett@gmail.com>
+-- Stability	: experimental
+-- Portability	: non-portable (class-associated types)
+--
+-- Comma categories (ala Slice categories) <http://en.wikipedia.org/wiki/Comma_category>.
+-- Note the similarity to f-algebras and f-coalgebras and the definitions for a natural
+-- transformation.
+-------------------------------------------------------------------------------------------
+
+module Control.Category.Comma where
+
+import Prelude hiding (Functor, fmap,(.))
+import qualified Prelude
+
+import Control.Category
+import Control.Category.Functor
+
+#ifndef __HADDOCK__
+data Comma (t :: * -> *) (s :: * -> *) ka kb (k :: * -> * -> *) a b where 
+	Comma   :: (Functor t ka k, Functor s kb k) => ka a a' -> kb b b' -> Comma t s ka kb k (a,b) (a',b')
+	CommaId :: Comma t s ka kb k a a
+#endif
+
+instance (Functor t ka k, Functor s kb k) => Category (Comma t s ka kb k) where
+	id = CommaId
+	CommaId . CommaId = CommaId
+	CommaId . Comma g h = Comma g h
+	Comma g h . CommaId = Comma g h
+	Comma g h . Comma g' h' = Comma (g . g') (h . h')
+
+preComma :: (Functor t ka k, Functor t kb k) => Comma t s ka kb k (a,b) (a',b') -> k (t a) (s b) -> k (t a) (s b')
+preComma CommaId f = f
+preComma (Comma g h) f = fmap h . f
+
+postComma :: (Functor t ka k, Functor t kb k) => k (t a') (s b') -> Comma t s ka kb k (a,b) (a',b') -> k (t a) (s b')
+postComma f CommaId = f
+postComma f (Comma g h) = f . fmap g
addfile ./src/Control/Category/Functor/Algebra.hs
hunk ./src/Control/Category/Functor/Algebra.hs 1
+-------------------------------------------------------------------------------------------
+-- |
+-- Module	: Control.Category.Functor.Algebra
+-- Copyright 	: 2008 Edward Kmett
+-- License	: BSD
+--
+-- Maintainer	: Edward Kmett <ekmett@gmail.com>
+-- Stability	: experimental
+-- Portability	: non-portable (functional-dependencies)
+--
+-------------------------------------------------------------------------------------------
+
+module Control.Category.Functor.Algebra where
+
+import Prelude hiding (Functor, fmap, (.), id, fst, snd, Monad, return, (>>=))
+import qualified Prelude
+
+import Control.Category.Classes
+
+#ifndef __HADDOCK__
+newtype Alg (f :: * -> *) k a b = Alg { runAlg :: k a b }
+#endif
+
+postAlg :: Functor f k k => k (f a) a -> Alg f k a b -> k (f a) b
+postAlg f (Alg g) = g . f
+
+preAlg :: Functor f k k => Alg f k a b -> k (f b) b -> k (f a) b
+preAlg (Alg f) g = g . fmap f
+
+instance Functor f k k => CategoryTransformer (Alg f) k where
+	lift = Alg
+
+instance Functor f k k => Category (Alg f k) where
+	id = Alg id
+	g . f = Alg (runAlg g . runAlg f)
+
addfile ./src/Control/Category/Functor/Instances.hs
hunk ./src/Control/Category/Functor/Instances.hs 1
+-------------------------------------------------------------------------------------------
+-- |
+-- Module	: Control.Category.Functor.Instances
+-- Copyright 	: 2008 Edward Kmett
+-- License	: BSD
+--
+-- Maintainer	: Edward Kmett <ekmett@gmail.com>
+-- Stability	: experimental
+-- Portability	: non-portable (class-associated types)
+--
+-- Redefines 'Functor' to allow it to represent a functor between different categories
+-------------------------------------------------------------------------------------------
+
+module Control.Category.Functor.Instances where
+
+import Prelude hiding (Functor, fmap)
+import qualified Prelude
+
+import Control.Category
+import Control.Category.Functor
+import Control.Category.Bifunctor
+
+instance Bifunctor f ka kb kc => Functor (f a) kb kc where
+	fmap = second
+
addfile ./src/Control/Category/Kleisli.hs
hunk ./src/Control/Category/Kleisli.hs 1
+{-# OPTIONS -fglasgow-exts #-}
+-------------------------------------------------------------------------------------------
+-- |
+-- Module	: Control.Category.Kleisli
+-- Copyright 	: 2008 Edward Kmett
+-- License	: BSD
+--
+-- Maintainer	: Edward Kmett <ekmett@gmail.com>
+-- Stability	: experimental
+-- Portability	: non-portable (class-associated types)
+--
+-------------------------------------------------------------------------------------------
+
+module Control.Category.Kleisli where
+
+import Prelude hiding (Functor, fmap, (.), id, fst, snd, Monad, return, (>>=))
+import qualified Prelude
+import Control.Category.Classes
+
+newtype Kleisli m k a b = Kleisli { runKleisli :: k a (m b) }
+
+instance Monad m k => Category (Kleisli m k) where
+	id = Kleisli return
+	g . f = Kleisli (bind (runKleisli g) . runKleisli f)
+
+instance Monad m k => CategoryTransformer (Kleisli m) k where
+	lift f = Kleisli (return . f)
+
+--instance (Monad m k, Bifunctor f k) => Bifunctor f (Kleisli m k) where
+--	bimap f g = 
}
