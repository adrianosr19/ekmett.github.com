[Added Full functors, groupoids, and fleshed out some others
ekmett@gmail.com**20080406041146] {
move ./src/Control/Category/Bifunctor/Pentagonal.hs ./src/Control/Category/Bifunctor/Associative.hs
move ./src/Control/Category/Functor/Monad.hs ./src/Control/Category/Monad.hs
adddir ./src/Control/Category/Arrow
adddir ./src/Control/Category/Comonad
adddir ./src/Control/Category/Transformer
hunk ./categories.cabal 3
-version:		0.2
+version:		0.3
hunk ./categories.cabal 27
+	TypeSynonymInstances,
hunk ./categories.cabal 34
+	Control.Category.Arrow,
+	Control.Category.Arrow.Dual,
hunk ./categories.cabal 37
-	Control.Category.Bifunctor,	
+	Control.Category.Bifunctor,
+	Control.Category.Bifunctor.Associative,
hunk ./categories.cabal 41
-	Control.Category.Bifunctor.Pentagonal,	
-	Control.Category.Cartesian,	
+	Control.Category.Cartesian,
hunk ./categories.cabal 43
-	Control.Category.Functor.Algebra,
hunk ./categories.cabal 44
-	Control.Category.Functor.Monad,	
+	Control.Category.Functor.Algebra,
+	Control.Category.Functor.Applicative,
+	Control.Category.Functor.Full
hunk ./categories.cabal 48
-	Control.Category.Loop,		
-	Control.Category.Object,	
+	Control.Category.Monad,	
+	Control.Category.Monad.Reader,	
+	Control.Category.Morphism,	
+	Control.Category.Comonad,	
+	Control.Category.Comonad.Reader,	
+	Control.Category.Groupoid,
+	Control.Category.Loop,
+	Control.Category.Object,
hunk ./categories.cabal 57
+	Control.Category.Transformer.Reader
hunk ./categories.cabal 59
-	Control.Category.Functor.Instances,	
-	Control.Category.Dual,	
+	Control.Category.Functor.Instances,
+	Control.Category.Dual,
addfile ./src/Control/Category/Arrow.hs
hunk ./src/Control/Category/Arrow.hs 1
+-------------------------------------------------------------------------------------------
+-- |
+-- Module	: Control.Category.Arrow
+-- Copyright 	: 2008 Edward Kmett
+-- License	: BSD
+--
+-- Maintainer	: Edward Kmett <ekmett@gmail.com>
+-- Stability	: experimental
+-- Portability	: non-portable (class-associated types)
+--
+-------------------------------------------------------------------------------------------
+module Control.Category.Arrow where
+
+import Prelude hiding (Functor, map, (.), id, fst, snd, curry, uncurry)
+
+import Control.Category
+import Control.Category.Cartesian
+
+-- Arrows have finite products, a fixed notion for Prod k and can inject functions from the metalanguage
+class (
+	HasProducts k
+#ifndef __HADDOCK__
+	, Prod k ~ (,)
+#endif
+      ) => Arrow k where
+	arr :: (a -> b) -> k a b
+
addfile ./src/Control/Category/Arrow/Dual.hs
hunk ./src/Control/Category/Arrow/Dual.hs 1
+-------------------------------------------------------------------------------------------
+-- |
+-- Module	: Control.Category.Arrow.Dual
+-- Copyright 	: 2008 Edward Kmett
+-- License	: BSD
+--
+-- Maintainer	: Edward Kmett <ekmett@gmail.com>
+-- Stability	: experimental
+-- Portability	: non-portable (class-associated types)
+--
+-------------------------------------------------------------------------------------------
+module Control.Category.Arrow.Dual where
+
+import Prelude hiding (Functor, map, (.), id, fst, snd, curry, uncurry)
+
+import Control.Category
+import Control.Category.Cartesian
+
+-- Contravariant arrow (which is not a coarrow, which would be the same thing as an arrow)
+class (
+	HasCoproducts k
+#ifndef __HADDOCK__
+	, Sum k ~ (,)
+#endif
+      ) => DualArrow k where
+	dualarr :: (a -> b) -> k b a
hunk ./src/Control/Category/Based.hs 19
-import Prelude hiding (Functor, fmap)
+import Prelude hiding (Functor, map)
hunk ./src/Control/Category/Bifunctor.hs 14
-import Prelude hiding ((.), id, fst, snd)
+import Prelude hiding (id)
hunk ./src/Control/Category/Bifunctor.hs 17
--- | A covariant bifunctor @f :: k1 * k2 -> k3@
+-- | A covariant 'Bifunctor' @f :: k1 * k2 -> k3@
+-- | NB: Bifunctors with contravariant arguments can be represented using the 'Dual' 'Category' in that argument
hunk ./src/Control/Category/Bifunctor.hs 20
-	-- | Analogous to '***' or '+++' in "Control.Arrow", but generalized to any covariant bifunctor
+	-- | Generalizes the arrow combinators @***@ and @+++@ to any covariant bifunctor
hunk ./src/Control/Category/Bifunctor.hs 22
-	-- | Analogous to 'first' or 'left' in "Control.Arrow", but generalized to any covariant bifunctor
hunk ./src/Control/Category/Bifunctor.hs 23
-	-- | Analogous to 'second' or 'right' in "Control.Arrow", but generalized to any covariant bifunctor
hunk ./src/Control/Category/Bifunctor/Associative.hs 4
--- Module	: Control.Category.Bifunctor.Pentagonal
+-- Module	: Control.Category.Bifunctor.Associative
hunk ./src/Control/Category/Bifunctor/Associative.hs 15
+--
+-- NB: this contradicts another common meaning for an associative category, which is one 
+-- where the pentagonal condition does not hold, but where there IS an identity. 
+--
+-- You really can't win.
hunk ./src/Control/Category/Bifunctor/Associative.hs 21
-module Control.Category.Bifunctor.Pentagonal where
+module Control.Category.Bifunctor.Associative where
hunk ./src/Control/Category/Bifunctor/Associative.hs 29
-class Bifunctor p k k k => Pentagonal p k where
+class Bifunctor p k k k => Associative p k where
hunk ./src/Control/Category/Bifunctor/Associative.hs 36
-class Bifunctor s k k k => Copentagonal s k where
+class Bifunctor s k k k => Coassociative s k where
hunk ./src/Control/Category/Bifunctor/Braided.hs 16
+-- * Braided (co)Monoidal Categories
+
hunk ./src/Control/Category/Bifunctor/Braided.hs 27
-If it is a symmetric (co)monoidal category, you get the additional law (currently not represented by a typeclass)
-
-> braid . braid = id
hunk ./src/Control/Category/Bifunctor/Braided.hs 32
--- class Braided p k => Symmetric p k
+{-# RULES 
+	"idr/braid" 			idr . braid = idl
+	"idl/braid" 			idl . braid = idr
+	"braid/coidr" 			braid . coidr = coidl
+	"braid/coidl" 			braid . coidl = coidr
+	"braid/associate/braid" 	second braid . associate . first braid = associate . braid . associate
+	"braid/coassociate/braid" 	first braid . coassociate . second braid = coassociate . braid . coassociate
+ #-}
+
+-- * Symmetric (co)Monoidal Categories
+
+{- |
+If we have a symmetric (co)'Monoidal' category, you get the additional law:
+
+> swap . swap = id
+ -}
+class Braided p k => Symmetric p k
+
+swap :: Symmetric p k => k (p a b) (p b a)
+swap = braid
+
+{-# RULES
+	"swap/swap" swap . swap = id
+ #-}
hunk ./src/Control/Category/Bifunctor/Monoidal.hs 11
--- A monoidal category is a category with an associated biendofunctor that has an identity.
--- which satisfies Mac Lane''s 'Pentagonal' coherence law and the triangular coherence law
--- that is included in 'Monoidal'. Technically we say that category is 'monoidal' but since
+-- A 'Monoidal' category is a category with an associated biendofunctor that has an identity,
+-- which satisfies Mac Lane''s pentagonal and triangular coherence conditions
+-- Technically we usually say that category is 'monoidal', but since
hunk ./src/Control/Category/Bifunctor/Monoidal.hs 17
--- newtyping, just as we do with Functor
+-- painful type annotations.
hunk ./src/Control/Category/Bifunctor/Monoidal.hs 24
-import Control.Category.Bifunctor.Pentagonal
+import Control.Category.Bifunctor.Associative
hunk ./src/Control/Category/Bifunctor/Monoidal.hs 41
-class (Pentagonal p k, HasIdentity p k) => Monoidal p k where
+class (Associative p k, HasIdentity p k) => Monoidal p k where
hunk ./src/Control/Category/Bifunctor/Monoidal.hs 59
-class (Copentagonal p k, HasIdentity p k) => Comonoidal p k where
+class (Coassociative p k, HasIdentity p k) => Comonoidal p k where
hunk ./src/Control/Category/Cartesian.hs 20
-	-- * Distributivity
-	, factor
+	-- * Distributive Categories
+	, factor	-- the canonical factoring morphism
hunk ./src/Control/Category/Cartesian.hs 31
-import Prelude hiding (Functor, fmap, (.), id, fst, snd, curry, uncurry)
+import Prelude hiding (Functor, map, (.), id, fst, snd, curry, uncurry)
hunk ./src/Control/Category/Cartesian.hs 34
+import Control.Category.Functor
hunk ./src/Control/Category/Cartesian.hs 36
+
hunk ./src/Control/Category/Cartesian.hs 38
+import Control.Category.Bifunctor.Associative
hunk ./src/Control/Category/Cartesian.hs 41
-import Control.Category.Bifunctor.Pentagonal
hunk ./src/Control/Category/Cartesian.hs 56
-class (Pentagonal (Prod k) k, Copentagonal (Prod k) k, Braided (Prod k) k) => HasProducts k where
+class (Associative (Prod k) k, Coassociative (Prod k) k, Braided (Prod k) k) => HasProducts k where
hunk ./src/Control/Category/Cartesian.hs 68
+{-# RULES
+	"fst . diag"  	fst . diag = id
+	"snd . diag"	snd . diag = id
+	"fst . f &&& g" forall f g. fst . (f &&& g) = f
+	"snd . f &&& g" forall f g. snd . (f &&& g) = g
+ #-}
+
hunk ./src/Control/Category/Cartesian.hs 83
--- | free construction of 'Pentagonal' for the product 'Bifunctor' @Prod k@
+-- | free construction of 'Associative' for the product 'Bifunctor' @Prod k@
hunk ./src/Control/Category/Cartesian.hs 87
--- | free construction of 'Copentagonal' for the product 'Bifunctor' @Prod k@
+-- | free construction of 'Coassociative' for the product 'Bifunctor' @Prod k@
hunk ./src/Control/Category/Cartesian.hs 94
-class (Pentagonal (Sum k) k, Copentagonal (Sum k) k, Braided (Sum k) k) => HasCoproducts k where
+class (Associative (Sum k) k, Coassociative (Sum k) k, Braided (Sum k) k) => HasCoproducts k where
hunk ./src/Control/Category/Cartesian.hs 106
+{-# RULES
+	"codiag . inl"  codiag . inl = id
+	"codiag . inr"	codiag . inr = id
+	"(f ||| g) . inl" forall f g. (f ||| g) . inl = f
+	"(f &&& g) . inr" forall f g. (f &&& g) . inr = g
+ #-}
+
hunk ./src/Control/Category/Cartesian.hs 121
--- | free construction of 'Pentagonal' for the coproduct 'Bifunctor' @Sum k@
+-- | free construction of 'Associative' for the coproduct 'Bifunctor' @Sum k@
hunk ./src/Control/Category/Cartesian.hs 125
--- | free construction of 'Copentagonal' for the coproduct 'Bifunctor' @Sum k@
+-- | free construction of 'Coassociative' for the coproduct 'Bifunctor' @Sum k@
hunk ./src/Control/Category/Cartesian.hs 136
+{-# RULES
+	"factor . distribute"	 factor . distribute = id
+	"distribute . factor"    distribute . factor = id
+ #-}
+
hunk ./src/Control/Category/Cartesian.hs 145
--- You probably also want an instance for @'Bifunctor' ('Exp' k) ('Dual' k) k k@.
+-- Ideally you also want an instance for @'Bifunctor' ('Exp' k) ('Dual' k) k k@.
+-- or at least @'Functor' ('Exp' k a) k k@, which cannot be expressed in the constraints here.
hunk ./src/Control/Category/Cartesian.hs 156
+{-# RULES
+	"curry apply" 		curry apply = id
+	"curry . uncurry" 	curry . uncurry = id
+	"uncurry . curry" 	uncurry . curry = id
+ #-}
+
hunk ./src/Control/Category/Cartesian.hs 184
+{-# RULES
+	"cocurry coapply" 	cocurry coapply = id
+	"cocurry . uncocurry"	cocurry . uncocurry = id
+	"uncocurry . cocurry"   uncocurry . cocurry = id
+ #-}
+
hunk ./src/Control/Category/Classes.hs 16
+	, module Control.Category.Arrow
+	, module Control.Category.Arrow.Dual
hunk ./src/Control/Category/Classes.hs 20
-	, module Control.Category.Bifunctor.Pentagonal
-	, module Control.Category.Bifunctor.Monoidal
hunk ./src/Control/Category/Classes.hs 21
+	, module Control.Category.Bifunctor.Associative
+	, module Control.Category.Bifunctor.Monoidal
hunk ./src/Control/Category/Classes.hs 24
+	, module Control.Category.Groupoid
hunk ./src/Control/Category/Classes.hs 26
+	, module Control.Category.Functor.Applicative
hunk ./src/Control/Category/Classes.hs 28
+	, module Control.Category.Functor.Full
+	, module Control.Category.Comonad
+	, module Control.Category.Monad
+	, module Control.Category.Morphism
hunk ./src/Control/Category/Classes.hs 33
-	, module Control.Category.Functor.Monad
hunk ./src/Control/Category/Classes.hs 40
+import Control.Category.Arrow
+import Control.Category.Arrow.Dual
hunk ./src/Control/Category/Classes.hs 44
-import Control.Category.Bifunctor.Pentagonal
+import Control.Category.Bifunctor.Associative
hunk ./src/Control/Category/Classes.hs 48
+import Control.Category.Comonad
hunk ./src/Control/Category/Classes.hs 50
+import Control.Category.Functor.Applicative
+import Control.Category.Functor.Full
hunk ./src/Control/Category/Classes.hs 54
-import Control.Category.Functor.Monad
+import Control.Category.Groupoid
+import Control.Category.Monad
+import Control.Category.Morphism
hunk ./src/Control/Category/Comma.hs 11
--- Comma categories (ala Slice categories) <http://en.wikipedia.org/wiki/Comma_category>.
--- Note the similarity to f-algebras and f-coalgebras and the definitions for a natural
+-- Comma categories (aka Slice categories) <http://en.wikipedia.org/wiki/Comma_category>.
+-- Note the similarity to f-algebras and f-coalgebras and the definition for a natural
hunk ./src/Control/Category/Comma.hs 18
-import Prelude hiding (Functor, fmap,(.))
+import Prelude hiding (Functor, map, (.))
hunk ./src/Control/Category/Comma.hs 39
-preComma (Comma g h) f = fmap h . f
+preComma (Comma g h) f = map h . f
hunk ./src/Control/Category/Comma.hs 43
-postComma f (Comma g h) = f . fmap g
+postComma f (Comma g h) = f . map g
addfile ./src/Control/Category/Comonad.hs
hunk ./src/Control/Category/Comonad.hs 1
+-------------------------------------------------------------------------------------------
+-- |
+-- Module	: Control.Category.Comonad
+-- Copyright 	: 2008 Edward Kmett
+-- License	: BSD-style (see the LICENSE file in the distribution)
+--
+-- Maintainer	: Edward Kmett <ekmett@gmail.com>
+-- Stability	: experimental
+-- Portability	: non-portable (class-associated types)
+--
+-- Defines 'Comonad' in a way that allows it to represent a 'Comonad' over 
+-- a 'Category' other than just 'Hask'.
+-------------------------------------------------------------------------------------------
+
+module Control.Category.Comonad 
+	( Comonad (extend, duplicate), mapComonad
+	) where
+
+import Prelude hiding (Functor, map, (.), id, Monad, return, (>>=),(=<<),(>>))
+import Control.Category
+import Control.Category.Functor
+import Control.Category.Functor.Pointed
+
+{- | Instances of Comonad should satisfy the following laws:
+
+> extract . extend k = k
+> extend extract = id
+> map f = extend (f . extract)
+
+-}
+
+class Copointed w k => Comonad w k where
+	extend :: k (w a) b -> k (w a) (w b)
+	duplicate :: k (w a) (w (w a))
+
+	extend f = map f . duplicate
+	duplicate = extend id
+
+{-# RULES
+        "extend extract"        extend extract = id
+        "extract . extend k"    forall k. extract . extend k = k
+ #-}
+
+-- | free definition of 'Functor' for a 'Comonad' @m@ over a 'Category' @k@
+
+mapComonad :: Comonad w k => k a b -> k (w a) (w b)
+mapComonad f = extend (f . extract)
addfile ./src/Control/Category/Comonad/Reader.hs
hunk ./src/Control/Category/Comonad/Reader.hs 1
+-------------------------------------------------------------------------------------------
+-- |
+-- Module	: Control.Category.Comonad.Reader
+-- Copyright 	: 2008 Edward Kmett
+-- License	: BSD-style (see the LICENSE file in the distribution)
+--
+-- Maintainer	: Edward Kmett <ekmett@gmail.com>
+-- Stability	: experimental
+-- Portability	: non-portable (class-associated types)
+--
+-------------------------------------------------------------------------------------------
+
+module Control.Category.Comonad.Reader where
+
+import Prelude hiding (Functor, fmap, (.), id, fst, snd)
+import Control.Category
+import Control.Category.Functor
+import Control.Category.Morphism
+import Control.Category.Cartesian
+import Control.Category.Comonad
+import Control.Category.Bifunctor
+import Control.Category.Bifunctor.Associative
+import Control.Category.Functor.Pointed
+
+newtype ReaderW e k a = ReaderW (Prod k a e)
+
+--instance (Canonical k (ReaderW e k a) (Prod k a e), HasProducts k) => Functor (ReaderW e k) k k where
+--	map = mapComonad 
+--
+--instance (Canonical k (ReaderW e k a) (Prod k a e), HasProducts k) => Copointed (ReaderW e k) k where
+--	extract = fst . iso
+--
+--instance (Canonical k (ReaderW e k a) (Prod k a e), HasProducts k) => Comonad (ReaderW e k) k where
+--	extend k = uniso . (k &&& snd) . iso
+--	duplicate = uniso .  coassociate . second diag . iso
hunk ./src/Control/Category/Dual.hs 16
-import Prelude hiding (Functor, fmap, (.), id, fst, snd, Monad, return, (>>=), curry, uncurry)
+import Prelude hiding (Functor, map, (.), id, fst, snd, Monad, return, (>>=), curry, uncurry)
hunk ./src/Control/Category/Dual.hs 30
-instance Pentagonal p k => Copentagonal p (Dual k) where
+instance Associative p k => Coassociative p (Dual k) where
hunk ./src/Control/Category/Dual.hs 33
-instance Copentagonal p k => Pentagonal p (Dual k) where
+instance Coassociative p k => Associative p (Dual k) where
hunk ./src/Control/Category/Dual.hs 71
-	fmap = Dual . fmap . runDual
+	map = Dual . map . runDual
+
+instance Full f k k => Full f (Dual k) (Dual k) where
+	unmap = Dual . unmap . runDual
hunk ./src/Control/Category/Dual.hs 112
+instance (
+	Arrow k
+#ifndef __HADDOCK__
+	, Prod k ~ (,)
+#endif
+	) => DualArrow (Dual k) where
+	dualarr f = Dual (arr f)
+
+instance (
+	DualArrow k
+#ifndef __HADDOCK__
+	, Sum k ~ (,)
+#endif
+	) => Arrow (Dual k) where
+	arr f = Dual (dualarr f)
+
+liftDualDual :: k a b -> Dual (Dual k) a b
+liftDualDual = Dual . Dual
+
+lowerDualDual :: Dual (Dual k) a b -> k a b
+lowerDualDual = runDual . runDual
hunk ./src/Control/Category/Functor.hs 14
-module Control.Category.Functor ( Functor(fmap)) where
+module Control.Category.Functor ( Functor(map)) where
hunk ./src/Control/Category/Functor.hs 16
-import Prelude hiding (Functor, fmap)
+import Prelude hiding (Functor, map)
hunk ./src/Control/Category/Functor.hs 23
-> fmap id = id
-> fmap (f . g) = fmap f . fmap g
+> map id = id
+> map (f . g) = map f . map g
hunk ./src/Control/Category/Functor.hs 27
-	fmap :: c a b -> d (f a) (f b)
+	map :: c a b -> d (f a) (f b)
hunk ./src/Control/Category/Functor.hs 30
-  "fmap identity" 	fmap id = id
-  "fmap deforestation"  forall f g.  fmap f . fmap g = fmap (f . g)
+  "map identity"       map id = id
+  "map deforestation"  forall f g.  map f . map g = map (f . g)
hunk ./src/Control/Category/Functor/Adjunction.hs 16
-import Prelude hiding (Functor, fmap, (.), id, fst, snd, Monad, return, (>>=))
+import Prelude hiding (Functor, map, (.), id, fst, snd, Monad, return, (>>=))
hunk ./src/Control/Category/Functor/Adjunction.hs 38
-	leftAdjunct f = fmap f . unit
-	rightAdjunct f = counit . fmap f
+	leftAdjunct f = map f . unit
+	rightAdjunct f = counit . map f
hunk ./src/Control/Category/Functor/Algebra.hs 15
-import Prelude hiding (Functor, fmap, (.), id, fst, snd, Monad, return, (>>=))
+import Prelude hiding (Functor, map, (.), id, fst, snd, Monad, return, (>>=))
hunk ./src/Control/Category/Functor/Algebra.hs 28
-preAlg (Alg f) g = g . fmap f
+preAlg (Alg f) g = g . map f
addfile ./src/Control/Category/Functor/Applicative.hs
hunk ./src/Control/Category/Functor/Applicative.hs 1
+-------------------------------------------------------------------------------------------
+-- |
+-- Module	: Control.Category.Functor.Applicative
+-- Copyright 	: 2008 Edward Kmett
+-- License	: BSD-style (see the LICENSE file in the distribution)
+--
+-- Maintainer	: Edward Kmett <ekmett@gmail.com>
+-- Stability	: experimental
+-- Portability	: non-portable
+--
+-- A strong lax (co)monoidal functor 
+-------------------------------------------------------------------------------------------
+
+module Control.Category.Functor.Applicative where
+
+import Prelude hiding (Functor,return,curry,uncurry)
+import Control.Category.Functor
+import Control.Category.Functor.Pointed
+import Control.Category.Cartesian
+
+class (CCC c, HasProducts d, Functor f c d) => Applicative f c d where
+	ap :: d (Prod d (f (Exp c a b)) (f a)) (f b)
+
+apc :: (CCC d, Applicative f c d) => d (f (Exp c a b)) (Exp d (f a) (f b))
+apc = curry ap
+
+class (CoCCC c, HasCoproducts d, Functor f c d) => Coapplicative f c d where
+	coap :: d (f b) (Sum d (f (Coexp c a b)) (f a)) 
+
+coapc :: (CoCCC d, Coapplicative f c d) => d (Coexp d (f a) (f b)) (f (Coexp c a b))
+coapc = cocurry coap
addfile ./src/Control/Category/Functor/Full.hs
hunk ./src/Control/Category/Functor/Full.hs 1
+-------------------------------------------------------------------------------------------
+-- |
+-- Module	: Control.Category.Functor.Full
+-- Copyright 	: 2008 Edward Kmett
+-- License	: BSD-style (see the LICENSE file in the distribution)
+--
+-- Maintainer	: Edward Kmett <ekmett@gmail.com>
+-- Stability	: experimental
+-- Portability	: non-portable (class-associated types)
+--
+-------------------------------------------------------------------------------------------
+
+module Control.Category.Functor.Full where
+
+import Prelude hiding (Functor, map, (.), id)
+import Control.Category
+import Control.Category.Functor
+
+{- |
+	A 'Full' Functor @F : C -> D@ provides for every pair of objects @c@, @c'@ in @C@
+	and every morphism @g : F c -> F c'l@ in D, a morphism @g' : c -> c'@ in C.
+-}
+
+class Functor f c d => Full f c d | f c -> d, f d -> c where
+	unmap :: d (f a) (f b) -> c a b
+	
+{-# RULES
+	"map/unmap" 	map . unmap = id
+	"unmap/map" 	unmap . map = id
+ #-}
hunk ./src/Control/Category/Functor/Instances.hs 11
--- Redefines 'Functor' to allow it to represent a functor between different categories
+-- Automatically derives functors from bifunctors
+{-
+@instance 'Bifunctor' f ka kb kc => 'Functor' (f a) kb kc where 'map' = 'second'@
+-}
hunk ./src/Control/Category/Functor/Instances.hs 19
-import Prelude hiding (Functor, fmap)
+import Prelude hiding (Functor, map)
hunk ./src/Control/Category/Functor/Instances.hs 27
-	fmap = second
+	map = second
addfile ./src/Control/Category/Groupoid.hs
hunk ./src/Control/Category/Groupoid.hs 1
+-------------------------------------------------------------------------------------------
+-- |
+-- Module	: Control.Category.Groupoid
+-- Copyright 	: 2008 Edward Kmett
+-- License	: BSD3
+--
+-- Maintainer	: Edward Kmett <ekmett@gmail.com>
+-- Stability	: experimental
+-- Portability	: non-portable (functional-dependencies)
+--
+-- A groupoid is a category in which each morphism is invertible
+-------------------------------------------------------------------------------------------
+module Control.Category.Groupoid where
+
+import Control.Category
+
+class Category k => Groupoid k where
+	inv :: k a b -> k b a
hunk ./src/Control/Category/Hask.hs 18
-import Prelude hiding (Functor, fmap, (.), id, fst, snd, Monad, return, (>>=))
+import Prelude hiding (Functor, map, (.), id, fst, snd, Monad, return, (>>=))
hunk ./src/Control/Category/Hask.hs 37
-instance Pentagonal (,) (->) where
+instance Associative (,) (->) where
hunk ./src/Control/Category/Hask.hs 39
-instance Copentagonal (,) (->) where
+instance Coassociative (,) (->) where
hunk ./src/Control/Category/Hask.hs 65
-instance Copentagonal Either (->) where
+instance Coassociative Either (->) where
hunk ./src/Control/Category/Hask.hs 67
-instance Pentagonal Either (->) where
+instance Associative Either (->) where
hunk ./src/Control/Category/Hask.hs 82
-	fmap f ~(x,t) = (x, f t)
+	map f ~(x,t) = (x, f t)
hunk ./src/Control/Category/Hask.hs 85
-	fmap f g = f . g 
+	map f g = f . g 
hunk ./src/Control/Category/Kleisli.hs 1
-{-# OPTIONS -fglasgow-exts #-}
hunk ./src/Control/Category/Kleisli.hs 15
-import Prelude hiding (Functor, fmap, (.), id, fst, snd, Monad, return, (>>=))
+import Prelude hiding (Functor, map, (.), id, fst, snd, Monad, return, (>>=))
hunk ./src/Control/Category/Kleisli.hs 20
+newtype CoKleisli w k a b = CoKleisli { runCoKleisli :: k (w a) b }
+
+-- * (co)Kleisli Category
hunk ./src/Control/Category/Kleisli.hs 26
-	g . f = Kleisli (bind (runKleisli g) . runKleisli f)
+	Kleisli g . Kleisli f = Kleisli (bind g . f)
+
+instance Comonad w k => Category (CoKleisli w k) where
+	id = CoKleisli extract
+	CoKleisli g . CoKleisli f = CoKleisli (g . extend f)
+
+-- * Category Transformers
hunk ./src/Control/Category/Kleisli.hs 37
---instance (Monad m k, Bifunctor f k) => Bifunctor f (Kleisli m k) where
---	bimap f g = 
+instance Comonad m k => CategoryTransformer (CoKleisli m) k where
+	lift f = CoKleisli (f . extract)
+
+-- * Isomorphisms
+
+instance (Monad m k, Iso k a b) => Iso (Kleisli m k) a b where
+	iso = lift iso
+	uniso = lift uniso
+
+instance (Comonad m k, Iso k a b) => Iso (CoKleisli m k) a b where
+	iso = lift iso
+	uniso = lift uniso
+
+-- * Canonical forms
+
+instance (Monad m k, Canonical k a b) => Canonical (Kleisli m k) a b
+instance (Comonad w k, Canonical k a b) => Canonical (CoKleisli w k) a b
+	
+-- * Arrows
+{-
+instance (Monad m k, Arrow k) => Arrow (Kleisli m k) where
+	arr f = lift (arr f)
+instance (Comonad w k, Arrow k) => Arrow (CoKleisli w k) where
+	arr f = lift (arr f)
+
+-}
+-- * Contravariant Arrows
+
+{-
+instance (Monad m k, DualArrow k) => DualArrow (Kleisli m k) where
+	dualarr f = lift (dualarr f)
+instance (Comonad w k, DualArrow k) => DualArrow (CoKleisli w k) where
+	dualarr f = lift (dualarr f)
+-}
hunk ./src/Control/Category/Monad.hs 3
--- Module	: Control.Category.Functor.Monad
+-- Module	: Control.Category.Monad
hunk ./src/Control/Category/Monad.hs 15
-module Control.Category.Functor.Monad 
+module Control.Category.Monad 
hunk ./src/Control/Category/Monad.hs 19
-	, Comonad (extend, duplicate)
+	, mapMonad
hunk ./src/Control/Category/Monad.hs 24
-import Prelude hiding (Functor, fmap, (.), id, Monad, return, (>>=),(=<<),(>>))
+import Prelude hiding (Functor, map, (.), id, Monad, return, (>>=),(=<<),(>>))
hunk ./src/Control/Category/Monad.hs 36
-> fmap f = bind (return . f)
+> map f = bind (return . f)
hunk ./src/Control/Category/Monad.hs 43
-	bind f = join . fmap f
+	bind f = join . map f
hunk ./src/Control/Category/Monad.hs 52
-fmapMonad :: Monad m k => k a b -> k (m a) (m b)
-fmapMonad f = bind (return . f)
-
-{- | Instances of Comonad should satisfy the following laws:
-
-> extract . extend k = k
-> extend extract = id
-> fmap f = extend (f . extract)
-
--}
-
-class Copointed w k => Comonad w k where
-	extend :: k (w a) b -> k (w a) (w b)
-	duplicate :: k (w a) (w (w a))
-
-	extend f = fmap f . duplicate
-	duplicate = extend id
-
-{-# RULES
-        "extend extract"        extend extract = id
-        "extract . extend k"    forall k. extract . extend k = k
- #-}
-
--- | free definition of 'Functor' for a 'Comonad' @m@ over a 'Category' @k@
-
-fmapComonad :: Comonad w k => k a b -> k (w a) (w b)
-fmapComonad f = extend (f . extract)
+mapMonad :: Monad m k => k a b -> k (m a) (m b)
+mapMonad f = bind (return . f)
addfile ./src/Control/Category/Morphism.hs
hunk ./src/Control/Category/Morphism.hs 1
+-------------------------------------------------------------------------------------------
+-- |
+-- Module	: Control.Category.Morphism
+-- Copyright 	: 2008 Edward Kmett
+-- License	: BSD
+--
+-- Maintainer	: Edward Kmett <ekmett@gmail.com>
+-- Stability	: experimental
+-- Portability	: non-portable (class-associated types)
+--
+-------------------------------------------------------------------------------------------
+
+module Control.Category.Morphism where
+
+import Control.Category
+
+-- | Isomorphism
+class Iso k a b where
+	iso :: k a b
+	uniso :: k b a
+
+class Iso k a b => Canonical k a b | k a -> b where
addfile ./src/Control/Category/Transformer/Reader.hs
hunk ./src/Control/Category/Transformer/Reader.hs 1
+module Control.Category.Transformer.Reader where
+
+import Prelude hiding (Functor,map,id,fst,snd,curry,uncurry,(.))
+import Control.Category.Classes
+
+class Category k => CategoryReader e k | k -> e where
+	ask :: k a e
+
+-- t| his is the CoKleisli construction for the Coreader Comonad 
+-- unfortunately, I can't wrap that comonad in a newtype to use
+-- it in its full generality
+newtype Reader e k a b = Reader { runReader :: k (Prod k e a) b }
+
+instance HasProducts k => Category (Reader e k) where
+	id = Reader snd
+	Reader f . Reader g = Reader $ f . (fst &&& g)
+
+instance HasProducts k => CategoryTransformer (Reader e) k where
+	lift g = Reader (g . snd)
+
+instance HasProducts k => CategoryReader e (Reader e k) where
+	ask = Reader fst
+
+instance (HasProducts k, HasTerminalObject k) => HasTerminalObject (Reader e k) where
+#ifndef __HADDOCK__
+	type Terminal (Reader e k) = Terminal k
+#endif
+	terminate = lift terminate
+
+instance (HasProducts k, HasInitialObject k) => HasInitialObject (Reader e k) where
+#ifndef __HADDOCK__
+	type Initial (Reader e k) = Initial k
+#endif
+	initiate = lift initiate
+
+--instance (Functor f k k, HasProducts k) => Functor f (Reader e k) (Reader e k) where
+--	map (Reader f) = lift . map . runReader
+
+instance (HasProducts k) => Bifunctor (Prod k) (Reader e k) (Reader e k) (Reader e k) where
+	bimap (Reader f) (Reader g) = Reader $ bimap f g . (second fst &&& second snd)
+	--first (Reader f) = Reader $ first f . (second fst &&& second snd) 
+	--second (Reader g) = Reader $ second g . (second fst &&& second snd)
+
+instance (HasProducts k, HasCoproducts k) => Bifunctor (Sum k) (Reader e k) (Reader e k) (Reader e k) where
+	 bimap (Reader f) (Reader g) = Reader undefined -- bimap f g . (second inl ||| second inr)
+	-- ...
+
+instance (HasProducts k, Bifunctor f (Reader e k) (Reader e k) (Reader e k), Associative f k) => Associative f (Reader e k) where
+	associate = lift associate
+
+instance (HasProducts k, Bifunctor f (Reader e k) (Reader e k) (Reader e k), Coassociative f k) => Coassociative f (Reader e k) where
+	coassociate = lift coassociate
+
+instance (Bifunctor f (Reader e k) (Reader e k) (Reader e k), HasIdentity f k) => HasIdentity f (Reader e k) 
+#ifndef __HADDOCK__
+	where type Identity (Reader e k) f = Identity k f
+#endif
+
+instance (Bifunctor f (Reader e k) (Reader e k) (Reader e k), Monoidal f k, HasProducts k) => Monoidal f (Reader e k) where
+	idl = lift idl
+	idr = lift idr
+
+instance (Bifunctor f (Reader e k) (Reader e k) (Reader e k), Comonoidal f k, HasProducts k) => Comonoidal f (Reader e k) where
+	coidl = lift coidl
+	coidr = lift coidr
+
+instance HasProducts k => HasProducts (Reader e k) where
+#ifndef __HADDOCK__
+	type Prod (Reader e k) = Prod k
+#endif
+	fst = lift fst
+	snd = lift snd
+	diag = lift diag
+
+instance (HasProducts k, HasCoproducts k) => HasCoproducts (Reader e k) where
+#ifndef __HADDOCK__
+	type Sum (Reader e k) = Sum k
+#endif
+	inl = lift inl
+	inr = lift inr
+	codiag = lift codiag
+
+instance (Bifunctor p (Reader e k) (Reader e k) (Reader e k), HasProducts k, Braided p k) => Braided p (Reader e k) where
+	braid = lift braid
}
