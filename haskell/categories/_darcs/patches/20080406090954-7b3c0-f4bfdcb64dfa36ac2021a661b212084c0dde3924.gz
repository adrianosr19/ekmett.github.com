[fixed up, it compiles again, added the identity functor
ekmett@gmail.com**20080406090954] {
hunk ./categories.cabal 28
+	TypeOperators,
hunk ./categories.cabal 47
+	Control.Category.Functor.Composition,
hunk ./categories.cabal 49
+	Control.Category.Functor.Identity,
hunk ./src/Control/Category/Bifunctor/Associative.hs 13
--- a 'near-monoidal' category that lacks an identity (since there is no initial object in
--- the category Hask, but it also has a 'coproduct' in the form of 'Either'.
+-- a 'near-monoidal' category that lacks an identity (since there can be no initial object in
+-- the category Hask, but it also has a near-coproduct in the form of 'Either'.
hunk ./src/Control/Category/Bifunctor/Associative.hs 16
--- NB: this contradicts another common meaning for an associative category, which is one 
--- where the pentagonal condition does not hold, but where there IS an identity. 
+-- NB: this contradicts another common meaning for an 'Associative' 'Category', which is one 
+-- where the pentagonal condition does not hold, but for which there is an identity.
hunk ./src/Control/Category/Bifunctor/Associative.hs 19
--- You really can't win.
hunk ./src/Control/Category/Bifunctor/Associative.hs 38
+{-# RULES
+	"copentagonal coherence"
+		first coassociate . coassociate . second coassociate = coassociate . coassociate
+	"pentagonal coherence"
+		second associate . associate . first associate = associate . associate
+ #-}
+
hunk ./src/Control/Category/Bifunctor/Monoidal.hs 37
-> second idl = first idl . associate
+> second idl = first idr . associate
hunk ./src/Control/Category/Bifunctor/Monoidal.hs 45
+{-# RULES
+	"second idl/associate" 	second idl . associate = first idr
+	"first idr/associate" 	first idr . associate = second idl
+ #-}
+
hunk ./src/Control/Category/Bifunctor/Monoidal.hs 53
-> second idl = coassociate . first idl
+> second idl = coassociate . first idr
hunk ./src/Control/Category/Bifunctor/Monoidal.hs 68
+{-# RULES
+	"coassociate/second idl"  coassociate . second idl = first idr
+	"coassociate/first idr"   coassociate . first idr = second idl
+ #-}
+
+{-# RULES
+	"idr/coidr" 		idr . coidr = id
+	"idl/coidl"		idl . coidl = id
+	"coidl/idl"		coidl . idl = id
+	"coidr/idr"		coidr . idr = id
+ #-}
+
hunk ./src/Control/Category/Classes.hs 28
+	, module Control.Category.Functor.Composition
hunk ./src/Control/Category/Classes.hs 30
+	, module Control.Category.Functor.Pointed
hunk ./src/Control/Category/Classes.hs 34
-	, module Control.Category.Functor.Pointed
hunk ./src/Control/Category/Classes.hs 55
+import Control.Category.Functor.Composition
hunk ./src/Control/Category/Dual.hs 27
-instance Bifunctor p k k k => Bifunctor p (Dual k) (Dual k) (Dual k) where
+instance Bifunctor p k1 k2 k3 => Bifunctor p (Dual k1) (Dual k2) (Dual k3) where
hunk ./src/Control/Category/Dual.hs 74
-	unmap = Dual . unmap . runDual
+	premap = Dual . premap . runDual
+
+instance Faithful f k k => Faithful f (Dual k) (Dual k)
hunk ./src/Control/Category/Dual.hs 136
+instance HasFunctorComposition k => HasFunctorComposition (Dual k) where
+	comp = Dual decomp
+	decomp = Dual comp
+
+instance HasBitransform p c d e => HasBitransform p (Dual c) (Dual d) (Dual e) where
+	unbitransform = Dual bitransform
+	bitransform = Dual unbitransform
+
+
addfile ./src/Control/Category/Functor/Composition.hs
hunk ./src/Control/Category/Functor/Composition.hs 1
+-------------------------------------------------------------------------------------------
+-- |
+-- Module	: Control.Category.Functor.Composition
+-- Copyright 	: 2008 Edward Kmett
+-- License	: BSD
+--
+-- Maintainer	: Edward Kmett <ekmett@gmail.com>
+-- Stability	: experimental
+-- Portability	: non-portable (class-associated types)
+--
+-- Generalized functor composition.
+-------------------------------------------------------------------------------------------
+
+module Control.Category.Functor.Composition where
+
+import Prelude hiding (Functor, map, id, (.), Monad, return)
+import qualified Prelude
+import Control.Category
+import Control.Category.Bifunctor
+import Control.Category.Functor
+import Control.Category.Functor.Adjunction
+import Control.Category.Functor.Pointed
+import Control.Category.Functor.Full
+import Control.Category.Monad
+import Control.Category.Comonad
+
+newtype Comp f g a = Comp (f (g a))
+
+-- | Categories don't always give us a way to deal with the newtype labels. 
+-- This hack witnesses the isomorphism.
+class Category e => HasFunctorComposition e 
+    where
+	comp :: e (f (g a)) (Comp f g a)
+	decomp :: e (Comp f g a) (f (g a))
+
+{-# RULES
+  "decomp/comp" decomp . comp = id
+  "comp/decomp" comp . decomp = id
+  #-}
+
+-- | 'Bitransform' transforms a pair of functors using a bifunctor as a functor transformer
+-- and boxes it up for typeclass purposes. 'HasBitransform' witnesses this isomorphism.
+
+newtype Bitransform p f g a = Bitransform (p (f a) (g a))
+
+class Bifunctor p k1 k2 k3 => HasBitransform p k1 k2 k3 | p k1 -> k2 k3, p k2 -> k1 k3, p k3 -> k1 k2 where
+	bitransform   :: k3 (p (f a) (g a)) (Bitransform p f g a)
+	unbitransform :: k3 (Bitransform p f g a) (p (f a) (g a))
+
+{-# RULES
+  "bitransform/unbitransform" bitransform . unbitransform = id
+  "unbitransform/bitransform" unbitransform . bitransform = id
+  #-}
+
hunk ./src/Control/Category/Functor/Full.hs 20
-	A 'Full' Functor @F : C -> D@ provides for every pair of objects @c@, @c'@ in @C@
-	and every morphism @g : F c -> F c'l@ in D, a morphism @g' : c -> c'@ in C.
+	A 'Full' 'Functor' @F : C -> D@ provides for every pair of objects @c@, @c'@ in @C@
+	and every morphism @g : F c -> F c'l@ in @D@, a morphism @g' : c -> c'@ in @C@. In short
+	map has a right-inverse under composition.
+
+> map . premap = id
hunk ./src/Control/Category/Functor/Full.hs 28
-	unmap :: d (f a) (f b) -> c a b
+	premap :: d (f a) (f b) -> c a b
hunk ./src/Control/Category/Functor/Full.hs 31
-	"map/unmap" 	map . unmap = id
-	"unmap/map" 	unmap . map = id
+	"map/premap" 	map . premap = id
+ #-}
+
+class Functor f c d => Faithful f c d | f c -> d, f d -> c
+
+{- | 
+
+For every pair of objects @a@ and @b@ in @C@ a 'Full' 'Faithful' 'Functor' @F : C -> D@ maps every morphism 
+@f : a -> b@ onto a distinct morphism @f : T a -> T b@ (since it is faithful) and every morphism from 
+@g : T a -> T b@ can be obtained from some @f@. (It maps Hom-sets bijectively, or in short map has both
+a left and right inverse under composition.
+
+> unmap . map = id
+-}
+
+unmap :: (Full f c d, Faithful f c d) => d (f a) (f b) -> c a b
+unmap = premap
+
+{-# RULES
+	"unmap/map"	unmap . map = id
hunk ./src/Control/Category/Functor/Instances.hs 11
--- Automatically derives functors from bifunctors
-{-
-@instance 'Bifunctor' f ka kb kc => 'Functor' (f a) kb kc where 'map' = 'second'@
--}
+-- Automatically derives functors from bifunctors, and implements the laws for composition,
+-- functor products and functor coproducts
hunk ./src/Control/Category/Functor/Instances.hs 17
-import Prelude hiding (Functor, map)
+import Prelude hiding (Functor, map,(.), id, fst, snd, Monad, return)
hunk ./src/Control/Category/Functor/Instances.hs 21
+import Control.Category.Cartesian
hunk ./src/Control/Category/Functor/Instances.hs 23
+import Control.Category.Functor.Adjunction
+import Control.Category.Functor.Full
+import Control.Category.Functor.Composition
+import Control.Category.Functor.Pointed
hunk ./src/Control/Category/Functor/Instances.hs 28
+import Control.Category.Monad
+import Control.Category.Comonad
hunk ./src/Control/Category/Functor/Instances.hs 31
-instance Bifunctor f ka kb kc => Functor (f a) kb kc where
+instance Bifunctor f k1 k2 k3 => Functor (f a) k2 k3 where
hunk ./src/Control/Category/Functor/Instances.hs 34
+#ifndef __HADDOCK__
+
+-- * Functor composition laws
+
+instance (HasFunctorComposition e, Functor f d e, Functor g c d) => Functor (Comp f g) c e where
+        map f = comp . map (map f) . decomp
+
+instance (HasFunctorComposition c, Adjunction f g c d) => Pointed (Comp g f) c where
+        return = comp . unit
+
+instance (HasFunctorComposition c, Adjunction f g c d) => Monad (Comp g f) c where
+        bind f = comp . map (rightAdjunct (decomp . f)) . decomp
+
+instance (HasFunctorComposition d, Adjunction f g c d) => Copointed (Comp f g) d where
+        extract = counit . decomp
+
+instance (HasFunctorComposition d, Adjunction f g c d) => Comonad (Comp f g) d where
+        extend f = comp . map (leftAdjunct (f . comp)) . decomp
+
+instance (HasFunctorComposition e, Full f d e, Full g c d) => Full (Comp f g) c e where
+        premap f = premap $ premap $ decomp . f . comp
+
+instance (HasFunctorComposition e, Faithful f d e, Faithful g c d) => Faithful (Comp f g) c e 
+
+-- * Functor bifunctor transformation laws (these are probably obvious in publication somewhere, but I derived them here)
+
+instance (HasBitransform p k1 k2 k3, Functor f k0 k1, Functor g k0 k2) => Functor (Bitransform p f g) k0 k3 where
+	map f = bitransform . bimap (map f) (map f) . unbitransform
+
+instance (HasProducts c, HasBitransform (Prod c) c c c, Pointed f c, Pointed g c) => Pointed (Bitransform (Prod c) f g) c where
+	return = bitransform . (return &&& return)
+
+instance (HasCoproducts c, HasBitransform (Sum c) c c c, Copointed f c, Copointed g c) => Copointed (Bitransform (Sum c) f g) c where
+	extract = (extract ||| extract) . unbitransform
+
+instance (HasBitransform (Prod d) d d d, Faithful f c d, Faithful g c d) => Faithful (Bitransform (Prod d) f g) c d
+
+#endif
hunk ./src/Control/Category/Functor/Pointed.hs 15
--- A simple @newtype@ is basically just a 'Pointed' 'Copointed' 'Functor'.
+-- A simple wrapper @newtype@ is basically just a 'Pointed' 'Copointed' 'Functor'. When 
+-- a functor is both pointed and copointed then:
+-- 	
+-- > extract . return = id
+-- > return . extract = id
hunk ./src/Control/Category/Functor/Pointed.hs 22
--- spaces in topology that is *not* represented by this type. See 'BasedEndoFunctor' in 
+-- spaces in topology that is *not* represented by this type. See 'Based' in 
hunk ./src/Control/Category/Functor/Pointed.hs 28
-import Prelude hiding (Functor,return)
+import Prelude hiding (Functor,return,id,(.))
hunk ./src/Control/Category/Functor/Pointed.hs 37
+{-# RULES
+	"extract/return" extract . return = id
+	"return/extract" return . extract = id
+ #-}
+
hunk ./src/Control/Category/Groupoid.hs 20
+{-# RULES 
+	"inv/inv" inv . inv = id
+ #-}
+
hunk ./src/Control/Category/Hask.hs 110
+-- permit the use of the built-in functor composition in this category
+instance HasFunctorComposition (->) where
+        comp = Comp
+        decomp (Comp x) = x
+
+instance Arrow (->) where
+	arr = id
+
+instance Bifunctor p (->) (->) (->) => HasBitransform p (->) (->) (->) where
+	bitransform = Bitransform
+	unbitransform (Bitransform x) = x
+
hunk ./src/Control/Category/Morphism.hs 21
+
+{-# RULES
+	"iso/uniso" iso . uniso = id
+	"uniso/iso" uniso . iso = id
+ #-}
}
