[initializing repository
ekmett@gmail.com**20080403082348] {
adddir ./src
adddir ./src/Control
adddir ./src/Control/Category
addfile ./ctl.cabal
addfile ./src/Control/Category/Bifunctor.hs
addfile ./src/Control/Category/Functor.hs
addfile ./src/Control/Category/Hask.hs
addfile ./src/Control/Category/Limit.hs
move ./src/Control/Category/Limit.hs ./src/Control/Category/Object.hs
adddir ./src/Control/Category/Functor
adddir ./src/Control/Category/Transformer
hunk ./ctl.cabal 1
+name:			ctl
+category:		Control, Monads
+version:		0.1
+license:		BSD3
+license-file:		LICENSE
+build-depends:		base -any
+author:			Edward A. Kmett
+maintainer:		ekmett@gmail.com
+stability:		experimental
+homepage:		http://comonad.com/
+synopsis:		Category Transformer Library
+copyright:		Copyright (C) 2008 Edward A. Kmett
+description: 		Defines monads, etc over arbitrary categories rather than the category of types and 
+			introduces the notion of category transformer, which generalizes the notion of an Arrow
+			transformer. Using categories we can construct BiArrows correctly.
+extensions:		MultiParamTypeClasses, FunctionalDependencies, UndecidableInstances, TypeFamilies, EmptyDataDecls
+exposed-modules:
+	Control.Category.Bifunctor,
+	Control.Category.Functor,
+	Control.Category.Functor.Adjunction,
+	Control.Category.Monad,
+	Control.Category.Product,
+	Control.Category.Object,
+	Control.Category.Transformer,
+	Control.Category.Transformer.Kleisli,
+	Control.Category.Transformer.Dual,
+	Control.Category.Hask
+ghc-options:		-O2 -funbox-strict-fields
+hs-source-dirs:		src
+
+--	Control.Category.Transformer.CoKleisi,
+--	Control.Category.Comonad,
+--	Control.Category.Coproduct,
+--	Control.Category.Functor.Product,
+--	Control.Category.Functor.Coproduct,
hunk ./src/Control/Category/Bifunctor.hs 1
+{-# OPTIONS -fglasgow-exts -fallow-undecidable-instances #-}
+module Control.Category.Bifunctor where
+
+import Prelude hiding ((.), id, fst, snd)
+import Control.Category
+import Control.Category.Object (HasTerminalObject(..), HasInitialObject(..))
+
+-- a covariant bi-functor f :: k1 * k2 -> k3
+class (Category k1, Category k2, Category k3) => Bifunctor f k1 k2 k3 | f k1 -> k2 k3, f k2 -> k1 k3, f k3 -> k1 k2 where
+	bimap :: k1 a c -> k2 b d -> k3 (f a b) (f c d)
+	first :: k1 a b -> k3 (f a c) (f b c)
+	second :: k2 a b -> k3 (f c a) (f c b)
+	first f = bimap f id
+	second g = bimap id g
+
+-- A category with an associative bifunctor satisfying Mac Lane's pentagonal coherence identity law:
+-- second associate . associate . first associate = associate . associate
+class Bifunctor p k k k => Associative p k where
+	associate :: k (p (p a b) c) (p a (p b c))
+
+-- A category with a coassociative bifunctor satisyfing the dual of Mac Lane's pentagonal coherence identity law:
+-- first coassociate . coassociate . second coassociate = coassociate . coassociate
+class Bifunctor s k k k => Coassociative s k where
+	coassociate :: k (s a (s b c)) (s (s a b) c)
+
+-- We have some reasonable notion of 'Identity' for a particular 'Bifunctor' in this 'Category'
+class Bifunctor p k k k => HasIdentity p k where
+	type Identity k p :: * 
+
+-- | A monoidal category. 'idl' and 'idr' are traditionally denoted lambda and rho
+-- the triangle identity holds:
+-- first idr = second idl . associate 
+-- second idl = first idl . associate
+
+class (Associative p k, HasIdentity p k) => Monoidal p k where
+	idl :: k (p (Identity k p) a) a
+	idr :: k (p a (Identity k p)) a
+
+-- | A comonoidal category. 
+-- first idr = coassociate . second idl
+-- second idl = coassociate . first idl
+
+-- This type class is also (ab)used for the inverse operations needed for a strict (co)monoidal category.
+-- A strict (co)monoidal category is one that implements both Monoidal and Comonoidal and satisfies the following laws:
+-- idr . coidr = id
+-- idl . coidl = id
+-- coidl . idl = id 
+-- coidr . idr = id
+class (Coassociative p k, HasIdentity p k) => Comonoidal p k where
+	coidl :: k a (p (Identity k p) a)
+	coidr :: k a (p a (Identity k p))
+
+
+-- | A braided (co)(monoidal/associative) category can commute the arguments of its bi-endofunctor. Obeys the laws:
+-- idr . braid = idl
+-- idl . braid = idr
+-- braid . coidr = coidl
+-- braid . coidl = coidr
+-- associate . braid . associate = second braid . associate . first braid
+-- coassociate . braid . coassociate = first braid . coassociate . second braid
+class Bifunctor p k k k => Braided p k where
+	braid :: k (p a b) (p b a)
+
+-- | A symmetric (co)monoidal category adds the law:
+-- braid . braid = id
+-- class Braided p k => Symmetric p k
hunk ./src/Control/Category/Functor.hs 1
+{-# OPTIONS -fglasgow-exts -fallow-undecidable-instances #-}
+-------------------------------------------------------------------------------------------
+-- |
+-- Module	: Control.Category.Functor
+-- Copyright 	: 2008 Edward Kmett
+-- License	: BSD
+--
+-- Maintainer	: Edward Kmett <ekmett@gmail.com>
+-- Stability	: experimental
+-- Portability	: non-portable (class-associated types)
+--
+-- Redefines 'Functor' to allow it to represent a functor between different categories
+-------------------------------------------------------------------------------------------
+
+
+module Control.Category.Functor 
+	( module Control.Category
+	, Functor(fmap)
+	) where
+
+import Prelude hiding (Functor, fmap)
+import qualified Prelude
+
+import Control.Category
+
+class (Category c, Category d) => Functor f c d | f c -> d, f d -> c where
+	fmap :: c a b -> d (f a) (f b)
addfile ./src/Control/Category/Functor/Adjunction.hs
hunk ./src/Control/Category/Functor/Adjunction.hs 1
+{-# OPTIONS -fglasgow-exts -fallow-undecidable-instances #-}
+-------------------------------------------------------------------------------------------
+-- |
+-- Module	: Control.Category.Functor.Adjunction
+-- Copyright 	: 2008 Edward Kmett
+-- License	: BSD
+--
+-- Maintainer	: Edward Kmett <ekmett@gmail.com>
+-- Stability	: experimental
+-- Portability	: non-portable (functional-dependencies)
+--
+-------------------------------------------------------------------------------------------
+
+module Control.Category.Functor.Adjunction where
+
+import Prelude hiding (Functor, fmap, (.), id, fst, snd, Monad, return, (>>=))
+import qualified Prelude
+
+import Control.Category
+import Control.Category.Functor
+
+-- | an adjunction between categories c and d formed by functors f and g 
+-- Minimal definition:
+-- 1. @leftAdjunct@ and @rightAdjunct@ 
+-- 2. @unit@ and @counit@
+
+class (Functor c d f, Functor d c g) => Adjunction c d f g | f c -> g d, f d -> g c, g c -> f d, g d -> f c where
+	unit   :: c a (g (f a))
+	counit :: d (f (g a)) a
+	leftAdjunct :: d (f a) b -> c a (g b)
+	rightAdjunct :: c a (g b) -> d (f a) b
+
+	unit = leftAdjunct id
+	counit = rightAdjunct id
+	leftAdjunct f = fmap f . unit
+	rightAdjunct f = counit . fmap f
hunk ./src/Control/Category/Hask.hs 1
+{-# OPTIONS -fglasgow-exts -fallow-undecidable-instances #-}
+-------------------------------------------------------------------------------------------
+-- |
+-- Module	: Control.Category.Hask
+-- Copyright 	: 2008 Edward Kmett
+-- License	: BSD-style (see the LICENSE file in the distribution)
+--
+-- Maintainer	: Edward Kmett <ekmett@gmail.com>
+-- Stability	: experimental
+-- Portability	: non-portable (class-associated types)
+--
+-- The category of Haskell types. Analogous to the 'Arrow' instance for (->)
+-------------------------------------------------------------------------------------------
+
+module Control.Category.Hask where
+
+import Prelude hiding (Functor, fmap, (.), id, fst, snd, Monad, return, (>>=))
+import qualified Prelude
+
+import Control.Category
+import Control.Category.Monad
+import Control.Category.Product
+import Control.Category.Object (HasTerminalObject(..), HasInitialObject(..))
+
+data Bottom
+-- NB: Hask does not actually have a Terminal object when seq is included, since you can distinguish const undefined from undefined!
+instance HasTerminalObject (->) where
+	type T (->) = Bottom
+	terminate = const (error "bottom encountered")
+--instance Category (->) where
+--	id = Prelude.id
+--	f . g = \x -> f (g x)
+
+instance Bifunctor (,) (->) (->) (->) where
+	bimap f g ~(x,y) = (f x, g y)
+instance Associative (,) (->) where
+	associate = associateProduct
+instance Coassociative (,) (->) where
+	coassociate = coassociateProduct
+instance HasIdentity (,) (->) where
+	type Identity (,) (->) = Bottom
+instance Monoidal (,) (->) where
+	idl = Prelude.snd
+	idr = Prelude.fst
+instance Comonoidal (,) (->) where
+	coidl = \x -> (undefined,x)
+	coidr = \x -> (x,undefined)
+instance Braided (,) (->) where
+	braid ~(x,y) = (y,x)
+instance HasProducts (->) where
+	type P (->) = (,)
+	fst = Prelude.fst
+	snd = Prelude.snd
+	diag x = (x,x)
+
+-- we only have a strict associative coproduct, not a comonoidal one!
+instance Bifunctor Either (->) (->) (->) where
+	bimap f g (Left x) = Left (f x)
+	bimap f g (Right x) = Right (g x)
+instance Coassociative Either (->) where
+	coassociate = coassociateCoproduct
+instance Associative Either (->) where
+	associate = associateCoproduct
+instance Braided Either (->) where
+	braid (Left x) = Right x
+	braid (Right x) = Left x
+instance HasCoproducts (->) where
+	type S (->) = Either
+	inl = Left
+	inr = Right
+	(|||) = either
+	codiag = either id id
+
+instance Functor ((,)e) (->) (->) where
+	fmap f ~(x,t) = (x, f t)
+
+instance Functor ((->)e) (->) (->) where
+	fmap f g = f . g 
addfile ./src/Control/Category/Library.hs
hunk ./src/Control/Category/Library.hs 1
+{-# OPTIONS -fglasgow-exts -fallow-undecidable-instances #-}
+-------------------------------------------------------------------------------------------
+-- |
+-- Module	: Control.Category.Library
+-- Copyright 	: 2008 Edward Kmett
+-- License	: BSD
+--
+-- Maintainer	: Edward Kmett <ekmett@gmail.com>
+-- Stability	: experimental
+-- Portability	: non-portable (class-associated types)
+--
+-- A single import for the entire kitchen sink 
+-------------------------------------------------------------------------------------------
+
+
+module Control.Category.Library 
+ 	( module Control.Category
+	, module Control.Category.Bifunctor
+	, module Control.Category.Functor
+	, module Control.Category.Functor.Adjunction
+	, module Control.Category.Hask
+	, module Control.Category.Monad
+	, module Control.Category.Object
+	, module Control.Category.Product
+	, module Control.Category.Transformer
+	, module Control.Category.Transformer.Kleisli
+	, module Control.Category.Transformer.Dual
+	) where
+
+import Prelude hiding (Functor, fmap, (.), id, fst, snd, Monad, return, (>>=))
+import qualified Prelude
+import Control.Category
+import Control.Category.Bifunctor
+import Control.Category.Functor
+import Control.Category.Functor.Adjunction
+import Control.Category.Hask
+import Control.Category.Monad
+import Control.Category.Product
+import Control.Category.Transformer
+import Control.Category.Transformer.Kleisli
+import Control.Category.Transformer.Dual
+import Control.Category.Object
addfile ./src/Control/Category/Monad.hs
hunk ./src/Control/Category/Monad.hs 1
+{-# OPTIONS -fglasgow-exts -fallow-undecidable-instances #-}
+-------------------------------------------------------------------------------------------
+-- |
+-- Module	: Control.Category.Monad
+-- Copyright 	: 2008 Edward Kmett
+-- License	: BSD-style (see the LICENSE file in the distribution)
+--
+-- Maintainer	: Edward Kmett <ekmett@gmail.com>
+-- Stability	: experimental
+-- Portability	: non-portable (class-associated types)
+--
+-- Defines 'Monad' and 'Comonad' in a way that allows it to represent a (co)monad over 
+-- other categories than just the category of types.
+-------------------------------------------------------------------------------------------
+
+
+module Control.Category.Monad 
+	( module Control.Category.Functor 
+	-- * Categorical monads and comonads
+	, Monad (bind, return, join)
+	, Comonad (extend, extract, duplicate)
+	-- * Traditional monad sugar
+	, (=<<), (>>=), (<<), (>>)
+	) where
+
+import Prelude hiding (Functor, fmap, (.), id, Monad, return, (>>=),(=<<),(>>))
+import Control.Category
+import Control.Category.Functor
+
+infixr 1 =<<
+infixl 1 >>=
+
+class Functor m k k => Monad m k where
+	return :: k a (m a)
+	bind :: k a (m b) -> k (m a) (m b)
+	join :: k (m (m a)) (m a)
+
+	bind f = join . fmap f
+	join = bind id
+
+(>>=) :: Monad m (->) => m a -> (a -> m b) -> m b
+m >>= k = bind k m 
+(>>) :: Monad m (->) => m a -> m b -> m b
+m >> n = bind (const n) m
+(<<) :: Monad m (->) => m b -> m a -> m b
+n << m = m >> n
+(=<<) :: Monad m (->) => (a -> m b) -> m a -> m b
+k =<< m = m >>= k
+
+class Functor w k k => Comonad w k where
+	extract :: k (w a) a
+	extend :: k (w a) b -> k (w a) (w b)
+	duplicate :: k (w a) (w (w a))
+
+	extend f = fmap f . duplicate
+	duplicate = extend id
hunk ./src/Control/Category/Object.hs 1
+{-# OPTIONS -fglasgow-exts #-}
+-------------------------------------------------------------------------------------------
+-- |
+-- Module	: Control.Category.Object
+-- Copyright 	: 2008 Edward Kmett
+-- License	: BSD
+--
+-- Maintainer	: Edward Kmett <ekmett@gmail.com>
+-- Stability	: experimental
+-- Portability	: non-portable (class-associated types)
+--
+-- This module declares the 'HasTerminalObject' and 'HasInitialObject' classes.
+-- These are defined in terms of class-associated types rather than functional dependencies
+-- because most of the time when you are manipulating a category you don't care about them;
+-- this gets them out of the signature of most functions that use the category.
+-- Both of these are special cases of the idea of a (co)limit.
+-------------------------------------------------------------------------------------------
+
+module Control.Category.Object 
+	( module Control.Category
+	, HasTerminalObject(..)
+	, HasInitialObject(..)
+	) where
+
+import Control.Category
+
+-- | The @Category k@ has a terminal object @Terminal k@ such that for all objects @a@ in @k@, 
+-- there exists a unique morphism from @a@ to @Terminal k@.
+class Category k => HasTerminalObject k where
+	type Terminal k :: *
+	terminate :: k a (Terminal k)
+
+-- | The @Category k@ has an initial (coterminal) object @Initial k@ such that for all objects 
+-- @a@ in @k@, there exists a unique morphism from @Initial k @ to @a@.
+class Category k => HasInitialObject k where
+	type Initial k :: *
+	initiate :: k (Initial k) a
addfile ./src/Control/Category/Product.hs
hunk ./src/Control/Category/Product.hs 1
+{-# OPTIONS -fglasgow-exts -fallow-undecidable-instances #-}
+-------------------------------------------------------------------------------------------
+-- |
+-- Module	: Control.Category.Product
+-- Copyright 	: 2008 Edward Kmett
+-- License	: BSD-style (see the LICENSE file in the distribution)
+--
+-- Maintainer	: Edward Kmett <ekmett@gmail.com>
+-- Stability	: experimental
+-- Portability	: non-portable (class-associated types)
+--
+-- Defines machinery for working with categories that have all finite products and/or
+-- all finite coproducts in categories other than the category of types. This is richer 
+-- than arrow sugar, because we cannot assume the form of the product/coproduct functor
+-- if we want to be able to support more interesting categories.
+-------------------------------------------------------------------------------------------
+
+module Control.Category.Product 
+	( module Control.Category
+	, module Control.Category.Bifunctor
+	, HasProducts(..)
+	, bimapProduct, braidProduct, associateProduct, coassociateProduct,
+	, (***)
+	, HasCoproducts(..)
+	, bimapCoproduct, braidCoproduct, associateCoproduct, coassociateCoproduct
+	, (+++), left, right
+	) where
+
+import Prelude hiding (Functor, fmap, (.), id, fst, snd)
+import qualified Prelude
+
+import Control.Category
+import Control.Category.Bifunctor
+
+-- * Products
+
+-- NB: This is weaker than traditional category with products! That would have to look like
+-- @class (Monoidal k (P k), Braided k (P k)) => HasProducts k where ...@
+-- the problem is @(->)@ lacks an initial object, since every type is inhabited in Haskell.
+-- Consequently its coproduct 'monoid' has no identity and we want to be able to
+-- describe its dual category, which has this non-traditional form being built
+-- over a category with an associative bifunctor rather than as a monoidal category
+-- for the product monoid.
+
+-- Minimum definition: 
+-- 1. fst, snd, diag 
+-- 2. fst, snd, (&&&) -- allows use of bimapProduct to define bimap
+class (Associative k (P k), Coassociative k (P k), Braided k (P k)) => HasProducts k where
+	type P k :: * -> * -> *
+	fst :: k (P k a b) a
+	snd :: k (P k a b) b
+	diag :: k a (P k a a)
+	(&&&) :: k a b -> k a c -> k a (P k b c)
+
+	diag = id &&& id
+	f &&& g = diag >>> bimap f g 
+
+
+-- | for ease of type checking
+(***) :: HasProducts k => k a c -> k b d -> k (P k a b) (P k c d)
+(***) = bimap
+
+-- | free construction of 'Bifunctor' for the product functor @P k@ if @(&&&)@ is known
+bimapProduct :: HasProducts k => k a c -> k b d -> k (P k a b) (P k c d)
+bimapProduct f g = (f . fst) &&& (g . snd)
+	
+-- | free construction of 'Braided' for the product bifunctor @P k@
+braidProduct :: HasProducts k => k (P k a b) (P k b a)
+braidProduct = snd &&& fst
+
+-- | free construction of 'Associative' for the product bifunctor @P k@
+associateProduct :: HasProducts k => k (P k (P k a b) c) (P k a (P k b c))
+associateProduct = (fst . fst) &&& first snd
+
+-- | free construction of 'Coassociative' for the product bifunctor @P k@
+coassociateProduct :: HasProducts k => k (P k a (P k b c)) (P k (P k a b) c)
+coassociateProduct = braid . second braid . associateProduct . first braid . braid 
+
+-- * Coproducts
+
+-- a category that has finite coproducts, weakened the same way as HasProducts above was weakened
+class (Associative k (S k), Coassociative k (S k), Braided k (S k)) => HasCoproducts k where
+	type S k :: * -> * -> *
+	inl :: k a (S k a b)
+	inr :: k b (S k a b)
+	codiag :: k (S k a a) a
+	(|||) :: k a c -> k b c -> k (S k a b) c
+
+	codiag = id ||| id
+	f ||| g = bimap f g >>> codiag 
+
+-- | for ease of type checking
+(+++) :: HasCoproducts k => k a c -> k b d -> k (S k a b) (S k c d)
+(+++) = bimap
+
+-- | for legacy/conceptual purposes and ease of type checking
+left :: HasCoproducts k => k a b -> k (S k a c) (S k b c)
+left = first
+
+-- | for legacy/conceptual purposes and ease of type checking
+right :: HasCoproducts k => k a b -> k (S k c a) (S k c b)
+right = second
+
+-- | free construction of 'Bifunctor' for the coproduct bifunctor @S k@ if @(|||)@ is known
+bimapCoproduct :: HasCoproducts k => k a c -> k b d -> k (S k a b) (S k c d)
+bimapCoproduct f g = (inl . f) ||| (inr . g)
+
+-- | free construction of 'Braided' for the coproduct bifunctor @S k@
+braidCoproduct :: HasCoproducts k => k (S k a b) (S k b a)
+braidCoproduct = inr ||| inl
+
+-- | free construction of 'Associative' for the coproduct bifunctor @S k@
+associateCoproduct :: HasCoproducts k => k (S k (S k a b) c) (S k a (S k b c))
+associateCoproduct = braid . first braid . coassociateCoproduct . second braid . braid
+
+-- | free construction of 'Coassociative' for the coproduct bifunctor @S k@
+coassociateCoproduct :: HasCoproducts k => k (S k a (S k b c)) (S k (S k a b) c)
+coassociateCoproduct = (inl . inl) ||| left inr
addfile ./src/Control/Category/Transformer.hs
hunk ./src/Control/Category/Transformer.hs 1
+-------------------------------------------------------------------------------------------
+-- |
+-- Module	: Control.Category.Transformer
+-- Copyright 	: 2008 Edward Kmett
+-- License	: BSD
+--
+-- Maintainer	: Edward Kmett <ekmett@gmail.com>
+-- Stability	: experimental
+-- Portability	: non-portable (class-associated types)
+--
+-------------------------------------------------------------------------------------------
+
+module Control.Category.Transformer 
+	( module Control.Category
+	, CategoryTransformer(lift)
+	) where
+
+import Control.Category
+
+class (Category k, Category (f k)) => CategoryTransformer f k where 
+	lift :: k b c -> f k b c
addfile ./src/Control/Category/Transformer/Dual.hs
hunk ./src/Control/Category/Transformer/Dual.hs 1
+{-# OPTIONS -fglasgow-exts -fallow-undecidable-instances #-}
+-------------------------------------------------------------------------------------------
+-- |
+-- Module	: Control.Category.Transformer.Dual
+-- Copyright 	: 2008 Edward Kmett
+-- License	: BSD-style (see the LICENSE file in the distribution)
+--
+-- Maintainer	: Edward Kmett <ekmett@gmail.com>
+-- Stability	: experimental
+-- Portability	: non-portable (class-associated types)
+--
+-- The dual of a category is another category
+-------------------------------------------------------------------------------------------
+
+module Control.Category.Transformer.Dual (Dual(..)) where
+
+import Prelude hiding (Functor, fmap, (.), id, fst, snd, Monad, return, (>>=))
+import qualified Prelude
+
+import Control.Category
+import Control.Category.Bifunctor
+import Control.Category.Functor
+import Control.Category.Monad
+import Control.Category.Object
+import Control.Category.Transformer
+
+newtype Dual k a b = Dual { runDual :: k b a }
+
+instance Category k => Category (Dual k) where
+	id = Dual id
+	f . g = Dual (runDual g . runDual f)
+
+instance Bifunctor p k k k => Bifunctor p (Dual k) (Dual k) (Dual k) where
+	bimap f g = Dual $ bimap (runDual f) (runDual g)
+
+instance Associative p k => Coassociative p (Dual k) where
+	coassociate = Dual associate
+
+instance Coassociative p k => Associative p (Dual k) where
+	associate = Dual coassociate
+
+instance Braided p k => Braided p (Dual k) where
+	braid = Dual braid
+
+instance HasProducts k => HasCoproducts (Dual k) where
+	type S (Dual k) = P k
+	inl = Dual fst
+	inr = Dual snd
+	f ||| g = Dual (runDual f &&& runDual g)
+	codiag = Dual diag
+
+instance HasCoproducts k => HasProducts (Dual k) where
+	type P (Dual k) = S k
+	fst = Dual inl
+	snd = Dual inr
+	f &&& g = Dual (runDual f ||| runDual g)
+	diag = Dual codiag
+
+instance Monoidal p k => Comonoidal p (Dual k) where
+	coidl = Dual idl
+	coidr = Dual idr
+	
+instance Comonoidal p k => Monoidal p (Dual k) where
+	idl = Dual coidl
+	idr = Dual coidr
+
+instance HasIdentity p k => HasIdentity p (Dual k) where
+	type Identity (Dual k) p = Identity k p 
+
+instance Functor f k k => Functor f (Dual k) (Dual k) where
+	fmap = Dual . fmap . runDual
+
+instance Monad m k => Comonad m (Dual k) where
+	extract = Dual return
+	extend = Dual . bind . runDual
+	duplicate = Dual join
+
+instance Comonad w k => Monad w (Dual k) where
+	return = Dual extract
+	bind = Dual . extend . runDual
+	join = Dual duplicate
addfile ./src/Control/Category/Transformer/Kleisli.hs
hunk ./src/Control/Category/Transformer/Kleisli.hs 1
+{-# OPTIONS -fglasgow-exts #-}
+-------------------------------------------------------------------------------------------
+-- |
+-- Module	: Control.Category.Transformer.Kleisli
+-- Copyright 	: 2008 Edward Kmett
+-- License	: BSD
+--
+-- Maintainer	: Edward Kmett <ekmett@gmail.com>
+-- Stability	: experimental
+-- Portability	: non-portable (class-associated types)
+--
+-------------------------------------------------------------------------------------------
+
+module Control.Category.Transformer.Kleisli (Kleisli(..)) where
+
+import Prelude hiding (Functor, fmap, (.), id, fst, snd, Monad, return, (>>=))
+import qualified Prelude
+import Control.Category
+import Control.Category.Functor 
+import Control.Category.Monad
+import Control.Category.Transformer
+
+newtype Kleisli m k a b = Kleisli { runKleisli :: k a (m b) }
+
+instance (Monad m k) => Category (Kleisli m k) where
+	id = Kleisli id
+	g . f = Kleisli (bind (runKleisli g) . runKleisli f)
+
+instance (Monad m k) => CategoryTransformer k (Kleisli m) where
+	lift f = Kleisli (return . f)
+
}
