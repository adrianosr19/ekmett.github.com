[added comma categories and cartesian closed categories
ekmett@gmail.com**20080405061520] {
move ./ctl.cabal ./categories.cabal
adddir ./src/Control/Category/Bifunctor
addfile ./src/Control/Category/Braided.hs
move ./src/Control/Category/Braided.hs ./src/Control/Category/Bifunctor/Braided.hs
move ./src/Control/Category/Monad.hs ./src/Control/Category/Functor/Monad.hs
move ./src/Control/Category/Transformer/Dual.hs ./src/Control/Category/Dual.hs
hunk ./Makefile 1
-URL=http://comonad.com/haskell/ctl-0.1
+URL=http://comonad.com/haskell/categories
hunk ./Makefile 4
-BASE=/home/slipwave/info/haskell/ctl-0.1
+BASE=/home/slipwave/info/haskell/categories
hunk ./Makefile 30
-docs: 
-	find . -name "*.hs" | egrep -v '_darcs' | xargs haddock -html -odocs --source=$(URL) --title=$(TITLE)
-
hunk ./categories.cabal 1
-name:			ctl
+name:			categories
hunk ./categories.cabal 11
-synopsis:		Category Transformer Library
+synopsis:		Category Library
hunk ./categories.cabal 18
-extensions:		MultiParamTypeClasses, FunctionalDependencies, UndecidableInstances, TypeFamilies, EmptyDataDecls, CPP
+
+extensions:		
+	CPP, 
+	EmptyDataDecls, 
+	FlexibleContexts,
+	FlexibleInstances,
+	FunctionalDependencies, 
+	MultiParamTypeClasses, 
+	TypeFamilies, 
+	UndecidableInstances,
+	GADTs
+
+
hunk ./categories.cabal 32
-	Control.Category.Bifunctor,
-	Control.Category.Functor,
-	Control.Category.Functor.Adjunction,
-	Control.Category.Monad,
-	Control.Category.Product,
-	Control.Category.Object,
+	Control.Category.Classes,
+	Control.Category.Based,	
+	Control.Category.Bifunctor,	
+	Control.Category.Bifunctor.Braided,
+	Control.Category.Bifunctor.Monoidal,
+	Control.Category.Bifunctor.Pentagonal,	
+	Control.Category.Cartesian,	
+	Control.Category.Functor,		
+	Control.Category.Functor.Algebra,
+	Control.Category.Functor.Adjunction,	
+	Control.Category.Functor.Monad,	
+	Control.Category.Functor.Pointed,
+	Control.Category.Loop,		
+	Control.Category.Object,	
hunk ./categories.cabal 47
-	Control.Category.Transformer.Kleisli,
-	Control.Category.Transformer.Dual,
-	Control.Category.Hask
+
+	Control.Category.Functor.Instances,	
+	Control.Category.Dual,	
+	Control.Category.Comma,
+	Control.Category.Hask,	
+	Control.Category.Kleisli
+
hunk ./categories.cabal 57
---	Control.Category.Transformer.CoKleisi,
---	Control.Category.Comonad,
---	Control.Category.Coproduct,
---	Control.Category.Functor.Product,
---	Control.Category.Functor.Coproduct,
-
hunk ./src/Control/Category/Bifunctor.hs 1
--- {-# OPTIONS -fglasgow-exts -fallow-undecidable-instances #-}
hunk ./src/Control/Category/Bifunctor.hs 3
--- Module	: Control.Category.Library
+-- Module	: Control.Category.Bifunctor
hunk ./src/Control/Category/Bifunctor.hs 5
--- License	: BSD
+-- License	: BSD3
hunk ./src/Control/Category/Bifunctor.hs 9
--- Portability	: non-portable (class-associated types)
+-- Portability	: non-portable (functional-dependencies)
hunk ./src/Control/Category/Bifunctor.hs 16
-import Control.Category.Object (HasTerminalObject(..), HasInitialObject(..))
hunk ./src/Control/Category/Bifunctor.hs 17
--- | A covariant bifunctor f :: k1 * k2 -> k3
+-- | A covariant bifunctor @f :: k1 * k2 -> k3@
hunk ./src/Control/Category/Bifunctor.hs 19
+	-- | Analogous to '***' or '+++' in "Control.Arrow', but generalized to any covariant bifunctor
hunk ./src/Control/Category/Bifunctor.hs 21
+	-- | Analogous to 'first' or 'left' in "Control.Arrow", but generalized to any covariant bifunctor
hunk ./src/Control/Category/Bifunctor.hs 23
+	-- | Analogous to 'second' or 'right' in "Control.Arrow", but generalized to any covariant bifunctor
hunk ./src/Control/Category/Bifunctor.hs 25
+
hunk ./src/Control/Category/Bifunctor.hs 29
--- | A category with an associative bifunctor satisfying Mac Lane's pentagonal coherence identity law:
--- second associate . associate . first associate = associate . associate
-class Bifunctor p k k k => Associative p k where
-	associate :: k (p (p a b) c) (p a (p b c))
-
--- | A category with a coassociative bifunctor satisyfing the dual of Mac Lane's pentagonal coherence identity law:
--- first coassociate . coassociate . second coassociate = coassociate . coassociate
-class Bifunctor s k k k => Coassociative s k where
-	coassociate :: k (s a (s b c)) (s (s a b) c)
-
--- | We have some reasonable notion of 'Identity' for a particular 'Bifunctor' in this 'Category'
-#ifndef HADDOCK
-class Bifunctor p k k k => HasIdentity p k where 
- 	type Identity k p :: * 
-#endif
-
--- | A monoidal category. 'idl' and 'idr' are traditionally denoted lambda and rho
--- the triangle identity holds:
--- first idr = second idl . associate 
--- second idl = first idl . associate
-
-class (Associative p k, HasIdentity p k) => Monoidal p k where
-	idl :: k (p (Identity k p) a) a
-	idr :: k (p a (Identity k p)) a
-
--- | A comonoidal category. 
--- first idr = coassociate . second idl
--- second idl = coassociate . first idl
-
--- This type class is also (ab)used for the inverse operations needed for a strict (co)monoidal category.
--- A strict (co)monoidal category is one that implements both Monoidal and Comonoidal and satisfies the following laws:
--- idr . coidr = id
--- idl . coidl = id
--- coidl . idl = id 
--- coidr . idr = id
-class (Coassociative p k, HasIdentity p k) => Comonoidal p k where
-	coidl :: k a (p (Identity k p) a)
-	coidr :: k a (p a (Identity k p))
-
-
--- | A braided (co)(monoidal/associative) category can commute the arguments of its bi-endofunctor. Obeys the laws:
--- idr . braid = idl
--- idl . braid = idr
--- braid . coidr = coidl
--- braid . coidl = coidr
--- associate . braid . associate = second braid . associate . first braid
--- coassociate . braid . coassociate = first braid . coassociate . second braid
-class Bifunctor p k k k => Braided p k where
-	braid :: k (p a b) (p b a)
-
--- | A symmetric (co)monoidal category adds the law:
--- braid . braid = id
--- class Braided p k => Symmetric p k
-
hunk ./src/Control/Category/Bifunctor/Braided.hs 1
+-------------------------------------------------------------------------------------------
+-- |
+-- Module	: Control.Category.Bifunctor.Braided
+-- Copyright 	: 2008 Edward Kmett
+-- License	: BSD
+--
+-- Maintainer	: Edward Kmett <ekmett@gmail.com>
+-- Stability	: experimental
+-- Portability	: non-portable (mptcs)
+--
+-------------------------------------------------------------------------------------------
+module Control.Category.Bifunctor.Braided where
+
+import Control.Category.Bifunctor
+
+{- | A braided (co)(monoidal or associative) category can commute the arguments of its bi-endofunctor. Obeys the laws:
+
+> idr . braid = idl 
+> idl . braid = idr 
+> braid . coidr = coidl 
+> braid . coidl = coidr 
+> associate . braid . associate = second braid . associate . first braid 
+> coassociate . braid . coassociate = first braid . coassociate . second braid 
+
+If it is a symmetric (co)monoidal category, you get the additional law (currently not represented by a typeclass)
+
+> braid . braid = id
+-}
+
+class Bifunctor p k k k => Braided p k where
+	braid :: k (p a b) (p b a)
+
+-- class Braided p k => Symmetric p k
addfile ./src/Control/Category/Classes.hs
hunk ./src/Control/Category/Classes.hs 1
+{-# OPTIONS -fglasgow-exts -fallow-undecidable-instances #-}
+-------------------------------------------------------------------------------------------
+-- |
+-- Module	: Control.Category.Classes
+-- Copyright 	: 2008 Edward Kmett
+-- License	: BSD
+--
+-- Maintainer	: Edward Kmett <ekmett@gmail.com>
+-- Stability	: experimental
+-- Portability	: non-portable (class-associated types)
+--
+-- A single import for the entire kitchen sink 
+-------------------------------------------------------------------------------------------
+
+
+module Control.Category.Classes
+ 	( module Control.Category
+	, module Control.Category.Based
+	, module Control.Category.Bifunctor
+	, module Control.Category.Bifunctor.Pentagonal
+	, module Control.Category.Bifunctor.Monoidal
+	, module Control.Category.Bifunctor.Braided
+	, module Control.Category.Cartesian
+	, module Control.Category.Functor
+	, module Control.Category.Functor.Adjunction
+	, module Control.Category.Functor.Pointed
+	, module Control.Category.Functor.Monad
+	, module Control.Category.Loop
+	, module Control.Category.Object
+	, module Control.Category.Transformer
+	) where
+
+import Prelude hiding (Functor, fmap, (.), id, fst, snd, Monad, return, (>>=))
+import qualified Prelude
+import Control.Category
+import Control.Category.Based
+import Control.Category.Bifunctor
+import Control.Category.Bifunctor.Pentagonal
+import Control.Category.Bifunctor.Monoidal
+import Control.Category.Bifunctor.Braided
+import Control.Category.Cartesian
+import Control.Category.Functor
+import Control.Category.Functor.Adjunction
+import Control.Category.Functor.Pointed
+import Control.Category.Functor.Monad
+import Control.Category.Loop
+import Control.Category.Object
+import Control.Category.Transformer
hunk ./src/Control/Category/Dual.hs 1
-{-# OPTIONS -fglasgow-exts -fallow-undecidable-instances #-}
hunk ./src/Control/Category/Dual.hs 3
--- Module	: Control.Category.Transformer.Dual
+-- Module	: Control.Category.Dual
hunk ./src/Control/Category/Dual.hs 14
-module Control.Category.Transformer.Dual (Dual(..)) where
+module Control.Category.Dual where
hunk ./src/Control/Category/Dual.hs 16
-import Prelude hiding (Functor, fmap, (.), id, fst, snd, Monad, return, (>>=))
+import Prelude hiding (Functor, fmap, (.), id, fst, snd, Monad, return, (>>=), curry, uncurry)
hunk ./src/Control/Category/Dual.hs 19
-import Control.Category
-import Control.Category.Bifunctor
-import Control.Category.Functor
-import Control.Category.Monad
-import Control.Category.Object
-import Control.Category.Product
-import Control.Category.Transformer
+import Control.Category.Classes
hunk ./src/Control/Category/Dual.hs 30
-instance Associative p k => Coassociative p (Dual k) where
+instance Pentagonal p k => Copentagonal p (Dual k) where
hunk ./src/Control/Category/Dual.hs 33
-instance Coassociative p k => Associative p (Dual k) where
+instance Copentagonal p k => Pentagonal p (Dual k) where
hunk ./src/Control/Category/Dual.hs 40
-	type S (Dual k) = P k
+#ifndef __HADDOCK__
+	type Sum (Dual k) = Prod k
+#endif
hunk ./src/Control/Category/Dual.hs 49
-	type P (Dual k) = S k
+#ifndef __HADDOCK__
+	type Prod (Dual k) = Sum k
+#endif
hunk ./src/Control/Category/Dual.hs 65
-instance HasIdentity p k => HasIdentity p (Dual k) where
-	type Identity (Dual k) p = Identity k p 
+instance HasIdentity p k => HasIdentity p (Dual k) 
+#ifndef __HADDOCK__
+	where type Identity (Dual k) p = Identity k p 
+#endif
hunk ./src/Control/Category/Dual.hs 73
-instance Monad m k => Comonad m (Dual k) where
+instance Pointed f k => Copointed f (Dual k) where
hunk ./src/Control/Category/Dual.hs 75
+
+instance Copointed f k => Pointed f (Dual k) where
+	return = Dual extract
+
+instance Monad m k => Comonad m (Dual k) where
hunk ./src/Control/Category/Dual.hs 84
-	return = Dual extract
hunk ./src/Control/Category/Dual.hs 87
+instance Adjunction f g k k => Adjunction g f (Dual k) (Dual k) where
+	unit = Dual counit
+	counit = Dual unit
+	leftAdjunct = Dual . rightAdjunct . runDual
+	rightAdjunct = Dual . leftAdjunct . runDual
+
+instance CCC k => CoCCC (Dual k) where
+	type Coexp (Dual k) = Exp k
+	coapply = Dual apply
+	cocurry = Dual . curry . runDual
+	uncocurry = Dual . uncurry . runDual
+
+instance CoCCC k => CCC (Dual k) where
+	type Exp (Dual k) = Coexp k
+	apply = Dual coapply
+	curry = Dual . cocurry . runDual
+	uncurry = Dual . uncocurry . runDual
+
+--instance (Loop k, HasCoproducts k) => Loop (Dual k) where
+--	loop f = Dual (runDual f)
+
hunk ./src/Control/Category/Functor.hs 1
-{-# OPTIONS -fglasgow-exts -fallow-undecidable-instances #-}
hunk ./src/Control/Category/Functor.hs 21
+{- | Must satisfy the functor laws:
+
+> fmap id = id
+> fmap (f . g) = fmap f . fmap g
+-}
hunk ./src/Control/Category/Functor.hs 29
+{-# RULES
+  "fmap identity" 	fmap id = id
+  "fmap deforestation"  forall f g.  fmap f . fmap g = fmap (f . g)
+ #-}
+
hunk ./src/Control/Category/Functor/Adjunction.hs 22
--- | an adjunction between categories c and d formed by functors f and g 
+-- | An 'Adjunction' between 'Category' c and 'Category' d formed by the 'Functor' f and 'Functor' g. 
+
hunk ./src/Control/Category/Functor/Adjunction.hs 25
+
hunk ./src/Control/Category/Functor/Adjunction.hs 27
+
hunk ./src/Control/Category/Functor/Monad.hs 1
-{-# OPTIONS -fglasgow-exts -fallow-undecidable-instances #-}
hunk ./src/Control/Category/Functor/Monad.hs 3
--- Module	: Control.Category.Monad
+-- Module	: Control.Category.Functor.Monad
hunk ./src/Control/Category/Functor/Monad.hs 15
-
-module Control.Category.Monad 
-	( Functor (fmap)
+module Control.Category.Functor.Monad 
+	( 
hunk ./src/Control/Category/Functor/Monad.hs 18
-	, Monad (bind, return, join)
-	, Comonad (extend, extract, duplicate)
+	  Monad (bind, join)
+	, Comonad (extend, duplicate)
hunk ./src/Control/Category/Functor/Monad.hs 27
+import Control.Category.Functor.Pointed
+
+infixr 1 =<<, <<
+infixl 1 >>=, >>
+
+{- | Instances of Monad should satisfy the following laws:
hunk ./src/Control/Category/Functor/Monad.hs 34
-infixr 1 =<<
-infixl 1 >>=
+> bind k . return = k
+> bind return = id
+> fmap f = bind (return . f)
+-}
hunk ./src/Control/Category/Functor/Monad.hs 39
-class Functor m k k => Monad m k where
-	return :: k a (m a)
+class Pointed m k => Monad m k where
hunk ./src/Control/Category/Functor/Monad.hs 46
+{-# RULES
+	"bind return" 		bind return = id
+	"bind k/return" 	forall k. bind k . return = k
+-}
+
+-- | free definition of 'Functor' for a 'Monad' @m@ over a 'Category' @k@
+fmapMonad :: Monad m k => k a b -> k (m a) (m b)
+fmapMonad f = bind (return . f)
+
+{- | Instances of Comonad should satisfy the following laws:
+
+> extract . extend k = k
+> extend extract = id
+> fmap f = extend (f . extract)
+
+-}
+
+class Copointed w k => Comonad w k where
+	extend :: k (w a) b -> k (w a) (w b)
+	duplicate :: k (w a) (w (w a))
+
+	extend f = fmap f . duplicate
+	duplicate = extend id
+
+{-# RULES
+        "extend extract"        extend extract = id
+        "extract . extend k"    forall k. extract . extend k = k
+ #-}
+
+-- | free definition of 'Functor' for a 'Comonad' @m@ over a 'Category' @k@
+
+fmapComonad :: Comonad w k => k a b -> k (w a) (w b)
+fmapComonad f = extend (f . extract)
+
hunk ./src/Control/Category/Functor/Monad.hs 89
-class Functor w k k => Comonad w k where
-	extract :: k (w a) a
-	extend :: k (w a) b -> k (w a) (w b)
-	duplicate :: k (w a) (w (w a))
-
-	extend f = fmap f . duplicate
-	duplicate = extend id
-
addfile ./src/Control/Category/Functor/Pointed.hs
hunk ./src/Control/Category/Functor/Pointed.hs 1
+-------------------------------------------------------------------------------------------
+-- |
+-- Module	: Control.Category.Functor.Pointed
+-- Copyright 	: 2008 Edward Kmett
+-- License	: BSD-style (see the LICENSE file in the distribution)
+--
+-- Maintainer	: Edward Kmett <ekmett@gmail.com>
+-- Stability	: experimental
+-- Portability	: non-portable (class-associated types)
+--
+-- Defines the notion of a 'Pointed' (and 'Copointed') functor in the sense of 
+-- Lenisa, Power and Watanabe''s Distributivity for Endofunctors, Pointed and Co-Pointed 
+-- Endofunctors, Monads and Comonads <http://citeseer.ist.psu.edu/301388.html>
+--
+-- A simple @newtype@ is basically just a 'Pointed' 'Copointed' 'Functor'.
+--
+-- NB: There is another notion of a pointed functor that can be derived from pointed 
+-- spaces in topology that is *not* represented by this type. See 'BasedEndoFunctor' in 
+-- "Control.Category.Based" for that definition.
+-------------------------------------------------------------------------------------------
+
+module Control.Category.Functor.Pointed where
+
+import Prelude hiding (Functor,return)
+import Control.Category.Functor
+
+class Functor f k k => Pointed f k where
+	return :: k a (f a)
+
+class Functor f k k => Copointed f k where
+	extract :: k (f a) a
hunk ./src/Control/Category/Hask.hs 12
--- The category of Haskell types. Analogous to the 'Arrow' instance for (->)
+-- The category of Haskell types. Analogous to the 'Arrow' instance for @(->)@
+-- The shortened name is a stylized convention from folklore.
hunk ./src/Control/Category/Hask.hs 21
-import Control.Category
-import Control.Category.Bifunctor
-import Control.Category.Functor
-import Control.Category.Monad
-import Control.Category.Product
-import Control.Category.Object (HasTerminalObject(..), HasInitialObject(..))
+import Control.Category.Classes
+import Control.Category.Dual
hunk ./src/Control/Category/Hask.hs 27
-#ifndef HADDOCK
+#ifndef __HADDOCK__
hunk ./src/Control/Category/Hask.hs 37
-instance Associative (,) (->) where
+instance Pentagonal (,) (->) where
hunk ./src/Control/Category/Hask.hs 39
-instance Coassociative (,) (->) where
+instance Copentagonal (,) (->) where
hunk ./src/Control/Category/Hask.hs 41
-instance HasIdentity (,) (->) where
-	type Identity (->) (,) = Bottom
+instance HasIdentity (,) (->) 
+#ifndef __HADDOCK__
+	where type Identity (->) (,) = Bottom
+#endif
hunk ./src/Control/Category/Hask.hs 54
-	type P (->) = (,)
+#ifndef __HADDOCK__
+	type Prod (->) = (,)
+#endif
hunk ./src/Control/Category/Hask.hs 65
-instance Coassociative Either (->) where
+instance Copentagonal Either (->) where
hunk ./src/Control/Category/Hask.hs 67
-instance Associative Either (->) where
+instance Pentagonal Either (->) where
hunk ./src/Control/Category/Hask.hs 73
-#ifndef HADDOCK
-	type S (->) = Either
+#ifndef __HADDOCK__
+	type Sum (->) = Either
hunk ./src/Control/Category/Hask.hs 87
+instance Loop (->) where
+	loop f b = let (a,c) = f (b,c) in a
+
+instance Distributive (->) where
+	distribute (x,Left y) = Left (x,y)
+	distribute (x,Right z) = Right (x,z)
+
+-- conflict!
+--instance Bifunctor (->) (Dual (->)) (->) (->) where
+--        bimap f g h = g . h . runDual f
+
+instance Adjunction ((,)a) ((->)a) (->) (->) where
+        unit = unitCCC
+        counit = counitCCC
+
+instance CCC (->) where
+#ifndef __HADDOCK__
+        type Exp (->) = (->)
+#endif
+        apply (f,x) = f x
+        curry = Prelude.curry
+        uncurry = Prelude.uncurry
+
hunk ./src/Control/Category/Library.hs 1
-{-# OPTIONS -fglasgow-exts -fallow-undecidable-instances #-}
--------------------------------------------------------------------------------------------
--- |
--- Module	: Control.Category.Library
--- Copyright 	: 2008 Edward Kmett
--- License	: BSD
---
--- Maintainer	: Edward Kmett <ekmett@gmail.com>
--- Stability	: experimental
--- Portability	: non-portable (class-associated types)
---
--- A single import for the entire kitchen sink 
--------------------------------------------------------------------------------------------
-
-
-module Control.Category.Library 
- 	( module Control.Category
-	, module Control.Category.Bifunctor
-	, module Control.Category.Functor
-	, module Control.Category.Functor.Adjunction
-	, module Control.Category.Hask
-	, module Control.Category.Monad
-	, module Control.Category.Object
-	, module Control.Category.Product
-	, module Control.Category.Transformer
-	, module Control.Category.Transformer.Kleisli
-	, module Control.Category.Transformer.Dual
-	) where
-
-import Prelude hiding (Functor, fmap, (.), id, fst, snd, Monad, return, (>>=))
-import qualified Prelude
-import Control.Category
-import Control.Category.Bifunctor
-import Control.Category.Functor
-import Control.Category.Functor.Adjunction
-import Control.Category.Hask
-import Control.Category.Monad
-import Control.Category.Product
-import Control.Category.Transformer
-import Control.Category.Transformer.Kleisli
-import Control.Category.Transformer.Dual
-import Control.Category.Object
rmfile ./src/Control/Category/Library.hs
addfile ./src/Control/Category/Loop.hs
hunk ./src/Control/Category/Loop.hs 1
+{-# OPTIONS -fglasgow-exts -fallow-undecidable-instances #-}
+-------------------------------------------------------------------------------------------
+-- |
+-- Module	: Control.Category.Loop
+-- Copyright 	: 2008 Edward Kmett
+-- License	: BSD-style (see the LICENSE file in the distribution)
+--
+-- Maintainer	: Edward Kmett <ekmett@gmail.com>
+-- Stability	: experimental
+-- Portability	: non-portable (class-associated types)
+--
+-- Defines 'Monad' and 'Comonad' in a way that allows it to represent a (co)monad over 
+-- other categories than just the category of types.
+-------------------------------------------------------------------------------------------
+
+
+module Control.Category.Loop where
+
+import Prelude hiding (Functor, fmap, (.), id, Monad, return, (>>=),(=<<),(>>))
+import Control.Category
+import Control.Category.Bifunctor.Product
+
+class HasProducts k => Loop k where
+	loop :: k (Prod k a c) (Prod k b c) -> k a b
+
hunk ./src/Control/Category/Object.hs 29
+#ifndef __HADDOCK__
hunk ./src/Control/Category/Object.hs 31
+#endif
hunk ./src/Control/Category/Object.hs 37
+#ifndef __HADDOCK__
hunk ./src/Control/Category/Object.hs 39
+#endif
hunk ./src/Control/Category/Product.hs 1
-{-# OPTIONS -fglasgow-exts -fallow-undecidable-instances #-}
--------------------------------------------------------------------------------------------
--- |
--- Module	: Control.Category.Product
--- Copyright 	: 2008 Edward Kmett
--- License	: BSD-style (see the LICENSE file in the distribution)
---
--- Maintainer	: Edward Kmett <ekmett@gmail.com>
--- Stability	: experimental
--- Portability	: non-portable (class-associated types)
---
--- Defines machinery for working with categories that have all finite products and/or
--- all finite coproducts in categories other than the category of types. This is richer 
--- than arrow sugar, because we cannot assume the form of the product/coproduct functor
--- if we want to be able to support more interesting categories.
--------------------------------------------------------------------------------------------
-
-module Control.Category.Product 
-	( HasProducts(..)
-	, bimapProduct, braidProduct, associateProduct, coassociateProduct
-	, (***)
-	, HasCoproducts(..)
-	, bimapCoproduct, braidCoproduct, associateCoproduct, coassociateCoproduct
-	, (+++), left, right
-	) where
-
-import Prelude hiding (Functor, fmap, (.), id, fst, snd)
-import qualified Prelude
-
-import Control.Category
-import Control.Category.Bifunctor
-
--- * Products
-
--- NB: This is weaker than traditional category with products! That would have to look like
--- @class (Monoidal k (P k), Braided k (P k)) => HasProducts k where ...@
--- the problem is @(->)@ lacks an initial object, since every type is inhabited in Haskell.
--- Consequently its coproduct 'monoid' has no identity and we want to be able to
--- describe its dual category, which has this non-traditional form being built
--- over a category with an associative bifunctor rather than as a monoidal category
--- for the product monoid.
-
--- Minimum definition: 
--- 1. fst, snd, diag 
--- 2. fst, snd, (&&&) -- allows use of bimapProduct to define bimap
-class (Associative (P k) k, Coassociative (P k) k, Braided (P k) k) => HasProducts k where
-	type P k :: * -> * -> *
-	fst :: k (P k a b) a
-	snd :: k (P k a b) b
-	diag :: k a (P k a a)
-	(&&&) :: k a b -> k a c -> k a (P k b c)
-
-	diag = id &&& id
-	f &&& g = diag >>> bimap f g 
-
-
--- | for ease of type checking
-(***) :: HasProducts k => k a c -> k b d -> k (P k a b) (P k c d)
-(***) = bimap
-
--- | free construction of 'Bifunctor' for the product functor @P k@ if @(&&&)@ is known
-bimapProduct :: HasProducts k => k a c -> k b d -> k (P k a b) (P k c d)
-bimapProduct f g = (f . fst) &&& (g . snd)
-	
--- | free construction of 'Braided' for the product bifunctor @P k@
-braidProduct :: HasProducts k => k (P k a b) (P k b a)
-braidProduct = snd &&& fst
-
--- | free construction of 'Associative' for the product bifunctor @P k@
-associateProduct :: HasProducts k => k (P k (P k a b) c) (P k a (P k b c))
-associateProduct = (fst . fst) &&& first snd
-
--- | free construction of 'Coassociative' for the product bifunctor @P k@
-coassociateProduct :: HasProducts k => k (P k a (P k b c)) (P k (P k a b) c)
-coassociateProduct = braid . second braid . associateProduct . first braid . braid 
-
--- * Coproducts
-
--- a category that has finite coproducts, weakened the same way as HasProducts above was weakened
-class (Associative (S k) k, Coassociative (S k) k, Braided (S k) k) => HasCoproducts k where
-	type S k :: * -> * -> *
-	inl :: k a (S k a b)
-	inr :: k b (S k a b)
-	codiag :: k (S k a a) a
-	(|||) :: k a c -> k b c -> k (S k a b) c
-
-	codiag = id ||| id
-	f ||| g = bimap f g >>> codiag 
-
--- | for ease of type checking
-(+++) :: HasCoproducts k => k a c -> k b d -> k (S k a b) (S k c d)
-(+++) = bimap
-
--- | for legacy/conceptual purposes and ease of type checking
-left :: HasCoproducts k => k a b -> k (S k a c) (S k b c)
-left = first
-
--- | for legacy/conceptual purposes and ease of type checking
-right :: HasCoproducts k => k a b -> k (S k c a) (S k c b)
-right = second
-
--- | free construction of 'Bifunctor' for the coproduct bifunctor @S k@ if @(|||)@ is known
-bimapCoproduct :: HasCoproducts k => k a c -> k b d -> k (S k a b) (S k c d)
-bimapCoproduct f g = (inl . f) ||| (inr . g)
-
--- | free construction of 'Braided' for the coproduct bifunctor @S k@
-braidCoproduct :: HasCoproducts k => k (S k a b) (S k b a)
-braidCoproduct = inr ||| inl
-
--- | free construction of 'Associative' for the coproduct bifunctor @S k@
-associateCoproduct :: HasCoproducts k => k (S k (S k a b) c) (S k a (S k b c))
-associateCoproduct = braid . first braid . coassociateCoproduct . second braid . braid
-
--- | free construction of 'Coassociative' for the coproduct bifunctor @S k@
-coassociateCoproduct :: HasCoproducts k => k (S k a (S k b c)) (S k (S k a b) c)
-coassociateCoproduct = (inl . inl) ||| left inr
rmfile ./src/Control/Category/Product.hs
hunk ./src/Control/Category/Transformer/Kleisli.hs 1
-{-# OPTIONS -fglasgow-exts #-}
--------------------------------------------------------------------------------------------
--- |
--- Module	: Control.Category.Transformer.Kleisli
--- Copyright 	: 2008 Edward Kmett
--- License	: BSD
---
--- Maintainer	: Edward Kmett <ekmett@gmail.com>
--- Stability	: experimental
--- Portability	: non-portable (class-associated types)
---
--------------------------------------------------------------------------------------------
-
-module Control.Category.Transformer.Kleisli ( Kleisli(..)) where
-
-import Prelude hiding (Functor, fmap, (.), id, fst, snd, Monad, return, (>>=))
-import qualified Prelude
-import Control.Category
-import Control.Category.Functor 
-import Control.Category.Monad
-import Control.Category.Transformer
-
-newtype Kleisli m k a b = Kleisli { runKleisli :: k a (m b) }
-
-instance Monad m k => Category (Kleisli m k) where
-	id = Kleisli return
-	g . f = Kleisli (bind (runKleisli g) . runKleisli f)
-
-instance Monad m k => CategoryTransformer (Kleisli m) k where
-	lift f = Kleisli (return . f)
-
rmfile ./src/Control/Category/Transformer/Kleisli.hs
rmdir ./src/Control/Category/Transformer
}
