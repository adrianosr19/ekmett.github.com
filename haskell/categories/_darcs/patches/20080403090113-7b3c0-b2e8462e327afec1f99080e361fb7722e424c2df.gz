[builds now, needs haddock
ekmett@gmail.com**20080403090113] {
addfile ./LICENSE
hunk ./LICENSE 1
+Copyright (c) 2008, Edward Kmett
+All rights reserved.
+
+Redistribution and use in source and binary forms, with or without modification, 
+are permitted provided that the following conditions are met:
+
+    * Redistributions of source code must retain the above copyright notice, 
+      this list of conditions and the following disclaimer.
+    * Redistributions in binary form must reproduce the above copyright notice, 
+      this list of conditions and the following disclaimer in the documentation 
+      and/or other materials provided with the distribution.
+    * Neither the name of Edward Kmett nor the names of its other contributors 
+      may be used to endorse or promote products derived from this software 
+      without specific prior written permission.
+
+THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND 
+ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED 
+WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. 
+IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, 
+INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT 
+NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR 
+PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, 
+WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) 
+ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE 
+POSSIBILITY OF SUCH DAMAGE.
addfile ./Makefile
hunk ./Makefile 1
+URL=http://comonad.com/haskell/ctl-0.1
+TITLE="Category Transformer Library"
+
+BASE=/home/slipwave/info/haskell/ctl-0.1
+SRC=$(BASE)/src
+
+.PHONY: docs
+
+build: all
+
+
+all:
+	@runhaskell Setup.lhs build
+
+config:
+	@runhaskell Setup.lhs configure
+
+html:
+	@runhaskell Setup.lhs haddock
+
+install:
+	@runhaskell Setup.lhs install
+
+run:
+	$(GHCI) Control.Category.Monad
+
+test:
+	find . -name "*.hs" | egrep -v '_darcs' | xargs qc
+
+docs: 
+	find . -name "*.hs" | egrep -v '_darcs' | xargs haddock -html -odocs --source=$(URL) --title=$(TITLE)
+
+tags:
+	find . -name "*.hs" | egrep -v '_darcs' | xargs hasktags -c
addfile ./README
hunk ./README 1
+This builds against ghc-HEAD (currently 6.9.2008-04-01), and requires the existence of Control.Category 
+and type-families to function.
addfile ./Setup.lhs
hunk ./Setup.lhs 1
+#!/usr/bin/env runhaskell
+> import Distribution.Simple
+> main = defaultMainWithHooks defaultUserHooks
hunk ./ctl.cabal 13
-description: 		Defines monads, etc over arbitrary categories rather than the category of types and 
-			introduces the notion of category transformer, which generalizes the notion of an Arrow
-			transformer. Using categories we can construct BiArrows correctly.
-extensions:		MultiParamTypeClasses, FunctionalDependencies, UndecidableInstances, TypeFamilies, EmptyDataDecls
+description: 		Defines functors, monads, etc over arbitrary categories rather than just endofunctors on 
+			the category of types. Also introduces the notion of a category transformer, which 
+			generalizes the notion of an Arrow transformer. Using categories in this fashion we can 
+			reconstruct BiArrows correctly without any flotsam in the type, and we can similarly 
+			construct a number of other useful notions from category theory that do not form Arrows.
+extensions:		MultiParamTypeClasses, FunctionalDependencies, UndecidableInstances, TypeFamilies, EmptyDataDecls, CPP
hunk ./src/Control/Category/Bifunctor.hs 1
-{-# OPTIONS -fglasgow-exts -fallow-undecidable-instances #-}
+-- {-# OPTIONS -fglasgow-exts -fallow-undecidable-instances #-}
+-------------------------------------------------------------------------------------------
+-- |
+-- Module	: Control.Category.Library
+-- Copyright 	: 2008 Edward Kmett
+-- License	: BSD
+--
+-- Maintainer	: Edward Kmett <ekmett@gmail.com>
+-- Stability	: experimental
+-- Portability	: non-portable (class-associated types)
+--
+-------------------------------------------------------------------------------------------
hunk ./src/Control/Category/Bifunctor.hs 19
--- a covariant bi-functor f :: k1 * k2 -> k3
+-- | A covariant bifunctor f :: k1 * k2 -> k3
hunk ./src/Control/Category/Bifunctor.hs 27
--- A category with an associative bifunctor satisfying Mac Lane's pentagonal coherence identity law:
+-- | A category with an associative bifunctor satisfying Mac Lane's pentagonal coherence identity law:
hunk ./src/Control/Category/Bifunctor.hs 32
--- A category with a coassociative bifunctor satisyfing the dual of Mac Lane's pentagonal coherence identity law:
+-- | A category with a coassociative bifunctor satisyfing the dual of Mac Lane's pentagonal coherence identity law:
hunk ./src/Control/Category/Bifunctor.hs 37
--- We have some reasonable notion of 'Identity' for a particular 'Bifunctor' in this 'Category'
-class Bifunctor p k k k => HasIdentity p k where
-	type Identity k p :: * 
+-- | We have some reasonable notion of 'Identity' for a particular 'Bifunctor' in this 'Category'
+#ifndef HADDOCK
+class Bifunctor p k k k => HasIdentity p k where 
+ 	type Identity k p :: * 
+#endif
hunk ./src/Control/Category/Functor.hs 15
-
-module Control.Category.Functor 
-	( module Control.Category
-	, Functor(fmap)
-	) where
+module Control.Category.Functor ( Functor(fmap)) where
hunk ./src/Control/Category/Functor/Adjunction.hs 27
-class (Functor c d f, Functor d c g) => Adjunction c d f g | f c -> g d, f d -> g c, g c -> f d, g d -> f c where
+class (Functor f c d, Functor g d c) => Adjunction f g c d | f c -> g d, f d -> g c, g c -> f d, g d -> f c where
hunk ./src/Control/Category/Hask.hs 1
-{-# OPTIONS -fglasgow-exts -fallow-undecidable-instances #-}
+{-# OPTIONS -fglasgow-exts -fallow-undecidable-instances -cpp #-}
hunk ./src/Control/Category/Hask.hs 15
-module Control.Category.Hask where
+module Control.Category.Hask (Bottom) where
hunk ./src/Control/Category/Hask.hs 21
+import Control.Category.Bifunctor
+import Control.Category.Functor
hunk ./src/Control/Category/Hask.hs 30
-	type T (->) = Bottom
+#ifndef HADDOCK
+	type Terminal (->) = Bottom
+#endif
hunk ./src/Control/Category/Hask.hs 45
-	type Identity (,) (->) = Bottom
+	type Identity (->) (,) = Bottom
hunk ./src/Control/Category/Hask.hs 72
+#ifndef HADDOCK
hunk ./src/Control/Category/Hask.hs 74
+#endif
hunk ./src/Control/Category/Monad.hs 18
-	( module Control.Category.Functor 
+	( Functor (fmap)
hunk ./src/Control/Category/Object.hs 20
-	( module Control.Category
-	, HasTerminalObject(..)
+	( HasTerminalObject(..)
hunk ./src/Control/Category/Product.hs 19
-	( module Control.Category
-	, module Control.Category.Bifunctor
-	, HasProducts(..)
-	, bimapProduct, braidProduct, associateProduct, coassociateProduct,
+	( HasProducts(..)
+	, bimapProduct, braidProduct, associateProduct, coassociateProduct
hunk ./src/Control/Category/Product.hs 46
-class (Associative k (P k), Coassociative k (P k), Braided k (P k)) => HasProducts k where
+class (Associative (P k) k, Coassociative (P k) k, Braided (P k) k) => HasProducts k where
hunk ./src/Control/Category/Product.hs 80
-class (Associative k (S k), Coassociative k (S k), Braided k (S k)) => HasCoproducts k where
+class (Associative (S k) k, Coassociative (S k) k, Braided (S k) k) => HasCoproducts k where
hunk ./src/Control/Category/Transformer.hs 14
-	( module Control.Category
-	, CategoryTransformer(lift)
+	( CategoryTransformer(lift)
hunk ./src/Control/Category/Transformer/Dual.hs 25
+import Control.Category.Product
hunk ./src/Control/Category/Transformer/Kleisli.hs 14
-module Control.Category.Transformer.Kleisli (Kleisli(..)) where
+module Control.Category.Transformer.Kleisli ( Kleisli(..)) where
hunk ./src/Control/Category/Transformer/Kleisli.hs 25
-instance (Monad m k) => Category (Kleisli m k) where
-	id = Kleisli id
+instance Monad m k => Category (Kleisli m k) where
+	id = Kleisli return
hunk ./src/Control/Category/Transformer/Kleisli.hs 29
-instance (Monad m k) => CategoryTransformer k (Kleisli m) where
+instance Monad m k => CategoryTransformer (Kleisli m) k where
}
