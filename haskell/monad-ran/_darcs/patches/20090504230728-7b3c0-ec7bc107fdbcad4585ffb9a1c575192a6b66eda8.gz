[cleanup, added IO, ST, STM
ekmett@gmail.com**20090504230728
 Ignore-this: 1a7af0d3c58111b00772b96133e4ef5
] {
adddir ./Control/Functor
addfile ./Control/Functor/Pointed.hs
hunk ./Control/Functor/Pointed.hs 1
+-------------------------------------------------------------------------------------------
+-- | 
+-- Module       : Control.Functor.Pointed
+-- Copyright    : 2008 Edward Kmett
+-- License      : BSD
+--
+-- Maintainer   : Edward Kmett <ekmett@gmail.com>
+-- Stability    : experimental
+-- Portability  : portable
+--
+-------------------------------------------------------------------------------------------
+
+module Control.Functor.Pointed 
+    ( Pointed(..)
+    ) where
+
+import Control.Monad.Identity
+import Control.Monad.Reader
+import qualified Control.Monad.Writer.Lazy as LW
+import qualified Control.Monad.Writer.Strict as SW
+import qualified Control.Monad.State.Lazy as LS
+import qualified Control.Monad.State.Strict as SS
+import qualified Control.Monad.RWS.Lazy as LR
+import qualified Control.Monad.RWS.Strict as SR
+import Control.Monad.Error
+import Control.Monad.Cont
+import Control.Monad.List
+import Data.Monoid
+
+-- return
+class Functor f => Pointed f where
+    point :: a -> f a
+
+instance Pointed Maybe where point = Just
+instance Pointed [] where point = return
+
+instance Pointed (Cont r) where point = return
+instance Monad m => Pointed (ContT r m) where point = return
+
+instance Pointed Identity where point = Identity
+
+instance Pointed (Either a) where point = Right
+instance (Error e, Monad m) => Pointed (ErrorT e m) where point = return
+
+instance Pointed (Reader r) where point = return
+instance Monad m => Pointed (ReaderT r m) where point = return
+instance Pointed ((->)r) where point = return
+
+instance Pointed (SS.State w) where point = return
+instance Pointed (LS.State w) where point = return
+instance Monad m => Pointed (SS.StateT w m) where point = return
+instance Monad m => Pointed (LS.StateT w m) where point = return
+
+instance Monoid w => Pointed (SW.Writer w) where point = return
+instance Monoid w => Pointed (LW.Writer w) where point = return
+instance (Monoid w, Monad m) => Pointed (SW.WriterT w m) where point = return
+instance (Monoid w, Monad m) => Pointed (LW.WriterT w m) where point = return
+
+instance Monoid w => Pointed (SR.RWS r w s) where point = return
+instance Monoid w => Pointed (LR.RWS r w s) where point = return
+instance (Monoid w, Monad m) => Pointed (SR.RWST r w s m) where point = return
+instance (Monoid w, Monad m) => Pointed (LR.RWST r w s m) where point = return
+
+instance Monad m => Pointed (ListT m) where point = return
adddir ./Control/Monad/CPS
addfile ./Control/Monad/CPS/Maybe.hs
hunk ./Control/Monad/CPS/Maybe.hs 1
+{-# LANGUAGE Rank2Types #-}
+
+module Control.Monad.CPS.Maybe
+    ( Maybe'(..)
+    , maybe'
+    ) where
+
+newtype Maybe' a = Maybe' { getMaybe' :: forall o. (a -> o) -> o -> o } 
+
+instance Functor Maybe' where
+    fmap f (Maybe' m) = Maybe' (\k -> m (k . f))
+
+instance Monad Maybe' where
+    return a = Maybe' (\k _ -> k a)
+    Maybe' g >>= f = Maybe' (\k z -> g (\a -> getMaybe' (f a) k z) z)
+    
+maybe' :: a -> (b -> a) -> Maybe' b -> a
+maybe' a b (Maybe' m) = m b a
addfile ./Control/Monad/Codensity.hs
hunk ./Control/Monad/Codensity.hs 1
+{-# LANGUAGE Rank2Types, MultiParamTypeClasses, FlexibleInstances, FlexibleContexts, UndecidableInstances #-}
+-- Finding the right Kan extension
+
+module Control.Monad.Codensity
+    ( -- * The codensity monad of a functor
+      Codensity(..)
+    , lowerCodensity
+    , lowerCodensityApp
+    , lowerCodensityPointed
+    ) where
+
+import Data.Monoid
+import Data.Maybe (maybe)
+import Control.Applicative
+import Control.Monad
+import Control.Monad.Trans
+import Control.Monad.Identity
+import Control.Monad.Cont.Class
+import Control.Monad.State.Class
+import Control.Monad.Error.Class
+import Control.Monad.Reader.Class
+import Control.Monad.Writer.Class
+import Control.Monad.RWS.Class
+import Control.Functor.Pointed
+
+-- | The Codensity monad of a functor/monad generated by a functor
+
+data Codensity f a = Codensity { getCodensity :: forall b. (a -> f b) -> f b }
+
+instance Functor (Codensity k) where
+    fmap f m = Codensity (\k -> getCodensity m (k . f))
+
+instance Pointed (Codensity f) where
+    point x = Codensity (\k -> k x)
+
+instance Applicative (Codensity f) where
+    pure x = Codensity (\k -> k x)
+    Codensity f <*> Codensity x = Codensity (\k -> f (\f' -> x (k . f')))
+
+instance Monad (Codensity f) where
+    return x = Codensity (\k -> k x)
+    Codensity m >>= k = Codensity 
+        (\c -> m (\a -> getCodensity (k a) c))
+
+instance MonadIO m => MonadIO (Codensity m) where
+    liftIO = lift . liftIO
+
+instance MonadPlus m => MonadPlus (Codensity m) where
+    mzero = Codensity (const mzero)
+    a `mplus` b = lift (lowerCodensity a `mplus` lowerCodensity b)
+
+instance MonadReader r m => MonadReader r (Codensity m) where
+    ask = lift ask
+    local f m = Codensity (\c -> do r <- ask; local f (getCodensity m (local (const r) . c)))
+
+instance MonadWriter w m => MonadWriter w (Codensity m) where
+    tell = lift . tell
+    listen = lift . listen . lowerCodensity
+    pass = lift . pass . lowerCodensity
+
+instance MonadState s m => MonadState s (Codensity m) where
+    get = lift get
+    put = lift . put
+
+instance MonadRWS r w s m => MonadRWS r w s (Codensity m)
+
+-- instance MonadFix f => MonadFix (Codensity f) where
+--    mfix f = lift . mfix (lowerCodensity . f)
+
+instance MonadError e m => MonadError e (Codensity m) where
+    throwError = lift . throwError
+--    Codensity f `catchError` h = catchError . run
+
+instance MonadTrans Codensity where
+    lift m = Codensity (m >>=)
+
+lowerCodensity :: Monad m => Codensity m a -> m a
+lowerCodensity = flip getCodensity return
+
+lowerCodensityApp :: Applicative f => Codensity f a -> f a
+lowerCodensityApp = flip getCodensity pure
+
+lowerCodensityPointed :: Applicative f => Codensity f a -> f a
+lowerCodensityPointed = flip getCodensity pure
+
adddir ./Control/Monad/Ran
hunk ./Control/Monad/Ran.hs 1
+{-# LANGUAGE RankNTypes, FlexibleInstances, FlexibleContexts, TypeFamilies, MultiParamTypeClasses, MagicHash, UnboxedTuples, UndecidableInstances  #-}
hunk ./Control/Monad/Ran.hs 16
-    , toRan
-    , fromRan
+    , liftRan
+    , lowerRan
hunk ./Control/Monad/Ran.hs 23
+import Control.Functor.Pointed
hunk ./Control/Monad/Ran.hs 25
+import Control.Monad.Yoneda
+import Control.Monad.Codensity
hunk ./Control/Monad/Ran.hs 35
-
-
+import GHC.Prim
+import GHC.IOBase hiding (liftIO)
+import GHC.Conc
+import GHC.ST
hunk ./Control/Monad/Ran.hs 44
-instance RMonad m => Functor (Ran m) where
-    fmap f m = Ran (\k -> getRan m (k . f))
-
-class (Monad (Ran f), Monad f) => RMonad f where
+class RanIso f where
hunk ./Control/Monad/Ran.hs 47
-    toRan      :: f a -> Ran f a
-    fromRan    :: Ran f a -> f a
+    liftRan       :: f a -> Ran f a
+    lowerRan      :: Ran f a -> f a
hunk ./Control/Monad/Ran.hs 50
+instance RanIso f => Functor (Ran f) where
+    fmap f m = Ran (\k -> getRan m (k . f))
hunk ./Control/Monad/Ran.hs 53
+returnCodensity :: (RanIso m, G m ~ H m) => a -> Ran m a
+returnCodensity a = Ran (\k -> k a)
hunk ./Control/Monad/Ran.hs 56
--- | The Yoneda lemma, TODO: just improve the category extras definition?
+bindCodensity :: (RanIso m, G m ~ H m) => Ran m a -> (a -> Ran m b) -> Ran m b
+bindCodensity (Ran m) k = Ran (\c -> m (\a -> getRan (k a) c))
hunk ./Control/Monad/Ran.hs 59
-data Yoneda f a = Yoneda { getYoneda :: forall b. (a -> b) -> f b } 
+class (Monad (Ran f), Monad f, RanIso f) => RMonad f 
+instance (Monad (Ran f), Monad f, RanIso f) => RMonad f
hunk ./Control/Monad/Ran.hs 62
-instance Functor (Yoneda f) where
-    fmap f m = Yoneda (\k -> getYoneda m (k . f))
+class (Applicative (Ran f), Applicative f, RanIso f) => RApplicative f 
+instance (Applicative (Ran f), Applicative f, RanIso f) => RApplicative f
hunk ./Control/Monad/Ran.hs 65
-instance Applicative f => Applicative (Yoneda f) where
-    pure a = Yoneda (\f -> pure (f a))
-    m <*> n = Yoneda (\f -> getYoneda m (f .) <*> getYoneda n id)
+-- The codensity monad as a right Kan extension of a functor along itself
+instance RanIso (Codensity f) where
+    type G (Codensity f) = f
+    type H (Codensity f) = f
+    liftRan (Codensity f) = Ran f
+    lowerRan (Ran f) = Codensity f
hunk ./Control/Monad/Ran.hs 72
-instance Monad f => Monad (Yoneda f) where
-    return a = Yoneda (\f -> return (f a))
-    m >>= k = Yoneda (\f -> getYoneda m id >>= \a -> getYoneda (k a) f)
+ranCodensity :: Ran (Codensity f) a -> Codensity f a
+ranCodensity = lowerRan
hunk ./Control/Monad/Ran.hs 75
-instance MonadPlus f => MonadPlus (Yoneda f) where
-    mzero = Yoneda (\_ -> mzero)
-    Yoneda m `mplus` Yoneda n = Yoneda (\f -> m f `mplus` n f)
+codensityRan :: Codensity f a -> Ran (Codensity f) a
+codensityRan = liftRan
hunk ./Control/Monad/Ran.hs 78
-instance MonadTrans Yoneda where
-    lift m = Yoneda (\f -> liftM f m)
+instance Pointed (Ran (Codensity f)) where
+    point = codensityRan . point
hunk ./Control/Monad/Ran.hs 81
-instance MonadReader r f => MonadReader r (Yoneda f)
+instance Applicative (Ran (Codensity f)) where
+    pure = codensityRan . pure
+    m <*> n = liftRan (lowerRan m <*> lowerRan n)
hunk ./Control/Monad/Ran.hs 85
-instance MonadWriter w f => MonadWriter w (Yoneda f)
+instance Monad (Ran (Codensity f)) where
+    return = liftRan . return
+    m >>= k = liftRan (lowerRan m >>= lowerRan . k)
hunk ./Control/Monad/Ran.hs 89
-instance MonadState s f => MonadState s (Yoneda f)
+instance MonadPlus f => Alternative (Ran (Codensity f)) where
+    empty = liftRan mzero
+    m <|> n = liftRan (lowerRan m `mplus` lowerRan n)
+    
+instance MonadPlus f => MonadPlus (Ran (Codensity f)) where
+    mzero = liftRan mzero
+    m `mplus` n = liftRan (lowerRan m `mplus` lowerRan n)
hunk ./Control/Monad/Ran.hs 97
-instance MonadRWS r w s f => MonadRWS r w s (Yoneda f)
hunk ./Control/Monad/Ran.hs 98
-instance MonadError e f => MonadError e (Yoneda f)
hunk ./Control/Monad/Ran.hs 99
-instance MonadCont f => MonadCont (Yoneda f)
+-- TODO: the other instances for Ran (Codensity f)
+-- MonadIO, MonadState, etc.
hunk ./Control/Monad/Ran.hs 102
-runYoneda :: Yoneda f a -> f a 
-runYoneda (Yoneda f) = f id
+-- Yoneda Identity a ~ Codensity Identity a ~ forall o. (a -> o) -> o
+instance RanIso Identity where
+    type G Identity = Identity
+    type H Identity = Identity
+    liftRan m = Ran (m >>=)
+    lowerRan = flip getRan Identity
hunk ./Control/Monad/Ran.hs 109
--- Ran (Yoneda f) a ~ forall o. (a -> Identity o) -> f o 
-instance Monad f => RMonad (Yoneda f) where
-    type G (Yoneda f) = Identity
-    type H (Yoneda f) = f
-    toRan (Yoneda f) = Ran (\b -> f (runIdentity . b))
-    fromRan (Ran f) = Yoneda (\b -> f (Identity . b))
+instance Pointed (Ran Identity) where
+    point = return
hunk ./Control/Monad/Ran.hs 112
-ranYoneda :: Monad f => Ran (Yoneda f) a -> Yoneda f a
-ranYoneda = fromRan
+instance Applicative (Ran Identity) where
+    pure = return
+    (<*>) = ap
hunk ./Control/Monad/Ran.hs 116
-yonedaRan :: Monad f => Yoneda f a -> Ran (Yoneda f) a
-yonedaRan = toRan
+instance Monad (Ran Identity) where
+    return a = Ran (\k -> k a)
+    Ran m >>= k = Ran (\c -> m (\a -> getRan (k a) c))
hunk ./Control/Monad/Ran.hs 120
--- TODO: break up RMonad into RFunctor...
-instance (Applicative f, Monad f) => Applicative (Ran (Yoneda f)) where
-    pure = yonedaRan . pure
-    m <*> n = yonedaRan (ranYoneda m <*> ranYoneda n)
hunk ./Control/Monad/Ran.hs 121
-instance Monad f => Monad (Ran (Yoneda f)) where
-    return = yonedaRan . return
-    m >>= k = yonedaRan (ranYoneda m >>= ranYoneda . k)
+newtype World w a = World { runWorld :: State# w -> a } 
hunk ./Control/Monad/Ran.hs 123
-instance MonadPlus f => MonadPlus (Ran (Yoneda f)) where
-    mzero = yonedaRan mzero
-    m `mplus` n = yonedaRan (ranYoneda m `mplus` ranYoneda n)
+-- homegrown STret with flopped arguments
+data STret' s a = STret' a (State# s)
hunk ./Control/Monad/Ran.hs 126
--- | The Codensity monad of a functor/monad generated by a functor
+liftRanWorld :: (G m ~ World w, H m ~ World w) => (State# w -> (# State# w, a #)) -> Ran m a
+liftRanWorld f = Ran (\k -> World (\w -> case f w of (# w', a #) -> runWorld (k a) w'))
hunk ./Control/Monad/Ran.hs 129
-data Codensity f a = Codensity { getCodensity :: forall b. (a -> f b) -> f b }
+-- viewpatterned to eliminate named temporaries:
+-- liftRanWorld f = Ran (\k -> World (\(f -> (# w, (runWorld . k -> j) #)) -> j w))
hunk ./Control/Monad/Ran.hs 132
-instance Functor (Codensity k) where
-    fmap f m = Codensity (\k -> getCodensity m (k . f))
+lowerRanWorld :: (G m ~ World w, H m ~ World w) => Ran m a -> State# w -> (# State# w, a #)
+lowerRanWorld (Ran r) w = case runWorld (r (World . STret')) w of 
+    STret' b w'' -> (# w'', b #)
hunk ./Control/Monad/Ran.hs 136
-instance Applicative (Codensity f) where
+-- Represent IO as the codensity of the RealWorld
+instance RanIso IO where
+    type G IO = World RealWorld
+    type H IO = World RealWorld
+    liftRan (IO s) = liftRanWorld s
+    lowerRan s = IO (lowerRanWorld s)
+
+instance Applicative (Ran IO) where
hunk ./Control/Monad/Ran.hs 147
-instance Monad (Codensity f) where
-    return x = Codensity (\k -> k x)
-    Codensity m >>= k = Codensity (\c -> m (\a -> getCodensity (k a) c))
+instance Monad (Ran IO) where
+    return = returnCodensity
+    (>>=) = bindCodensity
hunk ./Control/Monad/Ran.hs 151
-instance MonadTrans Codensity where
-    lift m = Codensity (m >>=)
+instance MonadIO (Ran IO) where
+    liftIO = liftRan
hunk ./Control/Monad/Ran.hs 154
-runCodensity :: Monad m => Codensity m a -> m a
-runCodensity = flip getCodensity return
+-- Represent ST s as the codensity of the world s
+instance RanIso (ST s) where
+    type G (ST s) = World s
+    type H (ST s) = World s
+    liftRan (ST s) = liftRanWorld s
+    lowerRan r = ST (lowerRanWorld r)
hunk ./Control/Monad/Ran.hs 161
-runCodensityApp :: Applicative f => Codensity f a -> f a
-runCodensityApp = flip getCodensity pure
+instance Applicative (Ran (ST s)) where
+    pure = return
+    (<*>) = ap
hunk ./Control/Monad/Ran.hs 165
--- .. runCodensityPointed
+instance Monad (Ran (ST s)) where
+    return = returnCodensity
+    (>>=) = bindCodensity
hunk ./Control/Monad/Ran.hs 169
-type Hom = (->)
-type (:->) = ReaderT
+-- todo make a MonadST class
hunk ./Control/Monad/Ran.hs 171
-data ErrorH b r  = ErrorH { getErrorH :: (b -> r) -> r } 
-data ErrorTH b m r = ErrorTH { getErrorTH :: (b -> G m r) -> H m r }
+-- Represent STM as the codensity of the RealWorld
+instance RanIso STM where
+    type G STM = World RealWorld
+    type H STM = World RealWorld
+    liftRan (STM s) = liftRanWorld s
+    lowerRan r = STM (lowerRanWorld r)
hunk ./Control/Monad/Ran.hs 178
--- Yoneda Identity a ~ Codensity Identity a ~ forall o. (a -> o) -> o
-instance RMonad Identity where
-    type G Identity = Identity
-    type H Identity = Identity
-    toRan m = Ran (m >>=)
-    fromRan = flip getRan Identity
-
-instance Applicative (Ran Identity) where
+instance Applicative (Ran STM) where
hunk ./Control/Monad/Ran.hs 182
-instance Monad (Ran Identity) where
-    return a = Ran (\k -> k a)
-    Ran m >>= k = Ran (\c -> m (\a -> getRan (k a) c))
+instance Monad (Ran STM) where
+    return = returnCodensity
+    (>>=) = bindCodensity
hunk ./Control/Monad/Ran.hs 186
+-- TODO: make a MonadSTM class
hunk ./Control/Monad/Ran.hs 189
-instance RMonad Maybe where
+-- note Endo is not a Hask Functor!
+instance RanIso Maybe where
hunk ./Control/Monad/Ran.hs 193
-    toRan = maybe mzero return 
-    fromRan f = appEndo (getRan f (Identity . return)) mzero
+    liftRan Nothing  = mzero
+    liftRan (Just x) = return x
+    lowerRan f = appEndo (getRan f (Identity . return)) mzero
hunk ./Control/Monad/Ran.hs 199
---  Ran m >>= k = Ran (\c -> Endo (\z -> m (\a -> appEndo (getRan (k a) c) z)))
+    Ran g >>= f = Ran (\k -> Endo (\z -> appEndo (g (\a -> Identity (appEndo (getRan (f a) k) z))) z))
hunk ./Control/Monad/Ran.hs 210
+type (:->) = ReaderT
+
+data ErrorH b r  = ErrorH { getErrorH :: (b -> r) -> r } 
+data ErrorTH b m r = ErrorTH { getErrorTH :: (b -> G m r) -> H m r }
+
+
hunk ./Control/Monad/Ran.hs 217
-instance Error e => RMonad (Either e) where
+instance Error e => RanIso (Either e) where
hunk ./Control/Monad/Ran.hs 220
-    toRan (Right x) = Ran (\k -> ErrorH (\_ -> runIdentity (k x)))
-    toRan (Left x) = Ran (\_ -> ErrorH (\e -> e x))
-    fromRan (Ran f) = getErrorH (f (Identity . Right)) Left
+    liftRan (Right x) = Ran (\k -> ErrorH (\_ -> runIdentity (k x)))
+    liftRan (Left x) = Ran (\_ -> ErrorH (\e -> e x))
+    lowerRan (Ran f) = getErrorH (f (Identity . Right)) Left
hunk ./Control/Monad/Ran.hs 250
-    toRan (Codensity f) = Ran f
-    fromRan (Ran f) = Codensity f
+    liftRan (Codensity f) = Ran f
+    lowerRan (Ran f) = Codensity f
hunk ./Control/Monad/Ran.hs 258
-    toRan m = Ran (\f -> liftM (runIdentity . f) m)
-    fromRan (Ran f) = f Identity
+    liftRan m = Ran (\f -> liftM (runIdentity . f) m)
+    lowerRan (Ran f) = f Identity
hunk ./Control/Monad/Ran.hs 265
-    type G (Writer w) = Hom w
-    type H (Writer w) = Hom w
-    toRan (Writer (a,w'))  = Ran (\f w -> f a (w `mappend` w'))
-    fromRan (Ran f) = Writer (f (,) mempty)
+    type G (Writer w) = (->) w
+    type H (Writer w) = (->) w
+    liftRan (Writer (a,w'))  = Ran (\f w -> f a (w `mappend` w'))
+    lowerRan (Ran f) = Writer (f (,) mempty)
hunk ./Control/Monad/Ran.hs 275
-    type G (State s) = Hom s
-    type H (State s) = Hom s
-    toRan (State g)  = Ran (\f -> uncurry f . g)
-    fromRan (Ran f)  = State (f (,))
+    type G (State s) = (->) s
+    type H (State s) = (->) s
+    liftRan (State g)  = Ran (\f -> uncurry f . g)
+    lowerRan (Ran f)  = State (f (,))
hunk ./Control/Monad/Ran.hs 309
+
+
+
+-- Yoneda lemma as a right Kan extension along the identity functor
+instance RanIso (Yoneda f) where
+    type G (Yoneda f) = Identity
+    type H (Yoneda f) = f
+    liftRan (Yoneda f) = Ran (\b -> f (runIdentity . b))
+    lowerRan (Ran f) = Yoneda (\b -> f (Identity . b))
+
+ranYoneda :: Ran (Yoneda f) a -> Yoneda f a
+ranYoneda = lowerRan
+
+yonedaRan :: Yoneda f a -> Ran (Yoneda f) a
+yonedaRan = liftRan
+
+instance Pointed f => Pointed (Ran (Yoneda f)) where
+    point = liftRan . point
+
+instance Applicative f => Applicative (Ran (Yoneda f)) where
+    pure = liftRan . pure
+    m <*> n = liftRan (lowerRan m <*> lowerRan n)
+
+instance Alternative f => Alternative (Ran (Yoneda f)) where
+    empty = liftRan empty
+    m <|> n = liftRan (lowerRan m <|> lowerRan n) 
+
+instance Monad f => Monad (Ran (Yoneda f)) where
+    return = liftRan . return
+    m >>= k = liftRan (lowerRan m >>= lowerRan . k)
+
+instance MonadPlus f => MonadPlus (Ran (Yoneda f)) where
+    mzero = liftRan mzero
+    m `mplus` n = liftRan (lowerRan m `mplus` lowerRan n)
+
+instance MonadReader r f => MonadReader r (Ran (Yoneda f)) where
+    ask = liftRan ask
+    local f = liftRan . local f . lowerRan
+
+instance MonadWriter w f => MonadWriter w (Ran (Yoneda f)) where
+    tell = liftRan . tell
+    listen = liftRan . listen . lowerRan
+    pass = liftRan . pass . lowerRan
+
+instance MonadState s f => MonadState s (Ran (Yoneda f)) where
+    get = liftRan get
+    put = liftRan . put
+
+instance MonadIO f => MonadIO (Ran (Yoneda f)) where
+    liftIO = liftRan . liftIO
+
+instance MonadRWS r w s f => MonadRWS r w s (Ran (Yoneda f))
+
+instance MonadError e f => MonadError e (Ran (Yoneda f)) where
+    throwError = liftRan . throwError
+--    Ran f `catchError` h = Yoneda (liftRan . (`catchError` h) . f)
+
+-- instance MonadFix m => MonadFix (Ran (Yoneda m)) where
+--    mfix = liftRan . mfix . lowerRan
+
addfile ./Control/Monad/Yoneda.hs
hunk ./Control/Monad/Yoneda.hs 1
+{-# LANGUAGE Rank2Types, MultiParamTypeClasses, FlexibleInstances, FlexibleContexts, UndecidableInstances #-}
+-- Finding the right Kan extension
+
+module Control.Monad.Yoneda
+    ( -- * The Yoneda Lemma
+      Yoneda(..)
+    , runYoneda
+    ) where
+
+import Data.Monoid
+import Data.Maybe (maybe)
+import Control.Applicative
+import Control.Functor.Pointed
+import Control.Monad
+import Control.Monad.Trans
+import Control.Monad.Fix
+import Control.Monad.Cont.Class
+import Control.Monad.State.Class
+import Control.Monad.Error.Class
+import Control.Monad.Reader.Class
+import Control.Monad.Writer.Class
+import Control.Monad.RWS.Class
+
+data Yoneda f a = Yoneda { getYoneda :: forall b. (a -> b) -> f b } 
+
+instance Functor (Yoneda f) where
+    fmap f m = Yoneda (\k -> getYoneda m (k . f))
+
+instance Pointed f => Pointed (Yoneda f) where
+    point a = Yoneda (\f -> point (f a))
+
+instance Applicative f => Applicative (Yoneda f) where
+    pure a = Yoneda (\f -> pure (f a))
+    m <*> n = Yoneda (\f -> getYoneda m (f .) <*> getYoneda n id)
+
+instance Alternative f => Alternative (Yoneda f) where
+    empty = Yoneda (const empty)
+    Yoneda m <|> Yoneda n = Yoneda (\f -> m f <|> n f)
+
+instance Monad f => Monad (Yoneda f) where
+    return a = Yoneda (\f -> return (f a))
+    m >>= k = Yoneda (\f -> getYoneda m id >>= \a -> getYoneda (k a) f)
+
+instance MonadPlus f => MonadPlus (Yoneda f) where
+    mzero = Yoneda (const mzero)
+    Yoneda m `mplus` Yoneda n = Yoneda (\f -> m f `mplus` n f)
+
+instance MonadTrans Yoneda where
+    lift m = Yoneda (\f -> liftM f m)
+
+instance MonadReader r f => MonadReader r (Yoneda f) where
+    ask = lift ask
+    local f = lift . local f . runYoneda 
+
+instance MonadWriter w f => MonadWriter w (Yoneda f) where
+    tell = lift . tell
+    listen = lift . listen . runYoneda
+    pass = lift . pass . runYoneda
+
+instance MonadState s f => MonadState s (Yoneda f) where
+    get = lift get
+    put = lift . put
+
+instance MonadIO f => MonadIO (Yoneda f) where
+    liftIO = lift . liftIO
+
+instance MonadRWS r w s f => MonadRWS r w s (Yoneda f)
+
+instance MonadError e f => MonadError e (Yoneda f) where
+    throwError = lift . throwError
+
+instance MonadFix m => MonadFix (Yoneda m)
+    
+runYoneda :: Yoneda f a -> f a 
+runYoneda (Yoneda f) = f id
+
hunk ./monad-ran.cabal 2
-version:                0.0.6
+version:                0.0.7
hunk ./monad-ran.cabal 8
-copyright:              (c) Edward Kmett 2009 (c) Matt Morrow 2008
+copyright:              (c) Edward Kmett 2009
hunk ./monad-ran.cabal 11
-synopsis:               Implementations of common monads and monad transformers as right Kan extensions
+synopsis:               Fast implementations of monads and monad transformers using right Kan extensions
hunk ./monad-ran.cabal 13
-description:            .
+description:            Fast implementations of monads and monad transformers using right Kan extensions
hunk ./monad-ran.cabal 23
+                        MagicHash,
+                        UnboxedTuples,
hunk ./monad-ran.cabal 29
-    build-depends:      base >= 4.0 && < 4.2, mtl >= 1.1 && < 1.2
-    exposed-modules:    Control.Monad.Ran
+    build-depends:      
+        base >= 4.0 && < 4.2, 
+        mtl >= 1.1 && < 1.2,
+        ghc-prim >= 0.1 && < 0.2
+    exposed-modules:    
+        Control.Functor.Pointed
+        Control.Monad.Ran
+        Control.Monad.Yoneda
+        Control.Monad.Codensity
+        Control.Monad.CPS.Maybe
}
