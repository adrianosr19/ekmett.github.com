[auto
ekmett@gmail.com**20090505083229
 Ignore-this: babc946605115f729d39cb2017bb66b2
] {
hunk ./Control/Functor/Pointed.hs 1
--------------------------------------------------------------------------------------------
--- | 
--- Module       : Control.Functor.Pointed
--- Copyright    : 2008 Edward Kmett
--- License      : BSD
---
--- Maintainer   : Edward Kmett <ekmett@gmail.com>
--- Stability    : experimental
--- Portability  : portable
---
--------------------------------------------------------------------------------------------
-
-module Control.Functor.Pointed 
-    ( Pointed(..)
-    ) where
-
-import Control.Monad.Identity
-import Control.Monad.Reader
-import qualified Control.Monad.Writer.Lazy as LW
-import qualified Control.Monad.Writer.Strict as SW
-import qualified Control.Monad.State.Lazy as LS
-import qualified Control.Monad.State.Strict as SS
-import qualified Control.Monad.RWS.Lazy as LR
-import qualified Control.Monad.RWS.Strict as SR
-import Control.Monad.Error
-import Control.Monad.Cont
-import Control.Monad.List
-import Data.Monoid
-
--- return
-class Functor f => Pointed f where
-    point :: a -> f a
-
-instance Pointed Maybe where point = Just
-instance Pointed [] where point = return
-
-instance Pointed (Cont r) where point = return
-instance Monad m => Pointed (ContT r m) where point = return
-
-instance Pointed Identity where point = Identity
-
-instance Pointed (Either a) where point = Right
-instance (Error e, Monad m) => Pointed (ErrorT e m) where point = return
-
-instance Pointed (Reader r) where point = return
-instance Monad m => Pointed (ReaderT r m) where point = return
-instance Pointed ((->)r) where point = return
-
-instance Pointed (SS.State w) where point = return
-instance Pointed (LS.State w) where point = return
-instance Monad m => Pointed (SS.StateT w m) where point = return
-instance Monad m => Pointed (LS.StateT w m) where point = return
-
-instance Monoid w => Pointed (SW.Writer w) where point = return
-instance Monoid w => Pointed (LW.Writer w) where point = return
-instance (Monoid w, Monad m) => Pointed (SW.WriterT w m) where point = return
-instance (Monoid w, Monad m) => Pointed (LW.WriterT w m) where point = return
-
-instance Monoid w => Pointed (SR.RWS r w s) where point = return
-instance Monoid w => Pointed (LR.RWS r w s) where point = return
-instance (Monoid w, Monad m) => Pointed (SR.RWST r w s m) where point = return
-instance (Monoid w, Monad m) => Pointed (LR.RWST r w s m) where point = return
-
-instance Monad m => Pointed (ListT m) where point = return
rmfile ./Control/Functor/Pointed.hs
rmdir ./Control/Functor
hunk ./Control/Monad/CPS/Maybe.hs 1
-{-# LANGUAGE Rank2Types #-}
-
-module Control.Monad.CPS.Maybe
-    ( Maybe'(..)
-    , maybe'
-    ) where
-
-newtype Maybe' a = Maybe' { getMaybe' :: forall o. (a -> o) -> o -> o } 
-
-instance Functor Maybe' where
-    fmap f (Maybe' m) = Maybe' (\k -> m (k . f))
-
-instance Monad Maybe' where
-    return a = Maybe' (\k _ -> k a)
-    Maybe' g >>= f = Maybe' (\k z -> g (\a -> getMaybe' (f a) k z) z)
-    
-maybe' :: a -> (b -> a) -> Maybe' b -> a
-maybe' a b (Maybe' m) = m b a
rmfile ./Control/Monad/CPS/Maybe.hs
rmdir ./Control/Monad/CPS
hunk ./Control/Monad/Codensity.hs 1
-{-# LANGUAGE Rank2Types, MultiParamTypeClasses, FlexibleInstances, FlexibleContexts, UndecidableInstances #-}
--- Finding the right Kan extension
-
-module Control.Monad.Codensity
-    ( -- * The codensity monad of a functor
-      Codensity(..)
-    , lowerCodensity
-    , lowerCodensityApp
-    , lowerCodensityPointed
-    ) where
-
-import Data.Monoid
-import Data.Maybe (maybe)
-import Control.Applicative
-import Control.Monad
-import Control.Monad.Trans
-import Control.Monad.Identity
-import Control.Monad.Cont.Class
-import Control.Monad.State.Class
-import Control.Monad.Error.Class
-import Control.Monad.Reader.Class
-import Control.Monad.Writer.Class
-import Control.Monad.RWS.Class
-import Control.Functor.Pointed
-
--- | The Codensity monad of a functor/monad generated by a functor
-
-data Codensity f a = Codensity { getCodensity :: forall b. (a -> f b) -> f b }
-
-instance Functor (Codensity k) where
-    fmap f m = Codensity (\k -> getCodensity m (k . f))
-
-instance Pointed (Codensity f) where
-    point x = Codensity (\k -> k x)
-
-instance Applicative (Codensity f) where
-    pure x = Codensity (\k -> k x)
-    Codensity f <*> Codensity x = Codensity (\k -> f (\f' -> x (k . f')))
-
-instance Monad (Codensity f) where
-    return x = Codensity (\k -> k x)
-    Codensity m >>= k = Codensity 
-        (\c -> m (\a -> getCodensity (k a) c))
-
-instance MonadIO m => MonadIO (Codensity m) where
-    liftIO = lift . liftIO
-
-instance MonadPlus m => MonadPlus (Codensity m) where
-    mzero = Codensity (const mzero)
-    a `mplus` b = lift (lowerCodensity a `mplus` lowerCodensity b)
-
-instance MonadReader r m => MonadReader r (Codensity m) where
-    ask = lift ask
-    local f m = Codensity (\c -> do r <- ask; local f (getCodensity m (local (const r) . c)))
-
-instance MonadWriter w m => MonadWriter w (Codensity m) where
-    tell = lift . tell
-    listen = lift . listen . lowerCodensity
-    pass = lift . pass . lowerCodensity
-
-instance MonadState s m => MonadState s (Codensity m) where
-    get = lift get
-    put = lift . put
-
-instance MonadRWS r w s m => MonadRWS r w s (Codensity m)
-
--- instance MonadFix f => MonadFix (Codensity f) where
---    mfix f = lift . mfix (lowerCodensity . f)
-
-instance MonadError e m => MonadError e (Codensity m) where
-    throwError = lift . throwError
-    f `catchError` h = lift $ lowerCodensity f `catchError` (lowerCodensity . h)
---    Codensity f `catchError` h = catchError . run
-
-instance MonadTrans Codensity where
-    lift m = Codensity (m >>=)
-
-lowerCodensity :: Monad m => Codensity m a -> m a
-lowerCodensity = flip getCodensity return
-
-lowerCodensityApp :: Applicative f => Codensity f a -> f a
-lowerCodensityApp = flip getCodensity pure
-
-lowerCodensityPointed :: Applicative f => Codensity f a -> f a
-lowerCodensityPointed = flip getCodensity pure
-
rmfile ./Control/Monad/Codensity.hs
rmdir ./Control/Monad/Ran
hunk ./Control/Monad/Yoneda.hs 1
-{-# LANGUAGE Rank2Types, MultiParamTypeClasses, FlexibleInstances, FlexibleContexts, UndecidableInstances #-}
--- Finding the right Kan extension
-
-module Control.Monad.Yoneda
-    ( -- * The Yoneda Lemma
-      Yoneda(..)
-    , lowerYoneda
-    ) where
-
-import Data.Monoid
-import Data.Maybe (maybe)
-import Control.Applicative
-import Control.Functor.Pointed
-import Control.Monad
-import Control.Monad.Trans
-import Control.Monad.Fix
-import Control.Monad.Cont.Class
-import Control.Monad.State.Class
-import Control.Monad.Error.Class
-import Control.Monad.Reader.Class
-import Control.Monad.Writer.Class
-import Control.Monad.RWS.Class
-
-data Yoneda f a = Yoneda { getYoneda :: forall b. (a -> b) -> f b } 
-
-instance Functor (Yoneda f) where
-    fmap f m = Yoneda (\k -> getYoneda m (k . f))
-
-instance Pointed f => Pointed (Yoneda f) where
-    point a = Yoneda (\f -> point (f a))
-
-instance Applicative f => Applicative (Yoneda f) where
-    pure a = Yoneda (\f -> pure (f a))
-    m <*> n = Yoneda (\f -> getYoneda m (f .) <*> getYoneda n id)
-
-instance Alternative f => Alternative (Yoneda f) where
-    empty = Yoneda (const empty)
-    Yoneda m <|> Yoneda n = Yoneda (\f -> m f <|> n f)
-
-instance Monad f => Monad (Yoneda f) where
-    return a = Yoneda (\f -> return (f a))
-    m >>= k = Yoneda (\f -> getYoneda m id >>= \a -> getYoneda (k a) f)
-
-instance MonadPlus f => MonadPlus (Yoneda f) where
-    mzero = Yoneda (const mzero)
-    Yoneda m `mplus` Yoneda n = Yoneda (\f -> m f `mplus` n f)
-
-instance MonadTrans Yoneda where
-    lift m = Yoneda (\f -> liftM f m)
-
-instance MonadReader r f => MonadReader r (Yoneda f) where
-    ask = lift ask
-    local f = lift . local f . lowerYoneda 
-
-instance MonadWriter w f => MonadWriter w (Yoneda f) where
-    tell = lift . tell
-    listen = lift . listen . lowerYoneda
-    pass = lift . pass . lowerYoneda
-
-instance MonadState s f => MonadState s (Yoneda f) where
-    get = lift get
-    put = lift . put
-
-instance MonadIO f => MonadIO (Yoneda f) where
-    liftIO = lift . liftIO
-
-instance MonadRWS r w s f => MonadRWS r w s (Yoneda f)
-
-instance MonadError e f => MonadError e (Yoneda f) where
-    throwError = lift . throwError
-    catchError m h = lift $ lowerYoneda m `catchError` (lowerYoneda . h)
-
-instance MonadFix m => MonadFix (Yoneda m) where
-    mfix f = lift $ mfix (lowerYoneda . f)
-    
-lowerYoneda :: Yoneda f a -> f a 
-lowerYoneda (Yoneda f) = f id
-
rmfile ./Control/Monad/Yoneda.hs
hunk ./LICENSE 2
-Copyright (c) 2008 Matt Morrow
hunk ./monad-ran.cabal 2
-version:                0.0.8
+version:                0.0.9
}
