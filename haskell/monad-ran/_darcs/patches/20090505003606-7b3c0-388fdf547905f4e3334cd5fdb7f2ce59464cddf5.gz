[lots of codensity additions
ekmett@gmail.com**20090505003606
 Ignore-this: d89fc21b5c247851eb079d291a70cec1
] {
hunk ./Control/Monad/Ran.hs 40
-
hunk ./Control/Monad/Ran.hs 58
+apCodensity :: (RanIso m, G m ~ H m) => Ran m (a -> b) -> Ran m a -> Ran m b
+apCodensity (Ran f) (Ran x) = Ran (\k -> f (\f' -> x (k . f')))
+
hunk ./Control/Monad/Ran.hs 68
+-- Many state-like monads can be CPS transformed into a codensity monad.
hunk ./Control/Monad/Ran.hs 81
+liftRanCodensity :: Monad f => f a -> Ran (Codensity f) a
+liftRanCodensity f = Ran (f >>=)
+
+lowerRanCodensity :: Monad f => Ran (Codensity f) a -> f a 
+lowerRanCodensity (Ran f) = f return
+
hunk ./Control/Monad/Ran.hs 88
-    point = codensityRan . point
+    point = returnCodensity
hunk ./Control/Monad/Ran.hs 91
-    pure = codensityRan . pure
-    m <*> n = liftRan (lowerRan m <*> lowerRan n)
+    pure = returnCodensity
+    (<*>) = apCodensity
hunk ./Control/Monad/Ran.hs 95
-    return = liftRan . return
-    m >>= k = liftRan (lowerRan m >>= lowerRan . k)
+    return = returnCodensity
+    (>>=) = bindCodensity
hunk ./Control/Monad/Ran.hs 106
+instance MonadIO f => MonadIO (Ran (Codensity f)) where
+    liftIO f = Ran (liftIO f >>=)
+
+instance MonadState s m => MonadState s (Ran (Codensity m)) where
+    get = Ran (get >>=)
+    put s = Ran (put s >>=)
hunk ./Control/Monad/Ran.hs 113
+instance MonadWriter w m => MonadWriter w (Ran (Codensity m)) where
+    tell w = Ran (tell w >>=) 
+    listen = liftRanCodensity . listen . lowerRanCodensity
+    pass = liftRanCodensity . pass . lowerRanCodensity
+
+instance MonadReader r m => MonadReader r (Ran (Codensity m)) where
+    ask = Ran (ask >>=)
+    local f = liftRanCodensity . local f . lowerRanCodensity
+
+instance MonadRWS r w s m => MonadRWS r w s (Ran (Codensity m))
+    
+instance MonadFix m => MonadFix (Ran (Codensity m)) where
+    mfix f = liftRanCodensity $ mfix (lowerRanCodensity . f)
+
+instance MonadError e m => MonadError e (Ran (Codensity m)) where
+    throwError e = Ran (throwError e >>=)
+    m `catchError` h = liftRanCodensity (lowerRanCodensity m `catchError` (lowerRanCodensity . h))
hunk ./Control/Monad/Ran.hs 142
-    point = return
+    point = returnCodensity
hunk ./Control/Monad/Ran.hs 145
-    pure = return
-    (<*>) = ap
+    pure = returnCodensity
+    (<*>) = apCodensity
hunk ./Control/Monad/Ran.hs 149
-    return a = Ran (\k -> k a)
-    Ran m >>= k = Ran (\c -> m (\a -> getRan (k a) c))
-
+    return = returnCodensity
+    (>>=) = bindCodensity
hunk ./Control/Monad/Ran.hs 175
-    pure = return
-    (<*>) = ap
+    pure = returnCodensity
+    (<*>) = apCodensity
hunk ./Control/Monad/Ran.hs 193
-    pure = return
-    (<*>) = ap
+    pure = returnCodensity
+    (<*>) = apCodensity
hunk ./Control/Monad/Ran.hs 210
-    pure = return
-    (<*>) = ap
+    pure = returnCodensity
+    (<*>) = apCodensity
hunk ./Control/Monad/Ran.hs 220
--- note Endo is not a Hask Functor!
+-- note Endo is not a Hask Functor and Maybe is not a Codensity monad, so this is trickier
hunk ./Control/Monad/Ran.hs 224
-    liftRan Nothing  = mzero
-    liftRan (Just x) = return x
+    liftRan = maybe mzero return
hunk ./Control/Monad/Ran.hs 232
+instance Applicative (Ran Maybe) where
+    pure x = Ran (\k -> Endo (\_ -> runIdentity (k x)))
+    Ran f <*> Ran g = Ran (\k -> Endo (\z -> appEndo (f (\f' -> Identity (appEndo (g (k . f')) z))) z))
+
hunk ./Control/Monad/Ran.hs 238
---  Ran m `mplus` n = Ran (\k -> Endo (\z -> appEndo (getRan m k) (appEndo (getRan n k) z)))
+    Ran m `mplus` Ran n = Ran (\k -> Endo (\z -> appEndo (m k) (appEndo (n k) z)))
hunk ./Control/Monad/Ran.hs 240
-instance Monoid (Ran Maybe a) where
+-- as per Maybe, this Monoid turns a semigroup into a monoid
+instance Monoid a => Monoid (Ran Maybe a) where
hunk ./Control/Monad/Ran.hs 243
-    mappend = mplus
+    Ran a `mappend` Ran b = Ran (\k -> Endo (\z -> appEndo (a (\a' -> Identity (appEndo (b (k . mappend a')) z))) z))
hunk ./Control/Monad/Ran.hs 247
-data ErrorH b r  = ErrorH { getErrorH :: (b -> r) -> r } 
-data ErrorTH b m r = ErrorTH { getErrorTH :: (b -> G m r) -> H m r }
+data ErrorH e o  = ErrorH { getErrorH :: (e -> o) -> o } 
+data ErrorTH e m o = ErrorTH { getErrorTH :: (e -> G m o) -> H m o }
hunk ./Control/Monad/Ran.hs 251
--- Yoneda (ErrorH e) ~ forall o. (a -> o) -> (e -> o) -> o
+-- Yoneda (ErrorH e) ~ forall o. (a -> o) -> (e -> o) -> o ~ forall o. (a -> Identity o) -> (e -> o) -> o ~ forall o. (a -> Identity o) -> ErrorH e o
hunk ./Control/Monad/Ran.hs 255
-    liftRan (Right x) = Ran (\k -> ErrorH (\_ -> runIdentity (k x)))
-    liftRan (Left x) = Ran (\_ -> ErrorH (\e -> e x))
-    lowerRan (Ran f) = getErrorH (f (Identity . Right)) Left
+    liftRan (Right a) = Ran (\k -> ErrorH (\_ -> runIdentity (k a)))
+    liftRan (Left x)  = Ran (\_ -> ErrorH (\e -> e x))
+    lowerRan          = eitherRan Left Right
+
+eitherRan :: (e -> b) -> (a -> b) -> Ran (Either e) a -> b
+eitherRan f g (Ran m) = getErrorH (m (Identity . g)) f
hunk ./Control/Monad/Ran.hs 265
---  m >>= k = Ran (\c -> ErrorH (\e -> m (\a -> getErrorH (getRan (k a) c) e)))
+    Ran g >>= f = Ran (\k -> ErrorH (\z -> getErrorH (g (\a -> Identity (getErrorH (getRan (f a) k) z))) z))
hunk ./Control/Monad/Ran.hs 270
+--  catchError :: Ran (Either e) a -> (e -> Ran (Either e) a -> Ran (Either e) a
+    Ran m `catchError` h = Ran (\k -> ErrorH (\z -> getErrorH (m k) (\e -> getErrorH (getRan (h e) k) z)))
hunk ./Control/Monad/Ran.hs 275
+    Ran m `mplus` Ran n = Ran (\k -> ErrorH (\z -> getErrorH (m k) (\_ -> getErrorH (n k) z)))
hunk ./Control/Monad/Ran.hs 405
---    Ran f `catchError` h = Yoneda (liftRan . (`catchError` h) . f)
-
--- instance MonadFix m => MonadFix (Ran (Yoneda m)) where
---    mfix = liftRan . mfix . lowerRan
+    Ran f `catchError` h = Ran (\k -> f k `catchError` \e -> getRan (h e) k)
hunk ./Control/Monad/Ran.hs 407
+instance MonadFix m => MonadFix (Ran (Yoneda m)) where
+    mfix f = Ran (\k -> liftM (runIdentity . k) $ mfix (\a -> getRan (f a) Identity))
}
