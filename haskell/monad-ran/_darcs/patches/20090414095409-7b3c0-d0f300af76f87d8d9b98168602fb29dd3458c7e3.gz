[added yoneda lemma
ekmett@gmail.com**20090414095409
 Ignore-this: d2dfe7cae6ad9a91d7ec71d9c55e3fef
] {
hunk ./Control/Monad/Ran.hs 31
--- | The Yoneda lemma
+
+
+
+
+-- | A right Kan extension transformer for a monad
+data Ran m a = Ran { getRan :: forall b. (a -> G m b) -> H m b } 
+
+instance RMonad m => Functor (Ran m) where
+    fmap f m = Ran (\k -> getRan m (k . f))
+
+class (Monad (Ran f), Monad f) => RMonad f where
+    type G f    :: * -> *
+    type H f    :: * -> *
+    toRan      :: f a -> Ran f a
+    fromRan    :: Ran f a -> f a
+
+
+
+-- | The Yoneda lemma, TODO: just improve the category extras definition?
hunk ./Control/Monad/Ran.hs 64
+instance MonadPlus f => MonadPlus (Yoneda f) where
+    mzero = Yoneda (\_ -> mzero)
+    Yoneda m `mplus` Yoneda n = Yoneda (\f -> m f `mplus` n f)
+
hunk ./Control/Monad/Ran.hs 71
+instance MonadReader r f => MonadReader r (Yoneda f)
+
+instance MonadWriter w f => MonadWriter w (Yoneda f)
+
+instance MonadState s f => MonadState s (Yoneda f)
+
+instance MonadRWS r w s f => MonadRWS r w s (Yoneda f)
+
+instance MonadError e f => MonadError e (Yoneda f)
+
+instance MonadCont f => MonadCont (Yoneda f)
+
hunk ./Control/Monad/Ran.hs 86
+-- Ran (Yoneda f) a ~ forall o. (a -> Identity o) -> f o 
+instance Monad f => RMonad (Yoneda f) where
+    type G (Yoneda f) = Identity
+    type H (Yoneda f) = f
+    toRan (Yoneda f) = Ran (\b -> f (runIdentity . b))
+    fromRan (Ran f) = Yoneda (\b -> f (Identity . b))
+
+ranYoneda :: Monad f => Ran (Yoneda f) a -> Yoneda f a
+ranYoneda = fromRan
+
+yonedaRan :: Monad f => Yoneda f a -> Ran (Yoneda f) a
+yonedaRan = toRan
+
+-- TODO: break up RMonad into RFunctor...
+instance (Applicative f, Monad f) => Applicative (Ran (Yoneda f)) where
+    pure = yonedaRan . pure
+    m <*> n = yonedaRan (ranYoneda m <*> ranYoneda n)
+
+instance Monad f => Monad (Ran (Yoneda f)) where
+    return = yonedaRan . return
+    m >>= k = yonedaRan (ranYoneda m >>= ranYoneda . k)
+
+instance MonadPlus f => MonadPlus (Ran (Yoneda f)) where
+    mzero = yonedaRan mzero
+    m `mplus` n = yonedaRan (ranYoneda m `mplus` ranYoneda n)
+
hunk ./Control/Monad/Ran.hs 138
--- | A right Kan extension transformer for a monad
-data Ran m a = Ran { getRan :: forall b. (a -> G m b) -> H m b } 
-
-instance RMonad m => Functor (Ran m) where
-    fmap f m = Ran (\k -> getRan m (k . f))
-
-class (Monad (Ran f), Monad f) => RMonad f where
-    type G f    :: * -> *
-    type H f    :: * -> *
-    toRan      :: f a -> Ran f a
-    fromRan    :: Ran f a -> f a
-
hunk ./Control/Monad/Ran.hs 144
--- Yoneda Identity ~ Codensity Identity
--- forall o. (a -> o) -> o
+-- Yoneda Identity a ~ Codensity Identity a ~ forall o. (a -> o) -> o
hunk ./Control/Monad/Ran.hs 151
+instance Applicative (Ran Identity) where
+    pure = return
+    (<*>) = ap
+
hunk ./Control/Monad/Ran.hs 159
+
hunk ./Control/Monad/Ran.hs 164
-    toRan = maybe mempty return 
-    fromRan f = appEndo (getRan f (Identity . return)) mempty
+    toRan = maybe mzero return 
+    fromRan f = appEndo (getRan f (Identity . return)) mzero
hunk ./Control/Monad/Ran.hs 169
-    Ran m >>= k = Ran (\c -> Endo (\z -> m (\a -> appEndo (getRan (k a) c) z)))
-    fail = mempty
+--  Ran m >>= k = Ran (\c -> Endo (\z -> m (\a -> appEndo (getRan (k a) c) z)))
+    fail _ = mzero
hunk ./Control/Monad/Ran.hs 174
-    Ran m `mplus` n = Ran (\k -> Endo (\z -> appEndo (getRan m k) (appEndo (getRan n k) z)))
+--  Ran m `mplus` n = Ran (\k -> Endo (\z -> appEndo (getRan m k) (appEndo (getRan n k) z)))
+
+instance Monoid (Ran Maybe a) where
+    mempty = mzero
+    mappend = mplus
hunk ./Control/Monad/Ran.hs 183
-    type H (Either e) = ErrorH b
+    type H (Either e) = ErrorH e
hunk ./Control/Monad/Ran.hs 193
-instance Error e => MonadError (Ran (Either e)) where
+instance Error e => MonadError e (Ran (Either e)) where
hunk ./Control/Monad/Ran.hs 200
-    
-
-
+{-
hunk ./Control/Monad/Ran.hs 208
--- Yoneda f
--- Ran (Yoneda f) forall o. (a -> Identity o) -> f o 
-instance Monad f => RMonad (Yoneda f) where
-    type G (Yoneda f) = Identity
-    type H (Yoneda f) = f
-    toRan (Yoneda f) = Ran (\b -> f (runIdentity . b))
-    fromRan (Ran f) = Yoneda (\b -> f (Identity . b))
hunk ./Control/Monad/Ran.hs 272
+-}
hunk ./monad-ran.cabal 25
-                        GeneralizedNewtypeDeriving
+                        GeneralizedNewtypeDeriving,
+                        UndecidableInstances
}
