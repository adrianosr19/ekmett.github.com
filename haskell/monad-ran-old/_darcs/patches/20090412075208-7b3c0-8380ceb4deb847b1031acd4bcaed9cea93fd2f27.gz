[Transformed to resemble the MTL, added Codensity, added alternative State and Writer, added RWS, included license
ekmett@gmail.com**20090412075208
 Ignore-this: 30a18c00903599fae3d1f0d80aed7835
] {
move ./src/Control/Monad/CPS/C.hs ./src/Control/Monad/CPS/Cont.hs
move ./src/Control/Monad/CPS/Id.hs ./src/Control/Monad/CPS/Identity.hs
move ./src/Control/Monad/CPS/R.hs ./src/Control/Monad/CPS/Reader.hs
move ./src/Control/Monad/CPS/S.hs ./src/Control/Monad/CPS/State.hs
move ./src/Control/Monad/CPS/W.hs ./src/Control/Monad/CPS/Writer.hs
hunk ./LICENSE 1
-Copyright (c) Matt Morrow.
-BSD3
+Copyright (c) 2009 Edward Kmett
+Copyright (c) 2008 Matt Morrow
+All rights reserved.
+
+Redistribution and use in source and binary forms, with or without
+modification, are permitted provided that the following conditions are
+met:
+
+    * Redistributions of source code must retain the above copyright
+      notice, this list of conditions and the following disclaimer.
+
+    * Redistributions in binary form must reproduce the above
+      copyright notice, this list of conditions and the following
+      disclaimer in the documentation and/or other materials provided
+      with the distribution.
+
+    * Neither the name of Isaac Jones nor the names of other
+      contributors may be used to endorse or promote products derived
+      from this software without specific prior written permission.
+
+THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+"AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
+A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
+OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
+SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
+LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
+OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
hunk ./monad-cps.cabal 2
-version:            0.0.1
+version:            0.0.2
hunk ./monad-cps.cabal 8
-author:             Matt Morrow
-copyright:          (c) Matt Morrow 2008
-maintainer:         Matt Morrow <mjm2002@gmail.com>
+author:             Matt Morrow, Edward Kmett
+copyright:          (c) Matt Morrow 2008, (c) Edward Kmett 2009
+maintainer:         Edward Kmett <ekmett@gmail.com>
hunk ./monad-cps.cabal 17
-  ghc-options:      -O2 -fglasgow-exts
-  extensions:
+  ghc-options:      -O2
+  build-depends:    mtl >= 1.1 && < 1.2
+  extensions:       MultiParamTypeClasses, 
+                    FlexibleContexts,
+                    FlexibleInstances,
+                    Rank2Types, 
+                    GeneralizedNewtypeDeriving
hunk ./monad-cps.cabal 26
-                    Control.Monad.CPS.Id,
-                    Control.Monad.CPS.R,
-                    Control.Monad.CPS.W,
-                    Control.Monad.CPS.S,
-                    Control.Monad.CPS.C
-
-
-
-
-
-
+                    Control.Monad.CPS.Identity,
+                    Control.Monad.CPS.Reader,
+                    Control.Monad.CPS.Writer,
+                    Control.Monad.CPS.State,
+                    Control.Monad.CPS.Cont,
+                    Control.Monad.CPS.Codensity,
+                    Control.Monad.CPS.Ran,
+                    Control.Monad.CPS.RWS
hunk ./src/Control/Monad/CPS.hs 1
+module Control.Monad.CPS 
+    ( module Control.Monad.CPS.Identity
+    , module Control.Monad.CPS.Reader
+    , module Control.Monad.CPS.Writer
+    , module Control.Monad.CPS.State
+    , module Control.Monad.CPS.Cont
+    , module Control.Monad.CPS.Codensity
+    , module Control.Monad.CPS.Ran
+    ) where
hunk ./src/Control/Monad/CPS.hs 11
-module Control.Monad.CPS (
-    module Control.Monad.CPS.Id
-  , module Control.Monad.CPS.R
-  , module Control.Monad.CPS.W
-  , module Control.Monad.CPS.S
-  , module Control.Monad.CPS.C
-) where
-
-import Control.Monad.CPS.Id
-import Control.Monad.CPS.R
-import Control.Monad.CPS.W
-import Control.Monad.CPS.S
-import Control.Monad.CPS.C
+import Control.Monad.CPS.Identity
+import Control.Monad.CPS.Reader
+import Control.Monad.CPS.Writer
+import Control.Monad.CPS.State
+import Control.Monad.CPS.Cont
+import Control.Monad.CPS.Codensity
+import Control.Monad.CPS.Ran
addfile ./src/Control/Monad/CPS/Codensity.hs
hunk ./src/Control/Monad/CPS/Codensity.hs 1
+module Control.Monad.CPS.Codensity
+    ( Codensity(Codensity, unCodensity)
+    , runCodensity, runCodensityApp
+    ) where
+
+import Control.Monad
+import Control.Monad.Trans
+import Control.Applicative
+
+newtype Codensity f a = Codensity { unCodensity :: forall o. (a -> f o) -> f o }
+
+instance Functor (Codensity f) where
+    fmap f (Codensity g) = Codensity (\k -> g (\a -> k (f a)))
+
+instance Applicative (Codensity f) where
+    pure = return
+    (<*>) = ap 
+
+instance Monad (Codensity f) where
+    return a = Codensity (\k -> k a)
+    Codensity g >>= f = Codensity (\k -> g (\a -> unCodensity (f a) k))
+
+runCodensity :: Monad f => Codensity f a -> f a
+runCodensity (Codensity f) = f return
+
+runCodensityApp :: Applicative f => Codensity f a -> f a
+runCodensityApp (Codensity f) = f pure
+
+instance MonadTrans Codensity where
+    lift m = Codensity (m >>=)
hunk ./src/Control/Monad/CPS/Cont.hs 1
+module Control.Monad.CPS.Cont 
+    ( Cont
+    , runCont
+    , idCont
+    , mapCont
+    , withCont
+    , shift
+    , reset
+    , module Control.Monad.Cont.Class
+    ) where
hunk ./src/Control/Monad/CPS/Cont.hs 12
+import Control.Monad
+import Control.Monad.Cont.Class
hunk ./src/Control/Monad/CPS/Cont.hs 15
-module Control.Monad.CPS.C (
-  module Control.Monad.CPS.C
-) where
+newtype Cont r a = Cont {unCont :: forall o. (a -> r) -> (r -> o) -> o}
hunk ./src/Control/Monad/CPS/Cont.hs 17
-newtype C r a = C {unC :: forall o. (a -> r) -> (r -> o) -> o}
+instance Functor (Cont r) where
+  fmap f (Cont g) = Cont (\k -> g (k . f))
hunk ./src/Control/Monad/CPS/Cont.hs 20
-instance Functor (C r) where
-  fmap f (C g) = C (\k z -> g (k . f) z)
+instance Monad (Cont r) where
+  return a = Cont (\k z -> z (k a))
+  Cont g >>= f = Cont (\k -> g (\a -> unCont (f a) k id))
hunk ./src/Control/Monad/CPS/Cont.hs 24
-instance Monad (C r) where
-  return a = C (\k z -> z (k a))
-  C g >>= f = C (\k z -> g (\a -> unC (f a) k id) z)
-  -- C g >>= f = C (\k z -> g (\a -> unC (f a) k z) id
+runCont :: Cont r a -> (a -> r) -> r
+runCont (Cont g) = flip g id
hunk ./src/Control/Monad/CPS/Cont.hs 27
-runC :: C r a -> (a -> r) -> r
-runC (C g) = flip g id
+idCont :: Cont a a -> a
+idCont = flip runCont id
hunk ./src/Control/Monad/CPS/Cont.hs 30
-idC :: C a a -> a
-idC = flip runC id
+mapCont :: (r -> r) -> Cont r a -> Cont r a
+mapCont f (Cont g) = Cont (\k -> g (f . k))
+-- mapCont f (Cont g) = Cont (\k z -> g k (z . f))
hunk ./src/Control/Monad/CPS/Cont.hs 34
-mapC :: (r -> r) -> C r a -> C r a
-mapC f (C g) = C (\k z -> g (f . k) z)
--- mapC f (C g) = C (\k z -> g k (z . f))
-
-withC :: ((b -> r) -> (a -> r)) -> C r a -> C r b
-withC f (C g) = C (\k z -> g (f k) z)
-
-callCC :: ((a -> (forall b. C r b)) -> C r a) -> C r a
-callCC f = C (\k z -> unC (f (\a -> C (\_ h -> (h . k) a))) k z)
-
-shift  :: ((a -> (forall s. C s r)) -> C r r) -> C r a
-shift f = C (\k z -> unC (f (\a -> C (\e h -> (h . e . k) a))) id z)
-
-reset :: C a a -> C r a
-reset m = C (\k z -> (z . k) (runC m id))
+withCont :: ((b -> r) -> (a -> r)) -> Cont r a -> Cont r b
+withCont f (Cont g) = Cont (g . f)
+-- withCont f (Cont g) = Cont (\k -> g (f k))
hunk ./src/Control/Monad/CPS/Cont.hs 38
+instance MonadCont (Cont r) where
+    callCC f = Cont (\k -> unCont (f (\a -> Cont (\_ h -> (h . k) a))) k)
hunk ./src/Control/Monad/CPS/Cont.hs 41
+shift  :: ((a -> Cont s r) -> Cont r r) -> Cont r a
+shift f = Cont (\k -> unCont (f (\a -> Cont (\e h -> (h . e . k) a))) id)
hunk ./src/Control/Monad/CPS/Cont.hs 44
+reset :: Cont a a -> Cont r a
+reset m = Cont (\k z -> (z . k) (runCont m id))
hunk ./src/Control/Monad/CPS/Identity.hs 1
+module Control.Monad.CPS.Identity 
+    ( Identity(Identity, unIdentity)
+    , runIdentity
+    ) where
hunk ./src/Control/Monad/CPS/Identity.hs 6
+import Control.Monad
+import Control.Applicative
hunk ./src/Control/Monad/CPS/Identity.hs 9
-module Control.Monad.CPS.Id (
-  module Control.Monad.CPS.Id
-) where
+newtype Identity a = Identity {unIdentity :: forall o. (a -> o) -> o}
hunk ./src/Control/Monad/CPS/Identity.hs 11
-newtype Id a = Id {unId :: forall o. (a -> o) -> o}
+instance Functor Identity where
+--  fmap f (Identity g) = Identity (\k -> g (\a -> k (f a)))
+    fmap f (Identity g) = Identity (\k -> g (k . f))
hunk ./src/Control/Monad/CPS/Identity.hs 15
-instance Functor Id where
-  fmap f (Id g) = Id (\k -> g (\a -> k (f a)))
+instance Applicative Identity where
+    pure = return
+    (<*>) = ap
hunk ./src/Control/Monad/CPS/Identity.hs 19
-instance Monad Id where
-  return a = Id (\k -> k a)
-  Id g >>= f = Id (\k -> g (\a -> unId (f a) k))
-
-runId :: Id a -> a
-runId = flip unId id
+instance Monad Identity where
+    return a = Identity (\k -> k a)
+    Identity g >>= f = Identity (\k -> g (\a -> unIdentity (f a) k))
hunk ./src/Control/Monad/CPS/Identity.hs 23
+runIdentity :: Identity a -> a
+runIdentity (Identity f) = f id
addfile ./src/Control/Monad/CPS/RWS.hs
hunk ./src/Control/Monad/CPS/RWS.hs 1
+{-# LANGUAGE MagicHash, UnboxedTuples #-}
+module Control.Monad.CPS.RWS 
+    ( RWS(RWS,unRWS)
+    , runRWS
+    ) where
+
+import Data.Monoid (Monoid(..))
+import Control.Monad.RWS.Class
+
+newtype RWS r w s a = RWS { unRWS :: forall o. (a -> w -> s -> o) -> r -> s -> o }
+
+instance Monoid w => Functor (RWS r w s) where
+    fmap f (RWS g) = RWS (\k -> g (\a -> k (f a)))
+
+--instance Monoid w => Applicative (RWS r w s) where
+--    pure a = RWS (\k _ -> k a mempty)
+--    RwS f <*> RWS x = RWS (\k r -> f (\f' s' w -> x (\x' s'' w' -> k (f' x') s'' (w `mappend` w')) r s'))
+
+instance Monoid w => Monad (RWS r w s) where
+    return a = RWS (\k _ -> k a mempty)
+    RWS g >>= f = RWS (\k r -> g (\a w -> unRWS (f a) (\b w' -> k b (w `mappend` w')) r) r)
+
+runRWS :: RWS r w s a -> r -> s -> (a, w, s)
+runRWS (RWS f) = f (,,)
+
+instance Monoid w => MonadState s (RWS r w s) where
+    get = RWS (\ k r s -> k s mempty s)
+    put s = RWS (\k _ _ -> k () mempty s)
+
+instance Monoid w => MonadWriter w (RWS r w s) where
+    tell w = RWS (\k _ -> k () w)
+    listen (RWS f) = RWS (\k -> f (\a w -> k (a,w) w))
+    pass (RWS f) = RWS (\k -> f (\(a,p) w -> k a (p w)))
+
+instance Monoid w => MonadReader r (RWS r w s) where
+    ask = RWS (\k r -> k r mempty)
+    local f (RWS g) = RWS (\k r -> g k (f r))
addfile ./src/Control/Monad/CPS/Ran.hs
hunk ./src/Control/Monad/CPS/Ran.hs 1
+module Control.Monad.CPS.Ran
+    ( Ran(Ran,runRan)
+    ) where
+
+newtype Ran g h a = Ran { runRan :: forall b. (a -> g b) -> h b } 
+
+instance Functor (Ran g h) where
+    fmap f m = Ran (\k -> runRan m (k . f))
hunk ./src/Control/Monad/CPS/Reader.hs 1
+module Control.Monad.CPS.Reader 
+    ( module Control.Monad.Reader.Class
+    , Reader(Reader, unReader)
+    , runReader 
+    ) where
hunk ./src/Control/Monad/CPS/Reader.hs 7
+import Control.Applicative
+import Control.Monad
+import Control.Monad.Reader.Class
hunk ./src/Control/Monad/CPS/Reader.hs 11
-module Control.Monad.CPS.R (
-  module Control.Monad.CPS.R
-) where
+newtype Reader r a = Reader { unReader :: forall o. (a -> o) -> r -> o }
hunk ./src/Control/Monad/CPS/Reader.hs 13
-newtype R r a = R {unR :: forall o. r -> (a -> o) -> o}
+instance Functor (Reader r) where
+    fmap f (Reader g) = Reader (\k -> g (\a -> k (f a)))
hunk ./src/Control/Monad/CPS/Reader.hs 16
-instance Functor (R r) where
-  fmap f (R g) = R (\r k -> g r (\a -> k (f a)))
+instance Monad (Reader r) where
+    return a = Reader (\k _ -> k a)
+    Reader g >>= f = Reader (\k r -> g (\a -> unReader (f a) k r) r)
hunk ./src/Control/Monad/CPS/Reader.hs 20
-instance Monad (R r) where
-  return a = R (\_ k -> k a)
-  R g >>= f = R (\r k -> g r (\a -> unR (f a) r k))
-
-runR :: R r a -> r -> a
-runR (R g) = flip g id
-
-ask :: R r r
-ask = R (\r k -> k r)
-
-asks :: (r -> a) -> R r a
-asks f = R (\r k -> (k . f) r)
-
-local :: (r -> r) -> R r a -> R r a
-local f (R g) = R (\r k -> g (f r) k)
+runReader :: Reader r a -> r -> a
+runReader (Reader g) = g id
hunk ./src/Control/Monad/CPS/Reader.hs 23
+instance MonadReader r (Reader r) where
+    ask = Reader id
+    local f (Reader g) = Reader (\k -> g k . f)
hunk ./src/Control/Monad/CPS/State.hs 1
+{-# LANGUAGE MagicHash, UnboxedTuples #-}
+module Control.Monad.CPS.State 
+    ( module Control.Monad.State.Class
+    , State
+    , runState
+    , State'
+--    , runState'
+    ) where
hunk ./src/Control/Monad/CPS/State.hs 10
+import Control.Monad
+import Control.Monad.CPS.Codensity
+import Control.Monad.State.Class
+import Control.Applicative
hunk ./src/Control/Monad/CPS/State.hs 15
-module Control.Monad.CPS.S (
-  module Control.Monad.CPS.S
-) where
+newtype State s a = State { unState :: forall o. (a -> s -> o) -> s -> o }
hunk ./src/Control/Monad/CPS/State.hs 17
-newtype S s a = S {unS :: forall o. s -> (s -> a -> o) -> o}
+instance Functor (State s) where
+  fmap f (State g) = State (\k -> g (\a -> k (f a)))
hunk ./src/Control/Monad/CPS/State.hs 20
-instance Functor (S s) where
-  fmap f (S g) = S (\s k -> g s (\s a -> k s (f a)))
+instance Applicative (State s) where
+  pure = return
+  (<*>) = ap
hunk ./src/Control/Monad/CPS/State.hs 24
-instance Monad (S s) where
-  return a = S (\s k -> k s a)
-  S g >>= f = S (\s k -> g s (\s a -> unS (f a) s k))
+instance Monad (State s) where
+  return a = State (\k -> k a)
+  State g >>= f = State (\k -> g (\a -> unState (f a) k))
hunk ./src/Control/Monad/CPS/State.hs 28
-runS :: S s a -> s -> (a, s)
-runS (S g) = flip g (flip (,))
+runState :: State s a -> s -> (a, s)
+runState (State g) = g (,)
hunk ./src/Control/Monad/CPS/State.hs 31
-get :: S s s
-get = S (\s k -> k s s)
+instance MonadState s (State s) where
+    get   = State (\k s -> k s s)
+    put s = State (\k _ -> k () s)
hunk ./src/Control/Monad/CPS/State.hs 35
-gets :: (s -> a) -> S s a
-gets f = S (\s k -> k s (f s))
+newtype State' s a = State' { unState' :: Codensity ((->)s) a }
+    deriving (Functor,Applicative,Monad)
hunk ./src/Control/Monad/CPS/State.hs 38
-set :: s -> S s ()
-set s = S (\_ k -> k s ())
-
-modify :: (s -> s) -> S s ()
-modify f = S (\s k -> k (f s) ())
+instance MonadState s (State' s) where
+    get = State' (Codensity (\k s -> k s s))
+    put s = State' (Codensity (\k s -> k () s))
hunk ./src/Control/Monad/CPS/State.hs 42
+-- runState' :: State' s a -> s -> (a,s)
+-- runState' (State' g) = runCodensity g (,)
hunk ./src/Control/Monad/CPS/Writer.hs 1
+{-# LANGUAGE MagicHash, UnboxedTuples #-}
+module Control.Monad.CPS.Writer 
+    ( module Control.Monad.Writer.Class
+    , Writer(Writer, unWriter)
+    , runWriter
+    , Writer'
+    , runWriter'
+    ) where
hunk ./src/Control/Monad/CPS/Writer.hs 10
+import Control.Applicative
+import Control.Monad
+import Control.Monad.Writer.Class
+import Data.Monoid (Monoid(..))
hunk ./src/Control/Monad/CPS/Writer.hs 15
-module Control.Monad.CPS.W (
-  module Control.Monad.CPS.W
-) where
+-- CPS transformed writer, with all of the traditional mempty mappend baggage
+newtype Writer w a = Writer { unWriter :: forall o. (a -> w -> o) -> o }
hunk ./src/Control/Monad/CPS/Writer.hs 18
-import Data.Monoid (Monoid(..))
+instance Functor (Writer w) where
+    fmap f (Writer g) = Writer (\k -> g (\a w -> k (f a) w))
+
+instance Monoid w => Applicative (Writer w) where
+    pure = return
+    (<*>) = ap 
+
+instance Monoid w => Monad (Writer w) where
+    return a = Writer (\k -> k a mempty)
+    Writer g >>= f = Writer (\k -> g (\a w -> unWriter (f a) (\a w' -> k a (w `mappend` w'))))
+
+runWriter :: Writer w a -> (a, w)
+runWriter (Writer g) = g (,)
+
+instance Monoid w => MonadWriter w (Writer w) where
+    tell w = Writer (\k -> k () w)
+    listen (Writer f) = Writer (\g -> f (\a w -> g (a,w) w))
+    pass (Writer f) = Writer (\g -> f (\(a,p) w -> g a (p w)))
hunk ./src/Control/Monad/CPS/Writer.hs 37
-newtype W w a = W {unW :: forall o. (a -> w -> o) -> o}
+-- writer as CPS transformed state, only pays for mappend when actually writing
+newtype Writer' w a = Writer' { unWriter' :: forall o. (a -> w -> o) -> w -> o }
hunk ./src/Control/Monad/CPS/Writer.hs 40
-instance Functor (W w) where
-  fmap f (W g) = W (\k -> g (\a w -> k (f a) w))
+instance Monoid w => Functor (Writer' w) where
+  fmap f (Writer' g) = Writer' (\k -> g (\a -> k (f a)))
hunk ./src/Control/Monad/CPS/Writer.hs 43
-instance (Monoid w) => Monad (W w) where
-  return a = W (\k -> k a mempty)
-  W g >>= f = W (\k -> g (\a w -> unW (f a) (\a w' -> k a (w`mappend`w'))))
+instance Monoid w => Applicative (Writer' w) where
+    pure = return
+    (<*>) = ap 
hunk ./src/Control/Monad/CPS/Writer.hs 47
-runW :: W w a -> (a, w)
-runW (W g) = g (,)
+instance Monoid w => Monad (Writer' w) where
+  return a = Writer' (\k -> k a)
+  Writer' g >>= f = Writer' (\k -> g (\a -> unWriter' (f a) k))
hunk ./src/Control/Monad/CPS/Writer.hs 51
-put :: w -> W w ()
-put w = W (\k -> k () w)
+runWriter' :: Monoid w => Writer' w a -> (a, w)
+runWriter' (Writer' g) = g (,) mempty
hunk ./src/Control/Monad/CPS/Writer.hs 54
+instance Monoid w => MonadWriter w (Writer' w) where
+    tell w' = Writer' (\k w -> k () (w `mappend` w')) 
+    listen (Writer' f) = Writer' (\k -> f (\a w -> k (a,w) w))
+    pass (Writer' f) = Writer' (\k -> f (\(a,p) w -> k a (p w)))
}
