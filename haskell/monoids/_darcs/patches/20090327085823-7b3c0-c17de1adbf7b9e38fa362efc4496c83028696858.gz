[change of the way we store Data.Ring to move more into the single namespace
ekmett@gmail.com**20090327085823] {
adddir ./Data/Ring
adddir ./Data/Ring/Semi
addfile ./Data/Ring/Bool.hs
hunk ./Data/Ring/Bool.hs 1
+{-# OPTIONS_GHC -fno-warn-orphans #-}
+module Data.Ring.Bool
+    ( module Data.Ring
+    ) where
+
+import Data.Ring
addfile ./Data/Ring/FromNum.hs
hunk ./Data/Ring/FromNum.hs 1
+{-# LANGUAGE FlexibleInstances, FlexibleContexts, MultiParamTypeClasses, GeneralizedNewtypeDeriving #-}
+module Data.Ring.FromNum 
+    ( module Data.Ring
+    , FromNum(FromNum, getFromNum)
+    ) where
+
+import Data.Ring
+import Data.Monoid.Reducer
+
+newtype FromNum a = FromNum { getFromNum :: a } deriving (Eq,Show,Num)
+
+instance Num a => Monoid (FromNum a) where
+    mempty = fromInteger 0
+    mappend = (+)
+
+instance Num a => Group (FromNum a) where
+    minus = (-)
+    gnegate = negate
+    
+instance Num a => MultiplicativeMonoid (FromNum a) where
+    one = fromInteger 1
+    times = (*)
+
+instance Num a => Seminearring (FromNum a)
+    
+instance Num a => Reducer Integer (FromNum a) where
+    unit = fromInteger
addfile ./Data/Ring/Semi.hs
hunk ./Data/Ring/Semi.hs 1
+{-# OPTIONS_GHC -fno-warn-orphans #-}
+module Data.Semiring
+    ( module Data.Seminearring
+    ) where
+
+import Data.Seminearring
+
+class Seminearring a => Semiring a
+
addfile ./Data/Ring/Semi/Near.hs
hunk ./Data/Ring/Semi/Near.hs 1
+module Data.Ring.Semi.Near
+    ( module Data.Monoid.Multiplicative
+    , Seminearring
+    ) where
+
+import Data.Monoid.Multiplicative
+import Data.FingerTree
+import Data.Monoid.FromString
+import Data.Monoid.Monad.Identity
+import Data.Monoid.Generator
+import qualified Data.Sequence as Seq
+import Data.Sequence (Seq)
+
+class (MultiplicativeMonoid m, Monoid m) => Seminearring m 
+instance Monoid m => Seminearring [m]
+instance Monoid m => Seminearring (Seq m)
+instance (Measured v m, Monoid m) => Seminearring (FingerTree v m)
+instance Seminearring m => Seminearring (Identity m)
+instance Seminearring m => Seminearring (FromString m)
addfile ./Data/Ring/Semi/Ord.hs
hunk ./Data/Ring/Semi/Ord.hs 1
+----------------------------------------------------------------------
+---- |
+---- Module      :  Data.Ring.Semi.Ord
+---- Copyright   :  (c) Edward Kmett 2009, Conal Elliott 2008
+---- License     :  BSD3
+---- 
+---- Maintainer  :  ekmett@gmail.com
+---- Stability   :  experimental
+---- 
+---- ordered types as semi-rings
+------------------------------------------------------------------------
+
+module Data.Ring.Semi.Ord
+    ( module Data.Ring.Semi
+    , Order(Order,getOrder)
+    , Priority(MinBound,Priority,MaxBound)
+    ) where
+
+import Test.QuickCheck
+import Data.Ring.Semi
+import Data.Monoid.Ord
+import Data.Monoid.Reducer
+
+newtype a = Order { getOrder :: a } deriving (Eq,Ord,Read,Show,Bounded,Ord,Arbitrary)
+
+instance (Bounded a, Ord a) => Monoid (Order a) where
+    mappend = max
+    mempty = minBound
+
+instance (Bounded a, Ord a) => MultiplicativeMonoid (Order a) where
+    times = min
+    one = maxBound
+    
+instance (Bounded a, Ord a) => Seminearring (Order a)
+instance (Bounded a, Ord a) => Semiring (Order a)
+
+instance (Bounded a, Ord a) => Reducer a (Order a) where
+    unit = Order
+
+instance Functor Order where
+    fmap f (Order a) = Order (f a)
+
+instance Pointed Order where
+    point = Order
+
+instance Copointed Order where
+    extract = getOrder
+
+newtype Priority a = MinBound | Priority a | MaxBound deriving (Eq,Read,Show)
+
+instance Bounded (Priority a) where
+    minBound = MinBound
+    maxBound = MaxBound
+
+instance Ord a => Ord (Priority a) where
+  MinBound   <= _         = True
+  Priority _ <= MinBound  = False
+  Priority a <= Priority b = a <= b
+  Priority _ <= MaxBound  = True
+  MaxBound   <= MaxBound  = True
+  MaxBound   <= _         = False
+
+  MinBound   `min` _          = MinBound
+  _          `min` MinBound   = MinBound
+  Priority a `min` Priority b = Priority (a `min` b)
+  u          `min` MaxBound   = u
+  MaxBound   `min` v          = v
+  
+  MinBound   `max` v          = v
+  u          `max` MinBound   = u
+  Priority a `max` Priority b = Priority (a `max` b)
+  _          `max` MaxBound   = MaxBound
+  MaxBound   `max` _          = MaxBound
+
+instance Arbitrary a => Arbitrary (Priority a) where
+  arbitrary = frequency [ (1 ,pure MinBound)
+                        , (10, Priority <$> arbitrary)
+                        , (1 ,pure MaxBound) ]
+  coarbitrary MinBound    = variant 0
+  coarbitrary (Priority a) = variant 1 . coarbitrary a
+  coarbitrary MaxBound    = variant 2
+
+instance Ord a => Monoid (Priority a) where
+    mappend = max
+    mempty = minBound
+
+instance Ord a => MultiplicativeMonoid (Priority a) where
+    times = min
+    one = maxBound
+
+instance Ord a => Seminearring (Priority a)
+instance Ord a => Semiring (Priority a)
+
+instance Ord a => Reducer a (Priority a) where
+    unit = Reducer
+
+instance Ord a => Reducer (MinPriority a) (Priority a) where
+    unit (MinPriority Nothing)  = MaxBound
+    unit (MinPriority (Just x)) = Priority x
+
+instance Ord a => Reducer (MaxPriority a) (Priority a) where
+    unit (MaxPriority Nothing)  = MinBound
+    unit (MaxPriority (Just x)) = Priority x
+
+instance Functor Priority where
+    fmap _ MaxBound = MaxBound
+    fmap f Priority a = Priority (f a)
+    fmap _ MinBound = MinBound
+
+instance Pointed Priority where
+    point = Priority
addfile ./Data/Ring/Sugar.hs
hunk ./Data/Ring/Sugar.hs 1
+module Data.Seminearring.Sugar 
+    ( module Data.Monoid.Multiplicative.Sugar
+    , module Data.Seminearring
+    ) where
+
+import Data.Monoid.Multiplicative.Sugar
+import Data.Seminearring
}
