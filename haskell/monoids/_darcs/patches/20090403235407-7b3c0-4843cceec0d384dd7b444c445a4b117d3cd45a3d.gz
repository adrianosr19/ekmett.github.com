[migrated generator, darcs crash recovery
ekmett@gmail.com**20090403235407] {
hunk ./Data/Generator/Compressive/LZ78.hs 5
--- Module      :  Data.Monoid.Generator.LZ78
+-- Module      :  Data.Generator.Compressive.LZ78
hunk ./Data/Generator/Compressive/LZ78.hs 24
-module Data.Monoid.Generator.LZ78 
-    ( module Data.Monoid.Generator
+module Data.Generator.Compressive.LZ78 
+    ( module Data.Generator
hunk ./Data/Generator/Compressive/LZ78.hs 43
-import Data.Monoid.Generator
+import Data.Generator
hunk ./Data/Generator/Compressive/RLE.hs 5
--- Module      :  Data.Monoid.Generator.RLE
+-- Module      :  Data.Generator.Compressive.RLE
hunk ./Data/Generator/Compressive/RLE.hs 18
-module Data.Monoid.Generator.RLE
-    ( module Data.Monoid.Generator
+module Data.Generator.Compressive.RLE
+    ( module Data.Generator
hunk ./Data/Generator/Compressive/RLE.hs 32
-import Data.Monoid.Generator
+import Data.Generator
hunk ./Data/Generator/Free.hs 5
--- Module      :  Data.Monoid.Generator.Free
+-- Module      :  Data.Generator.Free
hunk ./Data/Generator/Free.hs 14
-module Data.Monoid.Generator.Free
-    ( module Data.Monoid.Generator
+module Data.Generator.Free
+    ( module Data.Generator
hunk ./Data/Generator/Free.hs 22
-import Data.Monoid.Generator
+import Data.Generator
hunk ./Data/Generator.hs 5
--- Module      :  Data.Monoid.Generator
+-- Module      :  Data.Generator
hunk ./Data/Generator.hs 21
-module Data.Monoid.Generator
+module Data.Generator
hunk ./Data/Monoid/Combinators.hs 15
--- > import Data.Group.Combinators as Monoid 
+-- > import Data.Monoid.Combinators as Monoid 
hunk ./Data/Monoid/Combinators.hs 20
-    ( module Data.Monoid.Generator
-    -- * Monadic Reduction
-    , mapM_
-    , forM_
-    , msum
-    -- * Applicative Reduction
-    , traverse_
-    , for_
-    , asum
-    -- * Logical Reduction
-    , and
-    , or
-    , any
-    , all
-    -- * Monoidal Reduction
-    , foldMap
-    , fold
-    , toList 
-    -- * List-Like Reduction
-    , concatMap
-    , elem
-    , filter
-    , filterWith
-    , find
-    , sum
-    , product
-    , notElem
+    ( 
hunk ./Data/Monoid/Combinators.hs 22
-    , repeat
+      repeat
hunk ./Data/Monoid/Combinators.hs 29
-import Prelude hiding (mapM_, any, elem, filter, concatMap, and, or, all, sum, product, notElem, replicate, cycle, repeat)
-import Control.Applicative
-import Control.Monad (MonadPlus)
-import Data.Monoid.Generator
-import Data.Monoid.Applicative
-import Data.Monoid.Self
-import Data.Monoid.Monad
+import Prelude hiding (replicate, cycle, repeat)
+import Data.Monoid.Reducer
hunk ./Data/Monoid/Combinators.hs 33
--- | Efficiently 'mapReduce' a 'Generator' using the 'Traversal' monoid. A specialized version of its namesake from "Data.Foldable"
---
--- @
---     'mapReduce' 'getTraversal'
--- @
-traverse_ :: (Generator c, Applicative f) => (Elem c -> f b) -> c -> f ()
-traverse_ = mapReduceWith getTraversal
-{-# INLINE traverse_ #-}
-    
--- | Convenience function as found in "Data.Foldable"
---
--- @
---     'flip' 'traverse_'
--- @
-for_ :: (Generator c, Applicative f) => c -> (Elem c -> f b) -> f ()
-for_ = flip traverse_
-{-# INLINE for_ #-}
-
--- | The sum of a collection of actions, generalizing 'concat'
---
--- @
---    'reduceWith' 'getAlt'
--- @ 
-asum :: (Generator c, Alternative f, f a ~ Elem c) => c -> f a
-asum = reduceWith getAlt
-{-# INLINE asum #-}
-
--- | Efficiently 'mapReduce' a 'Generator' using the 'Action' monoid. A specialized version of its namesake from "Data.Foldable" and "Control.Monad"
--- 
--- @
---    'mapReduceWith' 'getAction'
--- @ 
-mapM_ :: (Generator c, Monad m) => (Elem c -> m b) -> c -> m ()
-mapM_ = mapReduceWith getAction
-{-# INLINE mapM_ #-}
-
--- | Convenience function as found in "Data.Foldable" and "Control.Monad"
---
--- @
---     'flip' 'mapM_'
--- @
-forM_ :: (Generator c, Monad m) => c -> (Elem c -> m b) -> m ()
-forM_ = flip mapM_
-{-# INLINE forM_ #-}
-
--- | The sum of a collection of actions, generalizing 'concat'
---
--- @
---     'reduceWith' 'getMonadSum'
--- @
-msum :: (Generator c, MonadPlus m, m a ~ Elem c) => c -> m a
-msum = reduceWith getMonadSum
-{-# INLINE msum #-}
-
--- | Efficiently 'mapReduce' a 'Generator' using the 'Self' monoid. A specialized version of its namesake from "Data.Foldable"
---
--- @
---     'mapReduceWith' 'getSelf'
--- @
-foldMap :: (Monoid m, Generator c) => (Elem c -> m) -> c -> m
-foldMap = mapReduceWith getSelf
-{-# INLINE foldMap #-}
-
--- | Type specialization of "foldMap" above
-concatMap :: Generator c => (Elem c -> [b]) -> c -> [b]
-concatMap = foldMap
-{-# INLINE concatMap #-}
-
--- | Efficiently 'reduce' a 'Generator' using the 'Self' monoid. A specialized version of its namesake from "Data.Foldable"
---
--- @
---     'reduceWith' 'getSelf'
--- @
-fold :: (Monoid m, Generator c, Elem c ~ m) => c -> m
-fold = reduceWith getSelf
-{-# INLINE fold #-}
-
--- | Convert any 'Generator' to a list of its contents. Specialization of 'reduce'
-toList :: Generator c => c -> [Elem c]
-toList = reduce
-{-# INLINE toList #-}
-
--- | Efficiently 'reduce' a 'Generator' that contains values of type 'Bool'
---
--- @
---     'reduceWith' 'getAll'
--- @
-and :: (Generator c, Elem c ~ Bool) => c -> Bool
-and = reduceWith getAll
-{-# INLINE and #-}
-
--- | Efficiently 'reduce' a 'Generator' that contains values of type 'Bool'
---
--- @
---     'reduceWith' 'getAny'
--- @
-or :: (Generator c, Elem c ~ Bool) => c -> Bool
-or = reduceWith getAny
-{-# INLINE or #-}
-
--- | Efficiently 'mapReduce' any 'Generator' checking to see if any of its values match the supplied predicate
---
--- @
---     'mapReduceWith' 'getAny'
--- @
-any :: Generator c => (Elem c -> Bool) -> c -> Bool
-any = mapReduceWith getAny
-{-# INLINE any #-}
-
--- | Efficiently 'mapReduce' any 'Generator' checking to see if all of its values match the supplied predicate
---
--- @
---     'mapReduceWith' 'getAll'
--- @
-all :: Generator c => (Elem c -> Bool) -> c -> Bool
-all = mapReduceWith getAll
-{-# INLINE all #-}
hunk ./Data/Monoid/Combinators.hs 34
--- | Efficiently sum over the members of any 'Generator'
---
--- @
---     'reduceWith' 'getSum'
--- @
-sum :: (Generator c, Num (Elem c)) => c -> Elem c
-sum = reduceWith getSum
-{-# INLINE sum #-}
-
--- | Efficiently take the product of every member of a 'Generator'
---
--- @
---     'reduceWith' 'getProduct'
--- @
-product :: (Generator c, Num (Elem c)) => c -> Elem c
-product = reduceWith getProduct
-{-# INLINE product #-}
-
--- | Check to see if 'any' member of the 'Generator' matches the supplied value
-elem :: (Generator c, Eq (Elem c)) => Elem c -> c -> Bool
-elem = any . (==)
-{-# INLINE elem #-}
-
--- | Check to make sure that the supplied value is not a member of the 'Generator'
-notElem :: (Generator c, Eq (Elem c)) => Elem c -> c -> Bool
-notElem x = not . elem x
-{-# INLINE notElem #-}
-
--- | Efficiently 'mapReduce' a subset of the elements in a 'Generator'
-filter :: (Generator c, Elem c `Reducer` m) => (Elem c -> Bool) -> c -> m
-filter p = foldMap f where
-    f x | p x = unit x
-        | otherwise = mempty
-{-# INLINE filter #-}
-
--- | Allows idiomatic specialization of filter by proving a function that will be used to transform the output
-filterWith :: (Generator c, Elem c `Reducer` m) => (m -> n) -> (Elem c -> Bool) -> c -> n 
-filterWith f p = f . filter p
-{-# INLINE filterWith #-}
+-- | A generalization of 'Data.List.cycle' to an arbitrary 'Monoid'. May fail to terminate for some values in some monoids.
+cycle :: Monoid m => m -> m
+cycle xs = xs' where xs' = xs `mappend` xs'
hunk ./Data/Monoid/Combinators.hs 38
--- | A specialization of 'filter' using the 'First' 'Monoid', analogous to 'Data.List.find'
---
--- @
---     'filterWith' 'getFirst'
--- @
-find :: Generator c => (Elem c -> Bool) -> c -> Maybe (Elem c)
-find = filterWith getFirst
-{-# INLINE find #-}
+-- | A generalization of 'Data.List.repeat' to an arbitrary 'Monoid'. May fail to terminate for some values in some monoids.
+repeat :: (e `Reducer` m) => e -> m 
+repeat x = xs where xs = cons x xs 
hunk ./Data/Monoid/Combinators.hs 60
--- | A generalization of 'Data.List.cycle' to an arbitrary 'Monoid'. May fail to terminate for some values in some monoids.
-cycle :: Monoid m => m -> m
-cycle xs = xs' where xs' = xs `mappend` xs'
-
--- | A generalization of 'Data.List.repeat' to an arbitrary 'Monoid'. May fail to terminate for some values in some monoids.
-repeat :: (e `Reducer` m) => e -> m 
-repeat x = xs where xs = cons x xs 
-
hunk ./Data/Monoid/FromString.hs 23
-import Data.Monoid.Generator
+import Data.Generator
hunk ./Data/Monoid/Lexical/Binary.hs 24
-import Data.Monoid.Generator
+import Data.Generator
hunk ./Data/Monoid/Lexical/SourcePosition.hs 36
-import Data.Monoid.Generator
+import Data.Generator
hunk ./Data/Monoid/Lexical/Words.hs 36
-import Data.Monoid.Generator
+import Data.Generator
hunk ./Data/Monoid/Multiplicative.hs 1
-{-# LANGUAGE FlexibleInstances, MultiParamTypeClasses, UndecidableInstances #-}
+{-# LANGUAGE FlexibleInstances, MultiParamTypeClasses, UndecidableInstances, TypeOperators #-}
hunk ./Data/Monoid/Multiplicative.hs 68
-import Data.Monoid.Generator
+import Data.Generator
hunk ./Data/Monoid/Multiplicative.hs 83
+instance Multiplicative m => Multiplicative (Dual m) where
+    one = Dual one
+    Dual x `times` Dual y = Dual (y `times` x)
+
+instance Multiplicative m => Multiplicative (m `ReducedBy` s) where
+    one = Reduction one
+    Reduction x `times` Reduction y = Reduction (x `times` y)
+
hunk ./Data/Monoid/Reducer.hs 1
-{-# LANGUAGE UndecidableInstances , FlexibleContexts , MultiParamTypeClasses , FlexibleInstances , GeneralizedNewtypeDeriving #-}
+{-# LANGUAGE UndecidableInstances , FlexibleContexts , MultiParamTypeClasses , FlexibleInstances , GeneralizedNewtypeDeriving, TypeOperators, ScopedTypeVariables #-}
hunk ./Data/Monoid/Reducer.hs 26
+    , ReducedBy(Reduction,getReduction)
hunk ./Data/Monoid/Reducer.hs 50
+import Data.Reflection
+
hunk ./Data/Monoid/Reducer.hs 198
+data (m `ReducedBy` s) = Reduction { getReduction :: m } 
+
+instance Monoid m => Monoid (m `ReducedBy` s) where
+    mempty = Reduction mempty
+    Reduction a `mappend` Reduction b = Reduction (a `mappend` b)
+
+instance (s `Reflects` (a -> m), Monoid m) => Reducer a (m `ReducedBy` s) where
+    unit = Reduction . reflect (undefined :: s)
+
hunk ./Data/Monoid/Self.hs 28
-import Data.Monoid.Generator
+import Data.Generator
hunk ./Data/Monoid/Union.hs 32
-import Data.Monoid.Reducer (Reducer, unit, cons, snoc, Monoid, mappend, mempty)
+import Data.Monoid.Reducer
hunk ./Data/Monoid/Union.hs 85
-class HasUnionWith f where
+class Functor f => HasUnionWith f where
hunk ./Data/Monoid/Union.hs 99
-
hunk ./Data/Monoid/Union.hs 110
+-- we want an absorbing 0, for that we need a seminearring and a notion of equality
hunk ./Data/Ring/Module.hs 27
+import Data.Monoid.Union
+
hunk ./Data/Ring/Module.hs 65
+
+-- we want an absorbing 0, for that we need a seminearring and a notion of equality
+instance (HasUnionWith f, Ord r, Eq r, RightSemiNearRing r) => LeftModule r (UnionWith f r) where
+    r *. m | r == zero = zero
+           | otherwise = fmap (r `times`) m
+instance (HasUnionWith f, Ord r, Eq r, RightSemiNearRing r) => RightModule r (UnionWith f r) where
+    m .* r | r == zero = zero
+           | otherwise = fmap (`times` r) m
+instance (HasUnionWith f, Ord r, Eq r, RightSemiNearRing r) => Module r (UnionWith f r) where
+
hunk ./Data/Ring/Semi/Natural.hs 38
-import Data.Monoid.Generator.Free
-import Data.Monoid.Generator.RLE
+import Data.Generator.Free
+import Data.Generator.Compressive.RLE
hunk ./Data/Ring/Semi/Near.hs 41
-import Data.Monoid.Generator
+import Data.Generator
hunk ./Data/Ring/Semi/Near.hs 48
--- | @(a + b) * c = (a * c) + (b * c)@
-class (Multiplicative m, Monoid m) => RightSemiNearRing m 
-
--- 'Monoid' transformers
-instance RightSemiNearRing m => RightSemiNearRing (Self m)
-instance RightSemiNearRing m => RightSemiNearRing (FromString m)
-
hunk ./Data/Ring/Semi/Near.hs 54
+instance LeftSemiNearRing m => LeftSemiNearRing (ReducedBy m s)
+instance RightSemiNearRing m => LeftSemiNearRing (Dual m)
+
+-- | @(a + b) * c = (a * c) + (b * c)@
+class (Multiplicative m, Monoid m) => RightSemiNearRing m 
+
+-- 'Monoid' transformers
+instance RightSemiNearRing m => RightSemiNearRing (Self m)
+instance RightSemiNearRing m => RightSemiNearRing (FromString m)
+instance RightSemiNearRing m => RightSemiNearRing (ReducedBy m s)
+instance LeftSemiNearRing m => RightSemiNearRing (Dual m)
hunk ./Data/Ring/Semi.hs 1
+{-# LANGUAGE MultiParamTypeClasses #-}
hunk ./Data/Ring/Semi.hs 20
+import Data.Monoid.Self
+import Data.Monoid.FromString
hunk ./Data/Ring/Semi.hs 27
+instance SemiRing r => SemiRing (Self r)
+instance SemiRing r => SemiRing (FromString r)
+instance SemiRing r => SemiRing (ReducedBy r s)
+instance SemiRing r => SemiRing (Dual r)
+
hunk ./Data/Ring.hs 20
+import Data.Monoid.Self
+import Data.Monoid.FromString
hunk ./Data/Ring.hs 25
+instance Ring r => Ring (Self r)
+instance Ring r => Ring (FromString r)
+instance Ring r => Ring (ReducedBy r s)
+instance Ring r => Ring (Dual r)
+
hunk ./monoids.cabal 2
-version:	    0.1.23
+version:	    0.1.27
hunk ./monoids.cabal 9
-category:	    Data
+category:	    Data, Math, Numerical, Natural Language Processing, Parsing
hunk ./monoids.cabal 46
-    Data.Monoid.Generator
-    Data.Monoid.Generator.Free
-    Data.Monoid.Generator.LZ78
-    Data.Monoid.Generator.RLE
+    Data.Generator
+    Data.Generator.Combinators
+    Data.Generator.Compressive.LZ78
+    Data.Generator.Compressive.RLE
+    Data.Generator.Free
hunk ./monoids.cabal 73
+    Data.Ring.Semi.Near.Trie
}
