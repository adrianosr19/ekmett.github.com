[restructured namespace to move Data.Monoid.Generator.Combinators into Data.Monoid.Combinators. Added RLE
ekmett@gmail.com**20090327193152] {
addfile ./Data/Monoid/Combinators.hs
hunk ./Data/Monoid/Combinators.hs 1
+{-# LANGUAGE UndecidableInstances, TypeOperators, FlexibleContexts, MultiParamTypeClasses, FlexibleInstances, TypeFamilies, ScopedTypeVariables #-}
+module Data.Monoid.Combinators
+    ( module Data.Monoid.Generator
+    , module Data.Monoid.Reducer
+    , traverse_
+    , for_
+    , mapM_
+    , forM_
+    , foldMap'
+    , concatMap
+    , and
+    , or
+    , any
+    , all
+    , sum
+    , product
+    , elem
+    , notElem
+    , filter
+    , find
+    , replicate
+    , cycle
+    , repeat
+    ) where
+
+import Prelude hiding (mapM_, any, elem, filter, concatMap, and, or, all, sum, product, notElem)
+import Data.Monoid.Generator
+import Data.Monoid.Applicative
+import Data.Monoid.Monad
+import Data.Monoid.Monad.Identity hiding (mapM_, forM_)
+
+traverse_ :: (Generator c, Applicative f) => (Elem c -> f b) -> c -> f ()
+traverse_ f = getTraversal . mapReduce f
+    
+for_ :: (Generator c, Applicative f) => c -> (Elem c -> f b) -> f ()
+for_ = flip traverse_
+
+mapM_ :: (Generator c, Monad m) => (Elem c -> m b) -> c -> m ()
+mapM_ f = getAction . mapReduce f
+
+forM_ :: (Generator c, Monad m) => c -> (Elem c -> m b) -> m ()
+forM_ = flip mapM_
+
+foldMap' :: (Monoid m, Generator c) => (Elem c -> m) -> c -> m
+foldMap' f = runIdentity . mapReduce f
+
+concatMap :: Generator c => (Elem c -> [b]) -> c -> [b]
+concatMap = foldMap'
+
+and :: (Generator c, Elem c ~ Bool) => c -> Bool
+and = getAll . reduce
+
+or :: (Generator c, Elem c ~ Bool) => c -> Bool
+or = getAny . reduce
+
+any :: Generator c => (Elem c -> Bool) -> c -> Bool
+any f = getAny . mapReduce f
+
+all :: Generator c => (Elem c -> Bool) -> c -> Bool
+all f = getAll . mapReduce f
+
+sum :: (Generator c, Num (Elem c)) => c -> Elem c
+sum = getSum . reduce
+
+product :: (Generator c, Num (Elem c)) => c -> Elem c
+product = getProduct . reduce
+
+elem :: (Generator c, Eq (Elem c)) => Elem c -> c -> Bool
+elem = any . (==)
+
+notElem :: (Generator c, Eq (Elem c)) => Elem c -> c -> Bool
+notElem x = not . elem x
+
+filter :: (Generator c, Elem c `Reducer` m) => (Elem c -> Bool) -> c -> m
+filter p = foldMap' f where
+    f x | p x = unit x
+        | otherwise = mempty
+
+find :: Generator c => (Elem c -> Bool) -> c -> Maybe (Elem c)
+find p = getFirst . filter p
+
+-- shamelessly stolen from Lennart Augustsson's post: 
+-- http://augustss.blogspot.com/2008/07/lost-and-found-if-i-write-108-in.html
+replicate :: (Monoid m, Integral n) => n -> m -> m
+replicate x0 y0 
+    | y0 < 0 = mempty -- error "negative length"
+    | y0 == 0 = mempty
+    | otherwise = f x0 y0
+    where
+        f x y 
+            | even y = f (x `mappend` x) (y `quot` 2)
+            | y == 1 = x
+            | otherwise = g (x `mappend` x) ((y - 1) `quot` 2) x
+        g x y z 
+            | even y = g (x `mappend` x) (y `quot` 2)
+            | y == 1 = x * z
+            | otherwise = g (x `mappend` x) ((y - 1) `quot` 2) (x `mappend` z)
+
+cycle :: m -> m
+cycle xs = xs' where xs' = xs `mappend` xs'
+
+repeat :: (e `Reducer` m) => e -> m 
+repeat x = xs where xs = cons x xs 
hunk ./Data/Monoid/Generator/Combinators.hs 1
-{-# LANGUAGE UndecidableInstances, TypeOperators, FlexibleContexts, MultiParamTypeClasses, FlexibleInstances, TypeFamilies, ScopedTypeVariables #-}
-module Data.Monoid.Generator.Combinators
-    ( module Data.Monoid.Generator
-    , traverse_
-    , for_
-    , mapM_
-    , forM_
-    , foldMap'
-    , concatMap
-    , and
-    , or
-    , any
-    , all
-    , sum
-    , product
-    , elem
-    , notElem
-    , filter
-    , find
-    ) where
-
-import Prelude hiding (mapM_, any, elem, filter, concatMap, and, or, all, sum, product, notElem)
-import Data.Monoid.Generator
-import Data.Monoid.Applicative
-import Data.Monoid.Monad
-import Data.Monoid.Monad.Identity hiding (mapM_, forM_)
-
-traverse_ :: (Generator c, Applicative f) => (Elem c -> f b) -> c -> f ()
-traverse_ f = getTraversal . mapReduce f
-    
-for_ :: (Generator c, Applicative f) => c -> (Elem c -> f b) -> f ()
-for_ = flip traverse_
-
-mapM_ :: (Generator c, Monad m) => (Elem c -> m b) -> c -> m ()
-mapM_ f = getAction . mapReduce f
-
-forM_ :: (Generator c, Monad m) => c -> (Elem c -> m b) -> m ()
-forM_ = flip mapM_
-
-foldMap' :: (Monoid m, Generator c) => (Elem c -> m) -> c -> m
-foldMap' f = runIdentity . mapReduce f
-
-concatMap :: Generator c => (Elem c -> [b]) -> c -> [b]
-concatMap = foldMap'
-
-and :: (Generator c, Elem c ~ Bool) => c -> Bool
-and = getAll . reduce
-
-or :: (Generator c, Elem c ~ Bool) => c -> Bool
-or = getAny . reduce
-
-any :: Generator c => (Elem c -> Bool) -> c -> Bool
-any f = getAny . mapReduce f
-
-all :: Generator c => (Elem c -> Bool) -> c -> Bool
-all f = getAll . mapReduce f
-
-sum :: (Generator c, Num (Elem c)) => c -> Elem c
-sum = getSum . reduce
-
-product :: (Generator c, Num (Elem c)) => c -> Elem c
-product = getProduct . reduce
-
-elem :: (Generator c, Eq (Elem c)) => Elem c -> c -> Bool
-elem = any . (==)
-
-notElem :: (Generator c, Eq (Elem c)) => Elem c -> c -> Bool
-notElem x = not . elem x
-
-filter :: (Generator c, Elem c `Reducer` m) => (Elem c -> Bool) -> c -> m
-filter p = foldMap' f where
-    f x | p x = unit x
-        | otherwise = mempty
-
-find :: Generator c => (Elem c -> Bool) -> c -> Maybe (Elem c)
-find p = getFirst . filter p
rmfile ./Data/Monoid/Generator/Combinators.hs
rmdir ./Data/Monoid/Generator
hunk ./Data/Monoid/Reducer/Sugar.hs 1
-{-# LANGUAGE FlexibleInstances, FlexibleContexts, UndecidableInstances #-}
-module Data.Monoid.Reducer.Sugar 
-    ( module Data.Monoid.Reducer
-    , fromInteger
-    , IsString, fromString
-    ) where
-
-import Prelude hiding (fromInteger)
-import GHC.Exts hiding (fromString)
-import Data.Monoid.Generator
-import Data.Monoid.Reducer
-
-fromInteger :: Reducer Integer m => Integer -> m
-fromInteger = unit
-
-fromString :: Reducer Char m => String -> m
-fromString = reduce
rmfile ./Data/Monoid/Reducer/Sugar.hs
hunk ./monoids.cabal 20
+    Data.Group.Combinators
hunk ./monoids.cabal 26
+    Data.Monoid.Combinators
hunk ./monoids.cabal 29
-    Data.Monoid.Generator.Combinators
hunk ./monoids.cabal 31
+    Data.Monoid.Lexical.RunLengthEncoding
}
