[documentation and added RLE
ekmett@gmail.com**20090329071829] {
hunk ./Data/Monoid/Generator/LZ78.hs 2
+
+-----------------------------------------------------------------------------
+-- |
+-- Module      :  Data.Monoid.Generator.LZ78
+-- Copyright   :  (c) Edward Kmett 2009
+-- License     :  BSD-style
+-- Maintainer  :  libraries@haskell.org
+-- Stability   :  experimental
+-- Portability :  portable
+--
+-- Compression algorithms are all about exploiting redundancy. When applying
+-- an expensive 'Reducer' to a redundant source, it may be better to 
+-- extract the structural redundancy that is present. 'LZ78' is a compression
+-- algorithm that does so, without requiring the dictionary to be populated
+-- with all of the possible values of a data type unlike its later 
+-- refinement LZW, and which has fewer comparison reqirements during encoding
+-- than its earlier counterpart LZ77. Since we aren't storing these as a 
+-- bitstream the LZSS refinement of only encoding pointers once you cross
+-- the break-even point is a net loss. 
+-----------------------------------------------------------------------------
+
+
hunk ./Data/Monoid/Generator/LZ78.hs 29
+    , encodeEq
+    , prop_decode_encode
+    , prop_decode_encodeEq
hunk ./Data/Monoid/Generator/LZ78.hs 38
+import qualified Data.List as List
hunk ./Data/Monoid/Generator/LZ78.hs 42
+-- | An LZ78 compressing 'Generator', which supports efficient 'mapReduce' operations
+
hunk ./Data/Monoid/Generator/LZ78.hs 58
+
+-- | a type-constrained 'reduce' operation
hunk ./Data/Monoid/Generator/LZ78.hs 64
+-- | contruct an LZ78-compressed 'Generator' using a 'Map' internally, requires an instance of Ord.
+
hunk ./Data/Monoid/Generator/LZ78.hs 76
+-- | contruct an LZ78-compressed 'Generator' using a list internally, requires an instance of Eq.
+
+encodeEq :: Eq a => [a] -> LZ78 a
+encodeEq = LZ78 . encodeEq' [] 1 0
+
+encodeEq' :: Eq a => [((Int,a),Int)] -> Int -> Int -> [a] -> [(Int,a)]
+encodeEq' _ _ p [c] = [(p,c)]
+encodeEq' d f p (c:cs) = case List.lookup (p,c) d of
+    Just p' -> encodeEq' d f p' cs
+    Nothing -> (p,c):encodeEq' (((p,c),f):d) (succ f) 0 cs
+encodeEq' _ _ _ [] = []
+
+-- | QuickCheck property: decode . encode = id
+prop_decode_encode :: Ord a => [a] -> Bool
+prop_decode_encode xs = decode (encode xs) == xs
hunk ./Data/Monoid/Generator/LZ78.hs 92
--- QuickCheck properties, this holds as long as Eq is structural
-prop_DecodeEncode :: Ord a => [a] -> Bool
-prop_DecodeEncode xs = decode (encode xs) == xs
+-- | QuickCheck property: decode . encodeEq = id
+prop_decode_encodeEq :: Eq a => [a] -> Bool
+prop_decode_encodeEq xs = decode (encodeEq xs) == xs
hunk ./Data/Monoid/Lexical/RunLengthEncoding.hs 1
-{-# LANGUAGE FlexibleInstances, MultiParamTypeClasses #-}
-
------------------------------------------------------------------------------
--- |
--- Module      :  Data.Monoid.Lexical.RunLengthEncoding
--- Copyright   :  (c) Edward Kmett 2009
--- License     :  BSD-style
--- Maintainer  :  libraries@haskell.org
--- Stability   :  experimental
--- Portability :  non-portable (MPTCs)
---
--- A simple 'Monoid' transformer that turns any monoidal 'Reducer' into a
--- a reducer that expects to be supplied both a run length @n@ with each item
--- and which efficiently exponentiates the result of 'unit' @n@ times through 
--- 'replicate'.
---
------------------------------------------------------------------------------
-
-module Data.Monoid.Lexical.RunLengthEncoding 
-    ( module Data.Monoid.Reducer
-    , RLE(RLE,getRLE) 
-    ) where
-
-import Prelude hiding (replicate)
-import Data.Monoid.Reducer
-import Data.Monoid.Combinators (replicate)
-
-newtype RLE n m = RLE { getRLE :: m } 
-
-instance (Integral n, Monoid m) => Monoid (RLE n m) where
-    mempty = RLE mempty
-    RLE a `mappend` RLE b = RLE (a `mappend` b)
-
-instance (Integral n, Reducer c m) => Reducer (n,c) (RLE n m) where
-    unit ~(n,c) = RLE $ replicate (unit c) n
rmfile ./Data/Monoid/Lexical/RunLengthEncoding.hs
hunk ./monoids.cabal 17
-  build-depends: base >= 4, text, fingertree, bytestring, category-extras, parallel, containers, mtl, stm, bitset, QuickCheck, array, parsec >= 3
+  build-depends: 
+    base >= 4 && < 4.1,
+    containers >= 0.2 && < 0.3, 
+    text >= 0.1 && < 0.2, 
+    parsec >= 3.0 && < 3.1,
+    fingertree >= 0.0 && < 0.1, 
+    bytestring >= 0.9 && < 1.0, 
+    category-extras >= 0.53 && < 0.60, 
+    parallel >= 1.1 && < 1.2, 
+    mtl >= 1.0 && < 1.2, 
+    stm >= 2.1 && < 2.2, 
+    bitset >= 1.0 && < 1.1, 
+    QuickCheck < 2.2, 
+    array >= 0.2 && < 0.3
hunk ./monoids.cabal 43
+    Data.Monoid.Generator.RLE
hunk ./monoids.cabal 45
-    Data.Monoid.Lexical.RunLengthEncoding
}
