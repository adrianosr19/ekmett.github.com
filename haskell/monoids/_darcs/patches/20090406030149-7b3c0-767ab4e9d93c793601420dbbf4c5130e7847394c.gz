[modified bitset to be better self-contained. added foldable instance. fixed eq instance
ekmett@gmail.com**20090406030149
 Ignore-this: f8af16c3e79b1b9babf626374e851cfd
] {
hunk ./Data/Ring/Semi/BitSet.hs 17
+--
hunk ./Data/Ring/Semi/BitSet.hs 45
-import Prelude hiding ( null, exponent, toInteger )
+import Prelude hiding ( null, exponent, toInteger, foldl, foldr, foldl1, foldr1 )
hunk ./Data/Ring/Semi/BitSet.hs 48
+import Data.Foldable hiding ( toList )
hunk ./Data/Ring/Semi/BitSet.hs 58
+-- | Set operations optimized for tightly grouped sets or nearly universal sets with a close by group of elements missing.
+--   Stores itself like an arbitrary precision floating point number, tracking the least valued member of the set and an
+--   Integer comprised of the members. 
hunk ./Data/Ring/Semi/BitSet.hs 66
-        , _count         :: Int                       -- ^ Lazy element count used when the above two disagree. O(1) environment size
+        , _count         ::                 Int       -- ^ Lazy element count used when the above two disagree. O(1) environment size
hunk ./Data/Ring/Semi/BitSet.hs 71
-        , _universe      :: (Int,Int)                 -- ^ invariant: whenever mantissa < 0 => universe = (fromEnum minBound,fromEnum maxBound)
-        } deriving (Data, Typeable)
+        , _universe      ::                 (Int,Int) -- ^ invariant: whenever mantissa < 0, universe = (fromEnum minBound,fromEnum maxBound)
+        , _fromEnum      ::                 Int -> a  -- ^ self-contained extraction behavior, enables Foldable
+        } deriving (Typeable)
+
+-- | omit reflection to preserve abstraction
+instance (Enum a, Data a) => Data (BitSet a) where
+    gfoldl f z im = z fromList `f` toList im
+    toConstr _ = error "toConstr"
+    gunfold _ _ = error "gunfold"
+    dataTypeOf _ = mkNorepType "Data.Ring.Semi.BitSet.BitSet"
+    dataCast1 f = gcast1 f 
hunk ./Data/Ring/Semi/BitSet.hs 84
-bs :: Int -> Int -> Int -> Int -> Int -> Integer -> (Int,Int) -> BitSet a
-bs !a !b c !l !h !m u | a == b = BS a a a l h m u
-                      | otherwise = BS a b c l h m u
+bs :: Enum a => Int -> Int -> Int -> Int -> Int -> Integer -> (Int,Int) -> BitSet a
+bs !a !b c !l !h !m u | a == b    = BS a a a l h m u toEnum
+                      | otherwise = BS a b c l h m u toEnum
hunk ./Data/Ring/Semi/BitSet.hs 89
--- | /O(d)/ where /d/ is absolute deviation in fromEnum over the set
-toList :: Enum a => BitSet a -> [a]
-toList (BS _ _ _ l h m u) 
-    | m < 0 = map toEnum [ul..max (pred l) ul] ++ toList' l (map toEnum [min (succ h) uh..uh])
+-- | /O(d)/ where /d/ is absolute deviation in the output of fromEnum over the set
+toList :: BitSet a -> [a]
+toList (BS _ _ _ l h m u f) 
+    | m < 0 = map f [ul..max (pred l) ul] ++ toList' l (map f [min (succ h) uh..uh])
hunk ./Data/Ring/Semi/BitSet.hs 96
-        toList' :: Enum a => Int -> [a] -> [a]
-        toList' !n t | n > h = t
-                     | testBit m (n - l) = toEnum n : toList' (n+1) t
-                     | otherwise         = toList' (n+1) t
+        toList' !n t 
+            | n > h = t
+            | testBit m (n - l) = f n : toList' (n+1) t
+            | otherwise         = toList' (n+1) t
hunk ./Data/Ring/Semi/BitSet.hs 103
-empty :: BitSet a
-empty = BS 0 0 0 0 0 0 undefined
+empty :: Enum a => BitSet a
+empty = BS 0 0 0 0 0 0 undefined toEnum
hunk ./Data/Ring/Semi/BitSet.hs 109
-singleton x = BS 1 1 1 e e 1 undefined where e = fromEnum x
+singleton x = BS 1 1 1 e e 1 undefined toEnum where e = fromEnum x
hunk ./Data/Ring/Semi/BitSet.hs 112
--- | /O(1|d)/ Is the 'BitSet' empty? May be faster than checking if @'size' == 0@ after union.
---   Operations that require a recount are noted.
+-- | /O(1)/ amortized cost. Is the 'BitSet' empty? May be faster than checking if @'size' == 0@.
hunk ./Data/Ring/Semi/BitSet.hs 114
-null (BS a b c _ _ _ _) 
+null (BS a b c _ _ _ _ _) 
hunk ./Data/Ring/Semi/BitSet.hs 120
--- | /O(1|d)/ The number of elements in the bit set.
+-- | /O(1)/ amortized cost. The number of elements in the bit set.
hunk ./Data/Ring/Semi/BitSet.hs 122
-size (BS a b c _ _ m (ul,uh)) 
+size (BS a b c _ _ m (ul,uh) _) 
hunk ./Data/Ring/Semi/BitSet.hs 136
-complement r@(BS a b c l h m _) = BS (Bits.complement b) (Bits.complement a) (Bits.complement c) l h (Bits.complement m) u where
+complement r@(BS a b c l h m _ f) = BS (Bits.complement b) (Bits.complement a) (Bits.complement c) l h (Bits.complement m) u f where
hunk ./Data/Ring/Semi/BitSet.hs 142
-recomplement (BS a b c l h m u) = BS (Bits.complement b) (Bits.complement a) (Bits.complement c) l h (Bits.complement m) u
+recomplement (BS a b c l h m u f) = BS (Bits.complement b) (Bits.complement a) (Bits.complement c) l h (Bits.complement m) u f
hunk ./Data/Ring/Semi/BitSet.hs 147
-pseudoComplement (BS a b c l h m _) u = BS (Bits.complement b) (Bits.complement a) (Bits.complement c) l h (Bits.complement m) u
+pseudoComplement (BS a b c l h m _ f) u = BS (Bits.complement b) (Bits.complement a) (Bits.complement c) l h (Bits.complement m) u f
hunk ./Data/Ring/Semi/BitSet.hs 162
-        fromDistinctAscList' [] !n !h !m  = BS n n n l h m undefined
-        fromDistinctAscList' (c':cs') !n _ !m = fromDistinctAscList' cs' (n+1) h' (setBit m (h' - l))
-            where
-                h' = fromEnum c'
+        fromDistinctAscList' [] !n !h !m  = BS n n n l h m undefined toEnum
+        fromDistinctAscList' (c':cs') !n _ !m = 
+            let h' = fromEnum c' in 
+            fromDistinctAscList' cs' (n+1) h' (setBit m (h' - l))
hunk ./Data/Ring/Semi/BitSet.hs 170
-insert x r@(BS a b c l h m u) 
+insert x r@(BS a b c l h m u _)  
hunk ./Data/Ring/Semi/BitSet.hs 173
-    | e < l = bs (a+1) (b+1) (c+1) e h (shiftL m (l - e) .|. 1) u
-    | e > h = bs (a+1) (b+1) (c+1) l p (setBit m p) u
-    | testBit m p = r 
-    | otherwise = bs (a+1) (b+1) (c+1) l h (setBit m p) u
+    | b == 0       = singleton x
+    | a == -1      = r
+    | e < l        = bs (a+1) (b+1) (c+1) e h (shiftL m (l - e) .|. 1) u
+    | e > h        = bs (a+1) (b+1) (c+1) l p (setBit m p) u
+    | testBit m p  = r 
+    | otherwise    = bs (a+1) (b+1) (c+1) l h (setBit m p) u
hunk ./Data/Ring/Semi/BitSet.hs 186
-delete x r@(BS a b c l h m u) 
+delete x r@(BS a b c l h m u _) 
hunk ./Data/Ring/Semi/BitSet.hs 189
-    | e < l       = r
-    | e > h       = r
-    | testBit m p = bs (a-1) (b-1) (c-1) l h (clearBit m p) u
-    | otherwise   = r
+    | b == 0       = r
+    | a == -1      = pseudoComplement (singleton x) u
+    | e < l        = r
+    | e > h        = r
+    | testBit m p  = bs (a-1) (b-1) (c-1) l h (clearBit m p) u
+    | otherwise    = r
hunk ./Data/Ring/Semi/BitSet.hs 202
-member x (BS _ _ _ l h m _) 
+member x (BS _ _ _ l h m _ _) 
hunk ./Data/Ring/Semi/BitSet.hs 213
+{-# INLINE toInteger #-}
hunk ./Data/Ring/Semi/BitSet.hs 215
--- | /O(d)/. May force 'size' to take /O(d)/ if ranges overlap, preserves order of 'null'
-union :: BitSet a -> BitSet a -> BitSet a 
-union x@(BS a b c l h m u) y@(BS a' b' c' l' h' m' u')
+-- | /O(d)/.
+union :: Enum a => BitSet a -> BitSet a -> BitSet a 
+union x@(BS a b c l h m u f) y@(BS a' b' c' l' h' m' u' _)
hunk ./Data/Ring/Semi/BitSet.hs 224
-    | m' < 0        = recomplement (pseudoDiff (recomplement y) x u')                   -- union with complement, recomplement obligation met by 2s complement
-    | m < 0         = recomplement (pseudoDiff (recomplement x) y u)                    -- union with complement, recomplement obligation met by 2s complement
+    | m' < 0        = recomplement (diff (recomplement y) x u')                         -- union with complement, recomplement obligation met by 2s complement
+    | m < 0         = recomplement (diff (recomplement x) y u)                          -- union with complement, recomplement obligation met by 2s complement
hunk ./Data/Ring/Semi/BitSet.hs 230
-        entire = BS (-1) (-1) (-1) 0 0 (-1)
+        entire u'' = BS (-1) (-1) (-1) 0 0 (-1) u'' f
hunk ./Data/Ring/Semi/BitSet.hs 232
--- | /O(1)/ check to see if we are represented as a complemented 'BitSet'. 
-isComplemented :: BitSet a -> Bool
+-- | /O(1)/ Check to see if we are represented as a complemented 'BitSet'. 
+isComplemented :: Enum a => BitSet a -> Bool
hunk ./Data/Ring/Semi/BitSet.hs 235
+{-# INLINE isComplemented #-}
hunk ./Data/Ring/Semi/BitSet.hs 237
--- | /O(d)/. May force 'size' and 'null' both to take /O(d)/.
-intersection :: BitSet a -> BitSet a -> BitSet a 
-intersection x@(BS a b _ l h m u) y@(BS a' b' _ l' h' m' u')
+-- | /O(d)/ 
+intersection :: Enum a => BitSet a -> BitSet a -> BitSet a 
+intersection x@(BS a b _ l h m u _) y@(BS a' b' _ l' h' m' u' _)
hunk ./Data/Ring/Semi/BitSet.hs 246
-    | m' < 0 = pseudoDiff x (recomplement y) u'
-    | m < 0 = pseudoDiff y (recomplement x) u
+    | m' < 0 = diff x (recomplement y) u'
+    | m < 0 = diff y (recomplement x) u
hunk ./Data/Ring/Semi/BitSet.hs 254
--- | Unsafe internal method for computing differences in a particular universe of discourse
--- preconditions:
---  m >= 0, m' >= 0, a /= -1, a' /= -1, b /= 0, b' /= 0, u'' is the universe of discourse
-pseudoDiff :: BitSet a -> BitSet a -> (Int,Int) -> BitSet a 
-pseudoDiff x@(BS a _ _ l h m _) (BS _ b' _ l' h' m' _) u''
+-- | Unsafe internal method for computing differences in a known universe of discourse.
+--
+-- Preconditions:
+--
+-- (1) @m >= 0@
+-- 2   @m' >= 0@
+-- 3   @a /= -1@
+-- 4   @a' /= -1@
+-- 5   @b /= 0@
+-- 6   @b' /= 0@
+-- 7   @u''@ is a previously obtained copy of @(fromEnum minBound, fromEnum maxBound)@
+--
+diff :: Enum a => BitSet a -> BitSet a -> (Int,Int) -> BitSet a 
+diff x@(BS a _ _ l h m _ _) (BS _ b' _ l' h' m' _ _) u''
hunk ./Data/Ring/Semi/BitSet.hs 273
+{-# INLINE diff #-}
hunk ./Data/Ring/Semi/BitSet.hs 275
--- | /O(d)/. Preserves order of 'null'. May force /O(d)/ 'size'.
+-- | /O(d)/ Remove all elements present in the second bitset from the first
hunk ./Data/Ring/Semi/BitSet.hs 277
-difference x@(BS a b _ _ _ m u)  y@(BS a' b' _ _ _ m' _) 
+difference x@(BS a b _ _ _ m u _)  y@(BS a' b' _ _ _ m' _ _) 
hunk ./Data/Ring/Semi/BitSet.hs 282
-   | m < 0, m' < 0 = pseudoDiff (recomplement y) (recomplement x) u
+   | m < 0, m' < 0 = diff (recomplement y) (recomplement x) u
hunk ./Data/Ring/Semi/BitSet.hs 285
-   | otherwise     = pseudoDiff x y u
+   | otherwise     = diff x y u
hunk ./Data/Ring/Semi/BitSet.hs 287
--- | /O(d)/. Preserves order of 'null'. May force /O(d)/ 'size'.
+-- | /O(d)/ Infix 'difference'
hunk ./Data/Ring/Semi/BitSet.hs 290
+{-# INLINE (\\) #-}
hunk ./Data/Ring/Semi/BitSet.hs 293
-    x@(BS _ _ _ l _ m u) == y@(BS _ _ _ l' _ m' _)
-        | signum m == signum m' = shift m (l - l'') == shift m' (l - l'') 
-        | m' < 0 = y == x
-        | otherwise = mask .&. shift m (l - ul) == shift m' (l - ul)
+    x@(BS _ _ _ l _ m u _) == y@(BS _ _ _ l' _ m' _ _)
+        | signum m == signum m' = shift m (l - l'') == shift m' (l' - l'') 
+        | m' < 0                = y == x
+        | otherwise             = mask .&. shift m (l - ul) == shift m' (l - ul)
hunk ./Data/Ring/Semi/BitSet.hs 303
--- instance Ord (BitSet a) where
---    BS _ _ _ l _ m _ `compare` BS _ _ _ l' _ m' _ = shift m (l'' - l) `compare` shift m' (l'' - l) where l'' = min l l'
-
hunk ./Data/Ring/Semi/BitSet.hs 306
-        result = BS n n n l h m (l,h)
+        result = BS n n n l h m (l,h) toEnum
hunk ./Data/Ring/Semi/BitSet.hs 345
-            | l == h = l
+            | l == h        = l
hunk ./Data/Ring/Semi/BitSet.hs 347
-            | otherwise = scan (m+1) h
-            where m = l + (h - l) `div` 2
+            | otherwise     = scan (m+1) h
+            where 
+                m = l + (h - l) `div` 2
hunk ./Data/Ring/Semi/BitSet.hs 352
-   showsPrec d x@(BS _ _ _ _ _ m u)
+   showsPrec d x@(BS _ _ _ _ _ m u _)
hunk ./Data/Ring/Semi/BitSet.hs 368
-    fromEnum b@(BS _ _ _ l _ m _) = fromInteger (shiftL m (l - l'))
+    fromEnum b@(BS _ _ _ l _ m _ _) = fromInteger (shiftL m (l - l'))
hunk ./Data/Ring/Semi/BitSet.hs 373
-            result = BS a i (recount m) l h m undefined -- n <= 2^n, so i serves as a valid upper bound
+            result = BS a i (recount m) l h m undefined toEnum -- n <= 2^n, so i serves as a valid upper bound
hunk ./Data/Ring/Semi/BitSet.hs 379
+
+instance Foldable BitSet where
+    fold = fold . toList
+    foldMap f = foldMap f . toList
+    foldr f z = foldr f z . toList
+    foldl f z = foldl f z . toList
+    foldr1 f = foldr1 f . toList
+    foldl1 f = foldl1 f . toList
hunk ./monoids.cabal 2
-version:	    0.1.31
+version:	    0.1.32
}
