[widened scope. added more common monoids
ekmett@gmail.com**20090325070459] {
move ./lexical-monoids.cabal ./monoids.cabal
addfile ./Data/Monoid/Applicative.hs
hunk ./Data/Monoid/Applicative.hs 1
+{-# LANGUAGE FlexibleInstances, MultiParamTypeClasses, GeneralizedNewtypeDeriving, FlexibleContexts #-}
+module Data.Monoid.Applicative 
+    ( module Control.Applicative
+    , module Data.Monoid.Reducer
+    , Traversal(Traversal,getTraversal)
+    , Alternate(Alternate,getAlternate)
+    ) where
+
+import Control.Applicative (Applicative, (*>), pure, Alternative, empty, (<|>))
+import Data.Monoid.Reducer
+
+newtype Traversal f = Traversal { getTraversal :: f () } 
+
+instance Applicative f => Monoid (Traversal f) where
+    mempty = Traversal (pure ())
+    Traversal a `mappend` Traversal b = Traversal (a *> b)
+
+instance Applicative f => Reducer (f a) (Traversal f) where
+    unit a = Traversal (a *> pure ())
+    a `cons` Traversal b = Traversal (a *> b)
+    Traversal a `snoc` b = Traversal (a *> b *> pure ())
+
+{-# RULES "unitTraversal" unit = Traversal #-}
+{-# RULES "snocTraversal" snoc = snocTraversal #-}
+snocTraversal :: Reducer (f ()) (Traversal f) => Traversal f -> f () -> Traversal f
+snocTraversal a = mappend a . Traversal
+
+newtype Alternate f a = Alternate { getAlternate :: f a } 
+    deriving (Eq,Ord,Show,Read,Functor,Applicative,Alternative)
+
+instance Alternative f => Monoid (Alternate f a) where
+    mempty = empty 
+    Alternate a `mappend` Alternate b = Alternate (a <|> b) 
+
+instance Alternative f => Reducer (f a) (Alternate f a) where
+    unit = Alternate
+    a `cons` Alternate b = Alternate (a <|> b) 
+    Alternate a `snoc` b = Alternate (a <|> b)
addfile ./Data/Monoid/FingerTree.hs
hunk ./Data/Monoid/FingerTree.hs 1
+{-# LANGUAGE FlexibleInstances, MultiParamTypeClasses #-}
+module Data.Monoid.FingerTree
+    ( module Data.Monoid.Reducer
+    , module Data.FingerTree
+    ) where
+
+import Data.Monoid.Reducer (Reducer, unit, cons, snoc, Monoid, mempty, mappend)
+import Data.FingerTree
+
+instance Measured v a => Monoid (FingerTree v a) where
+    mempty = empty
+    mappend = (><)
+
+instance Measured v a => Reducer a (FingerTree v a) where
+    unit = singleton
+    cons = (<|)
+    snoc = (|>) 
+
+{-
+instance Measured v a => Reducer (FingerTree v a) (FingerTree v a) where
+    unit = id
+    cons = mappend
+    snoc = mappend
+-}
hunk ./Data/Monoid/Generator.hs 6
-    , mapreduce
-    , mapreducer
-    , mapreducel
+    , mapReduce
+    , mapTo
+    , mapFrom
hunk ./Data/Monoid/Generator.hs 11
-import Prelude hiding (lex)
hunk ./Data/Monoid/Generator.hs 20
+import Data.Monoid.Applicative
+import Data.Monoid.Monad
hunk ./Data/Monoid/Generator.hs 23
--- minimal definition mapreduce or affixMapReduce
+-- minimal definition mapReduce or affixMapReduce
hunk ./Data/Monoid/Generator.hs 26
-    mapreduce   :: (e `Reducer` m) => (Elem c -> e) -> c -> m
-    mapreducer  :: (e `Reducer` m) => (Elem c -> e) -> m -> c -> m 
-    mapreducel  :: (e `Reducer` m) => (Elem c -> e) -> c -> m -> m
+    mapReduce :: (e `Reducer` m) => (Elem c -> e) -> c -> m
+    mapTo     :: (e `Reducer` m) => (Elem c -> e) -> m -> c -> m 
+    mapFrom   :: (e `Reducer` m) => (Elem c -> e) -> c -> m -> m
hunk ./Data/Monoid/Generator.hs 30
-    mapreduce  f = mapreducer f mempty
-    mapreducer f m = mappend m . mapreduce f
-    mapreducel f = mappend . mapreduce f
+    mapReduce f = mapTo f mempty
+    mapTo f m = mappend m . mapReduce f
+    mapFrom f = mappend . mapReduce f
hunk ./Data/Monoid/Generator.hs 36
-    mapreducer f = Strict.foldl' (\a -> reducer a . f)
+    mapTo f = Strict.foldl' (\a -> snoc a . f)
hunk ./Data/Monoid/Generator.hs 40
-    mapreduce f = fold . parMap rwhnf (mapreduce f) . Lazy.toChunks
+    mapReduce f = fold . parMap rwhnf (mapReduce f) . Lazy.toChunks
hunk ./Data/Monoid/Generator.hs 44
-    mapreducer f = Text.foldl' (\a -> reducer a . f)
+    mapTo f = Text.foldl' (\a -> snoc a . f)
hunk ./Data/Monoid/Generator.hs 48
-    mapreduce f = foldMap (reduce . f)
+    mapReduce f = foldMap (unit . f)
+
+{-# SPECIALIZE reduce :: (Word8 `Reducer` m) => Strict.ByteString -> m #-}
+{-# SPECIALIZE reduce :: (Word8 `Reducer` m) => Lazy.ByteString -> m #-}
+{-# SPECIALIZE reduce :: (Char `Reducer` m) => Text -> m #-}
+-- These aren't happy, but should work
+{-- RULES "reduce/fold" reduce = fold --}
+{-- RULES "mapReduce/foldMap" mapReduce = foldMap --}
+reduce :: (Generator c, Elem c `Reducer` m) => c -> m
+reduce = mapReduce id
+
+mtraverse_ :: (Generator c, Applicative f) => (Elem c -> f b) -> c -> f ()
+mtraverse_ f = getTraversal . mapReduce f
+    
+mfor_ :: (Generator c, Applicative f) => c -> (Elem c -> f b) -> f ()
+mfor_ = flip mtraverse_
+
+mmapM_ :: (Generator c, Monad m) => (Elem c -> m b) -> c -> m ()
+mmapM_ f = getAction . mapReduce f
+
+mforM_ :: (Generator c, Monad m) => c -> (Elem c -> m b) -> m ()
+mforM_ = flip mmapM_
+
+mconcatMap :: Generator c => (Elem c -> [b]) -> c -> [b]
+mconcatMap = mapReduce
+
+
addfile ./Data/Monoid/IntMap.hs
hunk ./Data/Monoid/IntMap.hs 1
+{-# LANGUAGE MultiParamTypeClasses #-}
+module Data.Monoid.IntMap 
+    ( module Data.Monoid.Reducer
+    , Union(getUnion)
+    , UnionWith(getUnionWith)
+    ) where
+
+import Data.Monoid.Reducer (Reducer, unit, cons, snoc, Monoid, mappend, mempty)
+import Data.IntMap
+
+newtype Union a = Union { getUnion :: IntMap a } 
+
+instance Monoid (Union a) where
+    mempty = Union empty
+    Union a `mappend` Union b = Union (a `union` b)
+
+instance Reducer (IntMap a) (Union a) where
+    unit = Union
+
+-- only needs m to be a semigroup, but Haskell doesn't have a semigroup class
+
+newtype UnionWith m = UnionWith { getUnionWith :: IntMap m } 
+
+instance Monoid m => Monoid (UnionWith m) where
+    mempty = UnionWith empty
+    UnionWith a `mappend` UnionWith b = UnionWith (unionWith mappend a b)
+
+instance Monoid m => Reducer (IntMap m) (UnionWith m) where
+    unit = UnionWith
hunk ./Data/Monoid/Lexical/SourcePosition.hs 62
-    reduce '\n' = Lines 1 1
-    reduce '\t' = Tab 0 0 
-    reduce _    = Columns 1
+    unit '\n' = Lines 1 1
+    unit '\t' = Tab 0 0 
+    unit _    = Columns 1
hunk ./Data/Monoid/Lexical/UTF8/Decoder.hs 32
--- S is a segment that contains a possible tail of a character, the result of reduceing some full characters, and the start of another character
+-- S is a segment that contains a possible tail of a character, the result of reducing some full characters, and the start of another character
hunk ./Data/Monoid/Lexical/UTF8/Decoder.hs 51
-reducerH :: CharReducer m => H -> Word8 -> (m -> H -> UTF8 m) -> m -> UTF8 m
-reducerH H0 c k m 
+snocH :: CharReducer m => H -> Word8 -> (m -> H -> UTF8 m) -> m -> UTF8 m
+snocH H0 c k m 
hunk ./Data/Monoid/Lexical/UTF8/Decoder.hs 59
-reducerH (H2_1 c) d k m
+snocH (H2_1 c) d k m
hunk ./Data/Monoid/Lexical/UTF8/Decoder.hs 62
-reducerH (H3_1 c) d k m 
+snocH (H3_1 c) d k m 
hunk ./Data/Monoid/Lexical/UTF8/Decoder.hs 65
-reducerH (H3_2 c d) e k m 
+snocH (H3_2 c d) e k m 
hunk ./Data/Monoid/Lexical/UTF8/Decoder.hs 68
-reducerH (H4_1 c) d k m 
+snocH (H4_1 c) d k m 
hunk ./Data/Monoid/Lexical/UTF8/Decoder.hs 71
-reducerH (H4_2 c d) e k m 
+snocH (H4_2 c d) e k m 
hunk ./Data/Monoid/Lexical/UTF8/Decoder.hs 74
-reducerH (H4_3 c d e) f k m 
+snocH (H4_3 c d e) f k m 
hunk ./Data/Monoid/Lexical/UTF8/Decoder.hs 85
-b1 c | c < 0x80 = reduceChar . toEnum $ fromEnum c
+b1 c | c < 0x80 = fromChar . toEnum $ fromEnum c
hunk ./Data/Monoid/Lexical/UTF8/Decoder.hs 89
-b2 c d | valid_b2 c d = reduceChar (toEnum (combine (mask c 0x1f) d))
+b2 c d | valid_b2 c d = fromChar (toEnum (combine (mask c 0x1f) d))
hunk ./Data/Monoid/Lexical/UTF8/Decoder.hs 93
-b3 c d e | valid_b3 c d e = reduceChar (toEnum (combine (combine (mask c 0x0f) d) e))
+b3 c d e | valid_b3 c d e = fromChar (toEnum (combine (combine (mask c 0x0f) d) e))
hunk ./Data/Monoid/Lexical/UTF8/Decoder.hs 98
-b4 c d e f | valid_b4 c d e f = reduceChar (toEnum (combine (combine (combine (mask c 0x07) d) e) f))
+b4 c d e f | valid_b4 c d e f = fromChar (toEnum (combine (combine (combine (mask c 0x07) d) e) f))
hunk ./Data/Monoid/Lexical/UTF8/Decoder.hs 113
-reducelT :: CharReducer m => Word8 -> T -> (H -> UTF8 m) -> (m -> UTF8 m) -> (T -> UTF8 m) -> UTF8 m
-reducelT c cs h m t
+consT :: CharReducer m => Word8 -> T -> (H -> UTF8 m) -> (m -> UTF8 m) -> (T -> UTF8 m) -> UTF8 m
+consT c cs h m t
hunk ./Data/Monoid/Lexical/UTF8/Decoder.hs 163
-    S t m h `reducer` c        = reducerH h c (S t) m
-    T t     `reducer` c        | c >= 0x80 && c < 0xc0 = T (t ++ [c])
-                               | otherwise = reducerH H0 c (S t) mempty
+    unit c | c >= 0x80 && c < 0xc0 = T [c]
+           | otherwise = snocH H0 c (S []) mempty
+    S t m h `snoc` c        = snocH h c (S t) m
+    T t     `snoc` c        | c >= 0x80 && c < 0xc0 = T (t ++ [c])
+                            | otherwise = snocH H0 c (S t) mempty
hunk ./Data/Monoid/Lexical/UTF8/Decoder.hs 169
-    c       `reducel` T cs     = reducelT c cs (S [] mempty) (flip (S []) H0) T
-    c       `reducel` S cs m h = reducelT c cs k1 k2 k3 where
+    c       `cons` T cs     = consT c cs (S [] mempty) (flip (S []) H0) T
+    c       `cons` S cs m h = consT c cs k1 k2 k3 where
hunk ./Data/Monoid/Lexical/Words.hs 36
-    reduce c | isSpace c = Segment (Just (reduce c)) [] mempty
-          | otherwise = Chunk (Just (reduce c))
+    unit c | isSpace c = Segment (Just (unit c)) [] mempty
+           | otherwise = Chunk (Just (unit c))
hunk ./Data/Monoid/Lexical/Words.hs 48
-    reduce '\n' = Lines $ Segment (Just (reduce '\n')) [] mempty
-    reduce c = Lines $ Chunk (Just (reduce c))
+    unit '\n' = Lines $ Segment (Just (unit '\n')) [] mempty
+    unit c = Lines $ Chunk (Just (unit c))
hunk ./Data/Monoid/Lexical/Words.hs 57
-    reduce c | isSpace c = mempty
-          | otherwise = Unspaced (reduce c)
+    unit c | isSpace c = mempty
+           | otherwise = Unspaced (unit c)
hunk ./Data/Monoid/Lexical/Words.hs 75
-    reduce '\n' = mempty
-    reduce c = Unlined (reduce c)
+    unit '\n' = mempty
+    unit c = Unlined (unit c)
hunk ./Data/Monoid/Lexical/Words.hs 93
-    (ls,rs) = unzip (runWords (mapreduce id c))
+    (ls,rs) = unzip (runWords (mapReduce id c))
hunk ./Data/Monoid/Lexical/Words.hs 98
-    (ls,rs) = unzip (runLines (mapreduce id c))
+    (ls,rs) = unzip (runLines (mapReduce id c))
addfile ./Data/Monoid/Map.hs
hunk ./Data/Monoid/Map.hs 1
+{-# LANGUAGE MultiParamTypeClasses #-}
+module Data.Monoid.Map 
+    ( module Data.Monoid.Reducer
+    , Union(getUnion)
+    , UnionWith(getUnionWith)
+    ) where
+
+import Prelude (Ord)
+import Data.Monoid.Reducer (Reducer, unit, cons, snoc, Monoid, mempty, mappend)
+import Data.Map
+
+newtype Union k a = Union { getUnion :: Map k a } 
+
+instance Ord k => Monoid (Union k a) where
+    mempty = Union empty
+    Union a `mappend` Union b = Union (a `union` b)
+
+instance Ord k => Reducer (Map k a) (Union k a) where
+    unit = Union
+
+-- only needs m to be a semigroup, but Haskell doesn't have a semigroup class
+
+newtype UnionWith k m = UnionWith { getUnionWith :: Map k m } 
+
+instance (Ord k, Monoid m) => Monoid (UnionWith k m) where
+    mempty = UnionWith empty
+    UnionWith a `mappend` UnionWith b = UnionWith (unionWith mappend a b)
+
+instance (Ord k, Monoid m) => Reducer (Map k m) (UnionWith k m) where
+    unit = UnionWith
addfile ./Data/Monoid/Monad.hs
hunk ./Data/Monoid/Monad.hs 1
+{-# LANGUAGE FlexibleInstances, MultiParamTypeClasses, GeneralizedNewtypeDeriving, FlexibleContexts #-}
+module Data.Monoid.Monad 
+    ( module Control.Monad
+    , module Data.Monoid.Reducer
+    , Action(Action,getAction)
+    , MonadSum(MonadSum,getMonadSum)
+    ) where
+
+import Data.Monoid.Reducer
+import Control.Monad (MonadPlus, mplus, mzero)
+
+newtype Action m = Action { getAction :: m () } 
+
+instance Monad m => Monoid (Action m) where
+    mempty = Action (return ())
+    Action a `mappend` Action b = Action (a >> b)
+
+instance Monad m => Reducer (m a) (Action m) where
+    unit a = Action (a >> return ())
+    a `cons` Action b = Action (a >> b)
+    Action a `snoc` b = Action (a >> b >> return ())
+
+{-# RULES "unitAction" unit = Action #-}
+{-# RULES "snocAction" snoc = snocAction #-} 
+snocAction :: Reducer (m ()) (Action m) => Action m -> m () -> Action m
+snocAction a = mappend a . Action
+
+newtype MonadSum m a = MonadSum { getMonadSum :: m a } 
+    deriving (Eq,Ord,Show,Read,Functor,Monad,MonadPlus)
+
+instance MonadPlus m => Monoid (MonadSum m a) where
+    mempty = MonadSum mzero
+    MonadSum a `mappend` MonadSum b = MonadSum (a `mplus` b)
+
+instance MonadPlus m => Reducer (m a) (MonadSum m a) where
+    unit = MonadSum
+    a `cons` MonadSum b = MonadSum (a `mplus` b)
+    MonadSum a `snoc` b = MonadSum (a `mplus` b)
+
hunk ./Data/Monoid/Reducer.hs 5
-    , reduce, reducer, reducel
+    , unit, snoc, cons
hunk ./Data/Monoid/Reducer.hs 10
--- minimal definition reduce or reducer
+-- minimal definition unit or snoc
hunk ./Data/Monoid/Reducer.hs 12
-    reduce :: c -> m 
-    reducer :: m -> c -> m
-    reducel :: c -> m -> m 
+    unit :: c -> m 
+    snoc :: m -> c -> m
+    cons :: c -> m -> m 
hunk ./Data/Monoid/Reducer.hs 16
-    reduce = reducer mempty 
-    reducer m = mappend m . reduce
-    reducel = mappend . reduce
+    unit = snoc mempty 
+    snoc m = mappend m . unit
+    cons = mappend . unit
hunk ./Data/Monoid/Reducer.hs 20
-instance (Reducer c m, Reducer c m') => Reducer c (m,m') where
-    reduce x = (reduce x,reduce x)
-    reducer (m,m') x = (reducer m x, reducer m' x)
-    reducel x (m,m') = (reducel x m, reducel x m')
+instance (Reducer c m, Reducer c n) => Reducer c (m,n) where
+    unit x = (unit x,unit x)
+    (m,n) `snoc` x = (m `snoc` x, n `snoc` x)
+    x `cons` (m,n) = (x `cons` m, x `cons` n)
hunk ./Data/Monoid/Reducer.hs 25
-instance (Reducer c m, Reducer c m', Reducer c m'') => Reducer c (m,m',m'') where
-    reduce x = (reduce x,reduce x, reduce x)
-    reducer (m,m',m'') x = (reducer m x, reducer m' x, reducer m'' x)
-    reducel x (m,m',m'') = (reducel x m, reducel x m', reducel x m'')
+instance (Reducer c m, Reducer c n, Reducer c o) => Reducer c (m,n,o) where
+    unit x = (unit x,unit x, unit x)
+    (m,n,o) `snoc` x = (m `snoc` x, n `snoc` x, o `snoc` x)
+    x `cons` (m,n,o) = (x `cons` m, x `cons` n, x `cons` o)
hunk ./Data/Monoid/Reducer.hs 30
-instance (Reducer c m, Reducer c m', Reducer c m'', Reducer c m''') => Reducer c (m,m',m'',m''') where
-    reduce x = (reduce x,reduce x, reduce x, reduce x)
-    reducer (m,m',m'',m''') x = (reducer m x, reducer m' x, reducer m'' x, reducer m''' x)
-    reducel x (m,m',m'',m''') = (reducel x m, reducel x m', reducel x m'', reducel x m''')
+instance (Reducer c m, Reducer c n, Reducer c o, Reducer c p) => Reducer c (m,n,o,p) where
+    unit x = (unit x,unit x, unit x, unit x)
+    (m,n,o,p) `snoc` x = (m `snoc` x, n `snoc` x, o `snoc` x, p `snoc` x)
+    x `cons` (m,n,o,p) = (x `cons` m, x `cons` n, x `cons` o, x `cons` p)
hunk ./Data/Monoid/Reducer.hs 36
-    reduce = return
-    reducel = (:)
-    reducer xs x = xs ++ [x]
+    unit = return
+    cons = (:)
+    xs `snoc` x = xs ++ [x]
+
+instance Reducer [c] [c] where
+    unit = id
+    snoc = mappend
+    cons = mappend
hunk ./Data/Monoid/Reducer.hs 46
-    reduce _ = ()
-    reducer _ _ = ()
-    reducel _ _ = ()
+    unit _ = ()
+    _ `snoc` _ = ()
+    _ `cons` _ = ()
hunk ./Data/Monoid/Reducer/Char.hs 6
-    , reduceChar
+    , fromChar
hunk ./Data/Monoid/Reducer/Char.hs 13
-    reduceChar :: Char -> m 
-    reduceChar = reduce
+    fromChar :: Char -> m 
+    fromChar = unit
hunk ./Data/Monoid/Reducer/With.hs 4
-    , WithReducer(runWithReducer)
-    , withReducer
+    , WithReducer(WithReducer,runWithReducer)
hunk ./Data/Monoid/Reducer/With.hs 13
-withReducer :: (c `Reducer` m) => c -> c `WithReducer` m
-withReducer x = d `seq` WithReducer (d, x) where d = reduce x
-
hunk ./Data/Monoid/Reducer/With.hs 17
-    reduce = fst . runWithReducer 
+    unit = fst . runWithReducer 
hunk ./monoids.cabal 1
-name:		    lexical-monoids
+name:		    monoids
hunk ./monoids.cabal 10
-synopsis:	    Lexical monoids
-description:    Facilities for lexing using monoids
+synopsis:	    Lots of Monoids
+description:    Lots of Monoids
hunk ./monoids.cabal 17
-  build-depends: base >= 4, text, fingertree, bytestring, category-extras, parallel
+  build-depends: base >= 4, text, fingertree, bytestring, category-extras, parallel, containers
hunk ./monoids.cabal 21
-    Data.Monoid.Ord
hunk ./monoids.cabal 26
+    Data.Monoid.Ord
+    Data.Monoid.Monad
+    Data.Monoid.Applicative
+    Data.Monoid.FingerTree
+    Data.Monoid.Map
+    Data.Monoid.IntMap
}
