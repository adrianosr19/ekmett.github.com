[refactored Data.Monoid.Lexical to split out Data.Monoid.Lexical.Generator and Data.Monoid.Lexical.WithLexer
ekmett@gmail.com**20090322163256] {
hunk ./Data/Monoid/Lexical.hs 1
-{-# LANGUAGE UndecidableInstances, TypeOperators, FlexibleContexts, MultiParamTypeClasses, FlexibleInstances #-}
+{-# LANGUAGE UndecidableInstances, FlexibleContexts, MultiParamTypeClasses, FlexibleInstances #-}
hunk ./Data/Monoid/Lexical.hs 6
-    , Generator
-    , lexMany, affixMany, prefixMany
hunk ./Data/Monoid/Lexical.hs 8
-    , WithLexer(WithLexer, runWithLexer)
-    , prelex
-    , unlex
hunk ./Data/Monoid/Lexical.hs 13
-import Data.Text (Text)
-import Data.FingerTree
-import Data.Foldable (fold,foldMap)
-import qualified Data.Text as Text
-import qualified Data.ByteString as Strict
-import qualified Data.ByteString.Lazy as Lazy
-import Control.Parallel.Strategies
hunk ./Data/Monoid/Lexical.hs 44
-instance (CharLexer m, CharLexer m') =>  CharLexer (m,m') where
-    invalid_char bs = (invalid_char bs, invalid_char bs)
-
-instance (CharLexer m, CharLexer m', CharLexer m'') =>  CharLexer (m,m',m'') where
-    invalid_char bs = (invalid_char bs, invalid_char bs, invalid_char bs)
-
-instance (CharLexer m, CharLexer m', CharLexer m'', CharLexer m''') =>  CharLexer (m,m',m'',m''') where
-    invalid_char bs = (invalid_char bs, invalid_char bs, invalid_char bs, invalid_char bs)
-
-class Monoid m => Generator c m where
-    lexMany :: c -> m
-    affixMany :: m -> c -> m
-    prefixMany :: c -> m -> m
-
-    lexMany = affixMany mempty
-    affixMany m c = m `mappend` lexMany c
-    prefixMany c m = lexMany c `mappend` m 
-
-instance Lexer Word8 m => Generator Strict.ByteString m where
-    affixMany = Strict.foldl' affix
-
-instance Lexer Word8 m => Generator Lazy.ByteString m where
-    lexMany = fold . parMap rwhnf lexMany . Lazy.toChunks
-
-instance Lexer Char m => Generator Text m where
-    affixMany = Text.foldl' affix
-
-instance Lexer c m => Generator [c] m where
-    lexMany = foldMap lex
-
-instance Measured v a => Generator (FingerTree v a) v where
-    lexMany = measure
-    affixMany m c = m `mappend` measure c
-    prefixMany c m = measure c `mappend` m
-
-snoc :: [a] -> a -> [a]
-snoc xs x = xs ++ [x]
-
hunk ./Data/Monoid/Lexical.hs 47
-    affix = snoc
+    affix xs x = xs ++ [x]
hunk ./Data/Monoid/Lexical.hs 54
-instance CharLexer [Char]
-
-newtype c `WithLexer` m = WithLexer { runWithLexer :: (m,c) } 
+instance (CharLexer m, CharLexer m') =>  CharLexer (m,m') where
+    invalid_char bs = (invalid_char bs, invalid_char bs)
hunk ./Data/Monoid/Lexical.hs 57
-prelex :: (c `Lexer` m) => c -> c `WithLexer` m
-prelex x = d `seq` WithLexer (d, x) where d = lex x
+instance (CharLexer m, CharLexer m', CharLexer m'') =>  CharLexer (m,m',m'') where
+    invalid_char bs = (invalid_char bs, invalid_char bs, invalid_char bs)
hunk ./Data/Monoid/Lexical.hs 60
-unlex :: c `WithLexer` m -> c
-unlex = snd . runWithLexer
+instance (CharLexer m, CharLexer m', CharLexer m'', CharLexer m''') =>  CharLexer (m,m',m'',m''') where
+    invalid_char bs = (invalid_char bs, invalid_char bs, invalid_char bs, invalid_char bs)
hunk ./Data/Monoid/Lexical.hs 63
-instance Lexer c m => Lexer (c `WithLexer` m) m where
-    lex = fst . runWithLexer 
+instance CharLexer [Char]
hunk ./Data/Monoid/Lexical.hs 65
-instance Lexer c m => Measured m (c `WithLexer` m) where
-    measure = fst . runWithLexer
+instance CharLexer ()
addfile ./Data/Monoid/Lexical/Generator.hs
hunk ./Data/Monoid/Lexical/Generator.hs 1
+{-# LANGUAGE UndecidableInstances, TypeOperators, FlexibleContexts, MultiParamTypeClasses, FlexibleInstances #-}
+module Data.Monoid.Lexical.Generator
+    ( module Data.Monoid.Lexical
+    , Generator
+    , lexMany, affixMany, prefixMany
+    ) where
+
+import Prelude hiding (lex)
+import Data.Word (Word8)
+import Data.Text (Text)
+import Data.FingerTree
+import Data.Foldable (fold,foldMap)
+import qualified Data.Text as Text
+import qualified Data.ByteString as Strict
+import qualified Data.ByteString.Lazy as Lazy
+import Control.Parallel.Strategies
+import Data.Monoid.Lexical
+
+class Monoid m => Generator c m where
+    lexMany :: c -> m
+    affixMany :: m -> c -> m
+    prefixMany :: c -> m -> m
+
+    lexMany = affixMany mempty
+    affixMany m c = m `mappend` lexMany c
+    prefixMany c m = lexMany c `mappend` m 
+
+instance Lexer Word8 m => Generator Strict.ByteString m where
+    affixMany = Strict.foldl' affix
+
+instance Lexer Word8 m => Generator Lazy.ByteString m where
+    lexMany = fold . parMap rwhnf lexMany . Lazy.toChunks
+
+instance Lexer Char m => Generator Text m where
+    affixMany = Text.foldl' affix
+
+instance Lexer c m => Generator [c] m where
+    lexMany = foldMap lex
+
+instance Measured v a => Generator (FingerTree v a) v where
+    lexMany = measure
+    affixMany m c = m `mappend` measure c
+    prefixMany c m = measure c `mappend` m
+
hunk ./Data/Monoid/Lexical/SourcePosition.hs 3
-    ( SourcePosition
+    ( module Data.Monoid.Lexical
+    , SourcePosition
hunk ./Data/Monoid/Lexical/UTF8/Decoder.hs 3
-    ( UTF8
+    ( module Data.Monoid.Lexical
+    , UTF8
hunk ./Data/Monoid/Lexical/UTF8/Decoder.hs 25
-       | H2_1 !Word8 
-       | H3_1 !Word8
-       | H3_2 !Word8 !Word8
-       | H4_1 !Word8
-       | H4_2 !Word8 !Word8
-       | H4_3 !Word8 !Word8 !Word8
+       | H2_1 {-# UNPACK #-} !Word8 
+       | H3_1 {-# UNPACK #-} !Word8
+       | H3_2 {-# UNPACK #-} !Word8 !Word8
+       | H4_1 {-# UNPACK #-} !Word8
+       | H4_2 {-# UNPACK #-} !Word8 !Word8
+       | H4_3 {-# UNPACK #-} !Word8 !Word8 !Word8
addfile ./Data/Monoid/Lexical/WithLexer.hs
hunk ./Data/Monoid/Lexical/WithLexer.hs 1
+{-# LANGUAGE UndecidableInstances, TypeOperators, FlexibleContexts, MultiParamTypeClasses, FlexibleInstances #-}
+module Data.Monoid.Lexical.WithLexer
+    ( module Data.Monoid.Lexical
+    , WithLexer(WithLexer, runWithLexer)
+    , prelex
+    , unlex
+    ) where
+
+import Prelude hiding (lex)
+import Data.Monoid.Lexical
+import Data.FingerTree
+
+newtype WithLexer c m = WithLexer { runWithLexer :: (m,c) } 
+
+prelex :: Lexer c m => c -> WithLexer c m
+prelex x = d `seq` WithLexer (d, x) where d = lex x
+
+unlex :: WithLexer c m -> c
+unlex = snd . runWithLexer
+
+instance Lexer c m => Lexer (WithLexer c m) m where
+    lex = fst . runWithLexer 
+
+instance Lexer c m => Measured m (WithLexer c m) where
+    measure = fst . runWithLexer
hunk ./Data/Monoid/Lexical/Words.hs 3
-    ( Words
+    ( module Data.Monoid.Lexical
+    , Words
hunk ./Data/Monoid/Lexical/Words.hs 9
+    , Unlined(runUnlined)
hunk ./Data/Monoid/Lexical/Words.hs 15
-import Data.Monoid.Lexical
hunk ./Data/Monoid/Lexical/Words.hs 17
--- import Control.Arrow (second)
+import Data.Monoid.Lexical
+import Data.Monoid.Lexical.Generator
hunk ./lexical-monoids.cabal 20
+    Data.Monoid.Lexical.Generator
+    Data.Monoid.Lexical.WithLexer
}
