[new combinators
ekmett@gmail.com**20090327201059] {
addfile ./Data/Group/Combinators.hs
hunk ./Data/Group/Combinators.hs 1
+module Data.Group.Combinators
+    ( module Data.Group
+    , replicate
+    ) where
+
+import Prelude hiding (replicate)
+import Data.Group
+
+
+-- shamelessly stolen from Lennart Augustsson's post: 
+-- http://augustss.blogspot.com/2008/07/lost-and-found-if-i-write-108-in.html
+-- adapted to groups, which can permit negative exponents
+replicate :: (Group m, Integral n) =>  m -> n -> m
+replicate x0 y0 
+    | y0 < 0 = f (gnegate x0) (negate y0)
+    | y0 == 0 = mempty
+    | otherwise = f x0 y0
+    where
+        f x y 
+            | even y = f (x `mappend` x) (y `quot` 2)
+            | y == 1 = x
+            | otherwise = g (x `mappend` x) ((y - 1) `quot` 2) x
+        g x y z 
+            | even y = g (x `mappend` x) (y `quot` 2) z
+            | y == 1 = x `mappend` z
+            | otherwise = g (x `mappend` x) ((y - 1) `quot` 2) (x `mappend` z)
+
hunk ./Data/Monoid/Combinators.hs 4
-    , module Data.Monoid.Reducer
hunk ./Data/Monoid/Combinators.hs 25
-import Prelude hiding (mapM_, any, elem, filter, concatMap, and, or, all, sum, product, notElem)
+import Prelude hiding (mapM_, any, elem, filter, concatMap, and, or, all, sum, product, notElem, replicate, cycle, repeat)
hunk ./Data/Monoid/Combinators.hs 83
-replicate :: (Monoid m, Integral n) => n -> m -> m
+replicate :: (Monoid m, Integral n) => m -> n -> m
hunk ./Data/Monoid/Combinators.hs 94
-            | even y = g (x `mappend` x) (y `quot` 2)
-            | y == 1 = x * z
+            | even y = g (x `mappend` x) (y `quot` 2) z
+            | y == 1 = x `mappend` z
hunk ./Data/Monoid/Combinators.hs 98
-cycle :: m -> m
+cycle :: Monoid m => m -> m
hunk ./monoids.cabal 57
-    Data.Monoid.Reducer.Sugar
}
