[free generator
ekmett@gmail.com**20090329110746] {
hunk ./Data/Monoid/Generator/Free.hs 1
-{-# LANGUAGE UndecidableInstances , FlexibleContexts , MultiParamTypeClasses , FlexibleInstances , GeneralizedNewtypeDeriving #-}
+{-# LANGUAGE UndecidableInstances , FlexibleContexts , MultiParamTypeClasses , FlexibleInstances , GeneralizedNewtypeDeriving, ExistentialQuantification, TypeFamilies #-}
hunk ./Data/Monoid/Generator/Free.hs 5
--- Module      :  Data.Monoid.Reducer
+-- Module      :  Data.Monoid.Generator.Free
hunk ./Data/Monoid/Generator/Free.hs 12
--- A @c@-'Reducer' is a 'Monoid' with a canonical mapping from @c@ to the Monoid.
--- This 'unit' acts in many ways like 'return' for a 'Monad' but is limited
--- to a single type.
---
hunk ./Data/Monoid/Generator/Free.hs 14
-module Data.Monoid.Reducer
-    ( module Data.Monoid
-    , Reducer
-    , unit, snoc, cons
-    , foldMapReduce
-    , foldReduce
-    , pureUnit
-    , returnUnit
+module Data.Monoid.Generator.Free
+    ( module Data.Monoid.Generator
+    , module Data.Monoid.Reducer
+    , Free -- (AnyGen)
hunk ./Data/Monoid/Generator/Free.hs 20
-import Control.Applicative
-import Control.Monad 
-
-import Data.Monoid
-import Data.Monoid.Instances ()
-
+import Control.Functor.Pointed
+import Data.Monoid.Generator
hunk ./Data/Monoid/Generator/Free.hs 23
-import Data.FingerTree
-
-import qualified Data.Sequence as Seq
-import Data.Sequence (Seq)
-
-import qualified Data.Set as Set
-import Data.Set (Set)
-
-import qualified Data.IntSet as IntSet
-import Data.IntSet (IntSet)
-
-import qualified Data.IntMap as IntMap
-import Data.IntMap (IntMap)
-
-import qualified Data.Map as Map
-
-import Data.Map (Map)
-
-import Text.Parsec.Prim
-
---import qualified Data.BitSet as BitSet
---import Data.BitSet (BitSet)
-
--- | This type may be best read infix. A @c `Reducer` m@ is a 'Monoid' @m@ that maps
--- values of type @c@ through @unit@ to values of type @m@. A @c@-'Reducer' may also
--- supply operations which tack-on another @c@ to an existing 'Monoid' @m@ on the left
--- or right. These specialized reductions may be more efficient in some scenarios
--- and are used when appropriate by a 'Generator'. The names 'cons' and 'snoc' work
--- by analogy to the synonymous operations in the list monoid.
---
--- This class deliberately avoids functional-dependencies, so that () can be a @c@-Reducer
--- for all @c@, and so many common reducers can work over multiple types, for instance,
--- First and Last may reduce both @a@ and 'Maybe' @a@. Since a 'Generator' has a fixed element
--- type, the input to the reducer is generally known and extracting from the monoid usually
--- is sufficient to fix the result type. Combinators are available for most scenarios where
--- this is not the case, and the few remaining cases can be handled by using an explicit 
--- type annotation.
---
--- Minimal definition: 'unit' or 'snoc'
-class Monoid m => Reducer c m where
-    -- | Convert a value into a 'Monoid'
-    unit :: c -> m 
-    -- | Append a value to a 'Monoid' for use in left-to-right reduction
-    snoc :: m -> c -> m
-    -- | Prepend a value onto a 'Monoid' for use during right-to-left reduction
-    cons :: c -> m -> m 
-
-    unit = snoc mempty 
-    snoc m = mappend m . unit
-    cons = mappend . unit
-
--- | Apply a 'Reducer' to a 'Foldable' container, after mapping the contents into a suitable form for reduction.
-foldMapReduce :: (Foldable f, e `Reducer` m) => (a -> e) -> f a -> m
-foldMapReduce f = foldMap (unit . f)
+import Data.Monoid.Reducer
+import Data.Monoid.Additive
+import Data.Monoid.Self
hunk ./Data/Monoid/Generator/Free.hs 27
--- | Apply a 'Reducer' to a 'Foldable' mapping each element through 'unit'
-foldReduce :: (Foldable f, e `Reducer` m) => f e -> m
-foldReduce = foldMap unit
+data Free a 
+    = a `Cons` Free a
+    | Free a `Snoc` a
+    | Free a `Plus` Free a
+    | Unit a
+    | Empty
+--    | forall c. (Generator c, Elem c ~ a) => AnyGen c
hunk ./Data/Monoid/Generator/Free.hs 35
-returnUnit :: (Monad m, c `Reducer` n) => c -> m n 
-returnUnit = return . unit
+instance Monoid (Free a) where
+    mempty = Empty
+    mappend = Plus
hunk ./Data/Monoid/Generator/Free.hs 39
-pureUnit :: (Applicative f, c `Reducer` n) => c -> f n
-pureUnit = pure . unit
+instance Reducer a (Free a) where
+    unit = Unit
hunk ./Data/Monoid/Generator/Free.hs 42
-instance (Reducer c m, Reducer c n) => Reducer c (m,n) where
-    unit x = (unit x,unit x)
-    (m,n) `snoc` x = (m `snoc` x, n `snoc` x)
-    x `cons` (m,n) = (x `cons` m, x `cons` n)
+    snoc Empty a = Unit a
+    snoc a b = Snoc a b
hunk ./Data/Monoid/Generator/Free.hs 45
-instance (Reducer c m, Reducer c n, Reducer c o) => Reducer c (m,n,o) where
-    unit x = (unit x,unit x, unit x)
-    (m,n,o) `snoc` x = (m `snoc` x, n `snoc` x, o `snoc` x)
-    x `cons` (m,n,o) = (x `cons` m, x `cons` n, x `cons` o)
+    cons b Empty = Unit b
+    cons a b = Cons a b 
hunk ./Data/Monoid/Generator/Free.hs 48
-instance (Reducer c m, Reducer c n, Reducer c o, Reducer c p) => Reducer c (m,n,o,p) where
-    unit x = (unit x,unit x, unit x, unit x)
-    (m,n,o,p) `snoc` x = (m `snoc` x, n `snoc` x, o `snoc` x, p `snoc` x)
-    x `cons` (m,n,o,p) = (x `cons` m, x `cons` n, x `cons` o, x `cons` p)
+instance Functor Free where
+    fmap f (a `Cons` b) = f a `Cons` fmap f b
+    fmap f (a `Snoc` b) = fmap f a `Snoc` f b
+    fmap f (a `Plus` b) = fmap f a `Plus` fmap f b
+    fmap f (Unit a) = Unit (f a)
+    fmap _ Empty = Empty
+--    fmap f (AnyGen c) = mapReduce f c
hunk ./Data/Monoid/Generator/Free.hs 56
-instance Reducer c [c] where
-    unit = return
-    cons = (:)
-    xs `snoc` x = xs ++ [x]
+instance Pointed Free where
+    point = Unit
hunk ./Data/Monoid/Generator/Free.hs 59
-instance Reducer c () where
-    unit _ = ()
-    _ `snoc` _ = ()
-    _ `cons` _ = ()
+instance Monad Free where
+    return = Unit
+    a `Cons` b >>= k = k a `Plus` (b >>= k)
+    a `Snoc` b >>= k = (a >>= k) `Plus` k b
+    a `Plus` b >>= k = (a >>= k) `Plus` (b >>= k)
+    Unit a >>= k = k a
+    Empty >>= _ = Empty
+--  AnyGen c >>= k = ...
hunk ./Data/Monoid/Generator/Free.hs 68
-instance Reducer Bool Any where
-    unit = Any
+instance Foldable Free where
+    foldMap f (a `Cons` b) = f a `mappend` foldMap f b
+    foldMap f (a `Snoc` b) = foldMap f a `mappend` f b
+    foldMap f (a `Plus` b) = foldMap f a `mappend` foldMap f b
+    foldMap f (Unit a) = f a 
+    foldMap _ Empty = mempty
+--    foldMap f (AnyGen c) = getSelf . mapReduce f c
hunk ./Data/Monoid/Generator/Free.hs 76
-instance Reducer Bool All where
-    unit = All
-
-instance Reducer (a -> a) (Endo a) where
-    unit = Endo
-
-instance Monoid a => Reducer a (Dual a) where
-    unit = Dual
+instance Generator (Free a) where
+    type Elem (Free a) = a
+    mapReduce f (a `Cons` b) = f a `cons` mapReduce f b
+    mapReduce f (a `Snoc` b) = mapReduce f a `snoc` f b
+    mapReduce f (a `Plus` b) = mapReduce f a `plus` mapReduce f b
+    mapReduce f (Unit a) = unit (f a)
+    mapReduce _ Empty = mempty
+--    mapReduce f (AnyGen c) = getSelf . mapReduce f c
hunk ./Data/Monoid/Generator/Free.hs 85
-instance Num a => Reducer a (Sum a) where
-    unit = Sum
-
-instance Num a => Reducer a (Product a) where
-    unit = Product
-
-instance Reducer (Maybe a) (First a) where
-    unit = First
-
-instance Reducer a (First a) where
-    unit = First . Just
-
-instance Reducer (Maybe a) (Last a) where
-    unit = Last
-
-instance Reducer a (Last a) where
-    unit = Last . Just
-
-instance Measured v a => Reducer a (FingerTree v a) where
-    unit = singleton
-    cons = (<|)
-    snoc = (|>) 
-
-instance (Stream s m t, c `Reducer` a) => Reducer c (ParsecT s u m a) where
-    unit = return . unit
-
-instance Reducer a (Seq a) where
-    unit = Seq.singleton
-    cons = (Seq.<|)
-    snoc = (Seq.|>)
-
-instance Reducer Int IntSet where
-    unit = IntSet.singleton
-    cons = IntSet.insert
-    snoc = flip IntSet.insert -- left bias irrelevant
-
-instance Ord a => Reducer a (Set a) where
-    unit = Set.singleton
-    cons = Set.insert
-    -- pedantic about order in case 'Eq' doesn't implement structural equality
-    snoc s m | Set.member m s = s 
-             | otherwise = Set.insert m s
-
-instance Reducer (Int,v) (IntMap v) where
-    unit = uncurry IntMap.singleton
-    cons = uncurry IntMap.insert
-    snoc = flip . uncurry . IntMap.insertWith $ const id
-
-instance Ord k => Reducer (k,v) (Map k v) where
-    unit = uncurry Map.singleton
-    cons = uncurry Map.insert
-    snoc = flip . uncurry . Map.insertWith $ const id
-
-{-
-instance Enum a => Reducer a (BitSet a) where
-    unit m = BitSet.insert m BitSet.empty
--}
+    mapTo f m (a `Cons` b) = m `plus` (f a `cons` mapReduce f b)
+    mapTo f m (a `Snoc` b) = mapTo f m a `snoc` f b
+    mapTo f m (a `Plus` b) = mapTo f m a `plus` mapReduce f b
+    mapTo f m (Unit a)     = m `snoc` f a
+    mapTo _ m Empty        = m 
+--    mapTo f m (AnyGen c)   = getSelf . mapTo f m c
+    
+    mapFrom f (a `Cons` b) m = f a `cons` mapFrom f b m 
+    mapFrom f (a `Snoc` b) m = mapFrom f a (f b `cons` m)
+    mapFrom f (a `Plus` b) m = mapReduce f a `plus` mapFrom f b m
+    mapFrom f (Unit a)     m = f a `cons` m
+    mapFrom _ Empty        m = m 
+--    mapFrom f (AnyGen c)   m = getSelf . mapFrom f c m 
addfile ./Data/Monoid/Reducer.hs
hunk ./Data/Monoid/Reducer.hs 1
+{-# LANGUAGE UndecidableInstances , FlexibleContexts , MultiParamTypeClasses , FlexibleInstances , GeneralizedNewtypeDeriving #-}
+
+-----------------------------------------------------------------------------
+-- |
+-- Module      :  Data.Monoid.Reducer
+-- Copyright   :  (c) Edward Kmett 2009
+-- License     :  BSD-style
+-- Maintainer  :  libraries@haskell.org
+-- Stability   :  experimental
+-- Portability :  non-portable (MPTCs)
+--
+-- A @c@-'Reducer' is a 'Monoid' with a canonical mapping from @c@ to the Monoid.
+-- This 'unit' acts in many ways like 'return' for a 'Monad' but is limited
+-- to a single type.
+--
+-----------------------------------------------------------------------------
+
+module Data.Monoid.Reducer
+    ( module Data.Monoid
+    , Reducer
+    , unit, snoc, cons
+    , foldMapReduce
+    , foldReduce
+    , pureUnit
+    , returnUnit
+    ) where
+
+import Control.Applicative
+import Control.Monad 
+
+import Data.Monoid
+import Data.Monoid.Instances ()
+
+import Data.Foldable
+import Data.FingerTree
+
+import qualified Data.Sequence as Seq
+import Data.Sequence (Seq)
+
+import qualified Data.Set as Set
+import Data.Set (Set)
+
+import qualified Data.IntSet as IntSet
+import Data.IntSet (IntSet)
+
+import qualified Data.IntMap as IntMap
+import Data.IntMap (IntMap)
+
+import qualified Data.Map as Map
+
+import Data.Map (Map)
+
+import Text.Parsec.Prim
+
+--import qualified Data.BitSet as BitSet
+--import Data.BitSet (BitSet)
+
+-- | This type may be best read infix. A @c `Reducer` m@ is a 'Monoid' @m@ that maps
+-- values of type @c@ through @unit@ to values of type @m@. A @c@-'Reducer' may also
+-- supply operations which tack-on another @c@ to an existing 'Monoid' @m@ on the left
+-- or right. These specialized reductions may be more efficient in some scenarios
+-- and are used when appropriate by a 'Generator'. The names 'cons' and 'snoc' work
+-- by analogy to the synonymous operations in the list monoid.
+--
+-- This class deliberately avoids functional-dependencies, so that () can be a @c@-Reducer
+-- for all @c@, and so many common reducers can work over multiple types, for instance,
+-- First and Last may reduce both @a@ and 'Maybe' @a@. Since a 'Generator' has a fixed element
+-- type, the input to the reducer is generally known and extracting from the monoid usually
+-- is sufficient to fix the result type. Combinators are available for most scenarios where
+-- this is not the case, and the few remaining cases can be handled by using an explicit 
+-- type annotation.
+--
+-- Minimal definition: 'unit' or 'snoc'
+class Monoid m => Reducer c m where
+    -- | Convert a value into a 'Monoid'
+    unit :: c -> m 
+    -- | Append a value to a 'Monoid' for use in left-to-right reduction
+    snoc :: m -> c -> m
+    -- | Prepend a value onto a 'Monoid' for use during right-to-left reduction
+    cons :: c -> m -> m 
+
+    unit = snoc mempty 
+    snoc m = mappend m . unit
+    cons = mappend . unit
+
+-- | Apply a 'Reducer' to a 'Foldable' container, after mapping the contents into a suitable form for reduction.
+foldMapReduce :: (Foldable f, e `Reducer` m) => (a -> e) -> f a -> m
+foldMapReduce f = foldMap (unit . f)
+
+-- | Apply a 'Reducer' to a 'Foldable' mapping each element through 'unit'
+foldReduce :: (Foldable f, e `Reducer` m) => f e -> m
+foldReduce = foldMap unit
+
+returnUnit :: (Monad m, c `Reducer` n) => c -> m n 
+returnUnit = return . unit
+
+pureUnit :: (Applicative f, c `Reducer` n) => c -> f n
+pureUnit = pure . unit
+
+instance (Reducer c m, Reducer c n) => Reducer c (m,n) where
+    unit x = (unit x,unit x)
+    (m,n) `snoc` x = (m `snoc` x, n `snoc` x)
+    x `cons` (m,n) = (x `cons` m, x `cons` n)
+
+instance (Reducer c m, Reducer c n, Reducer c o) => Reducer c (m,n,o) where
+    unit x = (unit x,unit x, unit x)
+    (m,n,o) `snoc` x = (m `snoc` x, n `snoc` x, o `snoc` x)
+    x `cons` (m,n,o) = (x `cons` m, x `cons` n, x `cons` o)
+
+instance (Reducer c m, Reducer c n, Reducer c o, Reducer c p) => Reducer c (m,n,o,p) where
+    unit x = (unit x,unit x, unit x, unit x)
+    (m,n,o,p) `snoc` x = (m `snoc` x, n `snoc` x, o `snoc` x, p `snoc` x)
+    x `cons` (m,n,o,p) = (x `cons` m, x `cons` n, x `cons` o, x `cons` p)
+
+instance Reducer c [c] where
+    unit = return
+    cons = (:)
+    xs `snoc` x = xs ++ [x]
+
+instance Reducer c () where
+    unit _ = ()
+    _ `snoc` _ = ()
+    _ `cons` _ = ()
+
+instance Reducer Bool Any where
+    unit = Any
+
+instance Reducer Bool All where
+    unit = All
+
+instance Reducer (a -> a) (Endo a) where
+    unit = Endo
+
+instance Monoid a => Reducer a (Dual a) where
+    unit = Dual
+    
+instance Num a => Reducer a (Sum a) where
+    unit = Sum
+
+instance Num a => Reducer a (Product a) where
+    unit = Product
+
+instance Reducer (Maybe a) (First a) where
+    unit = First
+
+instance Reducer a (First a) where
+    unit = First . Just
+
+instance Reducer (Maybe a) (Last a) where
+    unit = Last
+
+instance Reducer a (Last a) where
+    unit = Last . Just
+
+instance Measured v a => Reducer a (FingerTree v a) where
+    unit = singleton
+    cons = (<|)
+    snoc = (|>) 
+
+instance (Stream s m t, c `Reducer` a) => Reducer c (ParsecT s u m a) where
+    unit = return . unit
+
+instance Reducer a (Seq a) where
+    unit = Seq.singleton
+    cons = (Seq.<|)
+    snoc = (Seq.|>)
+
+instance Reducer Int IntSet where
+    unit = IntSet.singleton
+    cons = IntSet.insert
+    snoc = flip IntSet.insert -- left bias irrelevant
+
+instance Ord a => Reducer a (Set a) where
+    unit = Set.singleton
+    cons = Set.insert
+    -- pedantic about order in case 'Eq' doesn't implement structural equality
+    snoc s m | Set.member m s = s 
+             | otherwise = Set.insert m s
+
+instance Reducer (Int,v) (IntMap v) where
+    unit = uncurry IntMap.singleton
+    cons = uncurry IntMap.insert
+    snoc = flip . uncurry . IntMap.insertWith $ const id
+
+instance Ord k => Reducer (k,v) (Map k v) where
+    unit = uncurry Map.singleton
+    cons = uncurry Map.insert
+    snoc = flip . uncurry . Map.insertWith $ const id
+
+{-
+instance Enum a => Reducer a (BitSet a) where
+    unit m = BitSet.insert m BitSet.empty
+-}
}
