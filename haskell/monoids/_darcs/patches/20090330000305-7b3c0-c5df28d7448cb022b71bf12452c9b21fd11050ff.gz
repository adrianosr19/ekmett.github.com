[bikeshedding
ekmett@gmail.com**20090330000305] {
hunk ./Data/Group/Combinators.hs 20
+    -- * Combinators
hunk ./Data/Group/Combinators.hs 22
+    -- * QuickCheck Properties
+    , prop_replicate_right_distributive
hunk ./Data/Group/Combinators.hs 28
+import Test.QuickCheck
hunk ./Data/Group/Combinators.hs 48
+prop_replicate_right_distributive :: (Eq g, Group g, Arbitrary g, Integral n) => g -> n -> n -> Bool
+prop_replicate_right_distributive g x y 
+    = replicate g (x + y) == replicate g x `mappend` replicate g y
hunk ./Data/Monoid/Applicative.hs 21
-    , WrappedApplicative(WrappedApplicative,getWrappedApplicative)
-    , TraversalWith(TraversalWith,getTraversalWith)
+    , Alt(Alt,getAlt)
+    , App(App,getApp)
hunk ./Data/Monoid/Applicative.hs 46
-{-# RULES "unitTraversal" unit = Traversal #-}
-{-# RULES "snocTraversal" snoc = snocTraversal #-}
hunk ./Data/Monoid/Applicative.hs 51
+{-# RULES "unitTraversal" unit = Traversal #-}
+{-# RULES "snocTraversal" snoc = snocTraversal #-}
hunk ./Data/Monoid/Applicative.hs 54
-
--- | A 'WrappedApplicative' turns any 'Alternative' instance into a 'Monoid'.
+-- | A 'Alt' turns any 'Alternative' instance into a 'Monoid'.
hunk ./Data/Monoid/Applicative.hs 59
-newtype WrappedApplicative f a = WrappedApplicative { getWrappedApplicative :: f a } 
-    deriving (Eq,Ord,Show,Read,Functor,Pointed,Applicative,Alternative,Copointed)
+newtype Alt f a = Alt { getAlt :: f a } 
+    deriving (Eq,Ord,Show,Read,Functor,Applicative,Alternative,Copointed)
hunk ./Data/Monoid/Applicative.hs 62
-instance Alternative f => Monoid (WrappedApplicative f a) where
+instance Alternative f => Monoid (Alt f a) where
hunk ./Data/Monoid/Applicative.hs 64
-    WrappedApplicative a `mappend` WrappedApplicative b = WrappedApplicative (a <|> b) 
+    Alt a `mappend` Alt b = Alt (a <|> b) 
hunk ./Data/Monoid/Applicative.hs 66
-instance (Alternative f, Monoid a) => Multiplicative (WrappedApplicative f a) where
+instance (Applicative f, Monoid a) => Multiplicative (Alt f a) where
hunk ./Data/Monoid/Applicative.hs 70
-instance (Alternative f, c `Reducer` a) => Reducer c (WrappedApplicative f a) where
-    unit = WrappedApplicative . pure . unit
+instance Applicative f => Pointed (Alt f) where
+    point = pure
+
+instance Alternative f => Reducer (f a) (Alt f a) where
+    unit = Alt 
hunk ./Data/Monoid/Applicative.hs 76
-instance (Alternative f, Monoid a) => LeftSemiNearRing (WrappedApplicative f a)
+instance (Alternative f, Monoid a) => LeftSemiNearRing (Alt f a)
hunk ./Data/Monoid/Applicative.hs 78
--- | if @m@ is a 'Module' and @f@ is a 'Applicative' then @f `TraversalWith` m@ is a 'Module' as well
+-- | if @m@ is a 'Module' over @r@ and @f@ is a 'Applicative' then @f `App` m@ is a 'Module' over @r@ as well
hunk ./Data/Monoid/Applicative.hs 80
-newtype TraversalWith f m = TraversalWith { getTraversalWith :: f m } 
+newtype App f m = App { getApp :: f m } 
hunk ./Data/Monoid/Applicative.hs 83
-instance (Monoid m, Applicative f) => Monoid (f `TraversalWith` m) where
+instance (Monoid m, Applicative f) => Monoid (f `App` m) where
hunk ./Data/Monoid/Applicative.hs 87
-instance (Group m, Applicative f) => Group (f `TraversalWith` m) where
+instance (Group m, Applicative f) => Group (f `App` m) where
hunk ./Data/Monoid/Applicative.hs 92
-instance (c `Reducer` m, Applicative f) => Reducer c (f `TraversalWith` m) where
+instance (c `Reducer` m, Applicative f) => Reducer c (f `App` m) where
hunk ./Data/Monoid/Applicative.hs 95
-instance (LeftModule r m, Applicative f) => LeftModule r (f `TraversalWith` m) where
+instance (LeftModule r m, Applicative f) => LeftModule r (f `App` m) where
hunk ./Data/Monoid/Applicative.hs 98
-instance (RightModule r m, Applicative f) => RightModule r (f `TraversalWith` m) where
+instance (RightModule r m, Applicative f) => RightModule r (f `App` m) where
hunk ./Data/Monoid/Applicative.hs 101
-instance (Module r m, Applicative f) => Module r (f `TraversalWith` m)
+instance (Module r m, Applicative f) => Module r (f `App` m)
hunk ./Data/Monoid/Categorical.hs 20
-    , Mon(Mon)
-    , getMon
+    , CMonoid
+    , categoryToMonoid
+    , monoidToCategory
hunk ./Data/Monoid/Categorical.hs 36
--- | A 'Monoid' is just a 'Category' with one object. 
-data Mon m n o where
-    Mon :: Monoid m => m -> Mon m a a
+-- | A 'Monoid' is just a 'Category' with one object. This fakes that with a GADT
+data CMonoid m n o where
+    M :: Monoid m => m -> CMonoid m a a
hunk ./Data/Monoid/Categorical.hs 41
-getMon :: Mon m m m -> m 
-getMon (Mon m) = m
+categoryToMonoid :: CMonoid m m m -> m 
+categoryToMonoid (M m) = m
+{-# INLINE categoryToMonoid #-}
hunk ./Data/Monoid/Categorical.hs 45
-instance Monoid m => Category (Mon m) where
-    id = Mon mempty
-    Mon a . Mon b = Mon (a `mappend` b)
+-- | Convert a value in a 'Monoid' into an arrow in a 'Category'.
+monoidToCategory :: Monoid m => m -> CMonoid m m m 
+monoidToCategory = M 
+{-# INLINE monoidToCategory #-}
hunk ./Data/Monoid/Categorical.hs 50
-instance Monoid m => Monoid (Mon m m m) where
+instance Monoid m => Category (CMonoid m) where
+    id = M mempty
+    M a . M b = M (a `mappend` b)
+
+instance Monoid m => Monoid (CMonoid m m m) where
hunk ./Data/Monoid/Categorical.hs 58
-instance (c `Reducer` m) => Reducer c (Mon m m m) where
-    unit = Mon . unit
+instance (c `Reducer` m) => Reducer c (CMonoid m m m) where
+    unit = M . unit
+
+instance Monoid m => Reducer (CMonoid m m m) m where
+    unit (M m) = m 
hunk ./Data/Monoid/Combinators.hs 24
+    , msum
hunk ./Data/Monoid/Combinators.hs 28
+    , asum
hunk ./Data/Monoid/Combinators.hs 37
+    , toList 
hunk ./Data/Monoid/Combinators.hs 42
+    , filterWith
hunk ./Data/Monoid/Combinators.hs 47
-    -- * List-Like Monoid Generation
+    -- * List-Like Monoid Production
hunk ./Data/Monoid/Combinators.hs 51
+    -- * QuickCheck Properties
+    , prop_replicate_right_distributive
hunk ./Data/Monoid/Combinators.hs 57
+import Control.Monad (MonadPlus)
hunk ./Data/Monoid/Combinators.hs 62
+import Test.QuickCheck
hunk ./Data/Monoid/Combinators.hs 64
--- | Efficiently 'mapReduce' a 'Generator' using the 'Traversal' monoid. A specialized version of its namesake in "Data.Foldable"
+-- | Efficiently 'mapReduce' a 'Generator' using the 'Traversal' monoid. A specialized version of its namesake from "Data.Foldable"
+--
+-- @
+--     'mapReduce' 'getTraversal'
+-- @
hunk ./Data/Monoid/Combinators.hs 70
-traverse_ f = getTraversal . mapReduce f
+traverse_ = mapReduceWith getTraversal
+{-# INLINE traverse_ #-}
hunk ./Data/Monoid/Combinators.hs 73
--- | flipped 'traverse_' as in "Data.Foldable"
+-- | Convenience function as found in "Data.Foldable"
+--
+-- @
+--     'flip' 'traverse_'
+-- @
hunk ./Data/Monoid/Combinators.hs 80
+{-# INLINE for_ #-}
+
+-- | The sum of a collection of actions, generalizing 'concat'
+--
+-- @
+--    'reduceWith' 'getAlt'
+-- @ 
+asum :: (Generator c, Alternative f, f a ~ Elem c) => c -> f a
+asum = reduceWith getAlt
+{-# INLINE asum #-}
hunk ./Data/Monoid/Combinators.hs 92
+-- 
+-- @
+--    'mapReduceWith' 'getAction'
+-- @ 
hunk ./Data/Monoid/Combinators.hs 97
-mapM_ f = getAction . mapReduce f
+mapM_ = mapReduceWith getAction
+{-# INLINE mapM_ #-}
hunk ./Data/Monoid/Combinators.hs 100
--- | flipped 'mapM_' as in "Data.Foldable" and "Control.Monad"
+-- | Convenience function as found in "Data.Foldable" and "Control.Monad"
+--
+-- @
+--     'flip' 'mapM_'
+-- @
hunk ./Data/Monoid/Combinators.hs 107
+{-# INLINE forM_ #-}
+
+-- | The sum of a collection of actions, generalizing 'concat'
+--
+-- @
+--     'reduceWith' 'getMonadSum'
+-- @
+msum :: (Generator c, MonadPlus m, m a ~ Elem c) => c -> m a
+msum = reduceWith getMonadSum
+{-# INLINE msum #-}
hunk ./Data/Monoid/Combinators.hs 119
+--
+-- @
+--     'mapReduceWith' 'getSelf'
+-- @
hunk ./Data/Monoid/Combinators.hs 124
-foldMap f = getSelf . mapReduce f
+foldMap = mapReduceWith getSelf
+{-# INLINE foldMap #-}
+
+-- | Type specialization of "foldMap" above
+concatMap :: Generator c => (Elem c -> [b]) -> c -> [b]
+concatMap = foldMap
+{-# INLINE concatMap #-}
hunk ./Data/Monoid/Combinators.hs 133
+--
+-- @
+--     'reduceWith' 'getSelf'
+-- @
hunk ./Data/Monoid/Combinators.hs 138
-fold = getSelf . reduce
+fold = reduceWith getSelf
+{-# INLINE fold #-}
hunk ./Data/Monoid/Combinators.hs 141
--- | A further specialization of "foldMap"
-concatMap :: Generator c => (Elem c -> [b]) -> c -> [b]
-concatMap = foldMap
+-- | Convert any 'Generator' to a list of its contents. Specialization of 'reduce'
+toList :: Generator c => c -> [Elem c]
+toList = reduce
+{-# INLINE toList #-}
hunk ./Data/Monoid/Combinators.hs 147
+--
+-- @
+--     'reduceWith' 'getAll'
+-- @
hunk ./Data/Monoid/Combinators.hs 152
-and = getAll . reduce
+and = reduceWith getAll
+{-# INLINE and #-}
hunk ./Data/Monoid/Combinators.hs 156
+--
+-- @
+--     'reduceWith' 'getAny'
+-- @
hunk ./Data/Monoid/Combinators.hs 161
-or = getAny . reduce
+or = reduceWith getAny
+{-# INLINE or #-}
hunk ./Data/Monoid/Combinators.hs 165
+--
+-- @
+--     'mapReduceWith' 'getAny'
+-- @
hunk ./Data/Monoid/Combinators.hs 170
-any f = getAny . mapReduce f
+any = mapReduceWith getAny
+{-# INLINE any #-}
hunk ./Data/Monoid/Combinators.hs 174
+--
+-- @
+--     'mapReduceWith' 'getAll'
+-- @
hunk ./Data/Monoid/Combinators.hs 179
-all f = getAll . mapReduce f
+all = mapReduceWith getAll
+{-# INLINE all #-}
hunk ./Data/Monoid/Combinators.hs 182
--- | Efficiently 'mapReduce' any 'Generator' using the 'Sum' 'Monoid'
+-- | Efficiently sum over the members of any 'Generator'
+--
+-- @
+--     'reduceWith' 'getSum'
+-- @
hunk ./Data/Monoid/Combinators.hs 188
-sum = getSum . reduce
+sum = reduceWith getSum
+{-# INLINE sum #-}
hunk ./Data/Monoid/Combinators.hs 191
--- | Efficiently 'mapReduce' any 'Generator' using the 'Product' 'Monoid'
+-- | Efficiently take the product of every member of a 'Generator'
+--
+-- @
+--     'reduceWith' 'getProduct'
+-- @
hunk ./Data/Monoid/Combinators.hs 197
-product = getProduct . reduce
+product = reduceWith getProduct
+{-# INLINE product #-}
hunk ./Data/Monoid/Combinators.hs 203
+{-# INLINE elem #-}
hunk ./Data/Monoid/Combinators.hs 208
+{-# INLINE notElem #-}
hunk ./Data/Monoid/Combinators.hs 215
+{-# INLINE filter #-}
+
+-- | Allows idiomatic specialization of filter by proving a function that will be used to transform the output
+filterWith :: (Generator c, Elem c `Reducer` m) => (m -> n) -> (Elem c -> Bool) -> c -> n 
+filterWith f p = f . filter p
+{-# INLINE filterWith #-}
hunk ./Data/Monoid/Combinators.hs 223
+--
+-- @
+--     'filterWith' 'getFirst'
+-- @
hunk ./Data/Monoid/Combinators.hs 228
-find p = getFirst . filter p
+find = filterWith getFirst
+{-# INLINE find #-}
hunk ./Data/Monoid/Combinators.hs 247
+{-# INLINE replicate #-}
hunk ./Data/Monoid/Combinators.hs 257
+prop_replicate_right_distributive :: (Eq m, Monoid m, Arbitrary m, Integral n) => m -> n -> n -> Bool
+prop_replicate_right_distributive m x y
+    = replicate m (x + y) == replicate m x `mappend` replicate m y
+
hunk ./Data/Monoid/Generator/Free.hs 17
-    , Free -- (AnyGen)
+    , Free (AnyGenerator)
hunk ./Data/Monoid/Generator/Free.hs 21
+import Control.Monad
hunk ./Data/Monoid/Generator/Free.hs 26
+import qualified Data.Monoid.Combinators as M
hunk ./Data/Monoid/Generator/Free.hs 35
---    | forall c. (Generator c, Elem c ~ a) => AnyGen c
+    | forall c. (Generator c, Elem c ~ a) => AnyGenerator c
+
+instance Eq a => Eq (Free a) where
+    a == b = M.toList a == M.toList b
+    a /= b = M.toList a == M.toList b
+
+instance Ord a => Ord (Free a) where
+    a <= b = M.toList a <= M.toList b
+    a >= b = M.toList a >= M.toList b
+    a < b  = M.toList a <  M.toList b
+    a > b  = M.toList a >  M.toList b
+    a `compare` b = M.toList a `compare` M.toList b
hunk ./Data/Monoid/Generator/Free.hs 67
---    fmap f (AnyGen c) = mapReduce f c
+    fmap f (AnyGenerator c) = mapReduce f c
hunk ./Data/Monoid/Generator/Free.hs 74
-    a `Cons` b >>= k = k a `Plus` (b >>= k)
-    a `Snoc` b >>= k = (a >>= k) `Plus` k b
-    a `Plus` b >>= k = (a >>= k) `Plus` (b >>= k)
-    Unit a >>= k = k a
-    Empty >>= _ = Empty
---  AnyGen c >>= k = ...
+    a `Cons` b >>= k     = k a `Plus` (b >>= k)
+    a `Snoc` b >>= k     = (a >>= k) `Plus` k b
+    a `Plus` b >>= k     = (a >>= k) `Plus` (b >>= k)
+    Unit a >>= k         = k a
+    Empty >>= _          = Empty
+    AnyGenerator c >>= k = getSelf (mapReduce k c)
+
+instance MonadPlus Free where
+    mzero = Empty
+    mplus = Plus
hunk ./Data/Monoid/Generator/Free.hs 86
-    foldMap f (a `Cons` b) = f a `mappend` foldMap f b
-    foldMap f (a `Snoc` b) = foldMap f a `mappend` f b
-    foldMap f (a `Plus` b) = foldMap f a `mappend` foldMap f b
-    foldMap f (Unit a) = f a 
-    foldMap _ Empty = mempty
---    foldMap f (AnyGen c) = getSelf . mapReduce f c
+    foldMap f (a `Cons` b)     = f a `mappend` foldMap f b
+    foldMap f (a `Snoc` b)     = foldMap f a `mappend` f b
+    foldMap f (a `Plus` b)     = foldMap f a `mappend` foldMap f b
+    foldMap f (Unit a)         = f a 
+    foldMap _ Empty            = mempty
+    foldMap f (AnyGenerator c) = M.foldMap f c
hunk ./Data/Monoid/Generator/Free.hs 95
-    mapReduce f (a `Cons` b) = f a `cons` mapReduce f b
-    mapReduce f (a `Snoc` b) = mapReduce f a `snoc` f b
-    mapReduce f (a `Plus` b) = mapReduce f a `plus` mapReduce f b
-    mapReduce f (Unit a) = unit (f a)
-    mapReduce _ Empty = mempty
---    mapReduce f (AnyGen c) = getSelf . mapReduce f c
+    mapReduce f (a `Cons` b)     = f a `cons` mapReduce f b
+    mapReduce f (a `Snoc` b)     = mapReduce f a `snoc` f b
+    mapReduce f (a `Plus` b)     = mapReduce f a `plus` mapReduce f b
+    mapReduce f (Unit a)         = unit (f a)
+    mapReduce _ Empty            = mempty
+    mapReduce f (AnyGenerator c) = mapReduce f c
hunk ./Data/Monoid/Generator/Free.hs 102
-    mapTo f m (a `Cons` b) = m `plus` (f a `cons` mapReduce f b)
-    mapTo f m (a `Snoc` b) = mapTo f m a `snoc` f b
-    mapTo f m (a `Plus` b) = mapTo f m a `plus` mapReduce f b
-    mapTo f m (Unit a)     = m `snoc` f a
-    mapTo _ m Empty        = m 
---    mapTo f m (AnyGen c)   = getSelf . mapTo f m c
+    mapTo f m (a `Cons` b)       = m `plus` (f a `cons` mapReduce f b)
+    mapTo f m (a `Snoc` b)       = mapTo f m a `snoc` f b
+    mapTo f m (a `Plus` b)       = mapTo f m a `plus` mapReduce f b
+    mapTo f m (Unit a)           = m `snoc` f a
+    mapTo _ m Empty              = m 
+    mapTo f m (AnyGenerator c)   = mapTo f m c
hunk ./Data/Monoid/Generator/Free.hs 109
-    mapFrom f (a `Cons` b) m = f a `cons` mapFrom f b m 
-    mapFrom f (a `Snoc` b) m = mapFrom f a (f b `cons` m)
-    mapFrom f (a `Plus` b) m = mapReduce f a `plus` mapFrom f b m
-    mapFrom f (Unit a)     m = f a `cons` m
-    mapFrom _ Empty        m = m 
---    mapFrom f (AnyGen c)   m = getSelf . mapFrom f c m 
+    mapFrom f (a `Cons` b)     m = f a `cons` mapFrom f b m 
+    mapFrom f (a `Snoc` b)     m = mapFrom f a (f b `cons` m)
+    mapFrom f (a `Plus` b)     m = mapReduce f a `plus` mapFrom f b m
+    mapFrom f (Unit a)         m = f a `cons` m
+    mapFrom _ Empty            m = m 
+    mapFrom f (AnyGenerator c) m = mapFrom f c m 
hunk ./Data/Monoid/Generator/LZ78.hs 26
+    -- * Lempel-Ziv 78 
hunk ./Data/Monoid/Generator/LZ78.hs 28
+    -- * Decoding
hunk ./Data/Monoid/Generator/LZ78.hs 30
+    -- * Encoding
hunk ./Data/Monoid/Generator/LZ78.hs 33
+    -- * QuickCheck Properties
hunk ./Data/Monoid/Generator.hs 23
+    -- * Generators
hunk ./Data/Monoid/Generator.hs 29
-    , reduce
+    -- * Generator Transformers
hunk ./Data/Monoid/Generator.hs 33
+    -- * Combinators
+    , reduce
+    , mapReduceWith
+    , reduceWith
hunk ./Data/Monoid/Generator.hs 160
+-- | Apply a 'Reducer' directly to the elements of a 'Generator'
+reduce :: (Generator c, Elem c `Reducer` m) => c -> m
+reduce = mapReduce id
hunk ./Data/Monoid/Generator.hs 179
--- | Apply a 'Reducer' directly to the elements of a 'Generator'
-reduce :: (Generator c, Elem c `Reducer` m) => c -> m
-reduce = mapReduce id
+
+mapReduceWith :: (Generator c, e `Reducer` m) => (m -> n) -> (Elem c -> e) -> c -> n
+mapReduceWith f g = f . mapReduce g
+{-# INLINE mapReduceWith #-}
+
+reduceWith :: (Generator c, Elem c `Reducer` m) => (m -> n) -> c -> n
+reduceWith f = f . reduce
+{-# INLINE reduceWith #-}
hunk ./Data/Monoid/Monad.hs 22
+    -- * MonadPlus Monoid
+    , MonadSum(MonadSum, getMonadSum)
hunk ./Data/Monoid/Monad.hs 25
-    , ActionWith(ActionWith,getActionWith)
-    -- * Wrapped Monads
-    , WrappedMonad(WrappedMonad, getWrappedMonad)
+    , Mon(Mon,getMon)
hunk ./Data/Monoid/Monad.hs 28
+import Control.Applicative
hunk ./Data/Monoid/Monad.hs 57
--- | A 'WrappedMonad' turns any 'MonadPlus' instance into a 'Monoid'.
+-- | A 'MonadSum' turns any 'MonadPlus' instance into a 'Monoid'.
hunk ./Data/Monoid/Monad.hs 62
-newtype WrappedMonad m a = WrappedMonad { getWrappedMonad :: m a } 
-    deriving (Eq,Ord,Show,Read,Functor,Pointed, Monad,MonadPlus)
+newtype MonadSum m a = MonadSum { getMonadSum :: m a } 
+    deriving (Eq,Ord,Show,Read,Monad,MonadPlus)
hunk ./Data/Monoid/Monad.hs 65
-instance (Monad m, Monoid a) => Multiplicative (WrappedMonad m a) where
-    one = WrappedMonad (return mempty)
-    WrappedMonad m `times` WrappedMonad n = WrappedMonad (liftM2 mappend m n)
+instance (Monad m, Monoid a) => Multiplicative (MonadSum m a) where
+    one = MonadSum (return mempty)
+    MonadSum m `times` MonadSum n = MonadSum (liftM2 mappend m n)
hunk ./Data/Monoid/Monad.hs 69
-instance (MonadPlus m) => Monoid (WrappedMonad m a) where
+instance MonadPlus m => Monoid (MonadSum m a) where
hunk ./Data/Monoid/Monad.hs 73
-instance (MonadPlus m, c `Reducer` a) => Reducer c (WrappedMonad m a) where
-    unit = WrappedMonad . return . unit
+instance Monad m => Functor (MonadSum m) where
+    fmap = liftM
+
+instance Monad m => Applicative (MonadSum m) where
+    pure = return
+    (<*>) = ap
+
+instance Monad m => Pointed (MonadSum m) where
+    point = return
+
+instance MonadPlus m => Reducer (m a) (MonadSum m a) where
+    unit = MonadSum
hunk ./Data/Monoid/Monad.hs 86
-instance (MonadPlus m, Monoid a) => LeftSemiNearRing (WrappedMonad m a)
+instance (MonadPlus m, Monoid a) => LeftSemiNearRing (MonadSum m a)
hunk ./Data/Monoid/Monad.hs 88
--- | if @m@ is a 'Module' over @r@ and @f@ is a 'Monad' then @f `ActionWith` m@ is a 'Module' as well
+-- | if @m@ is a 'Module' over @r@ and @f@ is a 'Monad' then @f `Mon` m@ is a 'Module' as well
hunk ./Data/Monoid/Monad.hs 90
-newtype ActionWith f m = ActionWith { getActionWith :: f m } 
+newtype Mon f m = Mon { getMon :: f m } 
hunk ./Data/Monoid/Monad.hs 93
-instance (Monoid m, Monad f) => Monoid (f `ActionWith` m) where
+instance (Monoid m, Monad f) => Monoid (f `Mon` m) where
hunk ./Data/Monoid/Monad.hs 97
-instance (Group m, Monad f) => Group (f `ActionWith` m) where
+instance (Group m, Monad f) => Group (f `Mon` m) where
hunk ./Data/Monoid/Monad.hs 102
-instance (c `Reducer` m, Monad f) => Reducer c (f `ActionWith` m) where
+instance (c `Reducer` m, Monad f) => Reducer c (f `Mon` m) where
hunk ./Data/Monoid/Monad.hs 105
-instance (LeftModule r m, Monad f) => LeftModule r (f `ActionWith` m) where
+instance (LeftModule r m, Monad f) => LeftModule r (f `Mon` m) where
hunk ./Data/Monoid/Monad.hs 108
-instance (RightModule r m, Monad f) => RightModule r (f `ActionWith` m) where
+instance (RightModule r m, Monad f) => RightModule r (f `Mon` m) where
hunk ./Data/Monoid/Monad.hs 111
-instance (Module r m, Monad f) => Module r (f `ActionWith` m)
+instance (Module r m, Monad f) => Module r (f `Mon` m)
hunk ./Data/Ring/Boolean.hs 1
-{-# LANGUAGE FlexibleInstances, MultiParamTypeClasses #-}
+{-# LANGUAGE FlexibleInstances, MultiParamTypeClasses, GeneralizedNewtypeDeriving #-}
hunk ./Data/Ring/Boolean.hs 25
+import Test.QuickCheck
hunk ./Data/Ring/Boolean.hs 27
-newtype BoolRing = BoolRing { getBoolRing :: Bool } deriving (Eq,Ord,Show,Read)
+newtype BoolRing = BoolRing { getBoolRing :: Bool } deriving (Eq,Ord,Show,Read,Arbitrary,CoArbitrary)
hunk ./Data/Ring/FromNum.hs 24
+import Test.QuickCheck
hunk ./Data/Ring/FromNum.hs 26
-newtype FromNum a = FromNum { getFromNum :: a } deriving (Eq,Show,Num)
+newtype FromNum a = FromNum { getFromNum :: a } deriving (Eq,Show,Num,Arbitrary,CoArbitrary)
hunk ./Data/Ring/Module/AutomaticDifferentiation.hs 11
+import Test.QuickCheck
+import Control.Monad
hunk ./Data/Ring/Module/AutomaticDifferentiation.hs 39
+instance (Arbitrary r, Arbitrary m) => Arbitrary (D r m) where
+    arbitrary = liftM2 D arbitrary arbitrary
+    shrink (D r m) = liftM2 D (shrink r) (shrink m)
+
+instance (CoArbitrary r, CoArbitrary m) => CoArbitrary (D r m) where
+    coarbitrary (D r m) = coarbitrary r >< coarbitrary m
+
hunk ./Data/Ring/Semi/Ord.hs 28
-newtype Order a = Order { getOrder :: a } deriving (Eq,Ord,Read,Show,Bounded,Arbitrary)
+newtype Order a = Order { getOrder :: a } deriving (Eq,Ord,Read,Show,Bounded,Arbitrary,CoArbitrary)
hunk ./Data/Ring/Semi/Ord.hs 84
-  coarbitrary MinBound    = variant 0
-  coarbitrary (Priority a) = variant 1 . coarbitrary a
-  coarbitrary MaxBound    = variant 2
+  shrink (Priority x) = MinBound : MaxBound : fmap Priority (shrink x)
+  shrink MinBound = []
+  shrink MaxBound = []
+
+instance CoArbitrary a => CoArbitrary (Priority a) where
+  coarbitrary MinBound     = variant (0 :: Int)
+  coarbitrary (Priority a) = variant (1 :: Int) . coarbitrary a
+  coarbitrary MaxBound     = variant (2 :: Int)
hunk ./Data/Ring/Semi/Tropical.hs 1
-{-# LANGUAGE FlexibleInstances, MultiParamTypeClasses #-}
+{-# LANGUAGE FlexibleInstances, MultiParamTypeClasses, GeneralizedNewtypeDeriving #-}
hunk ./Data/Ring/Semi/Tropical.hs 21
+import Test.QuickCheck
hunk ./Data/Ring/Semi/Tropical.hs 37
-newtype Tropical a = Tropical { getTropical :: Maybe a } deriving (Eq,Show,Read)
+newtype Tropical a = Tropical { getTropical :: Maybe a } 
+    deriving (Eq,Show,Read,Arbitrary,CoArbitrary)
hunk ./monoids.cabal 2
-version:	    0.1.13
+version:	    0.1.15
hunk ./monoids.cabal 29
-    QuickCheck < 2.2, 
+    QuickCheck >= 2.1 && < 2.2, 
}
