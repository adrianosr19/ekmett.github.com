[more generators
ekmett@gmail.com**20090327051226] {
hunk ./Data/Monoid/Generator.hs 10
+    , Keys(Keys)
+    , Values(Values)
hunk ./Data/Monoid/Generator.hs 19
+-- import qualified Data.ByteString.Char8 as Strict8
hunk ./Data/Monoid/Generator.hs 21
+-- import qualified Data.ByteString.Lazy.Char8 as Lazy8
+import qualified Data.Sequence as Seq
+import Data.Sequence (Seq)
+import qualified Data.Set as Set
+import Data.Set (Set)
+import qualified Data.IntSet as IntSet
+import Data.IntSet (IntSet)
+import qualified Data.IntMap as IntMap
+import Data.IntMap (IntMap)
+import qualified Data.Map as Map
+import Data.Map (Map)
+
hunk ./Data/Monoid/Generator.hs 54
-    type Elem Lazy.ByteString = Elem Strict.ByteString
+    type Elem Lazy.ByteString = Word8
hunk ./Data/Monoid/Generator.hs 57
+{-
+instance Generator Strict8.ByteString where
+    type Elem Strict8.ByteString = Char
+    mapTo f = Strict8.foldl' (\a -> snoc a . f)
+
+instance Generator Lazy.ByteString where
+    type Elem Lazy8.ByteString = Char
+    mapReduce f = fold . parMap rwhnf (mapReduce f) . Lazy8.toChunks
+-}
+
hunk ./Data/Monoid/Generator.hs 75
-instance Measured v m => Generator (FingerTree v m) where
-    type Elem (FingerTree v m) = m 
+instance Measured v e => Generator (FingerTree v e) where
+    type Elem (FingerTree v e) = e
hunk ./Data/Monoid/Generator.hs 83
+instance Generator IntSet where
+    type Elem IntSet = Int
+    mapReduce f = mapReduce f . IntSet.toList
+
+instance Generator (Set a) where
+    type Elem (Set a) = a
+    mapReduce f = mapReduce f . Set.toList
+
+instance Generator (IntMap v) where
+    type Elem (IntMap v) = (Int,v)
+    mapReduce f = mapReduce f . IntMap.toList
+
+instance Generator (Map k v) where
+    type Elem (Map k v) = (k,v)
+    mapReduce f = mapReduce f . Map.toList
+
+newtype Keys c = Keys { getKeys :: c } 
+
+instance Generator (Keys (IntMap v)) where
+    type Elem (Keys (IntMap v)) = Int
+    mapReduce f = mapReduce f . IntMap.keys . getKeys
+
+instance Generator (Keys (Map k v)) where
+    type Elem (Keys (Map k v)) = k
+    mapReduce f = mapReduce f . Map.keys . getKeys
+
+newtype Values c = Values { getValues :: c } 
+
+instance Generator (Values (IntMap v)) where
+    type Elem (Values (IntMap v)) = v
+    mapReduce f = mapReduce f . IntMap.elems . getValues
+
+instance Generator (Values (Map k v)) where
+    type Elem (Values (Map k v)) = v
+    mapReduce f = mapReduce f . Map.elems . getValues
+
hunk ./Data/Monoid/Generator.hs 121
+{-- SPECIALIZE reduce :: (Char `Reducer` m) => Strict8.ByteString -> m --}
+{-- SPECIALIZE reduce :: (Char `Reducer` m) => Lazy8.ByteString -> m --}
+{-# SPECIALIZE reduce :: (c `Reducer` m) => [c] -> m #-}
+{-# SPECIALIZE reduce :: (Generator (FingerTree v e), e `Reducer` m) => FingerTree v e -> m #-}
hunk ./Data/Monoid/Generator.hs 126
--- These aren't happy, but should work
-{-- RULES "reduce/fold" reduce = fold --}
-{-- RULES "mapReduce/foldMap" mapReduce = foldMap --}
+{-# SPECIALIZE reduce :: (e `Reducer` m) => Seq e -> m #-}
+{-# SPECIALIZE reduce :: (Int `Reducer` m) => IntSet -> m #-}
+{-# SPECIALIZE reduce :: (a `Reducer` m) => Set a -> m #-}
+{-# SPECIALIZE reduce :: ((Int,v) `Reducer` m) => IntMap v -> m #-}
+{-# SPECIALIZE reduce :: ((k,v) `Reducer` m) => Map k v -> m #-}
+{-# SPECIALIZE reduce :: (Int `Reducer` m) => Keys (IntMap v) -> m #-}
+{-# SPECIALIZE reduce :: (k `Reducer` m) => Keys (Map k v) -> m #-}
+{-# SPECIALIZE reduce :: (v `Reducer` m) => Values (IntMap v) -> m #-}
+{-# SPECIALIZE reduce :: (v `Reducer` m) => Values (Map k v) -> m #-}
hunk ./Data/Monoid/IntMap.hs 4
-    , Union(getUnion)
hunk ./Data/Monoid/Map.hs 4
-    , Union(getUnion)
hunk ./Data/Monoid/Multiplicative.hs 13
-import Data.Foldable
}
