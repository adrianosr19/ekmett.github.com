[0.1.35
ekmett@gmail.com**20090409090313
 Ignore-this: 56ccf56a4e659ca1e97511218cbfc493
 
 big consolidation of modules to reduce namespace clutter
 
 attempt at flagging the API so it can be less difficult to install 
 
] {
hunk ./Data/Field/VectorSpace.hs 1
-{-# LANGUAGE MultiParamTypeClasses, FlexibleInstances, FlexibleContexts #-}
-module Data.Field.VectorSpace 
-    ( module Data.Field
-    , module Data.Ring.Module
-    , VectorSpace
-    ) where
-
-import Data.Field
-import Data.Ring.Module
-    
-class (Field f, Module f g) => VectorSpace f g
rmfile ./Data/Field/VectorSpace.hs
rmdir ./Data/Field
hunk ./Data/Field.hs 1
------------------------------------------------------------------------------
--- |
--- Module      :  Data.Field
--- Copyright   :  (c) Edward Kmett 2009
--- License     :  BSD-style
--- Maintainer  :  ekmett@gmail.com
--- Stability   :  experimental
--- Portability :  portable
---
------------------------------------------------------------------------------
-
-module Data.Field
-    ( module Data.Group.Multiplicative
-    , module Data.Ring
-    , Field
-    ) where
-
-import Data.Group.Multiplicative
-import Data.Ring
-import Data.Monoid.Self
-import Data.Monoid.FromString
-import Data.Monoid.Reducer
-
-class (Ring a, MultiplicativeGroup a) => Field a
-
-instance Field f => Field (Dual f)
-instance Field f => Field (Self f)
-instance Field f => Field (FromString f)
-instance Field f => Field (ReducedBy f s)
rmfile ./Data/Field.hs
hunk ./Data/Generator.hs 1
-{-# LANGUAGE UndecidableInstances, TypeOperators, FlexibleContexts, MultiParamTypeClasses, FlexibleInstances, TypeFamilies #-}
+{-# LANGUAGE UndecidableInstances, TypeOperators, FlexibleContexts, MultiParamTypeClasses, FlexibleInstances, TypeFamilies, CPP #-}
hunk ./Data/Generator.hs 39
+#ifdef M_ARRAY
hunk ./Data/Generator.hs 41
-import Data.Word (Word8)
+#endif
+
+
+#ifdef M_TEXT
hunk ./Data/Generator.hs 46
-import Data.Foldable (fold,foldMap)
hunk ./Data/Generator.hs 47
+#endif
+
+
+#ifdef M_BYTESTRING
hunk ./Data/Generator.hs 55
-import qualified Data.Sequence as Seq
+import Data.Word (Word8)
+#endif
+
+#ifdef M_FINGERTREE
hunk ./Data/Generator.hs 60
+#endif
+
+#ifdef M_CONTAINERS
+import qualified Data.Sequence as Seq
hunk ./Data/Generator.hs 73
+#endif
hunk ./Data/Generator.hs 75
+#ifdef M_PARALLEL
hunk ./Data/Generator.hs 77
+#endif
+
+import Data.Foldable (fold,foldMap)
hunk ./Data/Generator.hs 93
+#ifdef M_BYTESTRING
hunk ./Data/Generator.hs 101
+#endif
hunk ./Data/Generator.hs 103
+#ifdef M_TEXT
hunk ./Data/Generator.hs 107
+#endif
hunk ./Data/Generator.hs 113
+#ifdef M_FINGERTREE
hunk ./Data/Generator.hs 117
+#endif
hunk ./Data/Generator.hs 119
+#ifdef M_CONTAINERS
hunk ./Data/Generator.hs 139
+#endif
hunk ./Data/Generator.hs 141
+#ifdef M_ARRAY
hunk ./Data/Generator.hs 145
+#endif
hunk ./Data/Generator.hs 150
+#ifdef M_CONTAINERS
hunk ./Data/Generator.hs 158
+#endif
hunk ./Data/Generator.hs 160
+#ifdef M_ARRAY
hunk ./Data/Generator.hs 164
+#endif
hunk ./Data/Generator.hs 169
+#ifdef M_CONTAINERS
hunk ./Data/Generator.hs 177
+#endif
hunk ./Data/Generator.hs 179
+#ifdef M_ARRAY
hunk ./Data/Generator.hs 183
+#endif
hunk ./Data/Generator.hs 189
+#ifdef M_BYTESTRING
hunk ./Data/Generator.hs 197
+#endif
hunk ./Data/Generator.hs 202
+#ifdef M_BYTESTRING
hunk ./Data/Generator.hs 207
+#endif
hunk ./Data/Generator.hs 209
+#ifdef M_FINGERTREE
hunk ./Data/Generator.hs 211
+#endif
+#ifdef M_TEXT
hunk ./Data/Generator.hs 214
+#endif
+#ifdef M_CONTAINERS
hunk ./Data/Generator.hs 225
+#endif
hunk ./Data/Group/Multiplicative/Sugar.hs 1
------------------------------------------------------------------------------
--- |
--- Module      :  Data.Group.Multiplicative.Sugar
--- Copyright   :  (c) Edward Kmett 2009
--- License     :  BSD-style
--- Maintainer  :  ekmett@gmail.com
--- Stability   :  experimental
--- Portability :  portable
---
--- Syntactic sugar for working with groups that conflicts with names from the "Prelude".
---
--- > import Prelude hiding ((-), (+), (*), (/), negate, subtract, recip)
--- > import Data.Group.Multiplicative.Sugar
---
------------------------------------------------------------------------------
-
-module Data.Group.Multiplicative.Sugar 
-    ( module Data.Monoid.Multiplicative.Sugar
-    , module Data.Group.Multiplicative
-    , module Data.Group.Sugar
-    , (/)
-    , (\\)
-    , recip
-    ) where
-
-import Data.Group.Multiplicative
-import Data.Monoid.Multiplicative.Sugar
-import Data.Group.Sugar
-import Prelude hiding ((-), (+), (*), (/), negate, subtract, recip)
-
-infixl 7 /
-infixr 7 \\
-
-(/) :: MultiplicativeGroup g => g -> g -> g
-(/) = over
-
-(\\) :: MultiplicativeGroup g => g -> g -> g
-(\\) = under
-
-recip :: MultiplicativeGroup g => g -> g
-recip = grecip
rmfile ./Data/Group/Multiplicative/Sugar.hs
rmdir ./Data/Group/Multiplicative
hunk ./Data/Group.hs 15
-    ( module Data.Monoid.Additive
+    ( module Data.Monoid.Multiplicative
hunk ./Data/Group.hs 20
+    , MultiplicativeGroup
+    , over
+    , under
+    , grecip
hunk ./Data/Group.hs 26
-import Data.Monoid.Additive
+import Data.Monoid.Multiplicative
hunk ./Data/Group.hs 28
+
+#ifdef X_OverloadedStrings
hunk ./Data/Group.hs 31
-import Data.Monoid.Reducer
+#endif
hunk ./Data/Group.hs 61
-instance Group a => Group (FromString a) where
-    gnegate = FromString . gnegate . getFromString
-    FromString a `minus` FromString b = FromString (a `minus` b)
+-- | Minimal definition over or grecip
+class Multiplicative g => MultiplicativeGroup g where
+    -- | @x / y@
+    over :: g -> g -> g
+    -- | @x \ y@
+    under :: g -> g -> g
+    grecip :: g -> g
+
+    x `under` y = grecip x `times` y
+    x `over` y = x `times` grecip y
+    grecip x = one `over` x
+
+instance MultiplicativeGroup g => Group (Log g) where
+    Log x `minus` Log y = Log (x `over` y)
+    Log x `gsubtract` Log y = Log (x `under` y)
+    gnegate (Log x) = Log (grecip x)
+
+instance Group g => MultiplicativeGroup (Exp g) where
+    Exp x `over` Exp y = Exp (x `minus` y)
+    Exp x `under` Exp y = Exp (x `gsubtract` y)
+    grecip (Exp x) = Exp (gnegate x)
+
+instance MultiplicativeGroup g => MultiplicativeGroup (Self g) where
+    Self x `over` Self y = Self (x `over` y)
+    Self x `under` Self y = Self (x `under` y)
+    grecip (Self x) = Self (grecip x)
+
+#ifdef M_REFLECTION
+instance MultiplicativeGroup g => MultiplicativeGroup (ReducedBy g s) where
+    Reduction x `over` Reduction y = Reduction (x `over` y)
+    Reduction x `under` Reduction y = Reduction (x `under` y)
+    grecip (Reduction x) = Reduction (grecip x)
hunk ./Data/Group.hs 97
+    Reduction a `gsubtract` Reduction b = Reduction (a `gsubtract` b)
+#endif
+
+instance MultiplicativeGroup a => MultiplicativeGroup (Dual a) where
+    grecip = Dual . grecip . getDual
+
+#ifdef X_OverloadedStrings
+instance MultiplicativeGroup g => MultiplicativeGroup (FromString g) where
+    FromString x `over` FromString y = FromString (x `over` y)
+    FromString x `under` FromString y = FromString (x `under` y)
+    grecip (FromString x) = FromString (grecip x)
+
+instance Group a => Group (FromString a) where
+    gnegate = FromString . gnegate . getFromString
+    FromString a `minus` FromString b = FromString (a `minus` b)
+    FromString a `gsubtract` FromString b = FromString (a `gsubtract` b)
+#endif
hunk ./Data/Group/Multiplicative.hs 1
------------------------------------------------------------------------------
--- |
--- Module      :  Data.Group.Multiplicative
--- Copyright   :  (c) Edward Kmett 2009
--- License     :  BSD-style
--- Maintainer  :  ekmett@gmail.com
--- Stability   :  experimental
--- Portability :  portable
---
------------------------------------------------------------------------------
-
-module Data.Group.Multiplicative 
-    ( module Data.Monoid.Multiplicative
-    , module Data.Group
-    , MultiplicativeGroup
-    , over
-    , under
-    , grecip
-    ) where
-
-import Data.Monoid.Multiplicative
-import Data.Group
-import Data.Monoid.Self
-import Data.Monoid.FromString
-import Data.Monoid.Reducer
-
-    
--- | Minimal definition over or grecip
-class Multiplicative g => MultiplicativeGroup g where
-    -- | @x / y@
-    over :: g -> g -> g
-    -- | @x \ y@
-    under :: g -> g -> g
-    grecip :: g -> g
-
-    x `under` y = grecip x `times` y
-    x `over` y = x `times` grecip y
-    grecip x = one `over` x
-
-instance MultiplicativeGroup g => MultiplicativeGroup (Self g) where
-    Self x `over` Self y = Self (x `over` y)
-    Self x `under` Self y = Self (x `under` y)
-    grecip (Self x) = Self (grecip x)
-
-instance MultiplicativeGroup g => MultiplicativeGroup (FromString g) where
-    FromString x `over` FromString y = FromString (x `over` y)
-    FromString x `under` FromString y = FromString (x `under` y)
-    grecip (FromString x) = FromString (grecip x)
-
-instance MultiplicativeGroup g => MultiplicativeGroup (ReducedBy g s) where
-    Reduction x `over` Reduction y = Reduction (x `over` y)
-    Reduction x `under` Reduction y = Reduction (x `under` y)
-    grecip (Reduction x) = Reduction (grecip x)
-
-instance MultiplicativeGroup a => MultiplicativeGroup (Dual a) where
-    grecip = Dual . grecip . getDual
rmfile ./Data/Group/Multiplicative.hs
hunk ./Data/Group/Sugar.hs 12
--- > import Prelude hiding ((-), (+), negate, subtract)
+-- > import Prelude hiding ((-), (+), (*), (/), (^), (^^), negate, subtract, recip)
hunk ./Data/Group/Sugar.hs 18
-    ( module Data.Monoid.Additive.Sugar
+    ( module Data.Monoid.Sugar
hunk ./Data/Group/Sugar.hs 23
+    , (/)
+    , (.\.)
+    , (^^)
+    , recip
hunk ./Data/Group/Sugar.hs 29
-import Data.Monoid.Additive.Sugar
+import Data.Monoid.Sugar
+import Data.Group.Combinators as Group
hunk ./Data/Group/Sugar.hs 32
-import Prelude hiding ((-), negate, subtract)
+import Prelude hiding ((-), (+), (*), (/), (^^), negate, subtract, recip)
hunk ./Data/Group/Sugar.hs 34
+infixl 8 /
+infixr 8 .\.
hunk ./Data/Group/Sugar.hs 46
+
+(/) :: MultiplicativeGroup g => g -> g -> g
+(/) = over
+
+(.\.) :: MultiplicativeGroup g => g -> g -> g
+(.\.) = under
+
+recip :: MultiplicativeGroup g => g -> g
+recip = grecip
+
+(^^) :: MultiplicativeGroup g => g -> Integer -> g
+g ^^ n = getLog (Group.replicate (Log g) n)
hunk ./Data/Monoid/Additive/Sugar.hs 1
------------------------------------------------------------------------------
--- |
--- Module      :  Data.Monoid.Additive.Sugar
--- Copyright   :  (c) Edward Kmett 2009
--- License     :  BSD-style
--- Maintainer  :  ekmett@gmail.com
--- Stability   :  experimental
--- Portability :  portable
---
--- Syntactic sugar for working with a 'Monoid' that conflicts with names from the "Prelude".
---
--- > import Prelude hiding ((+))
--- > import Data.Monoid.Additive.Sugar
---
------------------------------------------------------------------------------
-
-module Data.Monoid.Additive.Sugar 
-    ( module Data.Monoid.Additive
-    , (+)
-    ) where
-
-import Data.Monoid.Additive
-import Prelude hiding ((+))
-
-infixl 6 + 
-
-(+) :: Monoid m => m -> m -> m 
-(+) = mappend
rmfile ./Data/Monoid/Additive/Sugar.hs
rmdir ./Data/Monoid/Additive
hunk ./Data/Monoid/Applicative.hs 18
-    , module Data.Ring.Semi.Near
hunk ./Data/Monoid/Applicative.hs 27
-import Data.Ring.Semi.Near
hunk ./Data/Monoid/Applicative.hs 81
-    deriving (Eq,Ord,Show,Read,Functor,Pointed,Applicative,Alternative,Copointed)
+    deriving (Eq,Ord,Show,Read,Functor,Applicative,Alternative,Pointed,Copointed)
hunk ./Data/Monoid/Combinators.hs 1
-{-# LANGUAGE UndecidableInstances, TypeOperators, FlexibleContexts, MultiParamTypeClasses, FlexibleInstances, TypeFamilies #-}
+{-# LANGUAGE UndecidableInstances, TypeOperators, FlexibleContexts, MultiParamTypeClasses, FlexibleInstances, TypeFamilies, CPP #-}
hunk ./Data/Monoid/Combinators.hs 25
+#ifdef M_QUICKCHECK
hunk ./Data/Monoid/Combinators.hs 28
+#endif
hunk ./Data/Monoid/Combinators.hs 33
-import Test.QuickCheck
hunk ./Data/Monoid/Combinators.hs 34
+#ifdef M_QUICKCHECK 
+import Test.QuickCheck
+#endif
hunk ./Data/Monoid/Combinators.hs 50
-    | y0 < 0 = mempty -- error "negative length"
+    | y0 < 0 = error "Data.Monoid.Combinators.replicate: negative length"
hunk ./Data/Monoid/Combinators.hs 64
+#ifdef M_QUICKCHECK
hunk ./Data/Monoid/Combinators.hs 68
+#endif
hunk ./Data/Monoid/FromString.hs 5
--- Module      :  Data.Monoid.Additive
+-- Module      :  Data.Monoid.FromString
hunk ./Data/Monoid/FromString.hs 26
-import GHC.Exts
+import Data.String
hunk ./Data/Monoid/Instances.hs 1
-{-# LANGUAGE FlexibleInstances, MultiParamTypeClasses, UndecidableInstances, OverloadedStrings #-}
+{-# LANGUAGE FlexibleInstances, MultiParamTypeClasses, UndecidableInstances, OverloadedStrings, CPP #-}
hunk ./Data/Monoid/Instances.hs 30
+-- * 'Num' and 'Bits' instances for 'Bool' as a 'Boolean' `&&`/`||` 'SemiRing'
+--
hunk ./Data/Monoid/Instances.hs 37
-module Data.Monoid.Instances where
+module Data.Monoid.Instances () where
hunk ./Data/Monoid/Instances.hs 39
+#ifdef M_MTL
hunk ./Data/Monoid/Instances.hs 41
-
hunk ./Data/Monoid/Instances.hs 43
-
hunk ./Data/Monoid/Instances.hs 45
-
hunk ./Data/Monoid/Instances.hs 47
+#endif
hunk ./Data/Monoid/Instances.hs 49
+#ifdef X_OverloadedStrings
hunk ./Data/Monoid/Instances.hs 51
+#endif
hunk ./Data/Monoid/Instances.hs 53
+import Data.Bits
hunk ./Data/Monoid/Instances.hs 56
+#ifdef M_FINGERTREE
hunk ./Data/Monoid/Instances.hs 58
+#endif
hunk ./Data/Monoid/Instances.hs 60
+#ifdef M_PARSEC
hunk ./Data/Monoid/Instances.hs 62
+#endif
hunk ./Data/Monoid/Instances.hs 64
--- orphan Monoid instances for Monad Transformers
+#ifdef M_MTL
hunk ./Data/Monoid/Instances.hs 92
+#endif
hunk ./Data/Monoid/Instances.hs 94
--- orphan, which should be in Data.FingerTree
+#ifdef M_FINGERTREE
hunk ./Data/Monoid/Instances.hs 98
+#endif
hunk ./Data/Monoid/Instances.hs 100
--- orphan, which should be in Parsec
+#ifdef M_PARSEC
hunk ./Data/Monoid/Instances.hs 104
+#endif
hunk ./Data/Monoid/Instances.hs 106
--- orphan, perhaps should be in Data.String
+#ifdef X_OverloadedStrings
hunk ./Data/Monoid/Instances.hs 118
+#endif
hunk ./Data/Monoid/Instances.hs 131
+
+instance Monoid Bool where
+    mempty = 0
+    mappend = (||)
+
+-- boolean semiring
+instance Num Bool where
+    (+) = (||)
+    (*) = (&&)
+    x - y = x && not y
+    negate = not
+    abs = id
+    signum = id
+    fromInteger 0 = False
+    fromInteger _ = True
+
+instance Bits Bool where
+    (.&.)           = (&&)
+    (.|.)           = (||)
+    xor True True   = False
+    xor False False = False
+    xor _ _         = True
+    complement      = not
+    shiftL a b      = a && (b == 0)
+    shiftR a b      = a && (b == 0)
+    shift  a b      = a && (b == 0)
+    rotate a _      = a
+    bit             = (==0)
+    setBit a b      = a || (b == 0)
+    testBit a b     = a && (b == 0)
+    bitSize _       = 1
+    isSigned _      = False
hunk ./Data/Monoid/Monad.hs 18
-    , module Data.Ring.Semi.Near
+    , module Data.Ring.Module
hunk ./Data/Monoid/Monad.hs 31
-import Data.Ring.Semi.Near
hunk ./Data/Monoid/Multiplicative/Sugar.hs 1
------------------------------------------------------------------------------
--- |
--- Module      :  Data.Monoid.Multiplicative.Sugar
--- Copyright   :  (c) Edward Kmett 2009
--- License     :  BSD-style
--- Maintainer  :  ekmett@gmail.com
--- Stability   :  experimental
--- Portability :  portable
---
--- Syntactic sugar for working with a 'Multiplicative' monoids that conflicts with names from the "Prelude".
---
--- > import Prelude hiding ((+),(*))
--- > import Data.Monoid.Multiplicative.Sugar
---
------------------------------------------------------------------------------
-
-module Data.Monoid.Multiplicative.Sugar
-    ( module Data.Monoid.Additive.Sugar
-    , module Data.Monoid.Multiplicative
-    , (*)
-    ) where
-
-import Data.Monoid.Additive.Sugar
-import Data.Monoid.Multiplicative
-import Prelude hiding ((*))
-
-infixl 7 *
-
-(*) :: Multiplicative r => r -> r -> r
-(*) = times
rmfile ./Data/Monoid/Multiplicative/Sugar.hs
rmdir ./Data/Monoid/Multiplicative
hunk ./Data/Monoid/Multiplicative.hs 44
+import Data.Monoid.Additive
+import Data.Generator
+import Data.Monoid.Instances ()
+import Data.Monoid.Self
+import Data.Ratio
hunk ./Data/Monoid/Multiplicative.hs 50
+#ifdef M_STM
hunk ./Data/Monoid/Multiplicative.hs 52
+#endif
hunk ./Data/Monoid/Multiplicative.hs 54
+#ifdef M_MTL
hunk ./Data/Monoid/Multiplicative.hs 57
-
hunk ./Data/Monoid/Multiplicative.hs 58
-
hunk ./Data/Monoid/Multiplicative.hs 60
-
hunk ./Data/Monoid/Multiplicative.hs 62
-
hunk ./Data/Monoid/Multiplicative.hs 64
-
hunk ./Data/Monoid/Multiplicative.hs 66
+#endif
hunk ./Data/Monoid/Multiplicative.hs 68
+#ifdef M_FINGERTREE
hunk ./Data/Monoid/Multiplicative.hs 70
-
-import Data.Monoid.Additive
-import Data.Monoid.FromString
-import Data.Generator
-import Data.Monoid.Instances ()
-import Data.Monoid.Self
-
-import Data.Ratio
+#endif
hunk ./Data/Monoid/Multiplicative.hs 72
+#ifdef M_CONTAINERS
hunk ./Data/Monoid/Multiplicative.hs 75
+#endif
hunk ./Data/Monoid/Multiplicative.hs 77
+#ifdef M_PARSEC
hunk ./Data/Monoid/Multiplicative.hs 79
+#endif
+
+#ifdef X_OverloadedStrings
+import Data.Monoid.FromString
+#endif
hunk ./Data/Monoid/Multiplicative.hs 111
--- simple monoid transformer instances
hunk ./Data/Monoid/Multiplicative.hs 115
-instance Multiplicative m => Multiplicative (FromString m) where
-    one = FromString one
-    FromString a `times` FromString b = FromString (a `times` b)
-
--- the goal of this is that I can make left seminearrings out of any 'Alternative' wrapped around a monoid
--- in particular its useful for containers
-
+-- Monad instances
hunk ./Data/Monoid/Multiplicative.hs 119
+instance Monoid m => Multiplicative (Maybe m) where
+    one = return mempty
+    times = liftM2 mappend
+instance Monoid n => Multiplicative (IO n) where
+    one = return mempty
+    times = liftM2 mappend
+instance Monoid n => Multiplicative (SST.ST s n) where
+    one = return mempty
+    times = liftM2 mappend
+instance Monoid n => Multiplicative (LST.ST s n) where
+    one = return mempty
+    times = liftM2 mappend
+
+-- Applicative instances
+instance Monoid n => Multiplicative (ZipList n) where
+    one = pure mempty
+    times = liftA2 mappend
+
+instance Monoid m => Multiplicative (Const m a) where
+    one = pure undefined
+    times = liftA2 undefined
+
+-- Numeric instances
+instance Multiplicative Int where
+    one = 1
+    times = (*)
+
+instance Multiplicative Integer where
+    one = 1
+    times = (*)
+
+instance Integral m => Multiplicative (Ratio m) where
+    one = 1
+    times = (*)
hunk ./Data/Monoid/Multiplicative.hs 154
+#ifdef M_CONTAINERS
hunk ./Data/Monoid/Multiplicative.hs 158
+#endif
hunk ./Data/Monoid/Multiplicative.hs 160
+#ifdef M_FINGERTREE
hunk ./Data/Monoid/Multiplicative.hs 165
-
--- but it can at least serve as a canonical multiplication for any monad. 
-instance Monoid m => Multiplicative (Maybe m) where
-    one = return mempty
-    times = liftM2 mappend
+#endif
hunk ./Data/Monoid/Multiplicative.hs 167
+#ifdef M_MTL
hunk ./Data/Monoid/Multiplicative.hs 171
-
hunk ./Data/Monoid/Multiplicative.hs 174
-
hunk ./Data/Monoid/Multiplicative.hs 177
-
hunk ./Data/Monoid/Multiplicative.hs 180
-
hunk ./Data/Monoid/Multiplicative.hs 183
-
hunk ./Data/Monoid/Multiplicative.hs 186
-
hunk ./Data/Monoid/Multiplicative.hs 189
-
hunk ./Data/Monoid/Multiplicative.hs 192
-
hunk ./Data/Monoid/Multiplicative.hs 195
-
hunk ./Data/Monoid/Multiplicative.hs 198
-
hunk ./Data/Monoid/Multiplicative.hs 201
-
hunk ./Data/Monoid/Multiplicative.hs 204
-
hunk ./Data/Monoid/Multiplicative.hs 207
-
hunk ./Data/Monoid/Multiplicative.hs 210
-
hunk ./Data/Monoid/Multiplicative.hs 213
-
hunk ./Data/Monoid/Multiplicative.hs 216
-
hunk ./Data/Monoid/Multiplicative.hs 219
+#endif
hunk ./Data/Monoid/Multiplicative.hs 221
-instance Monoid n => Multiplicative (IO n) where
-    one = return mempty
-    times = liftM2 mappend
-
-instance Monoid n => Multiplicative (SST.ST s n) where
-    one = return mempty
-    times = liftM2 mappend
-
-instance Monoid n => Multiplicative (LST.ST s n) where
-    one = return mempty
-    times = liftM2 mappend
-
+#ifdef M_STM
hunk ./Data/Monoid/Multiplicative.hs 225
+#endif
hunk ./Data/Monoid/Multiplicative.hs 227
+#ifdef M_PARSEC
hunk ./Data/Monoid/Multiplicative.hs 231
+#endif
hunk ./Data/Monoid/Multiplicative.hs 233
--- Applicative instances
-
-instance Monoid n => Multiplicative (ZipList n) where
-    one = pure mempty
-    times = liftA2 mappend
-
-instance Monoid m => Multiplicative (Const m a) where
-    one = pure undefined
-    times = liftA2 undefined
-
--- Numeric instances
-instance Multiplicative Int where
-    one = 1
-    times = (*)
-
-instance Multiplicative Integer where
-    one = 1
-    times = (*)
-
-instance Integral m => Multiplicative (Ratio m) where
-    one = 1
-    times = (*)
-
+#ifdef X_OverloadedStrings 
+instance Multiplicative m => Multiplicative (FromString m) where
+    one = FromString one
+    FromString a `times` FromString b = FromString (a `times` b)
+#endif
hunk ./Data/Monoid/Ord.hs 31
-import Data.Ring.Semi
+import Data.Ring
hunk ./Data/Monoid/Reducer.hs 1
-{-# LANGUAGE UndecidableInstances , FlexibleContexts , MultiParamTypeClasses , FlexibleInstances , GeneralizedNewtypeDeriving, TypeOperators, ScopedTypeVariables #-}
+{-# LANGUAGE UndecidableInstances , FlexibleContexts , MultiParamTypeClasses , FlexibleInstances , GeneralizedNewtypeDeriving, TypeOperators, ScopedTypeVariables, CPP #-}
hunk ./Data/Monoid/Reducer.hs 7
--- License     :  BSD-style
+-- License     :  BSD3
hunk ./Data/Monoid/Reducer.hs 36
+
+#ifdef M_FINGERTREE
hunk ./Data/Monoid/Reducer.hs 39
+#endif
hunk ./Data/Monoid/Reducer.hs 41
+#ifdef M_CONTAINERS
hunk ./Data/Monoid/Reducer.hs 44
-
hunk ./Data/Monoid/Reducer.hs 46
-
hunk ./Data/Monoid/Reducer.hs 48
-
hunk ./Data/Monoid/Reducer.hs 50
-
-import Data.Reflection
-
hunk ./Data/Monoid/Reducer.hs 51
-
hunk ./Data/Monoid/Reducer.hs 52
+#endif
hunk ./Data/Monoid/Reducer.hs 54
-import Text.Parsec.Prim
+#ifdef M_REFLECTION
+import Data.Reflection
+#endif
hunk ./Data/Monoid/Reducer.hs 58
---import qualified Data.BitSet as BitSet
---import Data.BitSet (BitSet)
+#ifdef M_PARSEC
+import Text.Parsec.Prim
+#endif
hunk ./Data/Monoid/Reducer.hs 159
+#ifdef M_FINGERTREE
hunk ./Data/Monoid/Reducer.hs 164
+#endif
hunk ./Data/Monoid/Reducer.hs 166
+#ifdef M_PARSEC
hunk ./Data/Monoid/Reducer.hs 169
+#endif
hunk ./Data/Monoid/Reducer.hs 171
+#ifdef M_CONTAINERS
hunk ./Data/Monoid/Reducer.hs 198
-
-{-
-instance Enum a => Reducer a (BitSet a) where
-    unit m = BitSet.insert m BitSet.empty
--}
+#endif
hunk ./Data/Monoid/Reducer.hs 200
+#ifdef M_REFLECTION
hunk ./Data/Monoid/Reducer.hs 209
+#endif
hunk ./Data/Ring.hs 1
+{-# OPTIONS_GHC -fno-warn-orphans #-}
+{-# LANGUAGE FlexibleInstances, MultiParamTypeClasses, UndecidableInstances #-}
hunk ./Data/Ring.hs 12
+--
+-- Defines left- and right- seminearrings. Every 'MonadPlus' wrapped around
+-- a 'Monoid' qualifies due to the distributivity of (>>=) over 'mplus'.
+--
+-- See <http://conway.rutgers.edu/~ccshan/wiki/blog/posts/WordNumbers1/>
+--
hunk ./Data/Ring.hs 22
-    , module Data.Ring.Semi
+    , Ringoid
+    , LeftSemiNearRing
+    , RightSemiNearRing
+    , SemiRing
hunk ./Data/Ring.hs 27
+    , DivisionRing
+    , Field
hunk ./Data/Ring.hs 32
-import Data.Ring.Semi
hunk ./Data/Ring.hs 33
+
+#ifdef X_OverloadedStrings
hunk ./Data/Ring.hs 36
+#endif
hunk ./Data/Ring.hs 38
-class (Group a, SemiRing a) => Ring a
+#ifdef M_MTL
+import Control.Monad.Reader
+import qualified Control.Monad.RWS.Lazy as LRWS
+import qualified Control.Monad.RWS.Strict as SRWS
+import qualified Control.Monad.State.Lazy as LState
+import qualified Control.Monad.State.Strict as SState
+import qualified Control.Monad.Writer.Lazy as LWriter
+import qualified Control.Monad.Writer.Strict as SWriter
+#endif
+
+#ifdef M_FINGERTREE
+import Data.FingerTree
+#endif
+
+#ifdef M_CONTAINERS
+import qualified Data.Sequence as Seq
+import Data.Sequence (Seq)
+#endif
+
+#ifdef M_PARSEC
+import Text.Parsec.Prim
+#endif
+
+#ifdef X_OverloadedStrings
+import Data.Monoid.FromString
+#endif
+
+-- | @0@ annihilates `times`
+class (Multiplicative m, Monoid m) => Ringoid m
+instance Ringoid Integer
+instance Ringoid Int
+instance Ringoid m => Ringoid (Self m)
+instance Ringoid m => Ringoid (Dual m)
+instance Monoid m => Ringoid [m]
+instance Monoid m => Ringoid (Maybe m)
+
+-- | @a * (b + c) = (a * b) + (a * c)@
+class Ringoid m => LeftSemiNearRing m 
+instance LeftSemiNearRing m => LeftSemiNearRing (Self m)
+instance RightSemiNearRing m => LeftSemiNearRing (Dual m)
+
+-- | @(a + b) * c = (a * c) + (b * c)@
+class Ringoid m => RightSemiNearRing m 
+instance RightSemiNearRing m => RightSemiNearRing (Self m)
+instance LeftSemiNearRing m => RightSemiNearRing (Dual m)
+instance Monoid m => RightSemiNearRing [m]
+instance Monoid m => RightSemiNearRing (Maybe m)
+
+-- | A 'SemiRing' is an instance of both 'Multiplicative' and 'Monoid' where 
+--   'times' distributes over 'plus'.
+class (RightSemiNearRing a, LeftSemiNearRing a) => SemiRing a
+instance SemiRing r => SemiRing (Self r)
+instance SemiRing r => SemiRing (Dual r)
hunk ./Data/Ring.hs 92
+class (Group a, SemiRing a) => Ring a
hunk ./Data/Ring.hs 94
-instance Ring r => Ring (FromString r)
-instance Ring r => Ring (ReducedBy r s)
hunk ./Data/Ring.hs 95
+
+class (Ring a, MultiplicativeGroup a) => DivisionRing a
+instance DivisionRing r => DivisionRing (Self r)
+instance DivisionRing r => DivisionRing (Dual r)
+
+class (Ring a, MultiplicativeGroup a) => Field a
+instance Field f => Field (Dual f)
+instance Field f => Field (Self f)
+
+#ifdef M_REFLECTION
+instance Ringoid m => Ringoid (ReducedBy m s)
+instance LeftSemiNearRing m => LeftSemiNearRing (ReducedBy m s)
+instance RightSemiNearRing m => RightSemiNearRing (ReducedBy m s)
+instance SemiRing r => SemiRing (ReducedBy r s)
+instance Ring r => Ring (ReducedBy r s)
+instance DivisionRing r => DivisionRing (ReducedBy r s)
+instance Field f => Field (ReducedBy f s)
+#endif
+
+#ifdef M_PARSEC
+instance (Stream s m t, Monoid a) => Ringoid (ParsecT s u m a)
+instance (Stream s m t, Monoid a) => RightSemiNearRing (ParsecT s u m a)
+#endif
+
+#ifdef M_MTL
+instance (MonadPlus m, Monoid n) => Ringoid (SState.StateT s m n)
+instance (MonadPlus m, Monoid n) => Ringoid (LState.StateT s m n)
+instance (MonadPlus m, Monoid n) => Ringoid (ReaderT e m n)
+instance (MonadPlus m, Monoid w, Monoid n) => Ringoid (SRWS.RWST r w s m n)
+instance (MonadPlus m, Monoid w, Monoid n) => Ringoid (LRWS.RWST r w s m n)
+instance (MonadPlus m, Monoid w, Monoid n) => Ringoid (SWriter.WriterT w m n)
+instance (MonadPlus m, Monoid w, Monoid n) => Ringoid (LWriter.WriterT w m n)
+instance (MonadPlus m, Monoid n) => RightSemiNearRing (SState.StateT s m n)
+instance (MonadPlus m, Monoid n) => RightSemiNearRing (LState.StateT s m n)
+instance (MonadPlus m, Monoid n) => RightSemiNearRing (ReaderT e m n)
+instance (MonadPlus m, Monoid w, Monoid n) => RightSemiNearRing (SRWS.RWST r w s m n)
+instance (MonadPlus m, Monoid w, Monoid n) => RightSemiNearRing (LRWS.RWST r w s m n)
+instance (MonadPlus m, Monoid w, Monoid n) => RightSemiNearRing (SWriter.WriterT w m n)
+instance (MonadPlus m, Monoid w, Monoid n) => RightSemiNearRing (LWriter.WriterT w m n)
+#endif
+
+#ifdef M_FINGERTREE
+instance (Measured v m, Monoid m) => Ringoid (FingerTree v m)
+instance (Measured v m, Monoid m) => RightSemiNearRing (FingerTree v m)
+#endif
+
+#ifdef M_CONTAINERS
+instance Monoid m => Ringoid (Seq m)
+instance Monoid m => RightSemiNearRing (Seq m)
+#endif
+
+#ifdef X_OverloadedStrings
+instance Ringoid m => Ringoid (FromString m)
+instance RightSemiNearRing m => RightSemiNearRing (FromString m)
+instance LeftSemiNearRing m => LeftSemiNearRing (FromString m)
+instance SemiRing r => SemiRing (FromString r)
+instance Ring r => Ring (FromString r)
+instance DivisionRing r => DivisionRing (FromString r)
+instance Field f => Field (FromString f)
+#endif
hunk ./Data/Ring/Algebra.hs 1
-{-# LANGUAGE MultiParamTypeClasses, FlexibleInstances, FlexibleContexts #-}
-module Data.Ring.Algebra
-    ( module Data.Ring.Module
-    , RAlgebra
-    ) where
-
-import Data.Ring.Module
-
--- | Algebra over a (near) (semi) ring.
---
--- @r *. (x * y) = (r *. x) * y = x * (r *. y)@
---
--- @(x * y) .* r = y * (x .* r) = (y .* r) * x@
-class (r `Module` m, Multiplicative m) => RAlgebra r m 
rmfile ./Data/Ring/Algebra.hs
hunk ./Data/Ring/Boolean.hs 12
--- A Boolean 'Ring' over 'Bool'. Note well that the 'mappend' of this ring is
--- symmetric difference and not disjunction like you might expect. To get that 
--- you should use use 'Ord' from "Data.Ring.Semi.Ord.Order" on 'Bool' to get the '&&'/'||'-based 
--- distributive-lattice 'SemiRing'
+-- A Boolean 'Ring' over any Bits instance. Note well that the 'mappend' of this ring is xor.
+-- You should use use 'Ord' from "Data.Ring.Semi.Ord.Order" on 'Bool' to get the '&&'/'||'-based 
+-- distributive-lattice 'SemiRing'.
+--
+-- Also note that @gnegate = id@ in a Boolean Ring!
hunk ./Data/Ring/Boolean.hs 21
-    , BoolRing(BoolRing, getBoolRing)
+    , Boolean(Boolean, getBoolean)
hunk ./Data/Ring/Boolean.hs 24
+import Data.Bits
hunk ./Data/Ring/Boolean.hs 26
+import Data.Ring.Module
+import Data.Ring.Semi.Natural
hunk ./Data/Ring/Boolean.hs 29
-import Test.QuickCheck
+import Test.QuickCheck hiding ((.&.))
hunk ./Data/Ring/Boolean.hs 31
-newtype BoolRing = BoolRing { getBoolRing :: Bool } deriving (Eq,Ord,Show,Read,Arbitrary,CoArbitrary)
+newtype Boolean a = Boolean { getBoolean :: a } deriving (Eq,Ord,Show,Read,Arbitrary,CoArbitrary)
hunk ./Data/Ring/Boolean.hs 33
-instance Monoid BoolRing where
-    mempty = BoolRing False
-    BoolRing a `mappend` BoolRing b = BoolRing ((a || b) && not (a && b))
+-- | @xor@
+instance Bits a => Monoid (Boolean a) where
+    mempty = Boolean 0  
+    Boolean a `mappend` Boolean b = Boolean ((a .|. b) .&. complement (a .&. b))
hunk ./Data/Ring/Boolean.hs 38
-instance Group BoolRing where
-    gnegate = BoolRing . not . getBoolRing
+-- | @id@, since @x `xor` x = zero@
+instance Bits a => Group (Boolean a) where
+    gnegate = Boolean . id . getBoolean
hunk ./Data/Ring/Boolean.hs 42
-instance Multiplicative BoolRing where
-    one = BoolRing True
-    BoolRing a `times` BoolRing b = BoolRing (a && b)
+-- | @and@
+instance Bits a => Multiplicative (Boolean a) where
+    one = Boolean (complement 0)
+    Boolean a `times` Boolean b = Boolean (a .&. b)
hunk ./Data/Ring/Boolean.hs 47
-instance Ringoid BoolRing
-instance LeftSemiNearRing BoolRing
-instance RightSemiNearRing BoolRing
-instance SemiRing BoolRing
-instance Ring BoolRing
+-- | the boolean ring (using symmetric difference as addition) is a ring
+instance Bits a => Ringoid (Boolean a)
+instance Bits a => LeftSemiNearRing (Boolean a)
+instance Bits a => RightSemiNearRing (Boolean a)
+instance Bits a => SemiRing (Boolean a)
+instance Bits a => Ring (Boolean a)
hunk ./Data/Ring/Boolean.hs 54
-instance Reducer Bool BoolRing where
-    unit = BoolRing
+-- | it reduces boolean values
+instance Bits a => Reducer a (Boolean a) where
+    unit = Boolean
+
+-- | every monoid is a module over the naturals, boolring is idempotent
+instance Bits a => Module Natural (Boolean a)
+instance Bits a => LeftModule Natural (Boolean a) where
+    0 *. _ = mempty
+    _ *. m = m
+instance Bits a => RightModule Natural (Boolean a) where
+    _ .* 0 = mempty
+    m .* _ = m
+instance Bits a => Bimodule Natural (Boolean a)
+
+-- | every group is a module over the integers, boolring is idempotent
+instance Bits a => Module Integer (Boolean a)
+instance Bits a => LeftModule Integer (Boolean a) where
+    0 *. _ = mempty
+    _ *. m = m
+instance Bits a => RightModule Integer (Boolean a) where
+    _ .* 0 = mempty
+    m .* _ = m
+instance Bits a => Bimodule Integer (Boolean a)
+
+-- | every ring is a module over itself
+instance Bits a => Module (Boolean a) (Boolean a)
+instance Bits a => LeftModule (Boolean a) (Boolean a) where 
+    (*.) = times
+instance Bits a => RightModule (Boolean a) (Boolean a) where 
+    (.*) = times
+instance Bits a => Bimodule (Boolean a) (Boolean a)
+instance Bits a => Normed (Boolean a) (Boolean a) where mabs = id
hunk ./Data/Ring/Module.hs 19
-    , LeftModule
-    , (*.)
-    , RightModule
-    , (.*)
+    -- * R-Modules
hunk ./Data/Ring/Module.hs 21
+    , LeftModule, (*.)
+    , RightModule, (.*)
+    , Bimodule
+    -- * R-Normed Modules
+    , Normed, mabs
+    -- * Vector Spaces
+    , VectorSpace
+    -- * R-Algebras
+    , Algebra
hunk ./Data/Ring/Module.hs 37
+
+class (Ringoid r, Monoid m) => Module r m where
+
hunk ./Data/Ring/Module.hs 41
-class (Monoid r, Multiplicative r, Monoid m) => LeftModule r m where
+class (Module r m) => LeftModule r m where
hunk ./Data/Ring/Module.hs 45
-class (Monoid r, Multiplicative r, Monoid m) => RightModule r m where
+class (Module r m) => RightModule r m where
hunk ./Data/Ring/Module.hs 49
-class (LeftModule r m, RightModule r m) => Module r m 
+class (LeftModule r m, RightModule r m) => Bimodule r m 
+
+class (Field f, Module f g) => VectorSpace f g
+
+-- | An r-normed module m satisfies:
+--
+-- (1) @mabs m >= 0@
+--
+-- 2 @mabs m == zero{-_r-} => m == zero{-_m-}@
+--
+-- 3 @mabs (m + n) <= mabs m + mabs n@
+--
+-- 4 @r * mabs m = mabs (r *. m) -- if m is an r-LeftModule@
+--
+-- 5 @mabs m * r = mabs (m .* r) -- if m is an r-RightModule@
+class Module r m => Normed r m where
+    mabs :: m -> r
+
+-- | Algebra over a (near) (semi) ring.
+-- @r *. (x * y) = (r *. x) * y = x * (r *. y)@
+-- @(x * y) .* r = y * (x .* r) = (y .* r) * x@
+class (r `Bimodule` m, Multiplicative m) => Algebra r m 
+
+instance (Module r m, Module r n) => Module r (m,n)
+instance (Module r m, Module r n, Module r o) => Module r (m,n,o)
+instance (Module r m, Module r n, Module r o, Module r p) => Module r (m,n,o,p)
+instance (Module r m, Module r n, Module r o, Module r p, Module r q) => Module r (m,n,o,p,q)
hunk ./Data/Ring/Module.hs 95
-instance (Module r m, Module r n) => Module r (m,n)
-instance (Module r m, Module r n, Module r o) => Module r (m,n,o)
-instance (Module r m, Module r n, Module r o, Module r p) => Module r (m,n,o,p)
-instance (Module r m, Module r n, Module r o, Module r p, Module r q) => Module r (m,n,o,p,q)
-
+instance (Bimodule r m, Bimodule r n) => Bimodule r (m,n)
+instance (Bimodule r m, Bimodule r n, Bimodule r o) => Bimodule r (m,n,o)
+instance (Bimodule r m, Bimodule r n, Bimodule r o, Bimodule r p) => Bimodule r (m,n,o,p)
+instance (Bimodule r m, Bimodule r n, Bimodule r o, Bimodule r p, Bimodule r q) => Bimodule r (m,n,o,p,q)
hunk ./Data/Ring/Module/AutomaticDifferentiation.hs 29
-lift :: (r `Module` m) => r -> D s r m
+lift :: (r `Bimodule` m) => r -> D s r m
hunk ./Data/Ring/Module/AutomaticDifferentiation.hs 32
-infinitesimal :: (r `Module` m, Ringoid m) => D s r m
+infinitesimal :: (r `Bimodule` m, Ringoid m) => D s r m
hunk ./Data/Ring/Module/AutomaticDifferentiation.hs 41
-instance (r `Module` m) => Monoid (D s r m) where
+instance (r `Bimodule` m) => Monoid (D s r m) where
hunk ./Data/Ring/Module/AutomaticDifferentiation.hs 45
-instance (r `Module` m) => Multiplicative (D s r m) where
+instance (r `Bimodule` m) => Multiplicative (D s r m) where
hunk ./Data/Ring/Module/AutomaticDifferentiation.hs 49
-instance (Group r, r `Module` m, Group m) => Group (D s r m) where
+instance (Group r, r `Bimodule` m, Group m) => Group (D s r m) where
hunk ./Data/Ring/Module/AutomaticDifferentiation.hs 67
-instance (Ringoid r, r `Module` m) => Ringoid (D s r m)
-instance (LeftSemiNearRing r, Module r m) => LeftSemiNearRing (D s r m)
-instance (RightSemiNearRing r, Module r m) => RightSemiNearRing (D s r m)
-instance (SemiRing r, r `Module` m) => SemiRing (D s r m)
-instance (Ring r, r `Module` m, Group m) => Ring (D s r m)
+instance (Ringoid r, r `Bimodule` m) => Ringoid (D s r m)
+instance (LeftSemiNearRing r, Bimodule r m) => LeftSemiNearRing (D s r m)
+instance (RightSemiNearRing r, Bimodule r m) => RightSemiNearRing (D s r m)
+instance (SemiRing r, r `Bimodule` m) => SemiRing (D s r m)
+instance (Ring r, r `Bimodule` m, Group m) => Ring (D s r m)
hunk ./Data/Ring/Module/AutomaticDifferentiation.hs 73
-instance (r `Module` m, c `Reducer` r, c `Reducer` m) => Reducer c (D s r m) where
+instance (r `Bimodule` m, c `Reducer` r, c `Reducer` m) => Reducer c (D s r m) where
hunk ./Data/Ring/Module/AutomaticDifferentiation.hs 85
-d :: (r `Module` m, Ringoid m) => (forall s. D s r m -> D s r m) -> (r,m)
+d :: (r `Bimodule` m, Ringoid m) => (forall s. D s r m -> D s r m) -> (r,m)
hunk ./Data/Ring/Semi.hs 1
-{-# LANGUAGE MultiParamTypeClasses #-}
------------------------------------------------------------------------------
--- |
--- Module      :  Data.Ring.Semi
--- Copyright   :  (c) Edward Kmett 2009
--- License     :  BSD-style
--- Maintainer  :  ekmett@gmail.com
--- Stability   :  experimental
--- Portability :  non-portable (MPTCs)
---
---
------------------------------------------------------------------------------
-
-module Data.Ring.Semi
-    ( module Data.Ring.Semi.Near
-    , SemiRing
-    ) where
-
-import Data.Ring.Semi.Near
-import Data.Monoid.Self
-import Data.Monoid.FromString
-
--- | A 'SemiRing' is an instance of both 'Multiplicative' and 'Monoid' where 
---   'times' distributes over 'plus'.
-class (RightSemiNearRing a, LeftSemiNearRing a) => SemiRing a
-
-instance SemiRing r => SemiRing (Self r)
-instance SemiRing r => SemiRing (FromString r)
-instance SemiRing r => SemiRing (ReducedBy r s)
-instance SemiRing r => SemiRing (Dual r)
rmfile ./Data/Ring/Semi.hs
hunk ./Data/Ring/Semi/BitSet.hs 16
--- enumeration
+-- enumeration. Treated as a Boolean semiring over `.&.`/`.|.`. To get a
+-- 'Boolean' 'Ring', use @'Boolean' ('BitSet' a)@.
hunk ./Data/Ring/Semi/BitSet.hs 23
-    , module Data.Ring.Semi
+    , module Data.Ring
hunk ./Data/Ring/Semi/BitSet.hs 47
-import Data.Bits hiding ( complement )
-import qualified Data.Bits as Bits
+import Data.Bits
hunk ./Data/Ring/Semi/BitSet.hs 51
-import Data.Ring.Semi
+import Data.Ring
hunk ./Data/Ring/Semi/BitSet.hs 54
-import Data.Ring.Algebra
+import Data.Ring.Module
hunk ./Data/Ring/Semi/BitSet.hs 131
-full = complement empty 
+full = complement' empty 
hunk ./Data/Ring/Semi/BitSet.hs 134
--- | /O(d)/ Complements a 'BitSet' with respect to the bounds of @a@. Preserves order of 'null' and 'size'
-complement :: (Enum a, Bounded a) => BitSet a -> BitSet a 
-complement r@(BS a b c l h m _ f) = BS (Bits.complement b) (Bits.complement a) (Bits.complement c) l h (Bits.complement m) u f where
-    u = (fromEnum (minBound `asArgTypeOf` r), fromEnum (maxBound `asArgTypeOf` r))
-{-# INLINE complement #-}
hunk ./Data/Ring/Semi/BitSet.hs 137
-recomplement (BS a b c l h m u f) = BS (Bits.complement b) (Bits.complement a) (Bits.complement c) l h (Bits.complement m) u f
+recomplement (BS a b c l h m u f) = BS (complement b) (complement a) (complement c) l h (complement m) u f
hunk ./Data/Ring/Semi/BitSet.hs 142
-pseudoComplement (BS a b c l h m _ f) u = BS (Bits.complement b) (Bits.complement a) (Bits.complement c) l h (Bits.complement m) u f
+pseudoComplement (BS a b c l h m _ f) u = BS (complement b) (complement a) (complement c) l h (complement m) u f
hunk ./Data/Ring/Semi/BitSet.hs 182
-    | m < 0, e < l = bs (a+1) (b+1) (c+1) e h (shiftL m (l - e) .&. Bits.complement 1) u
+    | m < 0, e < l = bs (a+1) (b+1) (c+1) e h (shiftL m (l - e) .&. complement 1) u
hunk ./Data/Ring/Semi/BitSet.hs 267
-        m'' = m .&. shift (Bits.complement m') (l' - l)
+        m'' = m .&. shift (complement m') (l' - l)
hunk ./Data/Ring/Semi/BitSet.hs 315
-    | n < 0     = Bits.complement (recount (Bits.complement n))
+    | n < 0     = complement (recount (complement n))
hunk ./Data/Ring/Semi/BitSet.hs 402
+instance Enum a => Module Natural (BitSet a)
hunk ./Data/Ring/Semi/BitSet.hs 409
-instance Enum a => Module Natural (BitSet a)
+instance Enum a => Bimodule Natural (BitSet a)
+instance (Bounded a, Enum a) => Algebra Natural (BitSet a)
hunk ./Data/Ring/Semi/BitSet.hs 412
+instance (Bounded a, Enum a) => Module (BitSet a) (BitSet a)
hunk ./Data/Ring/Semi/BitSet.hs 415
-instance (Bounded a, Enum a) => Module (BitSet a) (BitSet a)
-
-instance (Bounded a, Enum a) => RAlgebra Natural (BitSet a)
+instance (Bounded a, Enum a) => Bimodule (BitSet a) (BitSet a)
+instance (Bounded a, Enum a) => Algebra (BitSet a) (BitSet a)
hunk ./Data/Ring/Semi/BitSet.hs 421
+
+instance (Show a, Bounded a, Enum a) => Num (BitSet a) where
+    (+) = union
+    (-) = difference
+    (*) = intersection
+    fromInteger m = r where
+        r = BS c c c 0 (hwm m) m u toEnum where
+        c = recount m
+        u = (fromEnum (minBound `asArgTypeOf` r), fromEnum (maxBound `asArgTypeOf` r))
+    abs b | mantissa b < 0 = recomplement b
+          | otherwise = b
+    signum = error "BitSet.signum undefined"
+
+instance (Show a, Bounded a, Enum a) => Bits (BitSet a) where
+    (.&.) = intersection
+    (.|.) = union
+    a `xor` b = (a .|. b) .&. complement (a .&. b)
+
+    -- | /O(d)/ Complements a 'BitSet' with respect to the bounds of @a@. Preserves order of 'null' and 'size'
+    complement r@(BS a b c l h m _ _) = BS (complement b) (complement a) (complement c) l h (complement m) u toEnum where
+        u = (fromEnum (minBound `asArgTypeOf` r), fromEnum (maxBound `asArgTypeOf` r))
+    {-# INLINE complement #-}
+    {-
+    shift (BS a b c l h m _ f) n = BS a b c ((l + r) `max` uh) ((h + r) `max` uh) m (ul,uh) toEnum) where
+        ul = fromEnum (minBound `asArgTypeOf` r)
+        uh = fromEnum (maxBound `asArgTypeOf` r)
+    -}
+    shift = error "BitSet.shift undefined"
+    rotate = error "BitSet.rotate undefined"
+    bit = singleton . toEnum
+    setBit s b = s `union` singleton (toEnum b)
+    clearBit s b = s `difference` singleton (toEnum b)
+    complementBit s b = s `xor` singleton (toEnum b)
+    testBit s b = member (toEnum b) s 
+    bitSize r = fromEnum (maxBound `asArgTypeOf` r) - fromEnum (minBound `asArgTypeOf` r)
+    isSigned _ = True
+
+complement' :: (Bounded a, Enum a) => BitSet a -> BitSet a
+complement' r@(BS a b c l h m _ _) = BS (complement b) (complement a) (complement c) l h (complement m) u toEnum where
+    u = (fromEnum (minBound `asArgTypeOf` r), fromEnum (maxBound `asArgTypeOf` r))
hunk ./Data/Ring/Semi/Kleene.hs 2
-    ( module Data.Ring.Semi
+    ( module Data.Ring
hunk ./Data/Ring/Semi/Kleene.hs 7
-import Data.Ring.Semi
+import Data.Ring
hunk ./Data/Ring/Semi/Natural.hs 18
-    ( module Data.Ring.Semi
+    ( module Data.Ring
hunk ./Data/Ring/Semi/Natural.hs 20
-    , natural
+    , toNatural
+    , fromNatural
hunk ./Data/Ring/Semi/Natural.hs 28
-import Data.Ring.Semi
+import Data.Ring
hunk ./Data/Ring/Semi/Natural.hs 36
-import Data.Monoid.FromString
hunk ./Data/Ring/Semi/Natural.hs 39
+
+#ifdef M_CONTAINERS
+-- used with Seq
hunk ./Data/Ring/Semi/Natural.hs 44
+#endif
+
+#ifdef X_OverloadedStrings
+import Data.Monoid.FromString
+#endif
+
+toNatural :: Integer -> Natural
+toNatural = fromInteger
hunk ./Data/Ring/Semi/Natural.hs 53
-natural :: Integer -> Natural
-natural = fromInteger
+fromNatural :: Ringoid r => Natural -> r
+fromNatural = Monoid.replicate one . getNatural
hunk ./Data/Ring/Semi/Natural.hs 186
--- FromString
-instance Monoid m => LeftModule  Natural (FromString m) where (*.) = flip Monoid.replicate
-instance Monoid m => RightModule Natural (FromString m) where (.*) = Monoid.replicate
-instance Monoid m => Module Natural (FromString m)
-
hunk ./Data/Ring/Semi/Natural.hs 196
--- RLE Seq
-instance Eq a => LeftModule  Natural (RLE Seq a) where (*.) = flip Monoid.replicate
-instance Eq a => RightModule Natural (RLE Seq a) where (.*) = Monoid.replicate
-instance Eq a => Module Natural (RLE Seq a)
-
hunk ./Data/Ring/Semi/Natural.hs 250
+#ifdef M_CONTAINERS
+-- RLE Seq
+instance Eq a => LeftModule  Natural (RLE Seq a) where (*.) = flip Monoid.replicate
+instance Eq a => RightModule Natural (RLE Seq a) where (.*) = Monoid.replicate
+instance Eq a => Module Natural (RLE Seq a)
+#endif
+
+#ifdef X_OverloadedStrings
+-- FromString
+instance Monoid m => LeftModule  Natural (FromString m) where (*.) = flip Monoid.replicate
+instance Monoid m => RightModule Natural (FromString m) where (.*) = Monoid.replicate
+instance Monoid m => Module Natural (FromString m)
+#endif
hunk ./Data/Ring/Semi/Near.hs 1
-{-# OPTIONS_GHC -fno-warn-orphans #-}
-{-# LANGUAGE FlexibleInstances, MultiParamTypeClasses, UndecidableInstances #-}
-
------------------------------------------------------------------------------
--- |
--- Module      :  Data.Ring.Semi.Near
--- Copyright   :  (c) Edward Kmett 2009
--- License     :  BSD-style
--- Maintainer  :  ekmett@gmail.com
--- Stability   :  experimental
--- Portability :  portable (instances use MPTCs)
---
--- Defines left- and right- seminearrings. Every 'MonadPlus' wrapped around
--- a 'Monoid' qualifies due to the distributivity of (>>=) over 'mplus'.
---
--- See <http://conway.rutgers.edu/~ccshan/wiki/blog/posts/WordNumbers1/>
---
------------------------------------------------------------------------------
-
-module Data.Ring.Semi.Near
-    ( module Data.Monoid.Multiplicative
-    , Ringoid
-    , LeftSemiNearRing
-    , RightSemiNearRing
-    ) where
-
-import Control.Monad.Reader
-
-import qualified Control.Monad.RWS.Lazy as LRWS
-import qualified Control.Monad.RWS.Strict as SRWS
-
-import qualified Control.Monad.State.Lazy as LState
-import qualified Control.Monad.State.Strict as SState
-
-import qualified Control.Monad.Writer.Lazy as LWriter
-import qualified Control.Monad.Writer.Strict as SWriter
-
-import Data.Monoid.Multiplicative
-import Data.FingerTree
-import Data.Monoid.FromString
-import Data.Monoid.Self
-import Data.Generator
-
-import qualified Data.Sequence as Seq
-import Data.Sequence (Seq)
-
-import Text.Parsec.Prim
-
--- | @0@ annihilates `times`
-class (Multiplicative m, Monoid m) => Ringoid m
-instance Ringoid m => Ringoid (Self m)
-instance Ringoid m => Ringoid (FromString m)
-instance Ringoid m => Ringoid (ReducedBy m s)
-instance Ringoid m => Ringoid (Dual m)
-instance (Measured v m, Monoid m) => Ringoid (FingerTree v m)
-instance Monoid m => Ringoid [m]
-instance Monoid m => Ringoid (Maybe m)
-instance Monoid m => Ringoid (Seq m)
-instance (Stream s m t, Monoid a) => Ringoid (ParsecT s u m a)
-instance (MonadPlus m, Monoid n) => Ringoid (SState.StateT s m n)
-instance (MonadPlus m, Monoid n) => Ringoid (LState.StateT s m n)
-instance (MonadPlus m, Monoid n) => Ringoid (ReaderT e m n)
-instance (MonadPlus m, Monoid w, Monoid n) => Ringoid (SRWS.RWST r w s m n)
-instance (MonadPlus m, Monoid w, Monoid n) => Ringoid (LRWS.RWST r w s m n)
-instance (MonadPlus m, Monoid w, Monoid n) => Ringoid (SWriter.WriterT w m n)
-instance (MonadPlus m, Monoid w, Monoid n) => Ringoid (LWriter.WriterT w m n)
-
--- | @a * (b + c) = (a * b) + (a * c)@
-class Ringoid m => LeftSemiNearRing m 
-instance LeftSemiNearRing m => LeftSemiNearRing (Self m)
-instance LeftSemiNearRing m => LeftSemiNearRing (FromString m)
-instance LeftSemiNearRing m => LeftSemiNearRing (ReducedBy m s)
-instance RightSemiNearRing m => LeftSemiNearRing (Dual m)
-
--- | @(a + b) * c = (a * c) + (b * c)@
-class Ringoid m => RightSemiNearRing m 
-instance RightSemiNearRing m => RightSemiNearRing (Self m)
-instance RightSemiNearRing m => RightSemiNearRing (FromString m)
-instance RightSemiNearRing m => RightSemiNearRing (ReducedBy m s)
-instance LeftSemiNearRing m => RightSemiNearRing (Dual m)
-instance (Measured v m, Monoid m) => RightSemiNearRing (FingerTree v m)
-instance Monoid m => RightSemiNearRing [m]
-instance Monoid m => RightSemiNearRing (Maybe m)
-instance Monoid m => RightSemiNearRing (Seq m)
-instance (Stream s m t, Monoid a) => RightSemiNearRing (ParsecT s u m a)
-instance (MonadPlus m, Monoid n) => RightSemiNearRing (SState.StateT s m n)
-instance (MonadPlus m, Monoid n) => RightSemiNearRing (LState.StateT s m n)
-instance (MonadPlus m, Monoid n) => RightSemiNearRing (ReaderT e m n)
-instance (MonadPlus m, Monoid w, Monoid n) => RightSemiNearRing (SRWS.RWST r w s m n)
-instance (MonadPlus m, Monoid w, Monoid n) => RightSemiNearRing (LRWS.RWST r w s m n)
-instance (MonadPlus m, Monoid w, Monoid n) => RightSemiNearRing (SWriter.WriterT w m n)
-instance (MonadPlus m, Monoid w, Monoid n) => RightSemiNearRing (LWriter.WriterT w m n)
-
rmfile ./Data/Ring/Semi/Near.hs
hunk ./Data/Ring/Semi/Near/Trie.hs 3
-    ( module Data.Ring.Semi.Near
+    ( module Data.Ring
hunk ./Data/Ring/Semi/Near/Trie.hs 10
-
hunk ./Data/Ring/Semi/Near/Trie.hs 12
---import Data.Monoid.Multiplicative
---import Data.Monoid.Reducer
hunk ./Data/Ring/Semi/Near/Trie.hs 13
---import Data.Ring.Module
-import Data.Ring.Semi.Near
+import Data.Ring
hunk ./Data/Ring/Semi/Ord.hs 15
-    ( module Data.Ring.Semi
+    ( module Data.Ring
hunk ./Data/Ring/Semi/Ord.hs 20
-import Test.QuickCheck
hunk ./Data/Ring/Semi/Ord.hs 22
-import Data.Ring.Semi
+import Data.Ring
hunk ./Data/Ring/Semi/Ord.hs 26
+#ifdef M_QUICKCHECK
+import Test.QuickCheck
+#endif
+
hunk ./Data/Ring/Semi/Ord.hs 31
-newtype Order a = Order { getOrder :: a } deriving (Eq,Ord,Read,Show,Bounded,Arbitrary,CoArbitrary)
+newtype Order a = Order { getOrder :: a } deriving 
+    ( Eq
+    , Ord
+    , Read
+    , Show
+    , Bounded
+#ifdef M_QUICKCHECK
+    , Arbitrary
+    , CoArbitrary
+#endif
+    )
hunk ./Data/Ring/Semi/Ord.hs 94
+#ifdef M_QUICKCHECK
hunk ./Data/Ring/Semi/Ord.hs 107
+#endif
hunk ./Data/Ring/Semi/Tropical.hs 15
-    , module Data.Ring.Semi
+    , module Data.Ring
hunk ./Data/Ring/Semi/Tropical.hs 21
-import Test.QuickCheck
hunk ./Data/Ring/Semi/Tropical.hs 22
-import Data.Monoid.Reducer (Reducer, unit, Monoid, mappend, mempty)
-import Data.Ring.Semi
+import Data.Monoid.Reducer
+import Data.Monoid.Combinators as Monoid
+import Data.Ring.Semi.Natural
+import Data.Ring
+import Data.Ring.Module
hunk ./Data/Ring/Semi/Tropical.hs 29
+#ifdef M_QUICKCHECK
+import Test.QuickCheck
+#endif
+
hunk ./Data/Ring/Semi/Tropical.hs 43
-newtype Tropical a = Tropical { getTropical :: Maybe a } 
-    deriving (Eq,Show,Read,Arbitrary,CoArbitrary)
+newtype Tropical a = Tropical { getTropical :: Maybe a } deriving 
+    ( Eq
+    , Show
+    , Read
+#ifdef M_QUICKCHECK
+    , Arbitrary
+    , CoArbitrary
+#endif
+    )
hunk ./Data/Ring/Semi/Tropical.hs 55
-    Tropical Nothing  `compare` _                    = GT
+    Tropical Nothing  `compare` _                 = GT
hunk ./Data/Ring/Semi/Tropical.hs 88
+
+instance (Ord a, Num a) => Module (Tropical a) (Tropical a)
+instance (Ord a, Num a) => LeftModule (Tropical a) (Tropical a) where (*.) = times
+instance (Ord a, Num a) => RightModule (Tropical a) (Tropical a) where (.*) = times
+instance (Ord a, Num a) => Bimodule (Tropical a) (Tropical a)
+
+instance (Ord a, Num a) => Module Natural (Tropical a)
+instance (Ord a, Num a) => LeftModule Natural (Tropical a) where (*.) = flip Monoid.replicate
+instance (Ord a, Num a) => RightModule Natural (Tropical a) where (.*) = Monoid.replicate
+instance (Ord a, Num a) => Bimodule Natural (Tropical a)
hunk ./Data/Ring/Sugar.hs 1
------------------------------------------------------------------------------
--- |
--- Module      :  Data.Ring.Sugar
--- Copyright   :  (c) Edward Kmett 2009
--- License     :  BSD-style
--- Maintainer  :  ekmett@gmail.com
--- Stability   :  experimental
--- Portability :  portable
---
--- Syntactic sugar for working with rings that conflicts with names from the "Prelude".
---
--- > import Prelude hiding ((-), (+), (*), negate, subtract)
--- > import Data.Ring.Sugar
---
------------------------------------------------------------------------------
-
-module Data.Ring.Sugar 
-    ( module Data.Monoid.Multiplicative.Sugar
-    , module Data.Ring.Semi.Near
-    ) where
-
-import Data.Monoid.Multiplicative.Sugar
-import Data.Ring.Semi.Near
rmfile ./Data/Ring/Sugar.hs
hunk ./monoids.cabal 2
-version:	    0.1.33
+version:	    0.1.35
hunk ./monoids.cabal 16
+-- packages we can extend with new instances
+flag bytestring
+  description: Data.ByteString is available (bytestring)
+
+flag fingertree
+  description: Data.Fingertree is available (fingertree)
+
+flag parallel
+  description: Control.Parallel.Strategies is available (parallel)
+  
+flag stm
+  description: Control.Concurrent.STM is available (stm)
+
+flag QuickCheck
+  description: Test.QuickCheck is available (QuickCheck)
+ 
+flag text
+  description: Data.Text is available (text)
+
+flag reflection
+  description: Data.Reflection is available (reflection)
+
+flag parsec
+  description: Text.Parsec is available (parsec >= 3)
+
+flag mtl
+  description: Control.Monad.* is available (mtl)
+
+-- optional extensions
+flag overloaded-strings
+  description: OverloadedStrings extension is available (extension)
+
+-- compilation options
+flag optimize
+  description: Enable optimizations 
+  default: False
+
hunk ./monoids.cabal 55
-    base >= 4 && < 4.2,
-    containers >= 0.2 && < 0.3, 
-    text >= 0.1 && < 0.2, 
-    parsec >= 3.0 && < 3.1,
-    fingertree >= 0.0 && < 0.1, 
-    bytestring >= 0.9 && < 1.0, 
-    category-extras >= 0.53 && < 0.60, 
-    parallel >= 1.1 && < 1.2, 
-    mtl >= 1.0 && < 1.2, 
-    stm >= 2.1 && < 2.2, 
-    bitset >= 1.0 && < 1.1, 
-    QuickCheck >= 2.1 && < 2.2, 
+    base >= 4 && < 4.2, 
+    category-extras >= 0.53 && < 0.60,
hunk ./monoids.cabal 58
-    reflection >= 0.1 && < 0.2
+    containers >= 0.2 && < 0.3
+
+  extensions:
+    CPP
+
hunk ./monoids.cabal 64
-    Data.Field
-    Data.Field.VectorSpace
+    Data.Generator
+    Data.Generator.Combinators
+    Data.Generator.Compressive.LZ78
+    Data.Generator.Compressive.RLE
+    Data.Generator.Free
hunk ./monoids.cabal 71
-    Data.Group.Multiplicative
-    Data.Group.Multiplicative.Sugar
hunk ./monoids.cabal 73
-    Data.Monoid.Additive.Sugar
hunk ./monoids.cabal 76
-    Data.Monoid.FromString
-    Data.Generator
-    Data.Generator.Combinators
-    Data.Generator.Compressive.LZ78
-    Data.Generator.Compressive.RLE
-    Data.Generator.Free
hunk ./monoids.cabal 82
-    Data.Monoid.Multiplicative.Sugar
hunk ./monoids.cabal 87
+    Data.Monoid.Sugar
hunk ./monoids.cabal 90
-    Data.Ring.Algebra
hunk ./monoids.cabal 92
-    Data.Ring.ModularArithmetic
hunk ./monoids.cabal 94
-    Data.Ring.Semi
hunk ./monoids.cabal 96
-    Data.Ring.Semi.Near
hunk ./monoids.cabal 100
-    Data.Ring.Sugar
hunk ./monoids.cabal 101
+  if flag (bytestring)
+    build-depends: bytestring >= 0.9 && < 1.0 
+    cpp-options: -DM_BYTESTRING=1
+
+  if flag (fingertree)
+    build-depends: fingertree >= 0.0 && < 0.1
+    cpp-options: -DM_FINGERTREE=1
+
+  if flag (parallel)
+    build-depends: parallel >= 1.1 && < 1.2
+    cpp-options: -DM_PARALLEL=1
+
+  if flag (text)
+    build-depends: text >= 0.1 && < 0.2
+    cpp-options: -DM_TEXT=1
+
+  if flag (stm)
+    build-depends: stm >= 2.1 && < 2.2
+    cpp-options: -DM_STM=1
+
+  if flag (QuickCheck)
+    build-depends: QuickCheck >= 2.1 && < 2.2
+    cpp-options: -DM_QUICKCHECK=1
+
+  if flag (reflection)
+    build-depends: reflection >= 0.1 && < 0.2
+    cpp-options: -DM_REFLECTION=1
+    exposed-modules: Data.Ring.ModularArithmetic
+
+  if flag (parsec)
+    build-depends: parsec >= 3.0 && < 3.1
+    cpp-options: -DM_PARSEC=3
+
+  if flag (overloaded-strings)
+    extensions: OverloadedStrings
+    cpp-options: -DX_OverloadedStrings=1
+    exposed-modules: Data.Monoid.FromString
+
+  if flag (mtl) 
+    build-depends: mtl >= 1.0 && < 1.2 
+    cpp-options: -DM_MTL=1
+    
hunk ./monoids.cabal 144
+  cpp-options -DM_ARRAY=1 -DM_CONTAINERS=1
+
+  if flag (optimize)
+    ghc-options: -funbox-strict-fields -O2 -fdicts-cheap
}
