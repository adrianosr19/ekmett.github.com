[towards implementing tries
ekmett@gmail.com**20090403065254] {
adddir ./Data/Ring/Semi/Near
hunk ./Data/Monoid/Union.hs 32
-import Data.Monoid.Reducer (Reducer, unit, cons, snoc, Monoid, mappend, mempty)
+import Data.Monoid.Reducer
hunk ./Data/Monoid/Union.hs 85
-class HasUnionWith f where
+class Functor f => HasUnionWith f where
hunk ./Data/Monoid/Union.hs 99
-
hunk ./Data/Monoid/Union.hs 110
+-- we want an absorbing 0, for that we need a seminearring and a notion of equality
hunk ./Data/Ring/Module.hs 27
+import Data.Monoid.Union
+
hunk ./Data/Ring/Module.hs 65
+
+-- we want an absorbing 0, for that we need a seminearring and a notion of equality
+instance (HasUnionWith f, Ord r, Eq r, RightSemiNearRing r) => LeftModule r (UnionWith f r) where
+    r *. m | r == zero = zero
+           | otherwise = fmap (r `times`) m
+instance (HasUnionWith f, Ord r, Eq r, RightSemiNearRing r) => RightModule r (UnionWith f r) where
+    m .* r | r == zero = zero
+           | otherwise = fmap (`times` r) m
+instance (HasUnionWith f, Ord r, Eq r, RightSemiNearRing r) => Module r (UnionWith f r) where
+
addfile ./Data/Ring/Semi/Near/Trie.hs
hunk ./Data/Ring/Semi/Near/Trie.hs 1
+{-# LANGUAGE FlexibleInstances, MultiParamTypeClasses, FlexibleContexts #-}
+module Data.Ring.Semi.Near.Trie 
+    ( module Data.Ring.Semi.Near
+    , Trie(Trie, total, label, children)
+    , singleton
+    , empty
+    , null
+    ) where
+    
+
+import Data.Map (Map)
+import qualified Data.Map as Map
+--import Data.Monoid.Multiplicative
+--import Data.Monoid.Reducer
+import Data.Monoid.Union hiding (empty)
+--import Data.Ring.Module
+import Data.Ring.Semi.Near
+import Prelude hiding (null)
+
+singleton :: (Ord c, c `Reducer` m) => c -> Trie c m 
+singleton = unit
+
+empty :: (Ord c, Monoid m) => Trie c m
+empty = zero
+
+null :: Ord c => Trie c m -> Bool
+null = Map.null . getUnionWith . children
+
+data Trie c m = Trie { total :: m, label :: m, children :: UnionWith (Map c) (Trie c m) }
+    deriving (Eq,Show)
+
+instance Functor (Trie c) where
+    fmap f (Trie t e r) = Trie (f t) (f e) (fmap (fmap f) r)
+
+instance (Ord c, Monoid m) => Monoid (Trie c m) where
+    mempty = Trie mempty mempty mempty
+    Trie x y z `mappend` Trie x' y' z' = Trie (x `mappend` x') (y `mappend` y') (z `mappend` z')
+
+instance (Ord c, c `Reducer` m) => Reducer c (Trie c m) where
+    unit c = Trie r zero . UnionWith $ flip Map.singleton (Trie r r zero) c where r = unit c
+
+{-
+instance (Ord c, Eq r, RightSemiNearRing r) => Multiplicative (Trie c r) where
+    one = Trie one one zero
+    Trie t e r `times` rhs@(Trie t' e' r') = 
+        Trie (t `times` t') (e `times` e') (r .* rhs `plus` lhs *. r') where
+            lhs = Trie e e zero `asTypeOf` rhs
+
+instance (Ord c, Eq r, RightSemiNearRing r) => RightSemiNearRing (Trie c r)
+
+toList :: (Ord c, c `Reducer` [c]) => Trie c m -> [[c]]
+toList = fmap merge . Map.assocs . getUnionWith . children where
+    merge (k,t) = k `times` toList t
+-}
hunk ./monoids.cabal 73
+    Data.Ring.Semi.Near.Trie
}
