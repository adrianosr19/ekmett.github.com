[documentation
ekmett@gmail.com**20090328091810] {
hunk ./Data/Monoid/Applicative.hs 10
--- Portability :  portable
+-- Portability :  non-portable (MPTCs)
hunk ./Data/Monoid/Combinators.hs 1
-{-# LANGUAGE UndecidableInstances, TypeOperators, FlexibleContexts, MultiParamTypeClasses, FlexibleInstances, TypeFamilies, ScopedTypeVariables #-}
+{-# LANGUAGE UndecidableInstances, TypeOperators, FlexibleContexts, MultiParamTypeClasses, FlexibleInstances, TypeFamilies #-}
hunk ./Data/Monoid/Combinators.hs 10
--- Portability :  portable
+-- Portability :  non-portable (type families, MPTCs)
hunk ./Data/Monoid/FromString.hs 2
+
+-----------------------------------------------------------------------------
+-- |
+-- Module      :  Data.Monoid.Additive
+-- Copyright   :  (c) Edward Kmett 2009
+-- License     :  BSD-style
+-- Maintainer  :  libraries@haskell.org
+-- Stability   :  experimental
+-- Portability :  non-portable (overloaded strings, MPTCs)
+--
+-- Transform any 'Char' 'Reducer' into an 'IsString' instance so it can be
+-- used directly with overloaded string literals.
+--
+-----------------------------------------------------------------------------
+
hunk ./Data/Monoid/FromString.hs 25
+import Data.Monoid.Instances ()
hunk ./Data/Monoid/Generator.hs 2
+
+-----------------------------------------------------------------------------
+-- |
+-- Module      :  Data.Monoid.Generator
+-- Copyright   :  (c) Edward Kmett 2009
+-- License     :  BSD-style
+-- Maintainer  :  libraries@haskell.org
+-- Stability   :  experimental
+-- Portability :  portable
+--
+-- A 'Generator' @c@ is a possibly-specialized container, which contains values of 
+-- type 'Elem' @c@, and which knows how to efficiently apply a 'Reducer' to extract
+-- an answer.
+--
+-- Since a 'Generator' is not polymorphic in its contents, it is more specialized
+-- than "Data.Foldable.Foldable", and a 'Reducer' may supply efficient left-to-right
+-- and right-to-left reduction strategies that a 'Generator' may avail itself of.
+-----------------------------------------------------------------------------
+
hunk ./Data/Monoid/Generator.hs 171
--- apply a reducer that accepts the contents of this generator directly
+-- | Apply a 'Reducer' directly to the elements of a 'Generator'
hunk ./Data/Monoid/Instances.hs 3
+
+-----------------------------------------------------------------------------
+-- |
+-- Module      :  Data.Monoid.Instances
+-- Copyright   :  (c) Edward Kmett 2009
+-- License     :  BSD-style
+-- Maintainer  :  libraries@haskell.org
+-- Stability   :  experimental
+-- Portability :  portable
+--
+-- A collection of orphan instance declarations for Monoids that should
+-- eventually be pushed back down to the source packages.
+--
+-- Every package that uses these instances includes this package internally.
+--
+-- Includes:
+--
+-- * 'Monoid' instances for the 'Monad' transformers from the mtl package
+--
+-- * A 'Monoid' instance for the 'ParsecT' 'Monad' from parsec-3.
+--
+-- * 'IsString' instances for tuples of 'IsString' for overloaded string support.
+--
+-- * A 'Monoid' instance for the 'FingerTree' in the fingertree package 
+--
+-- This module is automatically included everywhere this functionality is required
+-- within this package. You should only have to import this module yourself if you 
+-- want these instances for your own purposes.
+-----------------------------------------------------------------------------
hunk ./Data/Monoid/Lexical/RunLengthEncoding.hs 2
+
+-----------------------------------------------------------------------------
+-- |
+-- Module      :  Data.Monoid.Lexical.RunLengthEncoding
+-- Copyright   :  (c) Edward Kmett 2009
+-- License     :  BSD-style
+-- Maintainer  :  libraries@haskell.org
+-- Stability   :  experimental
+-- Portability :  non-portable (MPTCs)
+--
+-- A simple 'Monoid' transformer that turns any monoidal 'Reducer' into a
+-- a reducer that expects to be supplied both a run length @n@ with each item
+-- and which efficiently exponentiates the result of 'unit' @n@ times through 
+-- 'replicate'.
+--
+-----------------------------------------------------------------------------
+
hunk ./Data/Monoid/Lexical/SourcePosition.hs 2
+
+-----------------------------------------------------------------------------
+-- |
+-- Module      :  Data.Monoid.Lexical.SourcePosition
+-- Copyright   :  (c) Edward Kmett 2009
+-- License     :  BSD-style
+-- Maintainer  :  libraries@haskell.org
+-- Stability   :  experimental
+-- Portability :  non-portable (MPTCs, OverloadedStrings)
+--
+-- Incrementally determine locations in a source file through local information
+-- This allows for efficient recomputation of line #s and token locations
+-- while the file is being interactively updated by storing this as a supplemental
+-- measure on a 'FingerTree'.
+--
+-- The general idea is to use this as part of a measure in a 'FingerTree' so you can
+-- use `mappend` to prepend a 'startOfFile' with the file information.
+-----------------------------------------------------------------------------
+
hunk ./Data/Monoid/Lexical/SourcePosition.hs 23
+    , nextTab
hunk ./Data/Monoid/Lexical/SourcePosition.hs 43
-data SourcePosition file = Pos file {-# UNPACK #-} !SourceLine !SourceColumn
-         | Lines {-# UNPACK #-} !SourceLine !SourceColumn
-         | Columns {-# UNPACK #-} !SourceColumn
-         | Tab {-# UNPACK #-} !SourceColumn !SourceColumn -- cols before and after an unresolved tab
+-- | A 'Monoid' of partial information about locations in a source file.
+--   This is polymorphic in the kind of information you want to maintain about each source file.
+data SourcePosition file 
+        = Pos file {-# UNPACK #-} !SourceLine !SourceColumn -- ^ An absolute position in a file is known, or an overriding #line directive has been seen
+        | Lines {-# UNPACK #-} !SourceLine !SourceColumn    -- ^ We've seen some carriage returns.
+        | Columns {-# UNPACK #-} !SourceColumn              -- ^ We've only seen part of a line.
+        | Tab {-# UNPACK #-} !SourceColumn !SourceColumn    -- ^ We have an unhandled tab to deal with.
hunk ./Data/Monoid/Lexical/SourcePosition.hs 52
+-- | Compute the location of the next standard 8-column aligned tab
hunk ./Data/Monoid/Lexical/SourcePosition.hs 74
+-- accumulate partial information
hunk ./Data/Monoid/Lexical/SourcePosition.hs 96
+-- Indicate that we ignore invalid characters to the UTF8 parser
hunk ./Data/Monoid/Lexical/SourcePosition.hs 99
+-- | lift information about a source file into a starting 'SourcePosition' for that file
hunk ./Data/Monoid/Lexical/SourcePosition.hs 103
+-- | extract partial information about the current column, even in the absence of knowledge of the source file
hunk ./Data/Monoid/Lexical/SourcePosition.hs 109
+-- | extract partial information about the current line number if possible
hunk ./Data/Monoid/Lexical/SourcePosition.hs 114
+-- | extract the standard format for an absolute source position
hunk ./Data/Monoid/Lexical/UTF8/Decoder.hs 2
+
+-----------------------------------------------------------------------------
+-- |
+-- Module      :  Data.Monoid.Lexical.UTF8.Decoder
+-- Copyright   :  (c) Edward Kmett 2009
+-- License     :  BSD-style
+-- Maintainer  :  libraries@haskell.org
+-- Stability   :  experimental
+-- Portability :  portable
+--
+-- UTF8 encoded unicode characters can be parsed both forwards and backwards,
+-- since the start of each 'Char' is clearly marked. This 'Monoid' accumulates
+-- information about the characters represented and reduces that information
+-- using a 'CharReducer', which is just a 'Reducer' 'Monoid' that knows what 
+-- it wants to do about an 'invalidChar' -- a  string of 'Word8' values that 
+-- don't form a valid UTF8 character.
+--
+-- As this monoid parses chars it just feeds them upstream to the underlying
+-- CharReducer. Efficient left-to-right and right-to-left traversals are 
+-- supplied so that a lazy 'ByteString' can be parsed efficiently by 
+-- chunking it into strict chunks, and batching the traversals over each
+-- before stitching the edges together.
+--
+-- Because this needs to be a 'Monoid' and should return the exact same result
+-- regardless of forward or backwards parsing, it chooses to parse only 
+-- canonical UTF8 unlike most Haskell UTF8 parsers, which will blissfully 
+-- accept illegal alternative long encodings of a character. 
+--
+-- This actually fixes a potential class of security issues in some scenarios:
+--
+-- <http://prowebdevelopmentblog.com/content/big-overhaul-java-utf-8-charset>
+--
+-- NB: Due to naive use of a list to track the tail of an unfinished character 
+-- this may exhibit @O(n^2)@ behavior parsing backwards along an invalid sequence 
+-- of a large number of bytes that all claim to be in the tail of a character.
+--
+-----------------------------------------------------------------------------
+
+
hunk ./Data/Monoid/Lexical/UTF8/Decoder.hs 50
+
hunk ./Data/Monoid/Lexical/Words.hs 1
-{-# LANGUAGE FlexibleInstances, MultiParamTypeClasses, FlexibleContexts, GeneralizedNewtypeDeriving, ParallelListComp, TypeFamilies #-}
+{-# LANGUAGE FlexibleInstances, MultiParamTypeClasses, FlexibleContexts, GeneralizedNewtypeDeriving, ParallelListComp, TypeFamilies, OverloadedStrings, UndecidableInstances #-}
+
+-----------------------------------------------------------------------------
+-- |
+-- Module      :  Data.Monoid.Lexical.Words
+-- Copyright   :  (c) Edward Kmett 2009
+-- License     :  BSD-style
+-- Maintainer  :  libraries@haskell.org
+-- Stability   :  experimental
+-- Portability :  non-portable (MPTCs, OverloadedStrings)
+--
+-- A simple demonstration of tokenizing a 'Generator' into distinct words 
+-- and/or lines using a word-parsing 'Monoid' that accumulates partial 
+-- information about words and then builds up a token stream.
+--
+-----------------------------------------------------------------------------
+
hunk ./Data/Monoid/Lexical/Words.hs 20
+    -- * Words
hunk ./Data/Monoid/Lexical/Words.hs 23
+    , Unspaced(runUnspaced)
+    , wordsFrom
+    -- * Lines
hunk ./Data/Monoid/Lexical/Words.hs 28
-    , Unspaced(runUnspaced)
hunk ./Data/Monoid/Lexical/Words.hs 29
-    , wordsFrom
hunk ./Data/Monoid/Lexical/Words.hs 32
+import Data.String
hunk ./Data/Monoid/Lexical/Words.hs 39
+-- | A 'CharReducer' transformer that breaks a 'Char' 'Generator' into distinct words, feeding a 'Char' 'Reducer' each line in turn
hunk ./Data/Monoid/Lexical/Words.hs 44
+-- | Extract the matched words from the 'Words' 'Monoid'
hunk ./Data/Monoid/Lexical/Words.hs 64
--- abuse the same machinery to handle lines as well
+instance (CharReducer m) => CharReducer (Words m) where
+    invalidChar xs = Segment (Just (invalidChar xs)) [] mempty
hunk ./Data/Monoid/Lexical/Words.hs 67
+instance Reducer Char m => IsString (Words m) where
+    fromString = reduce
+
+-- | A 'CharReducer' transformer that breaks a 'Char' 'Generator' into distinct lines, feeding a 'Char' 'Reducer' each line in turn.
hunk ./Data/Monoid/Lexical/Words.hs 77
+instance (CharReducer m) => CharReducer (Lines m) where
+    invalidChar xs = Lines $ Segment (Just (invalidChar xs)) [] mempty
+
+instance Reducer Char m => IsString (Lines m) where
+    fromString = reduce
+
+-- | Extract the matched lines from the 'Lines' 'Monoid'
hunk ./Data/Monoid/Lexical/Words.hs 87
+-- | A 'CharReducer' transformer that strips out any character matched by `isSpace`
hunk ./Data/Monoid/Lexical/Words.hs 106
+instance Reducer Char m => IsString (Unspaced m) where
+    fromString = reduce
+
+-- | A 'CharReducer' transformer that strips out newlines
hunk ./Data/Monoid/Lexical/Words.hs 128
--- accumulator, inside-word, and until-next-word monoids
+instance Reducer Char m => IsString (Unlined m) where
+    fromString = reduce
+
+-- | Utility function to extract words using accumulator, inside-word, and until-next-word monoids
hunk ./Data/Monoid/Lexical/Words.hs 136
--- accumulator, inside-line, and until-next-line monoids
+-- | Utility function to extract lines using accumulator, inside-line, and until-next-line monoids
hunk ./Data/Monoid/Monad.hs 2
+
+-----------------------------------------------------------------------------
+-- |
+-- Module      :  Data.Monoid.Applicative
+-- Copyright   :  (c) Edward Kmett 2009
+-- License     :  BSD-style
+-- Maintainer  :  libraries@haskell.org
+-- Stability   :  experimental
+-- Portability :  non-portable (MPTCs)
+--
+-- 'Monoid' instances for working with a 'Monad'
+--
+-----------------------------------------------------------------------------
+
hunk ./Data/Monoid/Monad.hs 19
+    -- * Actions
hunk ./Data/Monoid/Monad.hs 21
+    , snocAction
+    -- * Wrapped Monads
hunk ./Data/Monoid/Monad.hs 31
+-- | An 'Action' uses glues together 'Monad' actions with (>>)
+--   in the manner of 'mapM_' from "Data.Foldable". Any values returned by 
+--   reduced actions are discarded.
hunk ./Data/Monoid/Monad.hs 47
+
+-- | Efficiently avoid needlessly rebinding when using 'snoc' on an action that already returns ()
+--   A rewrite rule automatically applies this when possible
hunk ./Data/Monoid/Monad.hs 53
+-- | A 'WrappedMonad' turns any 'MonadPlus' instance into a 'Monoid'.
+--   It also provides a 'Multiplicative' instance for a 'Monad' wrapped around a 'Monoid'
+--   and asserts that any 'MonadPlus' applied to a 'Monoid' forms a 'LeftSemiNearRing' 
+--   under these operations.
hunk ./Data/Monoid/Multiplicative.hs 2
+
+-----------------------------------------------------------------------------
+-- |
+-- Module      :  Data.Monoid.Multiplicative
+-- Copyright   :  (c) Edward Kmett 2009
+-- License     :  BSD-style
+-- Maintainer  :  libraries@haskell.org
+-- Stability   :  experimental
+-- Portability :  portable
+--
+-- When dealing with a 'Ring' or other structure, you often need a pair of 
+-- 'Monoid' instances that are closely related. Making a @newtype@ for one
+-- is unsatisfying and yields an unnatural programming style. 
+--
+-- A 'Multiplicative' is a 'Monoid' that is intended for use in a scenario
+-- that can be extended to have another 'Monoid' slot in for addition. This
+-- enables one to use common notation.
+--
+-- Any 'Multiplicative' can be turned into a 'Monoid' using the 'Log' wrapper.
+--
+-- Any 'Monoid' can be turned into a 'Multiplicative' using the 'Exp' wrapper.
+--
+-- Instances are supplied for common Monads of Monoids, in a fashion 
+-- which can be extended if the 'Monad' is a 'MonadPlus' to yield a 'LeftSemiNearRing'
+--
+-- Instances are also supplied for common Applicatives of Monoids, in a
+-- fashion which can be extended if the 'Applicative' is 'Alternative' to
+-- yield a 'LeftSemiNearRing'
+-----------------------------------------------------------------------------
+
}
