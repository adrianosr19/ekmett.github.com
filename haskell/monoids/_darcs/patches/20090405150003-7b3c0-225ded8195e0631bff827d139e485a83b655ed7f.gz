[better documentation for bitsets
ekmett@gmail.com**20090405150003
 Ignore-this: 7431b269773b3eee15fb366ee252d139
] {
hunk ./Data/Ring/Semi/BitSet.hs 2
+
+-----------------------------------------------------------------------------
+-- |
+-- Module      :  Data.Ring.Semi.BitSet
+-- Copyright   :  (c) Edward Kmett 2009.
+-- License     :  BSD3
+-- Maintainer  :  ekmett@gmail.com
+-- Stability   :  experimental
+-- Portability :  portable (instances use MPTCs)
+--
+-- Replacement for "Data.BitSet" extended to handle enumerations where fromEnum
+-- can return negative values, support efficient intersection and union
+-- and allow complementing of the set with respect to the bounds of the
+-- enumeration
+-------------------------------------------------------------------------------
+
hunk ./Data/Ring/Semi/BitSet.hs 20
+    , module Data.Monoid.Semi
+    -- * BitSet
hunk ./Data/Ring/Semi/BitSet.hs 23
+    -- * manipulation
hunk ./Data/Ring/Semi/BitSet.hs 31
+    , (\\)
+    -- * Construction
hunk ./Data/Ring/Semi/BitSet.hs 35
+    -- * Destruction
hunk ./Data/Ring/Semi/BitSet.hs 37
-    , (\\)
+    -- * Membership
hunk ./Data/Ring/Semi/BitSet.hs 39
+    -- * Size
hunk ./Data/Ring/Semi/BitSet.hs 51
+import GHC.Integer.Internals
hunk ./Data/Ring/Semi/BitSet.hs 54
-        { _countAtLeast  :: {-# UNPACK #-} !Int       -- ^ a conservative upper bound on the element count
-        , _countAtMost   :: {-# UNPACK #-} !Int       -- ^ a conservative lower bound on the element count
-        , _count         :: Int                       -- ^ the actual element count (lazy) used when the above two disagree
-        , exponent       :: {-# UNPACK #-} !Int       -- ^ low water mark
-        , _hwm           :: {-# UNPACK #-} !Int       -- ^ high water mark
-        , mantissa       :: {-# UNPACK #-} !Integer   -- ^ the set of bits. TODO: negative mantissa = complement
-        , _universe      :: (Int,Int)                 -- ^ invariant: mantissa < 0 => universe = (fromEnum minBound,fromEnum maxBound)
-        } deriving (Data, Typeable,Show)
+        { _countAtLeast  :: {-# UNPACK #-} !Int       -- ^ A conservative upper bound on the element count.
+                                                      --   If negative, we are complemented with respect to the universe
+        , _countAtMost   :: {-# UNPACK #-} !Int       -- ^ A conservative lower bound on the element count.
+                                                      --   If negative, we are complemented with respect to the universe
+        , _count         :: Int                       -- ^ Lazy element count used when the above two disagree. O(1) environment size
+        , exponent       :: {-# UNPACK #-} !Int       -- ^ Low water mark. index of the least element potentially in the set.
+        , _hwm           :: {-# UNPACK #-} !Int       -- ^ High water mark. index of the greatest element potentially in the set.
+        , mantissa       :: {-# UNPACK #-} !Integer   -- ^ the set of bits starting from the exponent.
+                                                      --   if negative, then we are complmenented with respect to universe
+        , _universe      :: (Int,Int)                 -- ^ invariant: whenever mantissa < 0 => universe = (fromEnum minBound,fromEnum maxBound)
+        } deriving (Data, Typeable)
hunk ./Data/Ring/Semi/BitSet.hs 66
-debug :: BitSet a -> (Int,Int,Int,Int,Int,Integer)
-debug (BS a b c d e f _) = (a,b,c,d,e,f)
-
--- | internal smart constructor: makes sure the count is forced when known
+-- | Internal smart constructor. Forces count whenever it is pigeonholed.
hunk ./Data/Ring/Semi/BitSet.hs 72
--- instance (Enum a, Show a) => Show (BitSet a) where
---    show s = "fromDistinctAscList " ++ show (toList s) ++ 
-
--- | /O(d)/ where /d/ is absolute deviation in fromEnum from the least element in the set.
+-- | /O(d)/ where /d/ is absolute deviation in fromEnum over the set
hunk ./Data/Ring/Semi/BitSet.hs 85
--- | The empty bit set.
+-- | /O(1)/ The empty set. Permits /O(1)/ null and size.
hunk ./Data/Ring/Semi/BitSet.hs 90
+-- | /O(1)/ Construct a @BitSet@ with a single element. Permits /O(1)/ null and size
hunk ./Data/Ring/Semi/BitSet.hs 95
--- | Is the bit set empty? Asymptotically faster than checking if size == 0 in some cases.
+-- | /O(1|d)/ Is the 'BitSet' empty? May be faster than checking if @'size' == 0@ after union.
+--   Operations that require a recount are noted.
hunk ./Data/Ring/Semi/BitSet.hs 104
+-- | /O(1|d)/ The number of elements in the bit set.
+size :: BitSet a -> Int
+size (BS a b c _ _ m (ul,uh)) 
+    | a == b, m >= 0 = a
+    | a == b         = uh - ul - a 
+    | m >= 0         = c
+    | otherwise      = uh - ul - c 
+{-# INLINE size #-}
+
+-- | /O(d)/ A 'BitSet' containing every member of the enumeration of @a@.
hunk ./Data/Ring/Semi/BitSet.hs 116
+{-# INLINE full #-}
hunk ./Data/Ring/Semi/BitSet.hs 118
-universeOf :: (Bounded a, Enum a) => BitSet a -> (Int,Int)
-universeOf x = (fromEnum (minBound `asArgTypeOf` x), fromEnum (maxBound `asArgTypeOf` x))
-
--- ensures valid universe, may result in negative bitset, note recalculation of universe
+-- | /O(d)/ Complements a 'BitSet' with respect to the bounds of @a@. Preserves order of 'null' and 'size'
hunk ./Data/Ring/Semi/BitSet.hs 120
-complement r@(BS a b c l h m _) = BS (Bits.complement b) (Bits.complement a) (Bits.complement c) l h (Bits.complement m) (universeOf r)
+complement r@(BS a b c l h m _) = BS (Bits.complement b) (Bits.complement a) (Bits.complement c) l h (Bits.complement m) u where
+    u = (fromEnum (minBound `asArgTypeOf` r), fromEnum (maxBound `asArgTypeOf` r))
+{-# INLINE complement #-}
hunk ./Data/Ring/Semi/BitSet.hs 124
--- proof obligation: either the value is already complemented or it is a complement-complement, note retention of u
+-- | /O(d)/ unsafe internal method: complement a set that has already been complemented at least once.
hunk ./Data/Ring/Semi/BitSet.hs 127
+{-# INLINE recomplement #-}
hunk ./Data/Ring/Semi/BitSet.hs 129
--- | /O(d * n)/ Make a @BitSet@ from a list of items.
+-- | /O(d)/ unsafe internal method: complement a set that has already been complemented at least once.
+pseudoComplement :: BitSet a -> BitSet a 
+pseudoComplement (BS a b c l h m _) u = BS (Bits.complement b) (Bits.complement a) (Bits.complement c) l h (Bits.complement m) u
+{-# INLINE pseudoComplement #-}
+
+-- | /O(d * n)/ Make a 'BitSet' from a list of items.
hunk ./Data/Ring/Semi/BitSet.hs 139
+-- | /O(d * n)/ Make a 'BitSet' from a distinct ascending list of items
hunk ./Data/Ring/Semi/BitSet.hs 152
--- | /O(d)/ Insert an item into the bit set.
+-- | /O(d)/ Insert a single element of type @a@ into the 'BitSet'. Preserves order of 'null' and 'size'
hunk ./Data/Ring/Semi/BitSet.hs 157
-    | e < l = bs (a+1) (b+1) (c+1) e (h - e) (shiftL m (l - e) .|. 1) u
+    | e < l = bs (a+1) (b+1) (c+1) e h (shiftL m (l - e) .|. 1) u
hunk ./Data/Ring/Semi/BitSet.hs 159
-    | testBit m (e - l) = r 
+    | testBit m p = r 
hunk ./Data/Ring/Semi/BitSet.hs 166
--- | /O(d)/ Delete an item from the bit set.
+-- | /O(d)/ Delete a single item from the 'BitSet'. Preserves order of 'null' and 'size'
hunk ./Data/Ring/Semi/BitSet.hs 169
-    | m < 0, e < l = bs (a+1) (b+1) (c+1) e (h - e) (shiftL m (l - e) .&. Bits.complement 1) u
+    | m < 0, e < l = bs (a+1) (b+1) (c+1) e h (shiftL m (l - e) .&. Bits.complement 1) u
hunk ./Data/Ring/Semi/BitSet.hs 180
--- | /O(testBit on Integer)/ Ask whether the item is in the bit set.
+-- | /O(1)/ Test for membership in a 'BitSet'
hunk ./Data/Ring/Semi/BitSet.hs 190
--- | /O(1)/ or /O(d)/ The number of elements in the bit set.
-size :: BitSet a -> Int
-size (BS a b c _ _ m (ul,uh)) 
-    | a == b, m >= 0 = a
-    | a == b         = uh - ul - a 
-    | m >= 0         = c
-    | otherwise      = uh - ul - c 
-
hunk ./Data/Ring/Semi/BitSet.hs 194
+-- | /O(d)/. May force 'size' to take /O(d)/ if ranges overlap, preserves order of 'null'
hunk ./Data/Ring/Semi/BitSet.hs 197
-    | l' < l    = union y x                                                         -- ensure left side has lower exponent
-    | b == 0    = y                                                                 -- fast empty union
-    | b' == 0   = x                                                                 -- fast empty union
-    | a == -1   = BS (-1) (-1) (-1) 0 0 (-1) u                                      -- fast full union, recomplement obligation met by negative size
-    | a' == -1  = BS (-1) (-1) (-1) 0 0 (-1) u'                                     -- fast full union, recomplement obligation met by negative size
-    | m < 0, m' < 0 = recomplement (intersection (recomplement x) (recomplement y)) -- appeal to intersection, recomplement obligation met by 2s complement
-    | m' < 0    = recomplement (pseudoDiff (recomplement y) x u')                      -- union with complement, recomplement obligation met by 2s complement -- THESE ARE WRONG FIX!
-    | m < 0     = recomplement (pseudoDiff (recomplement x) y u)                      -- union with complement, recomplement obligation met by 2s complement -- THESE ARE WRONG FIX!
-    | h < l'    = bs (a + a') (b + b') (c + c') l h' m'' u                          -- disjoint positive ranges
-    | otherwise = bs (a `max` a') (b + b') (recount m'') l (h `max` h') m'' u       -- overlapped positives
+    | l' < l        = union y x                                                         -- ensure left side has lower exponent
+    | b == 0        = y                                                                 -- fast empty union
+    | b' == 0       = x                                                                 -- fast empty union
+    | a == -1       = entire u                                                          -- fast full union, recomplement obligation met by negative size
+    | a' == -1      = entire u'                                                         -- fast full union, recomplement obligation met by negative size
+    | m < 0, m' < 0 = recomplement (intersection (recomplement x) (recomplement y))     -- appeal to intersection, recomplement obligation met by 2s complement
+    | m' < 0        = recomplement (pseudoDiff (recomplement y) x u')                   -- union with complement, recomplement obligation met by 2s complement
+    | m < 0         = recomplement (pseudoDiff (recomplement x) y u)                    -- union with complement, recomplement obligation met by 2s complement
+    | h < l'        = bs (a + a') (b + b') (c + c') l h' m'' u                          -- disjoint positive ranges
+    | otherwise     = bs (a `max` a') (b + b') (recount m'') l (h `max` h') m'' u       -- overlapped positives
hunk ./Data/Ring/Semi/BitSet.hs 209
+        entire = BS (-1) (-1) (-1) 0 0 (-1)
+
+-- | /O(1)/ check to see if we are represented as a complemented 'BitSet'. 
+isComplemented :: BitSet a -> Bool
+isComplemented = (<0) . mantissa 
hunk ./Data/Ring/Semi/BitSet.hs 215
+-- | /O(d)/. May force 'size' and 'null' both to take /O(d)/.
hunk ./Data/Ring/Semi/BitSet.hs 232
--- we know m >= 0, m' >= 0, a /= -1, a' /= -1, b /= 0, b' /= 0, u' is the universe of discourse
+-- | Unsafe internal method for computing differences in a particular universe of discourse
+-- preconditions:
+--  m >= 0, m' >= 0, a /= -1, a' /= -1, b /= 0, b' /= 0, u'' is the universe of discourse
hunk ./Data/Ring/Semi/BitSet.hs 240
-    where m'' = m .&. shift (Bits.complement m') (l' - l)
+    where 
+        m'' = m .&. shift (Bits.complement m') (l' - l)
hunk ./Data/Ring/Semi/BitSet.hs 243
-(\\) :: (Enum a, Bounded a) => BitSet a -> BitSet a -> BitSet a 
-x \\ y = x `intersection` complement y
+-- | /O(d)/. Preserves order of 'null'. May force /O(d)/ 'size'.
+difference :: Enum a => BitSet a -> BitSet a -> BitSet a 
+difference x@(BS a b c l h m u)  y@(BS a' b' c' l' h' u') 
+   | a == -1       = pseudoComplement y u
+   | a' == -1      = empty
+   | b == 0        = empty
+   | b' == 0       = x
+   | m < 0, m' < 0 = pseudoDiff (recomplement y) (recomplement x) u
+   | m < 0         = pseudoComplement (recomplement x `union` y) u
+   | m' < 0        = x `union` recomplement y 
+   | otherwise     = pseudoDiff x y u
+    
+-- | /O(d)/. Preserves order of 'null'. May force /O(d)/ 'size'.
+(\\) :: Enum a => BitSet a -> BitSet a -> BitSet a 
+(\\) = difference
hunk ./Data/Ring/Semi/BitSet.hs 259
--- TODO: fix this so that it handles complements correctly
hunk ./Data/Ring/Semi/BitSet.hs 260
-    BS _ _ _ l _ m _ == BS _ _ _ l' _ m' _ = shift m (l'' - l) == shift m' (l'' - l) where l'' = min l l'
-    BS _ _ _ l _ m _ /= BS _ _ _ l' _ m' _ = shift m (l'' - l) /= shift m' (l'' - l) where l'' = min l l'
+    x@(BS _ _ _ l _ m u) == y@(BS _ _ _ l' _ m' _)
+        | signum m == signum m' = shift m (l - l'') == shift m' (l - l'') where l'' = min l l'
+        | m' < 0 = y == x
+        | otherwise = mask .&. shift m (l - ul) == shift m' (l - ul)
+        where 
+            mask = setBit 0 (uh - ul + 1) - 1
+            ul = fst u
+            uh = snd u
hunk ./Data/Ring/Semi/BitSet.hs 281
+-- | Utility function to avoid requiring ScopedTypeVariables
hunk ./Data/Ring/Semi/BitSet.hs 286
+-- | /O(d)/
hunk ./Data/Ring/Semi/BitSet.hs 288
-recount = recount' 0 where
-    recount' :: Int -> Integer -> Int
-    recount' !n 0 = n
-    recount' !n !m = recount' (if testBit m 0 then n+1 else n) (shiftR m 1)
+recount !n 
+recount !n = recount' 0 0 where
+    h = hwm n
+    recount' !i !c
+        | i > h = c
+        | otherwise = recount' (i+1) (if testBit n i then c+1 else c)
+
+-- | /O(d)/. Computes the equivalent of (truncate . logBase 2 . abs) extended with 0 at 0
+hwm :: Integer -> Int
+hwm !n 
+    | n < 0 = hwm (-n)
+    | n > 1 = scan p (2*p) 
+    | otherwise = 0
+    where
+        p = probe 1
+        -- incrementally compute 2^(2^(i+1)) until it exceeds n
+        probe :: Int -> Int
+        probe !i
+            | bit i' > n        = i
+            | otherwise         = probe i'
+            where i' = 2*i
+
+        -- then scan the powers for the highest set bit
+        scan :: Int -> Int -> Int
+        scan !l !h
+            | l == h = l
+            | bit (m+1) > n = scan l m
+            | otherwise = scan (m+1) h
+            where m = l + (h - l) `div` 2
+ 
+instance (Enum a, Show a) => Show (BitSet a) where
+   showsPrec d x@(BS _ _ _ _ _ m u)
+        | m < 0     = showParen (d > 10) $ showString "pseudoComplement " . showsPrec 11 (recomplement x)) . showString " " . showsPrec 11 u
+        | otherwise = showParen (d > 10) $ showString "fromDistinctAscList " . showsPrec 11 (toList x)
+
+instance (Read a) => Read (BitSet a) where
+    readPrec = parens $ complemented +++ normal where
+        complemented = prec 10 $ do 
+                Ident "pseudoComplement" <- lexP
+                x <- step readPrec
+                pseudoComplement x `fmap` step readPrec
+        normal = prec 10 $ do
+                Ident "fromDistinctAscList" <- lexP
+                fromDistinctAscList `fmap` step readPrec
}
