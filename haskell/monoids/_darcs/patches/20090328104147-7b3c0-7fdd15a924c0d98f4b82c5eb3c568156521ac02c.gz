[a ton of documentation
ekmett@gmail.com**20090328104147] {
hunk ./Data/Monoid/Reducer/With.hs 19
-import Control.Functor.Pointed
hunk ./Data/Monoid/Reducer/With.hs 22
-
hunk ./Data/Monoid/Union.hs 4
+    -- * Unions of Containers
hunk ./Data/Monoid/Union.hs 8
+    , Union(Union,getUnion)
+    -- * Unions of Containers of Monoids
hunk ./Data/Monoid/Union.hs 14
-    , Union(Union,getUnion)
hunk ./Data/Monoid/Union.hs 34
+-- | A Container suitable for the 'Union' 'Monoid'
hunk ./Data/Monoid/Union.hs 64
-
-
-
+-- | The 'Monoid' @('union','empty')@
hunk ./Data/Monoid/Union.hs 84
-
+-- | Polymorphic containers that we can supply an operation to handle unions with
hunk ./Data/Monoid/Union.hs 100
-
+-- | The 'Monoid' @('unionWith mappend','empty')@ for containers full of monoids.
hunk ./Data/Monoid/Unit.hs 1
-{-# LANGUAGE FlexibleInstances, FlexibleContexts, UndecidableInstances, MultiParamTypeClasses #-}
------------------------------------------------------------------------------
----- |
----- Module      :  Data.Monoid.Unit
----- Copyright   :  (c) Edward Kmett 2009
----- License     :  BSD-style
----- Maintainer  :  libraries@haskell.org
----- Stability   :  experimental
----- Portability :  portable
-----
------------------------------------------------------------------------------
-module Data.Monoid.Unit 
-    ( module Data.Monoid.Reducer
-    , Unit(Unit,getUnit) 
-    ) where
-
-import Control.Functor.Pointed
-import Data.Monoid.Reducer
-import Data.Monoid.Reducer.Char
-
-newtype Unit c = Unit { getUnit :: () } 
-
-instance Monoid (Unit c) where
-    mempty = Unit ()
-    _ `mappend` _ = Unit ()
-    mconcat _ = Unit ()
-
-instance Reducer c (Unit c) where 
-    unit _ = Unit ()
-    cons _ _ = Unit ()
-    snoc _ _ = Unit ()
-
-instance CharReducer (Unit Char)
-
-instance Functor Unit where
-    fmap _ _ = Unit ()
-    
-instance Pointed Unit where
-    point _ = Unit ()
rmfile ./Data/Monoid/Unit.hs
hunk ./Data/Ring/Boolean.hs 3
+
+-----------------------------------------------------------------------------
+-- |
+-- Module      :  Data.Ring.Boolean
+-- Copyright   :  (c) Edward Kmett 2009
+-- License     :  BSD-style
+-- Maintainer  :  libraries@haskell.org
+-- Stability   :  experimental
+-- Portability :  non-portable (MPTCs)
+--
+-- A Boolean 'Ring' over 'Bool'. Note well that the 'mappend' of this ring is
+-- symmetric difference and not disjunction like you might expect. To get that 
+-- you should use use 'Ord' from "Data.Ring.Semi.Ord.Order" on 'Bool' to get the '&&'/'||'-based 
+-- distributive-lattice 'SemiRing'
+-----------------------------------------------------------------------------
+
hunk ./Data/Ring/Boolean.hs 21
-    , BooleanRing(BooleanRing, getBooleanRing)
+    , BoolRing(BoolRing, getBoolRing)
hunk ./Data/Ring/Boolean.hs 27
--- | use @'Data.Ring.Semi.Ord.Order' 'Bool'@ to get the '&&'/'||' based distributive lattice 'SemiRing'
-newtype BooleanRing = BooleanRing { getBooleanRing :: Bool } deriving (Eq,Ord,Show,Read)
+newtype BoolRing = BoolRing { getBoolRing :: Bool } deriving (Eq,Ord,Show,Read)
hunk ./Data/Ring/Boolean.hs 29
-instance Monoid BooleanRing where
-    mempty = BooleanRing False
-    BooleanRing a `mappend` BooleanRing b = BooleanRing ((a || b) && not (a && b))
+instance Monoid BoolRing where
+    mempty = BoolRing False
+    BoolRing a `mappend` BoolRing b = BoolRing ((a || b) && not (a && b))
hunk ./Data/Ring/Boolean.hs 33
-instance Group BooleanRing where
-    gnegate = BooleanRing . not . getBooleanRing
+instance Group BoolRing where
+    gnegate = BoolRing . not . getBoolRing
hunk ./Data/Ring/Boolean.hs 36
-instance Multiplicative BooleanRing where
-    one = BooleanRing True
-    BooleanRing a `times` BooleanRing b = BooleanRing (a && b)
+instance Multiplicative BoolRing where
+    one = BoolRing True
+    BoolRing a `times` BoolRing b = BoolRing (a && b)
hunk ./Data/Ring/Boolean.hs 40
-instance LeftSemiNearRing BooleanRing
-instance RightSemiNearRing BooleanRing
-instance SemiRing BooleanRing
-instance Ring BooleanRing
+instance LeftSemiNearRing BoolRing
+instance RightSemiNearRing BoolRing
+instance SemiRing BoolRing
+instance Ring BoolRing
hunk ./Data/Ring/Boolean.hs 45
-instance Reducer Bool BooleanRing where
-    unit = BooleanRing
+instance Reducer Bool BoolRing where
+    unit = BoolRing
hunk ./Data/Ring/FromNum.hs 2
+
+-----------------------------------------------------------------------------
+-- |
+-- Module      :  Data.Ring.FromNum
+-- Copyright   :  (c) Edward Kmett 2009
+-- License     :  BSD-style
+-- Maintainer  :  libraries@haskell.org
+-- Stability   :  experimental
+-- Portability :  non-portable (MPTCs)
+--
+-- A wrapper that lies for you and claims any instance of 'Num' is a 'Ring'.
+-- Who knows, for your type it might even be telling the truth!
+--
+-----------------------------------------------------------------------------
+
hunk ./Data/Ring/Semi/Near.hs 3
+
+-----------------------------------------------------------------------------
+-- |
+-- Module      :  Data.Ring.Semi.Near
+-- Copyright   :  (c) Edward Kmett 2009
+-- License     :  BSD-style
+-- Maintainer  :  libraries@haskell.org
+-- Stability   :  experimental
+-- Portability :  portable (instances use MPTCs)
+--
+-- Defines left- and right- seminearrings. Every 'MonadPlus' wrapped around
+-- a 'Monoid' qualifies do to the distributivity of (>>=) over mplus.
+--
+-- See <http://conway.rutgers.edu/~ccshan/wiki/blog/posts/WordNumbers1/>
+--
+-----------------------------------------------------------------------------
hunk ./Data/Ring/Semi/Ord.hs 3
----- |
----- Module      :  Data.Ring.Semi.Ord
----- Copyright   :  (c) Edward Kmett 2009, Conal Elliott 2008
----- License     :  BSD3
----- 
----- Maintainer  :  ekmett@gmail.com
----- Stability   :  experimental
----- 
----- ordered types as semi-rings
+-- |
+-- Module      :  Data.Ring.Semi.Ord
+-- Copyright   :  (c) Edward Kmett 2009, Conal Elliott 2008
+-- License     :  BSD3
+-- 
+-- Maintainer  :  ekmett@gmail.com
+-- Stability   :  experimental
+-- 
+-- Turn an instance of 'Ord' into a 'SemiRing' over 'max' and 'min'
hunk ./Data/Ring/Semi/Ord.hs 27
+-- | A 'SemiRing' using a type's built-in Bounded instance.
hunk ./Data/Ring/Semi/Ord.hs 53
+-- | A 'SemiRing' which adds 'minBound' and 'maxBound' to a pre-existing type.
hunk ./Data/Ring/Semi.hs 1
+-----------------------------------------------------------------------------
+-- |
+-- Module      :  Data.Ring.Semi
+-- Copyright   :  (c) Edward Kmett 2009
+-- License     :  BSD-style
+-- Maintainer  :  libraries@haskell.org
+-- Stability   :  experimental
+-- Portability :  non-portable (MPTCs)
+--
+--
+-----------------------------------------------------------------------------
+
hunk ./Data/Ring/Semi.hs 20
+-- | A 'SemiRing' is an instance of both 'Multiplicative' and 'Monoid' where 
+--   'times' distributes over 'plus'.
hunk ./Data/Ring/Sugar.hs 1
+-----------------------------------------------------------------------------
+-- |
+-- Module      :  Data.Ring.Sugar
+-- Copyright   :  (c) Edward Kmett 2009
+-- License     :  BSD-style
+-- Maintainer  :  libraries@haskell.org
+-- Stability   :  experimental
+-- Portability :  portable
+--
+-- Syntactic sugar for working with rings that conflicts with names from the "Prelude".
+--
+-- > import Prelude hiding ((-), (+), (*), negate, subtract)
+-- > import Data.Ring.Sugar
+--
+-----------------------------------------------------------------------------
+
hunk ./monoids.cabal 41
-    Data.Monoid.Unit
}
