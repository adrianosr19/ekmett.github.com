[started putting proper headers on things
ekmett@gmail.com**20090328075224] {
hunk ./Data/Group/Combinators.hs 1
+-----------------------------------------------------------------------------
+-- |
+-- Module      :  Data.Group.Combinators
+-- Copyright   :  (c) Edward Kmett 2009
+-- License     :  BSD-style
+-- Maintainer  :  libraries@haskell.org
+-- Stability   :  experimental
+-- Portability :  portable
+--
+-- Utilities for working with Groups that conflict with names from the "Prelude".
+--
+-- Intended to be imported qualified.
+--
+-- > import Data.Group.Combinators as Group (replicate)
+--
+-----------------------------------------------------------------------------
+
hunk ./Data/Group/Combinators.hs 26
-
hunk ./Data/Group/Sugar.hs 1
+-----------------------------------------------------------------------------
+-- |
+-- Module      :  Data.Group.Sugar
+-- Copyright   :  (c) Edward Kmett 2009
+-- License     :  BSD-style
+-- Maintainer  :  libraries@haskell.org
+-- Stability   :  experimental
+-- Portability :  portable
+--
+-- Syntactic sugar for working with groups that conflicts with names from the "Prelude".
+--
+-- > import Prelude hiding ((-), (+), negate, subtract)
+-- > import Data.Group.Sugar
+--
+-----------------------------------------------------------------------------
+
hunk ./Data/Group/Sugar.hs 22
+    , subtract
hunk ./Data/Group/Sugar.hs 27
-import Prelude hiding ((-), negate)
+import Prelude hiding ((-), negate, subtract)
hunk ./Data/Group/Sugar.hs 37
+subtract :: Group g => g -> g -> g
+subtract = gsubtract
+
hunk ./Data/Group.hs 1
+----------------------------------------------------------------------------
+-- |
+-- Module     : Data.Group
+-- Copyright  : 2007-2009 Edward Kmett
+-- License    : BSD
+--
+-- Maintainer  : Edward Kmett <ekmett@gmail.com>
+-- Stability   : experimental
+-- Portability : portable
+--
+-- Extends 'Monoid' to support 'Group' operations
+-----------------------------------------------------------------------------
+
hunk ./Data/Group.hs 18
+    , gsubtract
hunk ./Data/Group.hs 28
+-- | Minimal complete definition: 'gnegate' or 'minus'
hunk ./Data/Group.hs 32
-
-    -- right cancellation
hunk ./Data/Group.hs 33
+    gsubtract :: a -> a -> a 
+
+    gnegate = minus zero
hunk ./Data/Group.hs 37
+    a `gsubtract` b = gnegate a `plus` b
hunk ./Data/Monoid/Additive/Sugar.hs 1
+-----------------------------------------------------------------------------
+-- |
+-- Module      :  Data.Monoid.Additive.Sugar
+-- Copyright   :  (c) Edward Kmett 2009
+-- License     :  BSD-style
+-- Maintainer  :  libraries@haskell.org
+-- Stability   :  experimental
+-- Portability :  portable
+--
+-- Syntactic sugar for working with a 'Monoid' that conflicts with names from the "Prelude".
+--
+-- > import Prelude hiding ((+))
+-- > import Data.Monoid.Additive.Sugar
+--
+-----------------------------------------------------------------------------
+
hunk ./Data/Monoid/Additive.hs 1
+-----------------------------------------------------------------------------
+-- |
+-- Module      :  Data.Monoid.Additive
+-- Copyright   :  (c) Edward Kmett 2009
+-- License     :  BSD-style
+-- Maintainer  :  libraries@haskell.org
+-- Stability   :  experimental
+-- Portability :  portable
+--
+-- More easily understood aliases for "mappend" and "mempty" 
+--
+-- > import Data.Monoid.Additive
+--
+-----------------------------------------------------------------------------
+
hunk ./Data/Monoid/Applicative.hs 2
+
+-----------------------------------------------------------------------------
+-- |
+-- Module      :  Data.Monoid.Applicative
+-- Copyright   :  (c) Edward Kmett 2009
+-- License     :  BSD-style
+-- Maintainer  :  libraries@haskell.org
+-- Stability   :  experimental
+-- Portability :  portable
+--
+-- Monoids for working with an 'Applicative' 'Functor'.
+--
+-----------------------------------------------------------------------------
+
hunk ./Data/Monoid/Applicative.hs 21
+    , snocTraversal
hunk ./Data/Monoid/Applicative.hs 29
+-- | A 'Traversal' uses an glues together 'Applicative' actions with (*>)
+--   in the manner of 'traverse_' from "Data.Foldable". Any values returned by 
+--   reduced actions are discarded.
hunk ./Data/Monoid/Applicative.hs 45
+
+-- | Efficiently avoid needlessly rebinding when using 'snoc' on an action that already returns ()
+--   A rewrite rule automatically applies this when possible
hunk ./Data/Monoid/Applicative.hs 52
+-- | A 'WrappedApplicative' turns any 'Alternative' instance into a 'Monoid'.
+--   It also provides a 'Multiplicative' instance for an 'Applicative' functor wrapped around a 'Monoid'
+--   and asserts that any 'Alternative' applied to a 'Monoid' forms a 'LeftSemiNearRing' 
+--   under these operations.
+
hunk ./Data/Monoid/Categorical.hs 2
+
+-----------------------------------------------------------------------------
+-- |
+-- Module      :  Data.Monoid.Categorical
+-- Copyright   :  (c) Edward Kmett 2009
+-- License     :  BSD-style
+-- Maintainer  :  libraries@haskell.org
+-- Stability   :  experimental
+-- Portability :  portable
+--
+-----------------------------------------------------------------------------
+
hunk ./Data/Monoid/Categorical.hs 17
+    -- * Generalized Endo
hunk ./Data/Monoid/Categorical.hs 19
+    -- * Monoids as Categories
hunk ./Data/Monoid/Categorical.hs 28
--- | The 'Monoid' of endomorphisms over some object in an arbitrary 'Category'
+-- | The 'Monoid' of the endomorphisms over some object in an arbitrary 'Category'.
hunk ./Data/Monoid/Categorical.hs 39
+-- | Extract the 'Monoid' from its representation as a 'Category'
hunk ./Data/Monoid/Combinators.hs 2
+
+-----------------------------------------------------------------------------
+-- |
+-- Module      :  Data.Monoid.Combinators
+-- Copyright   :  (c) Edward Kmett 2009
+-- License     :  BSD-style
+-- Maintainer  :  libraries@haskell.org
+-- Stability   :  experimental
+-- Portability :  portable
+--
+-- Utilities for working with Monoids that conflict with names from the "Prelude",
+-- "Data.Foldable", "Control.Monad" or elsewhere. Intended to be imported qualified.
+--
+-- > import Data.Group.Combinators as Monoid 
+--
+-----------------------------------------------------------------------------
+
hunk ./Data/Monoid/Combinators.hs 21
-    , all
+    -- * Monadic Reduction
+    , mapM_
+    , forM_
+    -- * Applicative Reduction
+    , traverse_
+    , for_
+    -- * Logical Reduction
hunk ./Data/Monoid/Combinators.hs 29
+    , or
hunk ./Data/Monoid/Combinators.hs 31
+    , all
+    -- * Monoidal Reduction
+    , foldMap
+    -- * List-Like Reduction
hunk ./Data/Monoid/Combinators.hs 36
-    , cycle
hunk ./Data/Monoid/Combinators.hs 39
-    , foldMap'
-    , for_
-    , forM_
-    , mapM_
-    , notElem
-    , or
+    , sum
hunk ./Data/Monoid/Combinators.hs 41
+    , notElem
+    -- * List-Like Monoid Generation
hunk ./Data/Monoid/Combinators.hs 45
-    , sum
-    , traverse_
+    , cycle
hunk ./Data/Monoid/Combinators.hs 55
+-- | Efficiently 'mapReduce' a 'Generator' using the 'Traversal' monoid. A specialized version of its namesake in "Data.Foldable"
hunk ./Data/Monoid/Combinators.hs 59
+-- | flipped 'traverse_' as in "Data.Foldable"
hunk ./Data/Monoid/Combinators.hs 63
+-- | Efficiently 'mapReduce' a 'Generator' using the 'Action' monoid. A specialized version of its namespace from "Data.Foldable" and "Control.Monad"
hunk ./Data/Monoid/Combinators.hs 67
+-- | flipped 'mapM_' as in "Data.Foldable" and "Control.Monad"
hunk ./Data/Monoid/Combinators.hs 71
-foldMap' :: (Monoid m, Generator c) => (Elem c -> m) -> c -> m
-foldMap' f = getSelf . mapReduce f
+-- | Efficiently 'mapReduce' a 'Generator' using the 'Self' monoid. A specialized version of its namespace from "Data.Foldable"
+foldMap :: (Monoid m, Generator c) => (Elem c -> m) -> c -> m
+foldMap f = getSelf . mapReduce f
hunk ./Data/Monoid/Combinators.hs 75
+-- | A further specialization of "foldMap"
hunk ./Data/Monoid/Combinators.hs 77
-concatMap = foldMap'
+concatMap = foldMap
hunk ./Data/Monoid/Combinators.hs 79
+-- | Efficiently 'reduce' a 'Generator' that contains values of type 'Bool'
hunk ./Data/Monoid/Combinators.hs 83
+-- | Efficiently 'reduce' a 'Generator' that contains values of type 'Bool'
hunk ./Data/Monoid/Combinators.hs 87
+-- | Efficiently 'mapReduce' any 'Generator' checking to see if any of its values match the supplied predicate
hunk ./Data/Monoid/Combinators.hs 91
+-- | Efficiently 'mapReduce' any 'Generator' checking to see if all of its values match the supplied predicate
hunk ./Data/Monoid/Combinators.hs 95
+-- | Efficiently 'mapReduce' any 'Generator' using the 'Sum' 'Monoid'
hunk ./Data/Monoid/Combinators.hs 99
+-- | Efficiently 'mapReduce' any 'Generator' using the 'Product' 'Monoid'
hunk ./Data/Monoid/Combinators.hs 103
+-- | Check to see if 'any' member of the 'Generator' matches the supplied value
hunk ./Data/Monoid/Combinators.hs 107
+-- | Check to make sure that the supplied value is not a member of the 'Generator'
hunk ./Data/Monoid/Combinators.hs 111
+-- | Efficiently 'mapReduce' a subset of the elements in a 'Generator'
hunk ./Data/Monoid/Combinators.hs 113
-filter p = foldMap' f where
+filter p = foldMap f where
hunk ./Data/Monoid/Combinators.hs 117
+-- | A specialization of 'filter' using the 'First' 'Monoid', analogous to 'Data.List.find'
hunk ./Data/Monoid/Combinators.hs 121
--- Shamelessly stolen from Lennart Augustsson's post on optimizing (^) in haskell
--- http://augustss.blogspot.com/2008/07/lost-and-found-if-i-write-108-in.html
+-- | A generalization of 'Data.List.replicate' to an arbitrary 'Monoid'. Adapted from 
+-- <http://augustss.blogspot.com/2008/07/lost-and-found-if-i-write-108-in.html>
hunk ./Data/Monoid/Combinators.hs 138
+-- | A generalization of 'Data.List.cycle' to an arbitrary 'Monoid'. May fail to terminate for some values in some monoids.
hunk ./Data/Monoid/Combinators.hs 142
+-- | A generalization of 'Data.List.repeat' to an arbitrary 'Monoid'. May fail to terminate for some values in some monoids.
hunk ./Data/Monoid/Instances.hs 1
-{-# LANGUAGE FlexibleInstances, MultiParamTypeClasses, UndecidableInstances #-}
+{-# LANGUAGE FlexibleInstances, MultiParamTypeClasses, UndecidableInstances, OverloadedStrings #-}
hunk ./Data/Monoid/Instances.hs 8
-
-
hunk ./Data/Monoid/Instances.hs 17
+import Data.String
+
hunk ./Data/Monoid/Instances.hs 62
+-- orphan, perhaps should be in Data.String
+instance (IsString a, IsString b) => IsString (a,b) where
+    fromString a = (fromString a, fromString a)
+
+instance (IsString a, IsString b, IsString c) => IsString (a,b,c) where
+    fromString a = (fromString a, fromString a, fromString a)
+
+instance (IsString a, IsString b, IsString c, IsString d) => IsString (a,b,c,d) where
+    fromString a = (fromString a, fromString a, fromString a, fromString a)
+
+instance (IsString a, IsString b, IsString c, IsString d, IsString e) => IsString (a,b,c,d,e) where
+    fromString a = (fromString a, fromString a, fromString a, fromString a, fromString a)
hunk ./Data/Monoid/Lexical/SourcePosition.hs 1
-{-# LANGUAGE FlexibleInstances, MultiParamTypeClasses #-}
+{-# LANGUAGE FlexibleInstances, MultiParamTypeClasses, OverloadedStrings #-}
hunk ./Data/Monoid/Lexical/SourcePosition.hs 17
+import Data.Monoid.Generator
+import Data.String
hunk ./Data/Monoid/Lexical/SourcePosition.hs 47
+instance IsString (SourcePosition file) where
+    fromString = reduce
+
hunk ./Data/Ring/Semi/Near.hs 10
-import Control.Applicative
-
-import Control.Monad.Cont
-import Control.Monad.Identity
-import Control.Monad (liftM2)
}
