[merging code fixes from c# version
ekmett@gmail.com**20071221044422] {
hunk ./src/Data/THash/THT.hs 43
+import Data.Bits
hunk ./src/Data/THash/THT.hs 45
-import Control.Monad (liftM, replicateM)
+import Control.Monad (liftM, replicateM,when)
hunk ./src/Data/THash/THT.hs 52
-    { key_count   :: !Int
-    , slots       :: Array Int (TVar [(k, v)])
-    , split_ptr   :: !Int
-    , max_split   :: !Int
+    { slots       :: Array Int (TVar [(k, v)])
+    , mask        :: !Int
+    , count	  :: !Int
hunk ./src/Data/THash/THT.hs 58
+{-# INLINE stride #-}
+stride :: THT k v -> Int
+stride this = (mask this + 1) `shiftR` 1
+
+{-# INLINE capacity #-}
+capacity :: THT k v -> Int
+capacity this = let (l,u) = bounds $ slots this in u - l + 1
+
hunk ./src/Data/THash/THT.hs 71
-        { key_count = 0
-        , slots     = listArray (0,3) slots
-        , split_ptr = 0
-        , max_split = 1
+        { slots     = listArray (0,3) slots
+        , mask 	    = 0
+	, count     = 0
hunk ./src/Data/THash/THT.hs 80
-    slots <- replicateM max2 $ newTVar []
+    slots <- replicateM capacity $ newTVar []
hunk ./src/Data/THash/THT.hs 82
-            { key_count = len
-            , slots     = listArray (0,max2-1) slots
-            , split_ptr = 0
-            , max_split = max
+            { slots     = listArray (0,mask) slots
+	    , count     = count
+            , mask      = mask
hunk ./src/Data/THash/THT.hs 93
-    where
-    len = List.length list 
-    max = p2 1
-    max2 = max*2
-    p2 m | len < m   = m
-         | otherwise = p2 (m+m)
+  where
+    count = List.length list 
+    pow2 m | count < m = m
+           | otherwise = pow2 (m+m)
+    capacity = 2*pow2 1 
+    mask = capacity - 1
hunk ./src/Data/THash/THT.hs 100
-{-# INLINE split #-}
-split :: THT k v -> STM (THT k v)
-split this
-    | old + 1 < max
-    = split' this { split_ptr = old + 1 }
-    | len < 2
-    = return this
-    | otherwise
-    = do slots' <- grow $ slots this
-         split' this 
-            { split_ptr = max
-            , max_split = max + max
-            , slots     = slots'
-            }
-    where 
-    old = split_ptr this
-    max = max_split this
-    len = key_count this
-    new = old + max
-    split' this' = do 
-        list <- readTVar $ slots this' ! old
-        let bin'    = bin this'
-            (ol,nl) = List.partition (\(k,v) -> old == (locate this' k)) list
-        writeTVar (slots this' ! old) ol -- reverse ol?
-        writeTVar (slots this' ! new) nl -- reverse nl?
-        return this'
+-- TODO fix from here down
+{-# INLINE addBucket #-}
+addBucket :: THT k v -> STM (THT k v)
+addBucket this = do
+    slots' <- maybeGrow $ slots this
+    addBucket' this slots'
+  where 
+    maybeGrow | count this == capacity this = grow 
+	      | otherwise  = return
+
+{-# INLINE addBucket' #-}
+addBucket' :: THT k v -> Array Int (TVar [(k, v)]) -> STM (THT k v)
+addBucket' this slots' = do 
+    when (count this > 0) $ do
+	ll <- readTVar left
+	let (ol,nl) = List.partition (\(k,v) -> old == locate this' k) ll
+	writeTVar left ol
+	writeTVar right nl
+    return this'
+  where
+    count' = count this + 1
+    mask'  = mask this .|. count'
+    this'  = this { count = count', mask = mask', slots = slots' }
+    new    = count this		-- intentionally using previous count
+    old    = new - stride this  -- intentionally using previous count and stride
+    left   = slots' ! old 
+    right  = slots' ! new 
hunk ./src/Data/THash/THT.hs 128
-{-# INLINE merge #-}
-merge :: THT k v -> STM (THT k v)
-merge this
-    | split_ptr this /= 0
-    = merge' this{ split_ptr = split_ptr this - 1 }
-    | key_count this < 1
-    = return this
-    | otherwise
-    = merge' this
-        { max_split = m + m
-        , split_ptr = m - 1 
-        }
-    where
-    m = max_split this
-    merge' this' = do
-        ol <- readTVar $ ov
-        nl <- readTVar $ nv
-        writeTVar nv (ol ++ nl) -- merge and reverse?
-        writeTVar ov []
-        return this'
-        where
-        new = split_ptr this'
-        max = max_split this'
-        old = new + max
-        v = slots this'
-        ov = v ! old
-        nv = v ! new
+{-# INLINE removeBucket #-}
+removeBucket :: THT k v -> STM (THT k v)
+removeBucket this = do
+    list1 <- readTVar right
+    list2 <- readTVar left
+    writeTVar left (list1 ++ list2)
+    writeTVar right []
+    return this'
+  where 
+    count'  = count this - 1
+    mask'   = if count' < stride this 
+		then mask this - stride this 
+		else mask this
+    stride' = (mask' + 1) `shiftR` 2
+    this' = this { count = count', mask = mask' } 
+    left  = slots this' ! (count this' - stride this')
+    right = slots this' ! count this'
hunk ./src/Data/THash/THT.hs 148
-lookup this key = if (key_count this == 0) 
-    then return Nothing
-    else do
+lookup this key = if (count this == 0) then return Nothing else do
hunk ./src/Data/THash/THT.hs 159
-            this' <- split this
+            this' <- addBucket this
hunk ./src/Data/THash/THT.hs 191
-            this' <- merge this
+            this' <- removeBucket this
hunk ./src/Data/THash/THT.hs 211
-    where
+  where
hunk ./src/Data/THash/THT.hs 220
-bin this val
-    | x < split_ptr this = val `mod` (m+m)
-    | otherwise          = x
-    where
-    x = val `mod` m 
-    m = max_split this
+bin this val = 
+    if residue >= count this 
+     then residue - stride this 
+     else residue
+  where
+    residue = val .&. mask this 
hunk ./src/Data/THash/THT.hs 240
-    lists <- sequence [ readTVar $ slots this ! i | i <- [0,key_count this] ]
+    lists <- sequence [ readTVar $ slots this ! i | i <- [0..count this] ]
hunk ./src/Data/THash.hs 33
+    get,
hunk ./src/Data/THash.hs 92
-update :: Eq k => THash k v -> k -> v ->               STM ()
+update :: Eq k => THash k v -> k -> v -> STM ()
hunk ./src/Data/THash.hs 97
-modify :: Eq k => THash k v -> k -> (Maybe v -> v) ->  STM ()
+modify :: Eq k => THash k v -> k -> (Maybe v -> v) -> STM ()
hunk ./src/Data/THash.hs 102
-delete :: Eq k => THash k v -> k ->                    STM (Bool)
+delete :: Eq k => THash k v -> k -> STM (Bool)
hunk ./src/Data/THash.hs 107
-lookup :: Eq k => THash k v -> k ->                    STM (Maybe v)
+lookup :: Eq k => THash k v -> k -> STM (Maybe v)
hunk ./src/Data/THash.hs 112
-mapH   :: ((k,v) -> r) -> THash k v ->                 STM [r]
+mapH :: ((k,v) -> r) -> THash k v -> STM [r]
hunk ./src/Data/THash.hs 117
-each   :: THash k v -> STM [(k,v)]
+each :: THash k v -> STM [(k,v)]
hunk ./thash.cabal 2
-version:		0.2
+version:		0.3
}
