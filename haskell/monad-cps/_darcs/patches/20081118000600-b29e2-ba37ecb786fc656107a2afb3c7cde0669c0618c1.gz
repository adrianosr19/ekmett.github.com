[0.0.1
Matt Morrow <mjm2002@gmail.com>**20081118000600] {
hunk ./StateCPS.hs 1
-{-# OPTIONS_GHC -O2 -fglasgow-exts #-}
-
-module StateCPS (
-  module StateCPS
-) where
-
-
-
-
-
-import Data.Monoid (Monoid(..))
-
-
-
-
-
-
-newtype C r a = C {unC :: forall o. (a -> r) -> (r -> o) -> o}
-
-
-newtype R r a = R {unR :: forall o. r -> (a -> o) -> o}
-runR :: R r a -> r -> a
-runR (R g) = flip g id
-ask :: R r r
-ask = R (\r k -> k r)
-asks :: (r -> a) -> R r a
-asks f = R (\r k -> (k . f) r)
-local :: (r -> r) -> R r a -> R r a
-local f (R g) = R (\r k -> g (f r) k)
-instance Functor (R r) where
-  fmap f (R g) = R (\r k -> g r (\a -> k (f a)))
-instance Monad (R r) where
-  return a = R (\_ k -> k a)
-  R g >>= f = R (\r k -> g r (\a -> unR (f a) r k))
-
-
-
-newtype W w a = W {unW :: forall o. (a -> w -> o) -> o}
-runW :: W w a -> (a, w)
-runW (W g) = g (,)
-tell :: w -> W w ()
-tell w = W (\k -> k () w)
-
-instance Functor (W w) where
-  fmap f (W g) = W (\k -> g (\a w -> k (f a) w))
-instance (Monoid w) => Monad (W w) where
-  return a = W (\k -> k a mempty)
-  W g >>= f = W (\k -> g (\a w -> unW (f a) (\a w' -> k a (w`mappend`w'))))
-
-
-
-newtype S s a = S {unS :: forall o. s -> (s -> a -> o) -> o}
-runS :: S s a -> s -> (a, s)
-runS (S g) = flip g (flip (,))
-get :: S s s
-get = S (\s k -> k s s)
-gets :: (s -> a) -> S s a
-gets f = S (\s k -> k s (f s))
-put :: s -> S s ()
-put s = S (\_ k -> k s ())
-modify :: (s -> s) -> S s ()
-modify f = S (\s k -> k (f s) ())
-instance Functor (S s) where
-  fmap f (S g) = S (\s k -> g s (\s a -> k s (f a)))
-instance Monad (S s) where
-  return a = S (\s k -> k s a)
-  S g >>= f = S (\s k -> g s (\s a -> unS (f a) s k))
-
-
-
-
-
-
-
-
-
-{-
-newtype S s a = S {unS :: forall o. s -> (s -> a -> o) -> o}
-
-instance Functor (S s) where
-  fmap f (S g) = S (\s k -> g s (\s a -> k s (f a)))
-
-instance Monad (S s) where
-  return a = S (\s k -> k s a)
-  S g >>= f = S (\s k -> g s (\s a -> unS (f a) s k))
-
-get :: S s s
-get = S (\s k -> k s s)
-
-gets :: (s -> a) -> S s a
-gets f = S (\s k -> k s (f s))
-
-put :: s -> S s ()
-put s = S (\_ k -> k s ())
-
-modify :: (s -> s) -> S s ()
-modify f = S (\s k -> k (f s) ())
-
-runS :: S s a -> s -> (a, s)
-runS (S g) = flip g (flip (,))
--}
-
-
-
-
-
rmfile ./StateCPS.hs
hunk ./monad-cps.cabal 1
-name:               luna
-version:            0.1.0
+name:               monad-cps
+version:            0.0.1
hunk ./monad-cps.cabal 5
-license:            GPL
+license:            BSD3
hunk ./monad-cps.cabal 7
-category:           Interpreter, GHC
+category:           Control
hunk ./monad-cps.cabal 12
-synopsis:           An interface to ghc.
+synopsis:           CPS implementations of common monads.
hunk ./monad-cps.cabal 15
-executable luna
-  executable:       luna
-  main-is:          luna.hs
-  hs-source-dirs:   tools, src
-  build-depends:    base == 4.*, readline
-  ghc-options:      -fglasgow-exts -O2
-
-
hunk ./monad-cps.cabal 16
-  build-tools:      happy
-  includes:         MyHsVersions.h, ghcplatform.h, luna_imports.h
hunk ./monad-cps.cabal 18
-  extensions:       CPP, ForeignFunctionInterface
-
-  build-depends:    base == 4.*, ghc == 6.10.1, ghc-paths,
-                    Cabal, unix, ghc-prim,
-                    packedstring, syb, pretty, containers,
-                    template-haskell, haskell-src-exts,
-                    array, haskell98, filepath, directory,
-                    old-time, process
-
-  exposed-modules:  Luna.Config,
-                    Luna.Util,
-
-                    Luna.Env,
-                    Luna.Eval,
-                    Luna.Run,
-                    Luna.Load,
-                    Luna.Interactive,
-                    Luna.Parser,
-
-                    Luna.Syntax.Hs,
-
-                    Luna.Internal.DriverPipeline,
-                    Luna.Internal.Parser,
-
-                    Luna.TH.Meta,
-                    Luna.TH.Utils,
-                    Luna.TH.Meta2,
-                    Luna.TH.Instances
-
-
-
+  extensions:
+  build-depends:    base
+  exposed-modules:  Control.Monad.CPS,
+                    Control.Monad.CPS.Id,
+                    Control.Monad.CPS.R,
+                    Control.Monad.CPS.W,
+                    Control.Monad.CPS.S,
+                    Control.Monad.CPS.C
hunk ./src/Control/Monad/CPS.hs 1
+
+module Control.Monad.CPS (
+    module Control.Monad.CPS.Id
+  , module Control.Monad.CPS.R
+  , module Control.Monad.CPS.W
+  , module Control.Monad.CPS.S
+  , module Control.Monad.CPS.C
+) where
+
+import Control.Monad.CPS.Id
+import Control.Monad.CPS.R
+import Control.Monad.CPS.W
+import Control.Monad.CPS.S
+import Control.Monad.CPS.C
hunk ./src/Control/Monad/CPS/C.hs 1
+
+
+module Control.Monad.CPS.C (
+  module Control.Monad.CPS.C
+) where
+
+newtype C r a = C {unC :: forall o. (a -> r) -> (r -> o) -> o}
+
+instance Functor (C r) where
+  fmap f (C g) = C (\k z -> g (k . f) z)
+
+instance Monad (C r) where
+  return a = C (\k z -> z (k a))
+  C g >>= f = C (\k z -> g (\a -> unC (f a) k id) z)
+  -- C g >>= f = C (\k z -> g (\a -> unC (f a) k z) id
+
+runC :: C r a -> (a -> r) -> r
+runC (C g) = flip g id
+
+idC :: C a a -> a
+idC = flip runC id
+
+mapC :: (r -> r) -> C r a -> C r a
+mapC f (C g) = C (\k z -> g (f . k) z)
+-- mapC f (C g) = C (\k z -> g k (z . f))
+
+withC :: ((b -> r) -> (a -> r)) -> C r a -> C r b
+withC f (C g) = C (\k z -> g (f k) z)
+
+callCC :: ((a -> (forall b. C r b)) -> C r a) -> C r a
+callCC f = C (\k z -> unC (f (\a -> C (\_ h -> (h . k) a))) k z)
+
+shift  :: ((a -> (forall s. C s r)) -> C r r) -> C r a
+shift f = C (\k z -> unC (f (\a -> C (\e h -> (h . e . k) a))) id z)
+
+reset :: C a a -> C r a
+reset m = C (\k z -> (z . k) (runC m id))
+
+
+
addfile ./src/Control/Monad/CPS/Id.hs
hunk ./src/Control/Monad/CPS/Id.hs 1
+
+
+module Control.Monad.CPS.Id (
+  module Control.Monad.CPS.Id
+) where
+
+newtype Id a = Id {unId :: forall o. (a -> o) -> o}
+
+instance Functor Id where
+  fmap f (Id g) = Id (\k -> g (\a -> k (f a)))
+
+instance Monad Id where
+  return a = Id (\k -> k a)
+  Id g >>= f = Id (\k -> g (\a -> unId (f a) k))
+
+runId :: Id a -> a
+runId = flip unId id
+
hunk ./src/Control/Monad/CPS/R.hs 1
+
+
+module Control.Monad.CPS.R (
+  module Control.Monad.CPS.R
+) where
+
+newtype R r a = R {unR :: forall o. r -> (a -> o) -> o}
+
+instance Functor (R r) where
+  fmap f (R g) = R (\r k -> g r (\a -> k (f a)))
+
+instance Monad (R r) where
+  return a = R (\_ k -> k a)
+  R g >>= f = R (\r k -> g r (\a -> unR (f a) r k))
+
+runR :: R r a -> r -> a
+runR (R g) = flip g id
+
+ask :: R r r
+ask = R (\r k -> k r)
+
+asks :: (r -> a) -> R r a
+asks f = R (\r k -> (k . f) r)
+
+local :: (r -> r) -> R r a -> R r a
+local f (R g) = R (\r k -> g (f r) k)
+
hunk ./src/Control/Monad/CPS/S.hs 1
+
+
+module Control.Monad.CPS.S (
+  module Control.Monad.CPS.S
+) where
+
+newtype S s a = S {unS :: forall o. s -> (s -> a -> o) -> o}
+
+instance Functor (S s) where
+  fmap f (S g) = S (\s k -> g s (\s a -> k s (f a)))
+
+instance Monad (S s) where
+  return a = S (\s k -> k s a)
+  S g >>= f = S (\s k -> g s (\s a -> unS (f a) s k))
+
+runS :: S s a -> s -> (a, s)
+runS (S g) = flip g (flip (,))
+
+get :: S s s
+get = S (\s k -> k s s)
+
+gets :: (s -> a) -> S s a
+gets f = S (\s k -> k s (f s))
+
+set :: s -> S s ()
+set s = S (\_ k -> k s ())
+
+modify :: (s -> s) -> S s ()
+modify f = S (\s k -> k (f s) ())
+
+
hunk ./src/Control/Monad/CPS/W.hs 1
+
+
+module Control.Monad.CPS.W (
+  module Control.Monad.CPS.W
+) where
+
+import Data.Monoid (Monoid(..))
+
+newtype W w a = W {unW :: forall o. (a -> w -> o) -> o}
+
+instance Functor (W w) where
+  fmap f (W g) = W (\k -> g (\a w -> k (f a) w))
+
+instance (Monoid w) => Monad (W w) where
+  return a = W (\k -> k a mempty)
+  W g >>= f = W (\k -> g (\a w -> unW (f a) (\a w' -> k a (w`mappend`w'))))
+
+runW :: W w a -> (a, w)
+runW (W g) = g (,)
+
+put :: w -> W w ()
+put w = W (\k -> k () w)
+
}
