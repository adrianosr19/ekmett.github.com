[repository initialized on a hacked up version of bytestring
ekmett@gmail.com**20100318012037
 Ignore-this: 12077dd84183777ee9414da4f73b965d
] adddir ./Data
adddir ./Data/Buffer
addfile ./Data/Buffer/Char8.hs
hunk ./Data/Buffer/Char8.hs 1
+{-# LANGUAGE CPP #-}
+-- We cannot actually specify all the language pragmas, see ghc ticket #
+-- If we could, these are what they would be:
+{- LANGUAGE MagicHash, UnboxedTuples -}
+{-# OPTIONS_HADDOCK prune #-}
+
+-- |
+-- Module      : Data.Buffer.Char8
+-- Copyright   : (c) Don Stewart 2006-2008, (c) Edward Kmett 2009-2010
+-- License     : BSD-style
+--
+-- Maintainer  : ekmett@gmail.com
+-- Stability   : experimental
+-- Portability : portable
+--
+-- Manipulate 'Buffer's using 'Char' operations. All Chars will be
+-- truncated to 8 bits. It can be expected that these functions will run
+-- at identical speeds to their 'Word8' equivalents in "Data.Buffer".
+--
+-- More specifically these byte strings are taken to be in the
+-- subset of Unicode covered by code points 0-255. This covers
+-- Unicode Basic Latin, Latin-1 Supplement and C0+C1 Controls.
+-- 
+-- See: 
+--
+--  * <http://www.unicode.org/charts/>
+--
+--  * <http://www.unicode.org/charts/PDF/U0000.pdf>
+--
+--  * <http://www.unicode.org/charts/PDF/U0080.pdf>
+--
+-- This module is intended to be imported @qualified@, to avoid name
+-- clashes with "Prelude" functions.  eg.
+--
+-- > import qualified Data.Buffer.Char8 as B
+--
+-- The Char8 interface to bytestrings provides an instance of IsString
+-- for the Buffer type, enabling you to use string literals, and
+-- have them implicitly packed to Buffers. Use -XOverloadedStrings
+-- to enable this.
+--
+
+module Data.Buffer.Char8 (
+
+        -- * The @Buffer@ type
+        Buffer,             -- abstract, instances: Eq, Ord, Show, Read, Data, Typeable, Monoid
+
+        -- * Introducing and eliminating 'Buffer's
+        empty,                  -- :: Buffer
+        singleton,              -- :: Char   -> Buffer
+        pack,                   -- :: String -> Buffer
+        unpack,                 -- :: Buffer -> String
+
+        -- * Basic interface
+        cons,                   -- :: Char -> Buffer -> Buffer
+        snoc,                   -- :: Buffer -> Char -> Buffer
+        append,                 -- :: Buffer -> Buffer -> Buffer
+        head,                   -- :: Buffer -> Char
+        uncons,                 -- :: Buffer -> Maybe (Char, Buffer)
+        last,                   -- :: Buffer -> Char
+        tail,                   -- :: Buffer -> Buffer
+        init,                   -- :: Buffer -> Buffer
+        null,                   -- :: Buffer -> Bool
+        length,                 -- :: Buffer -> Int
+
+        -- * Transformating Buffers
+        map,                    -- :: (Char -> Char) -> Buffer -> Buffer
+        reverse,                -- :: Buffer -> Buffer
+        intersperse,            -- :: Char -> Buffer -> Buffer
+        intercalate,            -- :: Buffer -> [Buffer] -> Buffer
+        transpose,              -- :: [Buffer] -> [Buffer]
+
+        -- * Reducing 'Buffer's (folds)
+        foldl,                  -- :: (a -> Char -> a) -> a -> Buffer -> a
+        foldl',                 -- :: (a -> Char -> a) -> a -> Buffer -> a
+        foldl1,                 -- :: (Char -> Char -> Char) -> Buffer -> Char
+        foldl1',                -- :: (Char -> Char -> Char) -> Buffer -> Char
+
+        foldr,                  -- :: (Char -> a -> a) -> a -> Buffer -> a
+        foldr',                 -- :: (Char -> a -> a) -> a -> Buffer -> a
+        foldr1,                 -- :: (Char -> Char -> Char) -> Buffer -> Char
+        foldr1',                -- :: (Char -> Char -> Char) -> Buffer -> Char
+
+        -- ** Special folds
+        concat,                 -- :: [Buffer] -> Buffer
+        concatMap,              -- :: (Char -> Buffer) -> Buffer -> Buffer
+        any,                    -- :: (Char -> Bool) -> Buffer -> Bool
+        all,                    -- :: (Char -> Bool) -> Buffer -> Bool
+        maximum,                -- :: Buffer -> Char
+        minimum,                -- :: Buffer -> Char
+
+        -- * Building Buffers
+        -- ** Scans
+        scanl,                  -- :: (Char -> Char -> Char) -> Char -> Buffer -> Buffer
+        scanl1,                 -- :: (Char -> Char -> Char) -> Buffer -> Buffer
+        scanr,                  -- :: (Char -> Char -> Char) -> Char -> Buffer -> Buffer
+        scanr1,                 -- :: (Char -> Char -> Char) -> Buffer -> Buffer
+
+        -- ** Accumulating maps
+        mapAccumL,              -- :: (acc -> Char -> (acc, Char)) -> acc -> Buffer -> (acc, Buffer)
+        mapAccumR,              -- :: (acc -> Char -> (acc, Char)) -> acc -> Buffer -> (acc, Buffer)
+
+        -- ** Generating and unfolding Buffers
+        replicate,              -- :: Int -> Char -> Buffer
+        unfoldr,                -- :: (a -> Maybe (Char, a)) -> a -> Buffer
+        unfoldrN,               -- :: Int -> (a -> Maybe (Char, a)) -> a -> (Buffer, Maybe a)
+
+        -- * Substrings
+
+        -- ** Breaking strings
+        take,                   -- :: Int -> Buffer -> Buffer
+        drop,                   -- :: Int -> Buffer -> Buffer
+        splitAt,                -- :: Int -> Buffer -> (Buffer, Buffer)
+        takeWhile,              -- :: (Char -> Bool) -> Buffer -> Buffer
+        dropWhile,              -- :: (Char -> Bool) -> Buffer -> Buffer
+        span,                   -- :: (Char -> Bool) -> Buffer -> (Buffer, Buffer)
+        spanEnd,                -- :: (Char -> Bool) -> Buffer -> (Buffer, Buffer)
+        break,                  -- :: (Char -> Bool) -> Buffer -> (Buffer, Buffer)
+        breakEnd,               -- :: (Char -> Bool) -> Buffer -> (Buffer, Buffer)
+        group,                  -- :: Buffer -> [Buffer]
+        groupBy,                -- :: (Char -> Char -> Bool) -> Buffer -> [Buffer]
+        inits,                  -- :: Buffer -> [Buffer]
+        tails,                  -- :: Buffer -> [Buffer]
+
+        -- ** Breaking into many substrings
+        split,                  -- :: Char -> Buffer -> [Buffer]
+        splitWith,              -- :: (Char -> Bool) -> Buffer -> [Buffer]
+
+        -- ** Breaking into lines and words
+        lines,                  -- :: Buffer -> [Buffer]
+        words,                  -- :: Buffer -> [Buffer]
+        unlines,                -- :: [Buffer] -> Buffer
+        unwords,                -- :: Buffer -> [Buffer]
+
+        -- * Predicates
+        isPrefixOf,             -- :: Buffer -> Buffer -> Bool
+        isSuffixOf,             -- :: Buffer -> Buffer -> Bool
+        isInfixOf,              -- :: Buffer -> Buffer -> Bool
+
+        -- ** Search for arbitrary substrings
+        breakSubstring,         -- :: Buffer -> Buffer -> (Buffer,Buffer)
+        findSubstring,          -- :: Buffer -> Buffer -> Maybe Int
+        findSubstrings,         -- :: Buffer -> Buffer -> [Int]
+
+        -- * Searching Buffers
+
+        -- ** Searching by equality
+        elem,                   -- :: Char -> Buffer -> Bool
+        notElem,                -- :: Char -> Buffer -> Bool
+
+        -- ** Searching with a predicate
+        find,                   -- :: (Char -> Bool) -> Buffer -> Maybe Char
+        filter,                 -- :: (Char -> Bool) -> Buffer -> Buffer
+--      partition               -- :: (Char -> Bool) -> Buffer -> (Buffer, Buffer)
+
+        -- * Indexing Buffers
+        index,                  -- :: Buffer -> Int -> Char
+        elemIndex,              -- :: Char -> Buffer -> Maybe Int
+        elemIndices,            -- :: Char -> Buffer -> [Int]
+        elemIndexEnd,           -- :: Char -> Buffer -> Maybe Int
+        findIndex,              -- :: (Char -> Bool) -> Buffer -> Maybe Int
+        findIndices,            -- :: (Char -> Bool) -> Buffer -> [Int]
+        count,                  -- :: Char -> Buffer -> Int
+
+        -- * Zipping and unzipping Buffers
+        zip,                    -- :: Buffer -> Buffer -> [(Char,Char)]
+        zipWith,                -- :: (Char -> Char -> c) -> Buffer -> Buffer -> [c]
+        unzip,                  -- :: [(Char,Char)] -> (Buffer,Buffer)
+
+        -- * Ordered Buffers
+        sort,                   -- :: Buffer -> Buffer
+
+        -- * Reading from Buffers
+        readInt,                -- :: Buffer -> Maybe (Int, Buffer)
+        readInteger,            -- :: Buffer -> Maybe (Integer, Buffer)
+
+        -- * Low level CString conversions
+
+        -- ** Copying Buffers
+        copy,                   -- :: Buffer -> Buffer
+
+        -- ** Packing CStrings and pointers
+        packCString,            -- :: CString -> IO Buffer
+        packCStringLen,         -- :: CStringLen -> IO Buffer
+
+        -- ** Using Buffers as CStrings
+        useAsCString,           -- :: Buffer -> (CString    -> IO a) -> IO a
+        useAsCStringLen,        -- :: Buffer -> (CStringLen -> IO a) -> IO a
+
+        -- * I\/O with 'Buffer's
+
+        -- ** Standard input and output
+        getLine,                -- :: IO Buffer
+        getContents,            -- :: IO Buffer
+        putStr,                 -- :: Buffer -> IO ()
+        putStrLn,               -- :: Buffer -> IO ()
+        interact,               -- :: (Buffer -> Buffer) -> IO ()
+
+        -- ** Files
+        readFile,               -- :: FilePath -> IO Buffer
+        writeFile,              -- :: FilePath -> Buffer -> IO ()
+        appendFile,             -- :: FilePath -> Buffer -> IO ()
+--      mmapFile,               -- :: FilePath -> IO Buffer
+
+        -- ** I\/O with Handles
+        hGetLine,               -- :: Handle -> IO Buffer
+        hGetContents,           -- :: Handle -> IO Buffer
+        hGet,                   -- :: Handle -> Int -> IO Buffer
+        hGetNonBlocking,        -- :: Handle -> Int -> IO Buffer
+        hPut,                   -- :: Handle -> Buffer -> IO ()
+        hPutStr,                -- :: Handle -> Buffer -> IO ()
+        hPutStrLn,              -- :: Handle -> Buffer -> IO ()
+
+  ) where
+
+import qualified Prelude as P
+import Prelude hiding           (reverse,head,tail,last,init,null
+                                ,length,map,lines,foldl,foldr,unlines
+                                ,concat,any,take,drop,splitAt,takeWhile
+                                ,dropWhile,span,break,elem,filter,unwords
+                                ,words,maximum,minimum,all,concatMap
+                                ,scanl,scanl1,scanr,scanr1
+                                ,appendFile,readFile,writeFile
+                                ,foldl1,foldr1,replicate
+                                ,getContents,getLine,putStr,putStrLn,interact
+                                ,zip,zipWith,unzip,notElem)
+
+import qualified Data.Buffer.Word8 as B
+import qualified Data.Buffer.Internal as B
+import qualified Data.Buffer.Unsafe as B
+
+-- Listy functions transparently exported
+import Data.Buffer (empty,null,length,tail,init,append
+                       ,inits,tails,reverse,transpose
+                       ,concat,take,drop,splitAt,intercalate
+                       ,sort,isPrefixOf,isSuffixOf,isInfixOf
+                       ,findSubstring,findSubstrings,breakSubstring,copy,group
+
+                       ,getLine, getContents, putStr, putStrLn, interact
+                       ,hGetContents, hGet, hPut, hPutStr, hPutStrLn
+                       ,hGetLine, hGetNonBlocking
+                       ,packCString,packCStringLen
+                       ,useAsCString,useAsCStringLen
+                       )
+
+import Data.Buffer.Internal (Buffer(PS), c2w, w2c, isSpaceWord8
+                                ,inlinePerformIO)
+
+import Data.Char    ( isSpace )
+import qualified Data.List as List (intersperse)
+
+import System.IO                (openFile,hClose,hFileSize,IOMode(..))
+#ifndef __NHC__
+import Control.Exception        (bracket)
+#else
+import IO			(bracket)
+#endif
+import Foreign
+
+#if defined(__GLASGOW_HASKELL__)
+import GHC.Base                 (Char(..),unpackCString#,ord#,int2Word#)
+#if __GLASGOW_HASKELL__ >= 611
+import GHC.IO                   (stToIO)
+#else
+import GHC.IOBase               (stToIO)
+#endif
+import GHC.Prim                 (Addr#,writeWord8OffAddr#,plusAddr#)
+import GHC.Ptr                  (Ptr(..))
+import GHC.ST                   (ST(..))
+#endif
+
+#if __GLASGOW_HASKELL__ >= 608
+import Data.String
+#endif
+
+#define STRICT1(f) f a | a `seq` False = undefined
+#define STRICT2(f) f a b | a `seq` b `seq` False = undefined
+#define STRICT3(f) f a b c | a `seq` b `seq` c `seq` False = undefined
+#define STRICT4(f) f a b c d | a `seq` b `seq` c `seq` d `seq` False = undefined
+
+------------------------------------------------------------------------
+
+-- | /O(1)/ Convert a 'Char' into a 'Buffer'
+singleton :: Char -> Buffer
+singleton = B.singleton . c2w
+{-# INLINE singleton #-}
+
+#if __GLASGOW_HASKELL__ >= 608
+instance IsString Buffer where
+    fromString = pack
+    {-# INLINE fromString #-}
+#endif
+
+-- | /O(n)/ Convert a 'String' into a 'Buffer'
+--
+-- For applications with large numbers of string literals, pack can be a
+-- bottleneck.
+pack :: String -> Buffer
+#if !defined(__GLASGOW_HASKELL__)
+
+pack str = B.unsafeCreate (P.length str) $ \p -> go p str
+    where go _ []     = return ()
+          go p (x:xs) = poke p (c2w x) >> go (p `plusPtr` 1) xs
+
+#else /* hack away */
+
+pack str = B.unsafeCreate (P.length str) $ \(Ptr p) -> stToIO (go p str)
+  where
+    go :: Addr# -> [Char] -> ST a ()
+    go _ []        = return ()
+    go p (C# c:cs) = writeByte p (int2Word# (ord# c)) >> go (p `plusAddr#` 1#) cs
+
+    writeByte p c = ST $ \s# ->
+        case writeWord8OffAddr# p 0# c s# of s2# -> (# s2#, () #)
+    {-# INLINE writeByte #-}
+{-# INLINE [1] pack #-}
+
+{-# RULES
+"Buffer pack/packAddress" forall s .
+   pack (unpackCString# s) = inlinePerformIO (B.unsafePackAddress s)
+ #-}
+
+#endif
+
+-- | /O(n)/ Converts a 'Buffer' to a 'String'.
+unpack :: Buffer -> [Char]
+unpack = P.map w2c . B.unpack
+{-# INLINE unpack #-}
+
+-- | /O(n)/ 'cons' is analogous to (:) for lists, but of different
+-- complexity, as it requires a memcpy.
+cons :: Char -> Buffer -> Buffer
+cons = B.cons . c2w
+{-# INLINE cons #-}
+
+-- | /O(n)/ Append a Char to the end of a 'Buffer'. Similar to
+-- 'cons', this function performs a memcpy.
+snoc :: Buffer -> Char -> Buffer
+snoc p = B.snoc p . c2w
+{-# INLINE snoc #-}
+
+-- | /O(1)/ Extract the head and tail of a Buffer, returning Nothing
+-- if it is empty.
+uncons :: Buffer -> Maybe (Char, Buffer)
+uncons bs = case B.uncons bs of
+                  Nothing -> Nothing
+                  Just (w, bs') -> Just (w2c w, bs')
+{-# INLINE uncons #-}
+
+-- | /O(1)/ Extract the first element of a Buffer, which must be non-empty.
+head :: Buffer -> Char
+head = w2c . B.head
+{-# INLINE head #-}
+
+-- | /O(1)/ Extract the last element of a packed string, which must be non-empty.
+last :: Buffer -> Char
+last = w2c . B.last
+{-# INLINE last #-}
+
+-- | /O(n)/ 'map' @f xs@ is the Buffer obtained by applying @f@ to each element of @xs@
+map :: (Char -> Char) -> Buffer -> Buffer
+map f = B.map (c2w . f . w2c)
+{-# INLINE map #-}
+
+-- | /O(n)/ The 'intersperse' function takes a Char and a 'Buffer'
+-- and \`intersperses\' that Char between the elements of the
+-- 'Buffer'.  It is analogous to the intersperse function on Lists.
+intersperse :: Char -> Buffer -> Buffer
+intersperse = B.intersperse . c2w
+{-# INLINE intersperse #-}
+
+-- | 'foldl', applied to a binary operator, a starting value (typically
+-- the left-identity of the operator), and a Buffer, reduces the
+-- Buffer using the binary operator, from left to right.
+foldl :: (a -> Char -> a) -> a -> Buffer -> a
+foldl f = B.foldl (\a c -> f a (w2c c))
+{-# INLINE foldl #-}
+
+-- | 'foldl\'' is like foldl, but strict in the accumulator.
+foldl' :: (a -> Char -> a) -> a -> Buffer -> a
+foldl' f = B.foldl' (\a c -> f a (w2c c))
+{-# INLINE foldl' #-}
+
+-- | 'foldr', applied to a binary operator, a starting value
+-- (typically the right-identity of the operator), and a packed string,
+-- reduces the packed string using the binary operator, from right to left.
+foldr :: (Char -> a -> a) -> a -> Buffer -> a
+foldr f = B.foldr (\c a -> f (w2c c) a)
+{-# INLINE foldr #-}
+
+-- | 'foldr\'' is a strict variant of foldr
+foldr' :: (Char -> a -> a) -> a -> Buffer -> a
+foldr' f = B.foldr' (\c a -> f (w2c c) a)
+{-# INLINE foldr' #-}
+
+-- | 'foldl1' is a variant of 'foldl' that has no starting value
+-- argument, and thus must be applied to non-empty 'Buffers'.
+foldl1 :: (Char -> Char -> Char) -> Buffer -> Char
+foldl1 f ps = w2c (B.foldl1 (\x y -> c2w (f (w2c x) (w2c y))) ps)
+{-# INLINE foldl1 #-}
+
+-- | A strict version of 'foldl1'
+foldl1' :: (Char -> Char -> Char) -> Buffer -> Char
+foldl1' f ps = w2c (B.foldl1' (\x y -> c2w (f (w2c x) (w2c y))) ps)
+{-# INLINE foldl1' #-}
+
+-- | 'foldr1' is a variant of 'foldr' that has no starting value argument,
+-- and thus must be applied to non-empty 'Buffer's
+foldr1 :: (Char -> Char -> Char) -> Buffer -> Char
+foldr1 f ps = w2c (B.foldr1 (\x y -> c2w (f (w2c x) (w2c y))) ps)
+{-# INLINE foldr1 #-}
+
+-- | A strict variant of foldr1
+foldr1' :: (Char -> Char -> Char) -> Buffer -> Char
+foldr1' f ps = w2c (B.foldr1' (\x y -> c2w (f (w2c x) (w2c y))) ps)
+{-# INLINE foldr1' #-}
+
+-- | Map a function over a 'Buffer' and concatenate the results
+concatMap :: (Char -> Buffer) -> Buffer -> Buffer
+concatMap f = B.concatMap (f . w2c)
+{-# INLINE concatMap #-}
+
+-- | Applied to a predicate and a Buffer, 'any' determines if
+-- any element of the 'Buffer' satisfies the predicate.
+any :: (Char -> Bool) -> Buffer -> Bool
+any f = B.any (f . w2c)
+{-# INLINE any #-}
+
+-- | Applied to a predicate and a 'Buffer', 'all' determines if
+-- all elements of the 'Buffer' satisfy the predicate.
+all :: (Char -> Bool) -> Buffer -> Bool
+all f = B.all (f . w2c)
+{-# INLINE all #-}
+
+-- | 'maximum' returns the maximum value from a 'Buffer'
+maximum :: Buffer -> Char
+maximum = w2c . B.maximum
+{-# INLINE maximum #-}
+
+-- | 'minimum' returns the minimum value from a 'Buffer'
+minimum :: Buffer -> Char
+minimum = w2c . B.minimum
+{-# INLINE minimum #-}
+
+-- | The 'mapAccumL' function behaves like a combination of 'map' and
+-- 'foldl'; it applies a function to each element of a Buffer,
+-- passing an accumulating parameter from left to right, and returning a
+-- final value of this accumulator together with the new list.
+mapAccumL :: (acc -> Char -> (acc, Char)) -> acc -> Buffer -> (acc, Buffer)
+mapAccumL f = B.mapAccumL (\acc w -> case f acc (w2c w) of (acc', c) -> (acc', c2w c))
+
+-- | The 'mapAccumR' function behaves like a combination of 'map' and
+-- 'foldr'; it applies a function to each element of a Buffer,
+-- passing an accumulating parameter from right to left, and returning a
+-- final value of this accumulator together with the new Buffer.
+mapAccumR :: (acc -> Char -> (acc, Char)) -> acc -> Buffer -> (acc, Buffer)
+mapAccumR f = B.mapAccumR (\acc w -> case f acc (w2c w) of (acc', c) -> (acc', c2w c))
+
+-- | 'scanl' is similar to 'foldl', but returns a list of successive
+-- reduced values from the left:
+--
+-- > scanl f z [x1, x2, ...] == [z, z `f` x1, (z `f` x1) `f` x2, ...]
+--
+-- Note that
+--
+-- > last (scanl f z xs) == foldl f z xs.
+scanl :: (Char -> Char -> Char) -> Char -> Buffer -> Buffer
+scanl f z = B.scanl (\a b -> c2w (f (w2c a) (w2c b))) (c2w z)
+
+-- | 'scanl1' is a variant of 'scanl' that has no starting value argument:
+--
+-- > scanl1 f [x1, x2, ...] == [x1, x1 `f` x2, ...]
+scanl1 :: (Char -> Char -> Char) -> Buffer -> Buffer
+scanl1 f = B.scanl1 (\a b -> c2w (f (w2c a) (w2c b)))
+
+-- | scanr is the right-to-left dual of scanl.
+scanr :: (Char -> Char -> Char) -> Char -> Buffer -> Buffer
+scanr f z = B.scanr (\a b -> c2w (f (w2c a) (w2c b))) (c2w z)
+
+-- | 'scanr1' is a variant of 'scanr' that has no starting value argument.
+scanr1 :: (Char -> Char -> Char) -> Buffer -> Buffer
+scanr1 f = B.scanr1 (\a b -> c2w (f (w2c a) (w2c b)))
+
+-- | /O(n)/ 'replicate' @n x@ is a Buffer of length @n@ with @x@
+-- the value of every element. The following holds:
+--
+-- > replicate w c = unfoldr w (\u -> Just (u,u)) c
+--
+-- This implemenation uses @memset(3)@
+replicate :: Int -> Char -> Buffer
+replicate w = B.replicate w . c2w
+{-# INLINE replicate #-}
+
+-- | /O(n)/, where /n/ is the length of the result.  The 'unfoldr' 
+-- function is analogous to the List \'unfoldr\'.  'unfoldr' builds a 
+-- Buffer from a seed value.  The function takes the element and 
+-- returns 'Nothing' if it is done producing the Buffer or returns 
+-- 'Just' @(a,b)@, in which case, @a@ is the next character in the string, 
+-- and @b@ is the seed value for further production.
+--
+-- Examples:
+--
+-- > unfoldr (\x -> if x <= '9' then Just (x, succ x) else Nothing) '0' == "0123456789"
+unfoldr :: (a -> Maybe (Char, a)) -> a -> Buffer
+unfoldr f x0 = B.unfoldr (fmap k . f) x0
+    where k (i, j) = (c2w i, j)
+
+-- | /O(n)/ Like 'unfoldr', 'unfoldrN' builds a Buffer from a seed
+-- value.  However, the length of the result is limited by the first
+-- argument to 'unfoldrN'.  This function is more efficient than 'unfoldr'
+-- when the maximum length of the result is known.
+--
+-- The following equation relates 'unfoldrN' and 'unfoldr':
+--
+-- > unfoldrN n f s == take n (unfoldr f s)
+unfoldrN :: Int -> (a -> Maybe (Char, a)) -> a -> (Buffer, Maybe a)
+unfoldrN n f w = B.unfoldrN n ((k `fmap`) . f) w
+    where k (i,j) = (c2w i, j)
+{-# INLINE unfoldrN #-}
+
+-- | 'takeWhile', applied to a predicate @p@ and a Buffer @xs@,
+-- returns the longest prefix (possibly empty) of @xs@ of elements that
+-- satisfy @p@.
+takeWhile :: (Char -> Bool) -> Buffer -> Buffer
+takeWhile f = B.takeWhile (f . w2c)
+{-# INLINE takeWhile #-}
+
+-- | 'dropWhile' @p xs@ returns the suffix remaining after 'takeWhile' @p xs@.
+dropWhile :: (Char -> Bool) -> Buffer -> Buffer
+dropWhile f = B.dropWhile (f . w2c)
+#if defined(__GLASGOW_HASKELL__)
+{-# INLINE [1] dropWhile #-}
+#endif
+
+{-# RULES
+"Buffer specialise dropWhile isSpace -> dropSpace"
+    dropWhile isSpace = dropSpace
+  #-}
+
+-- | 'break' @p@ is equivalent to @'span' ('not' . p)@.
+break :: (Char -> Bool) -> Buffer -> (Buffer, Buffer)
+break f = B.break (f . w2c)
+#if defined(__GLASGOW_HASKELL__)
+{-# INLINE [1] break #-}
+#endif
+
+#if __GLASGOW_HASKELL__ >= 606
+-- This RULE LHS is not allowed by ghc-6.4
+{-# RULES
+"Buffer specialise break (x==)" forall x.
+    break ((==) x) = breakChar x
+"Buffer specialise break (==x)" forall x.
+    break (==x) = breakChar x
+  #-}
+#endif
+
+-- INTERNAL:
+
+-- | 'breakChar' breaks its Buffer argument at the first occurence
+-- of the specified char. It is more efficient than 'break' as it is
+-- implemented with @memchr(3)@. I.e.
+-- 
+-- > break (=='c') "abcd" == breakChar 'c' "abcd"
+--
+breakChar :: Char -> Buffer -> (Buffer, Buffer)
+breakChar c p = case elemIndex c p of
+    Nothing -> (p,empty)
+    Just n  -> (B.unsafeTake n p, B.unsafeDrop n p)
+{-# INLINE breakChar #-}
+
+-- | 'span' @p xs@ breaks the Buffer into two segments. It is
+-- equivalent to @('takeWhile' p xs, 'dropWhile' p xs)@
+span :: (Char -> Bool) -> Buffer -> (Buffer, Buffer)
+span f = B.span (f . w2c)
+{-# INLINE span #-}
+
+-- | 'spanEnd' behaves like 'span' but from the end of the 'Buffer'.
+-- We have
+--
+-- > spanEnd (not.isSpace) "x y z" == ("x y ","z")
+--
+-- and
+--
+-- > spanEnd (not . isSpace) ps
+-- >    == 
+-- > let (x,y) = span (not.isSpace) (reverse ps) in (reverse y, reverse x) 
+--
+spanEnd :: (Char -> Bool) -> Buffer -> (Buffer, Buffer)
+spanEnd f = B.spanEnd (f . w2c)
+{-# INLINE spanEnd #-}
+
+-- | 'breakEnd' behaves like 'break' but from the end of the 'Buffer'
+-- 
+-- breakEnd p == spanEnd (not.p)
+breakEnd :: (Char -> Bool) -> Buffer -> (Buffer, Buffer)
+breakEnd f = B.breakEnd (f . w2c)
+{-# INLINE breakEnd #-}
+
+{-
+-- | 'breakChar' breaks its Buffer argument at the first occurence
+-- of the specified Char. It is more efficient than 'break' as it is
+-- implemented with @memchr(3)@. I.e.
+-- 
+-- > break (=='c') "abcd" == breakChar 'c' "abcd"
+--
+breakChar :: Char -> Buffer -> (Buffer, Buffer)
+breakChar = B.breakByte . c2w
+{-# INLINE breakChar #-}
+
+-- | 'spanChar' breaks its Buffer argument at the first
+-- occurence of a Char other than its argument. It is more efficient
+-- than 'span (==)'
+--
+-- > span  (=='c') "abcd" == spanByte 'c' "abcd"
+--
+spanChar :: Char -> Buffer -> (Buffer, Buffer)
+spanChar = B.spanByte . c2w
+{-# INLINE spanChar #-}
+-}
+
+-- | /O(n)/ Break a 'Buffer' into pieces separated by the byte
+-- argument, consuming the delimiter. I.e.
+--
+-- > split '\n' "a\nb\nd\ne" == ["a","b","d","e"]
+-- > split 'a'  "aXaXaXa"    == ["","X","X","X",""]
+-- > split 'x'  "x"          == ["",""]
+-- 
+-- and
+--
+-- > intercalate [c] . split c == id
+-- > split == splitWith . (==)
+-- 
+-- As for all splitting functions in this library, this function does
+-- not copy the substrings, it just constructs new 'Buffers' that
+-- are slices of the original.
+--
+split :: Char -> Buffer -> [Buffer]
+split = B.split . c2w
+{-# INLINE split #-}
+
+-- | /O(n)/ Splits a 'Buffer' into components delimited by
+-- separators, where the predicate returns True for a separator element.
+-- The resulting components do not contain the separators.  Two adjacent
+-- separators result in an empty component in the output.  eg.
+--
+-- > splitWith (=='a') "aabbaca" == ["","","bb","c",""]
+--
+splitWith :: (Char -> Bool) -> Buffer -> [Buffer]
+splitWith f = B.splitWith (f . w2c)
+{-# INLINE splitWith #-}
+-- the inline makes a big difference here.
+
+{-
+-- | Like 'splitWith', except that sequences of adjacent separators are
+-- treated as a single separator. eg.
+-- 
+-- > tokens (=='a') "aabbaca" == ["bb","c"]
+--
+tokens :: (Char -> Bool) -> Buffer -> [Buffer]
+tokens f = B.tokens (f . w2c)
+{-# INLINE tokens #-}
+-}
+
+-- | The 'groupBy' function is the non-overloaded version of 'group'.
+groupBy :: (Char -> Char -> Bool) -> Buffer -> [Buffer]
+groupBy k = B.groupBy (\a b -> k (w2c a) (w2c b))
+
+-- | /O(1)/ 'Buffer' index (subscript) operator, starting from 0.
+index :: Buffer -> Int -> Char
+index = (w2c .) . B.index
+{-# INLINE index #-}
+
+-- | /O(n)/ The 'elemIndex' function returns the index of the first
+-- element in the given 'Buffer' which is equal (by memchr) to the
+-- query element, or 'Nothing' if there is no such element.
+elemIndex :: Char -> Buffer -> Maybe Int
+elemIndex = B.elemIndex . c2w
+{-# INLINE elemIndex #-}
+
+-- | /O(n)/ The 'elemIndexEnd' function returns the last index of the
+-- element in the given 'Buffer' which is equal to the query
+-- element, or 'Nothing' if there is no such element. The following
+-- holds:
+--
+-- > elemIndexEnd c xs == 
+-- > (-) (length xs - 1) `fmap` elemIndex c (reverse xs)
+--
+elemIndexEnd :: Char -> Buffer -> Maybe Int
+elemIndexEnd = B.elemIndexEnd . c2w
+{-# INLINE elemIndexEnd #-}
+
+-- | /O(n)/ The 'elemIndices' function extends 'elemIndex', by returning
+-- the indices of all elements equal to the query element, in ascending order.
+elemIndices :: Char -> Buffer -> [Int]
+elemIndices = B.elemIndices . c2w
+{-# INLINE elemIndices #-}
+
+-- | The 'findIndex' function takes a predicate and a 'Buffer' and
+-- returns the index of the first element in the Buffer satisfying the predicate.
+findIndex :: (Char -> Bool) -> Buffer -> Maybe Int
+findIndex f = B.findIndex (f . w2c)
+{-# INLINE findIndex #-}
+
+-- | The 'findIndices' function extends 'findIndex', by returning the
+-- indices of all elements satisfying the predicate, in ascending order.
+findIndices :: (Char -> Bool) -> Buffer -> [Int]
+findIndices f = B.findIndices (f . w2c)
+
+-- | count returns the number of times its argument appears in the Buffer
+--
+-- > count = length . elemIndices
+-- 
+-- Also
+--  
+-- > count '\n' == length . lines
+--
+-- But more efficiently than using length on the intermediate list.
+count :: Char -> Buffer -> Int
+count c = B.count (c2w c)
+
+-- | /O(n)/ 'elem' is the 'Buffer' membership predicate. This
+-- implementation uses @memchr(3)@.
+elem :: Char -> Buffer -> Bool
+elem    c = B.elem (c2w c)
+{-# INLINE elem #-}
+
+-- | /O(n)/ 'notElem' is the inverse of 'elem'
+notElem :: Char -> Buffer -> Bool
+notElem c = B.notElem (c2w c)
+{-# INLINE notElem #-}
+
+-- | /O(n)/ 'filter', applied to a predicate and a Buffer,
+-- returns a Buffer containing those characters that satisfy the
+-- predicate.
+filter :: (Char -> Bool) -> Buffer -> Buffer
+filter f = B.filter (f . w2c)
+{-# INLINE filter #-}
+
+{-
+-- | /O(n)/ and /O(n\/c) space/ A first order equivalent of /filter .
+-- (==)/, for the common case of filtering a single Char. It is more
+-- efficient to use /filterChar/ in this case.
+--
+-- > filterChar == filter . (==)
+--
+-- filterChar is around 10x faster, and uses much less space, than its
+-- filter equivalent
+--
+filterChar :: Char -> Buffer -> Buffer
+filterChar c ps = replicate (count c ps) c
+{-# INLINE filterChar #-}
+
+{-# RULES
+"Buffer specialise filter (== x)" forall x.
+    filter ((==) x) = filterChar x
+"Buffer specialise filter (== x)" forall x.
+    filter (== x) = filterChar x
+  #-}
+-}
+
+-- | /O(n)/ The 'find' function takes a predicate and a Buffer,
+-- and returns the first element in matching the predicate, or 'Nothing'
+-- if there is no such element.
+find :: (Char -> Bool) -> Buffer -> Maybe Char
+find f ps = w2c `fmap` B.find (f . w2c) ps
+{-# INLINE find #-}
+
+{-
+-- | /O(n)/ A first order equivalent of /filter . (==)/, for the common
+-- case of filtering a single Char. It is more efficient to use
+-- filterChar in this case.
+--
+-- > filterChar == filter . (==)
+--
+-- filterChar is around 10x faster, and uses much less space, than its
+-- filter equivalent
+--
+filterChar :: Char -> Buffer -> Buffer
+filterChar c = B.filterByte (c2w c)
+{-# INLINE filterChar #-}
+
+-- | /O(n)/ A first order equivalent of /filter . (\/=)/, for the common
+-- case of filtering a single Char out of a list. It is more efficient
+-- to use /filterNotChar/ in this case.
+--
+-- > filterNotChar == filter . (/=)
+--
+-- filterNotChar is around 3x faster, and uses much less space, than its
+-- filter equivalent
+--
+filterNotChar :: Char -> Buffer -> Buffer
+filterNotChar c = B.filterNotByte (c2w c)
+{-# INLINE filterNotChar #-}
+-}
+
+-- | /O(n)/ 'zip' takes two Buffers and returns a list of
+-- corresponding pairs of Chars. If one input Buffer is short,
+-- excess elements of the longer Buffer are discarded. This is
+-- equivalent to a pair of 'unpack' operations, and so space
+-- usage may be large for multi-megabyte Buffers
+zip :: Buffer -> Buffer -> [(Char,Char)]
+zip ps qs
+    | B.null ps || B.null qs = []
+    | otherwise = (unsafeHead ps, unsafeHead qs) : zip (B.unsafeTail ps) (B.unsafeTail qs)
+
+-- | 'zipWith' generalises 'zip' by zipping with the function given as
+-- the first argument, instead of a tupling function.  For example,
+-- @'zipWith' (+)@ is applied to two Buffers to produce the list
+-- of corresponding sums.
+zipWith :: (Char -> Char -> a) -> Buffer -> Buffer -> [a]
+zipWith f = B.zipWith ((. w2c) . f . w2c)
+
+-- | 'unzip' transforms a list of pairs of Chars into a pair of
+-- Buffers. Note that this performs two 'pack' operations.
+unzip :: [(Char,Char)] -> (Buffer,Buffer)
+unzip ls = (pack (P.map fst ls), pack (P.map snd ls))
+{-# INLINE unzip #-}
+
+-- | A variety of 'head' for non-empty Buffers. 'unsafeHead' omits
+-- the check for the empty case, which is good for performance, but
+-- there is an obligation on the programmer to provide a proof that the
+-- Buffer is non-empty.
+unsafeHead :: Buffer -> Char
+unsafeHead  = w2c . B.unsafeHead
+{-# INLINE unsafeHead #-}
+
+-- ---------------------------------------------------------------------
+-- Things that depend on the encoding
+
+{-# RULES
+"Buffer specialise break -> breakSpace"
+    break isSpace = breakSpace
+  #-}
+
+-- | 'breakSpace' returns the pair of Buffers when the argument is
+-- broken at the first whitespace byte. I.e.
+-- 
+-- > break isSpace == breakSpace
+--
+breakSpace :: Buffer -> (Buffer,Buffer)
+breakSpace (PS x s l) = inlinePerformIO $ withForeignPtr x $ \p -> do
+    i <- firstspace (p `plusPtr` s) 0 l
+    return $! case () of {_
+        | i == 0    -> (empty, PS x s l)
+        | i == l    -> (PS x s l, empty)
+        | otherwise -> (PS x s i, PS x (s+i) (l-i))
+    }
+{-# INLINE breakSpace #-}
+
+firstspace :: Ptr Word8 -> Int -> Int -> IO Int
+STRICT3(firstspace)
+firstspace ptr n m
+    | n >= m    = return n
+    | otherwise = do w <- peekByteOff ptr n
+                     if (not . isSpaceWord8) w then firstspace ptr (n+1) m else return n
+
+-- | 'dropSpace' efficiently returns the 'Buffer' argument with
+-- white space Chars removed from the front. It is more efficient than
+-- calling dropWhile for removing whitespace. I.e.
+-- 
+-- > dropWhile isSpace == dropSpace
+--
+dropSpace :: Buffer -> Buffer
+dropSpace (PS x s l) = inlinePerformIO $ withForeignPtr x $ \p -> do
+    i <- firstnonspace (p `plusPtr` s) 0 l
+    return $! if i == l then empty else PS x (s+i) (l-i)
+{-# INLINE dropSpace #-}
+
+firstnonspace :: Ptr Word8 -> Int -> Int -> IO Int
+STRICT3(firstnonspace)
+firstnonspace ptr n m
+    | n >= m    = return n
+    | otherwise = do w <- peekElemOff ptr n
+                     if isSpaceWord8 w then firstnonspace ptr (n+1) m else return n
+
+{-
+-- | 'dropSpaceEnd' efficiently returns the 'Buffer' argument with
+-- white space removed from the end. I.e.
+-- 
+-- > reverse . (dropWhile isSpace) . reverse == dropSpaceEnd
+--
+-- but it is more efficient than using multiple reverses.
+--
+dropSpaceEnd :: Buffer -> Buffer
+dropSpaceEnd (PS x s l) = inlinePerformIO $ withForeignPtr x $ \p -> do
+    i <- lastnonspace (p `plusPtr` s) (l-1)
+    return $! if i == (-1) then empty else PS x s (i+1)
+{-# INLINE dropSpaceEnd #-}
+
+lastnonspace :: Ptr Word8 -> Int -> IO Int
+STRICT2(lastnonspace)
+lastnonspace ptr n
+    | n < 0     = return n
+    | otherwise = do w <- peekElemOff ptr n
+                     if isSpaceWord8 w then lastnonspace ptr (n-1) else return n
+-}
+
+-- | 'lines' breaks a Buffer up into a list of Buffers at
+-- newline Chars. The resulting strings do not contain newlines.
+--
+lines :: Buffer -> [Buffer]
+lines ps
+    | null ps = []
+    | otherwise = case search ps of
+             Nothing -> [ps]
+             Just n  -> take n ps : lines (drop (n+1) ps)
+    where search = elemIndex '\n'
+
+{-
+-- Just as fast, but more complex. Should be much faster, I thought.
+lines :: Buffer -> [Buffer]
+lines (PS _ _ 0) = []
+lines (PS x s l) = inlinePerformIO $ withForeignPtr x $ \p -> do
+        let ptr = p `plusPtr` s
+
+            STRICT1(loop)
+            loop n = do
+                let q = memchr (ptr `plusPtr` n) 0x0a (fromIntegral (l-n))
+                if q == nullPtr
+                    then return [PS x (s+n) (l-n)]
+                    else do let i = q `minusPtr` ptr
+                            ls <- loop (i+1)
+                            return $! PS x (s+n) (i-n) : ls
+        loop 0
+-}
+
+-- | 'unlines' is an inverse operation to 'lines'.  It joins lines,
+-- after appending a terminating newline to each.
+unlines :: [Buffer] -> Buffer
+unlines [] = empty
+unlines ss = (concat $ List.intersperse nl ss) `append` nl -- half as much space
+    where nl = singleton '\n'
+
+-- | 'words' breaks a Buffer up into a list of words, which
+-- were delimited by Chars representing white space.
+words :: Buffer -> [Buffer]
+words = P.filter (not . B.null) . B.splitWith isSpaceWord8
+{-# INLINE words #-}
+
+-- | The 'unwords' function is analogous to the 'unlines' function, on words.
+unwords :: [Buffer] -> Buffer
+unwords = intercalate (singleton ' ')
+{-# INLINE unwords #-}
+
+-- ---------------------------------------------------------------------
+-- Reading from Buffers
+
+-- | readInt reads an Int from the beginning of the Buffer.  If there is no
+-- integer at the beginning of the string, it returns Nothing, otherwise
+-- it just returns the int read, and the rest of the string.
+readInt :: Buffer -> Maybe (Int, Buffer)
+readInt as
+    | null as   = Nothing
+    | otherwise =
+        case unsafeHead as of
+            '-' -> loop True  0 0 (B.unsafeTail as)
+            '+' -> loop False 0 0 (B.unsafeTail as)
+            _   -> loop False 0 0 as
+
+    where loop :: Bool -> Int -> Int -> Buffer -> Maybe (Int, Buffer)
+          STRICT4(loop)
+          loop neg i n ps
+              | null ps   = end neg i n ps
+              | otherwise =
+                  case B.unsafeHead ps of
+                    w | w >= 0x30
+                     && w <= 0x39 -> loop neg (i+1)
+                                          (n * 10 + (fromIntegral w - 0x30))
+                                          (B.unsafeTail ps)
+                      | otherwise -> end neg i n ps
+
+          end _    0 _ _  = Nothing
+          end True _ n ps = Just (negate n, ps)
+          end _    _ n ps = Just (n, ps)
+
+-- | readInteger reads an Integer from the beginning of the Buffer.  If
+-- there is no integer at the beginning of the string, it returns Nothing,
+-- otherwise it just returns the int read, and the rest of the string.
+readInteger :: Buffer -> Maybe (Integer, Buffer)
+readInteger as
+    | null as   = Nothing
+    | otherwise =
+        case unsafeHead as of
+            '-' -> first (B.unsafeTail as) >>= \(n, bs) -> return (-n, bs)
+            '+' -> first (B.unsafeTail as)
+            _   -> first as
+
+    where first ps | null ps   = Nothing
+                   | otherwise =
+                       case B.unsafeHead ps of
+                        w | w >= 0x30 && w <= 0x39 -> Just $
+                            loop 1 (fromIntegral w - 0x30) [] (B.unsafeTail ps)
+                          | otherwise              -> Nothing
+
+          loop :: Int -> Int -> [Integer]
+               -> Buffer -> (Integer, Buffer)
+          STRICT4(loop)
+          loop d acc ns ps
+              | null ps   = combine d acc ns empty
+              | otherwise =
+                  case B.unsafeHead ps of
+                   w | w >= 0x30 && w <= 0x39 ->
+                       if d == 9 then loop 1 (fromIntegral w - 0x30)
+                                           (toInteger acc : ns)
+                                           (B.unsafeTail ps)
+                                 else loop (d+1)
+                                           (10*acc + (fromIntegral w - 0x30))
+                                           ns (B.unsafeTail ps)
+                     | otherwise -> combine d acc ns ps
+
+          combine _ acc [] ps = (toInteger acc, ps)
+          combine d acc ns ps =
+              ((10^d * combine1 1000000000 ns + toInteger acc), ps)
+
+          combine1 _ [n] = n
+          combine1 b ns  = combine1 (b*b) $ combine2 b ns
+
+          combine2 b (n:m:ns) = let t = m*b + n in t `seq` (t : combine2 b ns)
+          combine2 _ ns       = ns
+
+------------------------------------------------------------------------
+-- For non-binary text processing:
+
+-- | Read an entire file strictly into a 'Buffer'.  This is far more
+-- efficient than reading the characters into a 'String' and then using
+-- 'pack'.  It also may be more efficient than opening the file and
+-- reading it using hGet.
+readFile :: FilePath -> IO Buffer
+readFile f = bracket (openFile f ReadMode) hClose
+    (\h -> hFileSize h >>= hGet h . fromIntegral)
+
+-- | Write a 'Buffer' to a file.
+writeFile :: FilePath -> Buffer -> IO ()
+writeFile f txt = bracket (openFile f WriteMode) hClose
+    (\h -> hPut h txt)
+
+-- | Append a 'Buffer' to a file.
+appendFile :: FilePath -> Buffer -> IO ()
+appendFile f txt = bracket (openFile f AppendMode) hClose
+    (\h -> hPut h txt)
+
addfile ./Data/Buffer/Fusion.hs
hunk ./Data/Buffer/Fusion.hs 1
+{-# OPTIONS_HADDOCK hide #-}
+-- |
+-- Module      : Data.Buffer.Fusion
+-- License     : BSD-style
+-- Maintainer  : ekmett@gmail.com
+-- Stability   : experimental
+-- Portability : portable
+--
+-- Stream fusion for Buffers.
+--
+-- See the paper /Stream Fusion: From Lists to Streams to Nothing at All/,
+-- Coutts, Leshchinskiy and Stewart, 2007.  
+--
+
+module Data.Buffer.Fusion (
+
+    -- A place holder for Stream Fusion
+
+  ) where
+
+
addfile ./Data/Buffer/Internal.hs
hunk ./Data/Buffer/Internal.hs 1
+s{-# LANGUAGE CPP, ForeignFunctionInterface #-}
+-- We cannot actually specify all the language pragmas, see ghc ticket #
+-- If we could, these are what they would be:
+{- LANGUAGE UnliftedFFITypes, MagicHash,
+            UnboxedTuples, DeriveDataTypeable -}
+{-# OPTIONS_HADDOCK hide #-}
+
+-- |
+-- Module      : Data.Buffer.Internal
+-- License     : BSD-style
+-- Maintainer  : Edward Kmett <ekmett@gmail.com>
+-- Stability   : experimental
+-- Portability : portable
+--
+-- A module containing semi-public 'Buffer' internals. This exposes the
+-- 'Buffer' representation and low level construction functions. As such
+-- all the functions in this module are unsafe. The API is also not stable.
+--
+-- Where possible application should instead use the functions from the normal
+-- public interface modules, such as "Data.Buffer.Unsafe". Packages that
+-- extend the Buffer system at a low level will need to use this module.
+--
+module Data.Buffer.Internal (
+
+        -- * The @Buffer@ type and representation
+        Buffer(..),         -- instances: Eq, Ord, Show, Read, Data, Typeable
+
+        -- * Low level introduction and elimination
+        create,                 -- :: Int -> (Ptr Word8 -> IO ()) -> IO Buffer
+        createAndTrim,          -- :: Int -> (Ptr Word8 -> IO Int) -> IO  Buffer
+        createAndTrim',         -- :: Int -> (Ptr Word8 -> IO (Int, Int, a)) -> IO (Buffer, a)
+        unsafeCreate,           -- :: Int -> (Ptr Word8 -> IO ()) ->  Buffer
+        mallocBuffer,           -- :: Int -> IO (ForeignPtr a)
+
+        -- * Conversion to and from ForeignPtrs
+        fromForeignPtr,         -- :: ForeignPtr Word8 -> Int -> Int -> Buffer
+        toForeignPtr,           -- :: Buffer -> (ForeignPtr Word8, Int, Int)
+
+        -- * Utilities
+        inlinePerformIO,        -- :: IO a -> a
+        nullForeignPtr,         -- :: ForeignPtr Word8
+
+        -- * Standard C Functions
+        c_strlen,               -- :: CString -> IO CInt
+        c_free_finalizer,       -- :: FunPtr (Ptr Word8 -> IO ())
+
+        memchr,                 -- :: Ptr Word8 -> Word8 -> CSize -> IO Ptr Word8
+        memcmp,                 -- :: Ptr Word8 -> Ptr Word8 -> CSize -> IO CInt
+        memcpy,                 -- :: Ptr Word8 -> Ptr Word8 -> CSize -> IO ()
+        memset,                 -- :: Ptr Word8 -> Word8 -> CSize -> IO (Ptr Word8)
+
+        -- * cbits functions
+        c_reverse,              -- :: Ptr Word8 -> Ptr Word8 -> CInt -> IO ()
+        c_intersperse,          -- :: Ptr Word8 -> Ptr Word8 -> CInt -> Word8 -> IO ()
+        c_maximum,              -- :: Ptr Word8 -> CInt -> IO Word8
+        c_minimum,              -- :: Ptr Word8 -> CInt -> IO Word8
+        c_count,                -- :: Ptr Word8 -> CInt -> Word8 -> IO CInt
+#if defined(__GLASGOW_HASKELL__) && __GLASGOW_HASKELL__ < 611
+        -- * Internal GHC magic
+        memcpy_ptr_baoff,       -- :: Ptr a -> RawBuffer -> CInt -> CSize -> IO (Ptr ())
+#endif
+
+        -- * Chars
+        w2c, c2w, isSpaceWord8, isSpaceChar8
+
+        -- * UTF8 multibyte tail counting
+        extra, minusExtra, plusExtra 
+
+  ) where
+
+import Foreign.ForeignPtr       (ForeignPtr, withForeignPtr)
+import Foreign.Ptr              (Ptr, FunPtr, plusPtr)
+import Foreign.Storable         (Storable(..))
+import Foreign.C.Types          (CInt, CSize, CULong)
+import Foreign.C.String         (CString)
+
+#ifndef __NHC__
+import Control.Exception        (assert)
+#endif
+
+import Data.Char                (ord)
+import Data.Word                (Word8)
+
+#if defined(__GLASGOW_HASKELL__)
+import Data.Typeable            (Typeable)
+#if __GLASGOW_HASKELL__ >= 610
+import Data.Data                (Data)
+#else
+import Data.Generics            (Data)
+#endif
+import GHC.Base                 (realWorld#,unsafeChr)
+#if __GLASGOW_HASKELL__ >= 611
+import GHC.IO                   (IO(IO))
+#else
+import GHC.IOBase               (IO(IO),RawBuffer)
+#endif
+#if __GLASGOW_HASKELL__ >= 611
+import GHC.IO                   (unsafeDupablePerformIO)
+#elif __GLASGOW_HASKELL__ >= 608
+import GHC.IOBase               (unsafeDupablePerformIO)
+#else
+import GHC.IOBase               (unsafePerformIO)
+#endif
+#else
+import Data.Char                (chr)
+import System.IO.Unsafe         (unsafePerformIO)
+#endif
+
+#if __GLASGOW_HASKELL__ >= 605 && !defined(SLOW_FOREIGN_PTR)
+import GHC.ForeignPtr           (mallocPlainForeignPtrBytes)
+#else
+import Foreign.ForeignPtr       (mallocForeignPtrBytes)
+#endif
+
+#if __GLASGOW_HASKELL__>=605
+import GHC.ForeignPtr           (ForeignPtr(ForeignPtr))
+import GHC.Base                 (nullAddr#)
+#else
+import Foreign.Ptr              (nullPtr)
+#endif
+
+#if __HUGS__
+import Hugs.ForeignPtr          (newForeignPtr_)
+#elif __GLASGOW_HASKELL__<=604
+import Foreign.ForeignPtr       (newForeignPtr_)
+#endif
+
+-- CFILES stuff is Hugs only
+{-# CFILES cbits/fpstring.c #-}
+
+-- An alternative to Control.Exception (assert) for nhc98
+#ifdef __NHC__
+#define assert	assertS "__FILE__ : __LINE__"
+assertS :: String -> Bool -> a -> a
+assertS _ True  = id
+assertS s False = error ("assertion failed at "++s)
+#endif
+
+-- -----------------------------------------------------------------------------
+--
+-- Useful macros, until we have bang patterns
+--
+
+#define STRICT1(f) f a | a `seq` False = undefined
+#define STRICT2(f) f a b | a `seq` b `seq` False = undefined
+#define STRICT3(f) f a b c | a `seq` b `seq` c `seq` False = undefined
+#define STRICT4(f) f a b c d | a `seq` b `seq` c `seq` d `seq` False = undefined
+#define STRICT5(f) f a b c d e | a `seq` b `seq` c `seq` d `seq` e `seq` False = undefined
+
+-- -----------------------------------------------------------------------------
+
+-- | A space-efficient representation of a Word8 vector, supporting many
+-- efficient operations.  A 'Buffer' contains 8-bit characters only.
+--
+-- Instances of Eq, Ord, Read, Show, Data, Typeable
+--
+data Buffer = PS {-# UNPACK #-} !(ForeignPtr Word8) -- payload
+                     {-# UNPACK #-} !Int                -- offset
+                     {-# UNPACK #-} !Int                -- length
+                     {-# UNPACK #-} !Int                -- extras
+#if defined(__GLASGOW_HASKELL__)
+    deriving (Data, Typeable)
+#endif
+                     
+
+extra :: Word8 -> Int
+extra b = if b >= 0x80 && b < 0xC0 then 1 else 0
+{-# INLINE extra #-}
+
+minusExtra :: Int -> Word8 -> Int
+minusExtra 0 _ = 0 
+minusExtra e b = e - extra b
+{-# INLINE minusExtra #-}
+
+plusExtra :: Int -> Word8 -> Int
+plusExtra e b = e + extra b
+{-# INLINE plusExtra #-}
+
+
+instance Show Buffer where
+    showsPrec p ps r = showsPrec p (unpackWith w2c ps) r
+
+instance Read Buffer where
+    readsPrec p str = [ (packWith c2w x, y) | (x, y) <- readsPrec p str ]
+
+-- | /O(n)/ Converts a 'Buffer' to a '[a]', using a conversion function.
+unpackWith :: (Word8 -> a) -> Buffer -> [a]
+unpackWith _ (PS _  _ 0 _) = []
+unpackWith k (PS ps s l _) = inlinePerformIO $ withForeignPtr ps $ \p ->
+        go (p `plusPtr` s) (l - 1) []
+    where
+        STRICT3(go)
+        go p 0 acc = peek p          >>= \e -> return (k e : acc)
+        go p n acc = peekByteOff p n >>= \e -> go p (n-1) (k e : acc)
+{-# INLINE unpackWith #-}
+{-# SPECIALIZE unpackWith :: (Word8 -> Char) -> Buffer -> [Char] #-}
+
+-- | /O(n)/ Convert a '[a]' into a 'Buffer' using some
+-- conversion function
+packWith :: (a -> Word8) -> [a] -> Buffer
+packWith k str = unsafeCreate' (length str) $ \p -> go p str 0
+    where
+        STRICT3(go)
+        go _ [] acc = return acc
+        go p (x:xs) = do
+            let kx = k x
+            poke p kx
+            go (p `plusPtr` 1) xs $! acc + extra kx
+{-# INLINE packWith #-}
+{-# SPECIALIZE packWith :: (Char -> Word8) -> [Char] -> Buffer #-}
+
+------------------------------------------------------------------------
+
+-- | The 0 pointer. Used to indicate the empty Buffer.
+nullForeignPtr :: ForeignPtr Word8
+#if __GLASGOW_HASKELL__>=605
+nullForeignPtr = ForeignPtr nullAddr# undefined --TODO: should ForeignPtrContents be strict?
+#else
+nullForeignPtr = unsafePerformIO $ newForeignPtr_ nullPtr
+{-# NOINLINE nullForeignPtr #-}
+#endif
+
+-- ---------------------------------------------------------------------
+-- Low level constructors
+
+-- | /O(1)/ Build a Buffer from a ForeignPtr.
+--
+-- If you do not need the offset parameter then you do should be using
+-- 'Data.Buffer.Unsafe.unsafePackCStringLen' or
+-- 'Data.Buffer.Unsafe.unsafePackCStringFinalizer' instead.
+--
+fromForeignPtr :: ForeignPtr Word8
+               -> Int -- ^ Offset
+               -> Int -- ^ Length
+               -> Buffer
+fromForeignPtr fp s l = PS fp s l
+{-# INLINE fromForeignPtr #-}
+
+-- | /O(1)/ Deconstruct a ForeignPtr from a Buffer
+toForeignPtr :: Buffer -> (ForeignPtr Word8, Int, Int) -- ^ (ptr, offset, length)
+toForeignPtr (PS ps s l) = (ps, s, l)
+{-# INLINE toForeignPtr #-}
+
+-- | A way of creating Buffers outside the IO monad. The @Int@
+-- argument gives the final size of the Buffer. Unlike
+-- 'createAndTrim' the Buffer is not reallocated if the final size
+-- is less than the estimated size.
+unsafeCreate :: Int -> (Ptr Word8 -> IO ()) -> Buffer
+unsafeCreate l f = unsafeDupablePerformIO (create l f)
+{-# INLINE unsafeCreate #-}
+
+-- | A way of creating Buffers outside the IO monad. The @Int@
+-- argument gives the final size of the Buffer. Unlike
+-- 'createAndTrim' the Buffer is not reallocated if the final size
+-- is less than the estimated size.
+unsafeCreate' :: Int -> (Ptr Word8 -> IO Int) -> Buffer
+unsafeCreate' l f = unsafeDupablePerformIO (create' l f)
+{-# INLINE unsafeCreate #-}
+
+
+#if !defined(__GLASGOW_HASKELL__) || __GLASGOW_HASKELL__ < 608
+-- for Hugs   
+unsafeDupablePerformIO :: IO a -> a
+unsafeDupablePerformIO = unsafePerformIO
+#endif
+
+-- | Create Buffer of size @l@ and use action @f@ to fill it's contents.
+create :: Int -> (Ptr Word8 -> IO ()) -> IO Buffer
+create l f = do
+    fp <- mallocBuffer l
+    withForeignPtr fp $ \p -> f p
+    return $! ps fp 0 l
+{-# INLINE create #-}
+
+
+-- | Create Buffer of size @l@ and use action @f@ to fill it's contents and count the high bits.
+create' :: Int -> (Ptr Word8 -> IO Int) -> IO Buffer
+create' l f = do
+    fp <- mallocBuffer l
+    h <- withForeignPtr fp $ \p -> f p
+    return $! PS fp 0 1 h 
+{-# INLINE create' #-}
+
+-- | Given the maximum size needed and a function to make the contents
+-- of a Buffer, createAndTrim makes the 'Buffer'. The generating
+-- function is required to return the actual final size (<= the maximum
+-- size), and the resulting byte array is realloced to this size.
+--
+-- createAndTrim is the main mechanism for creating custom, efficient
+-- Buffer functions, using Haskell or C functions to fill the space.
+--
+createAndTrim :: Int -> (Ptr Word8 -> IO Int) -> IO Buffer
+createAndTrim l f = do
+    fp <- mallocBuffer l
+    withForeignPtr fp $ \p -> do
+        l' <- f p
+        if assert (l' <= l) $ l' >= l
+            then return $! ps fp 0 l
+            else create l' $ \p' -> memcpy p' p (fromIntegral l')
+{-# INLINE createAndTrim #-}
+
+createAndTrim' :: Int -> (Ptr Word8 -> IO (Int, Int, a)) -> IO (Buffer, a)
+createAndTrim' l f = do
+    fp <- mallocBuffer l
+    withForeignPtr fp $ \p -> do
+        (off, l', res) <- f p
+        if assert (l' <= l) $ l' >= l
+            then return $! (PS fp 0 l, res)
+            else do ps <- create l' $ \p' ->
+                            memcpy p' (p `plusPtr` off) (fromIntegral l')
+                    return $! (ps, res)
+
+-- | Wrapper of mallocForeignPtrBytes with faster implementation
+-- for GHC 6.5 builds newer than 06/06/06
+mallocBuffer :: Int -> IO (ForeignPtr a)
+mallocBuffer l = do
+#if __GLASGOW_HASKELL__ >= 605 && !defined(SLOW_FOREIGN_PTR)
+    mallocPlainForeignPtrBytes l
+#else
+    mallocForeignPtrBytes l
+#endif
+{-# INLINE mallocBuffer #-}
+
+------------------------------------------------------------------------
+
+-- | Conversion between 'Word8' and 'Char'. Should compile to a no-op.
+w2c :: Word8 -> Char
+#if !defined(__GLASGOW_HASKELL__)
+w2c = chr . fromIntegral
+#else
+w2c = unsafeChr . fromIntegral
+#endif
+{-# INLINE w2c #-}
+
+-- | Unsafe conversion between 'Char' and 'Word8'. This is a no-op and
+-- silently truncates to 8 bits Chars > '\255'. It is provided as
+-- convenience for Buffer construction.
+c2w :: Char -> Word8
+c2w = fromIntegral . ord
+{-# INLINE c2w #-}
+
+-- | Selects words corresponding to white-space characters in the Latin-1 range
+-- ordered by frequency. 
+isSpaceWord8 :: Word8 -> Bool
+isSpaceWord8 w =
+    w == 0x20 ||
+    w == 0x0A || -- LF, \n
+    w == 0x09 || -- HT, \t
+    w == 0x0C || -- FF, \f
+    w == 0x0D || -- CR, \r
+    w == 0x0B || -- VT, \v
+    w == 0xA0    -- spotted by QC..
+{-# INLINE isSpaceWord8 #-}
+
+-- | Selects white-space characters in the Latin-1 range
+isSpaceChar8 :: Char -> Bool
+isSpaceChar8 c =
+    c == ' '     ||
+    c == '\t'    ||
+    c == '\n'    ||
+    c == '\r'    ||
+    c == '\f'    ||
+    c == '\v'    ||
+    c == '\xa0'
+{-# INLINE isSpaceChar8 #-}
+
+------------------------------------------------------------------------
+
+-- | Just like unsafePerformIO, but we inline it. Big performance gains as
+-- it exposes lots of things to further inlining. /Very unsafe/. In
+-- particular, you should do no memory allocation inside an
+-- 'inlinePerformIO' block. On Hugs this is just @unsafePerformIO@.
+--
+{-# INLINE inlinePerformIO #-}
+inlinePerformIO :: IO a -> a
+#if defined(__GLASGOW_HASKELL__)
+inlinePerformIO (IO m) = case m realWorld# of (# _, r #) -> r
+#else
+inlinePerformIO = unsafePerformIO
+#endif
+
+-- ---------------------------------------------------------------------
+-- 
+-- Standard C functions
+--
+
+foreign import ccall unsafe "string.h strlen" c_strlen
+    :: CString -> IO CSize
+
+foreign import ccall unsafe "static stdlib.h &free" c_free_finalizer
+    :: FunPtr (Ptr Word8 -> IO ())
+
+foreign import ccall unsafe "string.h memchr" c_memchr
+    :: Ptr Word8 -> CInt -> CSize -> IO (Ptr Word8)
+
+memchr :: Ptr Word8 -> Word8 -> CSize -> IO (Ptr Word8)
+memchr p w s = c_memchr p (fromIntegral w) s
+
+foreign import ccall unsafe "string.h memcmp" memcmp
+    :: Ptr Word8 -> Ptr Word8 -> CSize -> IO CInt
+
+foreign import ccall unsafe "string.h memcpy" c_memcpy
+    :: Ptr Word8 -> Ptr Word8 -> CSize -> IO (Ptr Word8)
+
+memcpy :: Ptr Word8 -> Ptr Word8 -> CSize -> IO ()
+memcpy p q s = c_memcpy p q s >> return ()
+
+{-
+foreign import ccall unsafe "string.h memmove" c_memmove
+    :: Ptr Word8 -> Ptr Word8 -> CSize -> IO (Ptr Word8)
+
+memmove :: Ptr Word8 -> Ptr Word8 -> CSize -> IO ()
+memmove p q s = do c_memmove p q s
+                   return ()
+-}
+
+foreign import ccall unsafe "string.h memset" c_memset
+    :: Ptr Word8 -> CInt -> CSize -> IO (Ptr Word8)
+
+memset :: Ptr Word8 -> Word8 -> CSize -> IO (Ptr Word8)
+memset p w s = c_memset p (fromIntegral w) s
+
+-- ---------------------------------------------------------------------
+--
+-- Uses our C code
+--
+
+foreign import ccall unsafe "static fpstring.h bfps_reverse" c_reverse
+    :: Ptr Word8 -> Ptr Word8 -> CULong -> IO ()
+
+foreign import ccall unsafe "static fpstring.h bfps_intersperse" c_intersperse
+    :: Ptr Word8 -> Ptr Word8 -> CULong -> Word8 -> IO ()
+
+foreign import ccall unsafe "static fpstring.h bfps_maximum" c_maximum
+    :: Ptr Word8 -> CULong -> IO Word8
+
+foreign import ccall unsafe "static fpstring.h bfps_minimum" c_minimum
+    :: Ptr Word8 -> CULong -> IO Word8
+
+foreign import ccall unsafe "static fpstring.h bfps_count" c_count
+    :: Ptr Word8 -> CULong -> Word8 -> IO CULong
+    
+foreign import ccall unsafe "static fpstring.h bfps_count_extras" c_count_extras
+    :: Ptr Word8 -> CULong -> Word8 -> IO CULong    
+
+-- ---------------------------------------------------------------------
+-- Internal GHC Haskell magic
+
+#if defined(__GLASGOW_HASKELL__) && __GLASGOW_HASKELL__ < 611
+foreign import ccall unsafe "__hscore_memcpy_src_off"
+   memcpy_ptr_baoff :: Ptr a -> RawBuffer -> CInt -> CSize -> IO (Ptr ())
+#endif
adddir ./Data/Buffer/Lazy
addfile ./Data/Buffer/Lazy/Char8.hs
hunk ./Data/Buffer/Lazy/Char8.hs 1
+{-# LANGUAGE CPP #-}
+{-# OPTIONS_HADDOCK prune #-}
+
+-- |
+-- Module      : Data.Buffer.Lazy.Char8
+-- Copyright   : (c) Don Stewart 2006
+-- License     : BSD-style
+--
+-- Maintainer  : dons@cse.unsw.edu.au
+-- Stability   : experimental
+-- Portability : non-portable (imports Data.Buffer.Lazy)
+--
+-- Manipulate /lazy/ 'Buffer's using 'Char' operations. All Chars will
+-- be truncated to 8 bits. It can be expected that these functions will
+-- run at identical speeds to their 'Data.Word.Word8' equivalents in
+-- "Data.Buffer.Lazy".
+--
+-- This module is intended to be imported @qualified@, to avoid name
+-- clashes with "Prelude" functions.  eg.
+--
+-- > import qualified Data.Buffer.Lazy.Char8 as C
+--
+
+module Data.Buffer.Lazy.Char8 (
+
+        -- * The @Buffer@ type
+        Buffer,             -- instances: Eq, Ord, Show, Read, Data, Typeable
+
+        -- * Introducing and eliminating 'Buffer's
+        empty,                  -- :: Buffer
+        singleton,              -- :: Char   -> Buffer
+        pack,                   -- :: String -> Buffer
+        unpack,                 -- :: Buffer -> String
+        fromChunks,             -- :: [Strict.Buffer] -> Buffer
+        toChunks,               -- :: Buffer -> [Strict.Buffer]
+
+        -- * Basic interface
+        cons,                   -- :: Char -> Buffer -> Buffer
+        cons',                  -- :: Char -> Buffer -> Buffer
+        snoc,                   -- :: Buffer -> Char -> Buffer
+        append,                 -- :: Buffer -> Buffer -> Buffer
+        head,                   -- :: Buffer -> Char
+        uncons,                 -- :: Buffer -> Maybe (Char, Buffer)
+        last,                   -- :: Buffer -> Char
+        tail,                   -- :: Buffer -> Buffer
+        init,                   -- :: Buffer -> Buffer
+        null,                   -- :: Buffer -> Bool
+        length,                 -- :: Buffer -> Int64
+
+        -- * Transforming Buffers
+        map,                    -- :: (Char -> Char) -> Buffer -> Buffer
+        reverse,                -- :: Buffer -> Buffer
+        intersperse,            -- :: Char -> Buffer -> Buffer
+        intercalate,            -- :: Buffer -> [Buffer] -> Buffer
+        transpose,              -- :: [Buffer] -> [Buffer]
+
+        -- * Reducing 'Buffer's (folds)
+        foldl,                  -- :: (a -> Char -> a) -> a -> Buffer -> a
+        foldl',                 -- :: (a -> Char -> a) -> a -> Buffer -> a
+        foldl1,                 -- :: (Char -> Char -> Char) -> Buffer -> Char
+        foldl1',                -- :: (Char -> Char -> Char) -> Buffer -> Char
+        foldr,                  -- :: (Char -> a -> a) -> a -> Buffer -> a
+        foldr1,                 -- :: (Char -> Char -> Char) -> Buffer -> Char
+
+        -- ** Special folds
+        concat,                 -- :: [Buffer] -> Buffer
+        concatMap,              -- :: (Char -> Buffer) -> Buffer -> Buffer
+        any,                    -- :: (Char -> Bool) -> Buffer -> Bool
+        all,                    -- :: (Char -> Bool) -> Buffer -> Bool
+        maximum,                -- :: Buffer -> Char
+        minimum,                -- :: Buffer -> Char
+
+        -- * Building Buffers
+        -- ** Scans
+        scanl,                  -- :: (Char -> Char -> Char) -> Char -> Buffer -> Buffer
+--      scanl1,                 -- :: (Char -> Char -> Char) -> Buffer -> Buffer
+--      scanr,                  -- :: (Char -> Char -> Char) -> Char -> Buffer -> Buffer
+--      scanr1,                 -- :: (Char -> Char -> Char) -> Buffer -> Buffer
+
+        -- ** Accumulating maps
+        mapAccumL,              -- :: (acc -> Char -> (acc, Char)) -> acc -> Buffer -> (acc, Buffer)
+        mapAccumR,              -- :: (acc -> Char -> (acc, Char)) -> acc -> Buffer -> (acc, Buffer)
+
+        -- ** Infinite Buffers
+        repeat,                 -- :: Char -> Buffer
+        replicate,              -- :: Int64 -> Char -> Buffer
+        cycle,                  -- :: Buffer -> Buffer
+        iterate,                -- :: (Char -> Char) -> Char -> Buffer
+
+        -- ** Unfolding Buffers
+        unfoldr,                -- :: (a -> Maybe (Char, a)) -> a -> Buffer
+
+        -- * Substrings
+
+        -- ** Breaking strings
+        take,                   -- :: Int64 -> Buffer -> Buffer
+        drop,                   -- :: Int64 -> Buffer -> Buffer
+        splitAt,                -- :: Int64 -> Buffer -> (Buffer, Buffer)
+        takeWhile,              -- :: (Char -> Bool) -> Buffer -> Buffer
+        dropWhile,              -- :: (Char -> Bool) -> Buffer -> Buffer
+        span,                   -- :: (Char -> Bool) -> Buffer -> (Buffer, Buffer)
+        break,                  -- :: (Char -> Bool) -> Buffer -> (Buffer, Buffer)
+        group,                  -- :: Buffer -> [Buffer]
+        groupBy,                -- :: (Char -> Char -> Bool) -> Buffer -> [Buffer]
+        inits,                  -- :: Buffer -> [Buffer]
+        tails,                  -- :: Buffer -> [Buffer]
+
+        -- ** Breaking into many substrings
+        split,                  -- :: Char -> Buffer -> [Buffer]
+        splitWith,              -- :: (Char -> Bool) -> Buffer -> [Buffer]
+
+        -- ** Breaking into lines and words
+        lines,                  -- :: Buffer -> [Buffer]
+        words,                  -- :: Buffer -> [Buffer]
+        unlines,                -- :: [Buffer] -> Buffer
+        unwords,                -- :: Buffer -> [Buffer]
+
+        -- * Predicates
+        isPrefixOf,             -- :: Buffer -> Buffer -> Bool
+--      isSuffixOf,             -- :: Buffer -> Buffer -> Bool
+
+        -- * Searching Buffers
+
+        -- ** Searching by equality
+        elem,                   -- :: Char -> Buffer -> Bool
+        notElem,                -- :: Char -> Buffer -> Bool
+
+        -- ** Searching with a predicate
+        find,                   -- :: (Char -> Bool) -> Buffer -> Maybe Char
+        filter,                 -- :: (Char -> Bool) -> Buffer -> Buffer
+--      partition               -- :: (Char -> Bool) -> Buffer -> (Buffer, Buffer)
+
+        -- * Indexing Buffers
+        index,                  -- :: Buffer -> Int64 -> Char
+        elemIndex,              -- :: Char -> Buffer -> Maybe Int64
+        elemIndices,            -- :: Char -> Buffer -> [Int64]
+        findIndex,              -- :: (Char -> Bool) -> Buffer -> Maybe Int64
+        findIndices,            -- :: (Char -> Bool) -> Buffer -> [Int64]
+        count,                  -- :: Char -> Buffer -> Int64
+
+        -- * Zipping and unzipping Buffers
+        zip,                    -- :: Buffer -> Buffer -> [(Char,Char)]
+        zipWith,                -- :: (Char -> Char -> c) -> Buffer -> Buffer -> [c]
+--      unzip,                  -- :: [(Char,Char)] -> (Buffer,Buffer)
+
+        -- * Ordered Buffers
+--        sort,                   -- :: Buffer -> Buffer
+
+        -- * Low level conversions
+        -- ** Copying Buffers
+        copy,                   -- :: Buffer -> Buffer
+
+        -- * Reading from Buffers
+        readInt,
+        readInteger,
+
+        -- * I\/O with 'Buffer's
+
+        -- ** Standard input and output
+        getContents,            -- :: IO Buffer
+        putStr,                 -- :: Buffer -> IO ()
+        putStrLn,               -- :: Buffer -> IO ()
+        interact,               -- :: (Buffer -> Buffer) -> IO ()
+
+        -- ** Files
+        readFile,               -- :: FilePath -> IO Buffer
+        writeFile,              -- :: FilePath -> Buffer -> IO ()
+        appendFile,             -- :: FilePath -> Buffer -> IO ()
+
+        -- ** I\/O with Handles
+        hGetContents,           -- :: Handle -> IO Buffer
+        hGet,                   -- :: Handle -> Int64 -> IO Buffer
+        hGetNonBlocking,        -- :: Handle -> Int64 -> IO Buffer
+        hPut,                   -- :: Handle -> Buffer -> IO ()
+
+  ) where
+
+-- Functions transparently exported
+import Data.Buffer.Lazy.Word8
+        (fromChunks, toChunks
+        ,empty,null,length,tail,init,append,reverse,transpose,cycle
+        ,concat,take,drop,splitAt,intercalate,isPrefixOf,group,inits,tails,copy
+        ,hGetContents, hGet, hPut, getContents
+        ,hGetNonBlocking
+        ,putStr, putStrLn, interact)
+
+-- Functions we need to wrap.
+import qualified Data.Buffer.Lazy.Word8 as L
+import qualified Data.Buffer as S (Buffer) -- typename only
+import qualified Data.Buffer as B
+import qualified Data.Buffer.Unsafe as B
+import Data.Buffer.Lazy.Internal
+
+import Data.Buffer.Internal (w2c, c2w, isSpaceWord8)
+
+import Data.Int (Int64)
+import qualified Data.List as List
+
+import Prelude hiding           
+        (reverse,head,tail,last,init,null,length,map,lines,foldl,foldr,unlines
+        ,concat,any,take,drop,splitAt,takeWhile,dropWhile,span,break,elem,filter
+        ,unwords,words,maximum,minimum,all,concatMap,scanl,scanl1,foldl1,foldr1
+        ,readFile,writeFile,appendFile,replicate,getContents,getLine,putStr,putStrLn
+        ,zip,zipWith,unzip,notElem,repeat,iterate,interact,cycle)
+
+import System.IO            (hClose,openFile,IOMode(..))
+#ifndef __NHC__
+import Control.Exception    (bracket)
+#else
+import IO                   (bracket)
+#endif
+
+#if __GLASGOW_HASKELL__ >= 608
+import Data.String
+#endif
+
+#define STRICT1(f) f a | a `seq` False = undefined
+#define STRICT2(f) f a b | a `seq` b `seq` False = undefined
+#define STRICT3(f) f a b c | a `seq` b `seq` c `seq` False = undefined
+#define STRICT4(f) f a b c d | a `seq` b `seq` c `seq` d `seq` False = undefined
+#define STRICT5(f) f a b c d e | a `seq` b `seq` c `seq` d `seq` e `seq` False = undefined
+#define STRICT5_(f) f a b c d _ | a `seq` b `seq` c `seq` d `seq` False = undefined
+
+------------------------------------------------------------------------
+
+-- | /O(1)/ Convert a 'Char' into a 'Buffer'
+singleton :: Char -> Buffer
+singleton = L.singleton . c2w
+{-# INLINE singleton #-}
+
+#if __GLASGOW_HASKELL__ >= 608
+instance IsString Buffer where
+    fromString = pack
+    {-# INLINE fromString #-}
+#endif
+
+-- | /O(n)/ Convert a 'String' into a 'Buffer'. 
+pack :: [Char] -> Buffer
+pack = L.pack. List.map c2w
+
+-- | /O(n)/ Converts a 'Buffer' to a 'String'.
+unpack :: Buffer -> [Char]
+unpack = List.map w2c . L.unpack
+{-# INLINE unpack #-}
+
+-- | /O(1)/ 'cons' is analogous to '(:)' for lists.
+cons :: Char -> Buffer -> Buffer
+cons = L.cons . c2w
+{-# INLINE cons #-}
+
+-- | /O(1)/ Unlike 'cons', 'cons\'' is
+-- strict in the Buffer that we are consing onto. More precisely, it forces
+-- the head and the first chunk. It does this because, for space efficiency, it
+-- may coalesce the new byte onto the first \'chunk\' rather than starting a
+-- new \'chunk\'.
+--
+-- So that means you can't use a lazy recursive contruction like this:
+--
+-- > let xs = cons\' c xs in xs
+--
+-- You can however use 'cons', as well as 'repeat' and 'cycle', to build
+-- infinite lazy Buffers.
+--
+cons' :: Char -> Buffer -> Buffer
+cons' = L.cons' . c2w
+{-# INLINE cons' #-}
+
+-- | /O(n)/ Append a Char to the end of a 'Buffer'. Similar to
+-- 'cons', this function performs a memcpy.
+snoc :: Buffer -> Char -> Buffer
+snoc p = L.snoc p . c2w
+{-# INLINE snoc #-}
+
+-- | /O(1)/ Extract the first element of a Buffer, which must be non-empty.
+head :: Buffer -> Char
+head = w2c . L.head
+{-# INLINE head #-}
+
+-- | /O(1)/ Extract the head and tail of a Buffer, returning Nothing
+-- if it is empty.
+uncons :: Buffer -> Maybe (Char, Buffer)
+uncons bs = case L.uncons bs of
+                  Nothing -> Nothing
+                  Just (w, bs') -> Just (w2c w, bs')
+{-# INLINE uncons #-}
+
+-- | /O(1)/ Extract the last element of a packed string, which must be non-empty.
+last :: Buffer -> Char
+last = w2c . L.last
+{-# INLINE last #-}
+
+-- | /O(n)/ 'map' @f xs@ is the Buffer obtained by applying @f@ to each element of @xs@
+map :: (Char -> Char) -> Buffer -> Buffer
+map f = L.map (c2w . f . w2c)
+{-# INLINE map #-}
+
+-- | /O(n)/ The 'intersperse' function takes a Char and a 'Buffer'
+-- and \`intersperses\' that Char between the elements of the
+-- 'Buffer'.  It is analogous to the intersperse function on Lists.
+intersperse :: Char -> Buffer -> Buffer
+intersperse = L.intersperse . c2w
+{-# INLINE intersperse #-}
+
+-- | 'foldl', applied to a binary operator, a starting value (typically
+-- the left-identity of the operator), and a Buffer, reduces the
+-- Buffer using the binary operator, from left to right.
+foldl :: (a -> Char -> a) -> a -> Buffer -> a
+foldl f = L.foldl (\a c -> f a (w2c c))
+{-# INLINE foldl #-}
+
+-- | 'foldl\'' is like foldl, but strict in the accumulator.
+foldl' :: (a -> Char -> a) -> a -> Buffer -> a
+foldl' f = L.foldl' (\a c -> f a (w2c c))
+{-# INLINE foldl' #-}
+
+-- | 'foldr', applied to a binary operator, a starting value
+-- (typically the right-identity of the operator), and a packed string,
+-- reduces the packed string using the binary operator, from right to left.
+foldr :: (Char -> a -> a) -> a -> Buffer -> a
+foldr f = L.foldr (\c a -> f (w2c c) a)
+{-# INLINE foldr #-}
+
+-- | 'foldl1' is a variant of 'foldl' that has no starting value
+-- argument, and thus must be applied to non-empty 'Buffers'.
+foldl1 :: (Char -> Char -> Char) -> Buffer -> Char
+foldl1 f ps = w2c (L.foldl1 (\x y -> c2w (f (w2c x) (w2c y))) ps)
+{-# INLINE foldl1 #-}
+
+-- | 'foldl1\'' is like 'foldl1', but strict in the accumulator.
+foldl1' :: (Char -> Char -> Char) -> Buffer -> Char
+foldl1' f ps = w2c (L.foldl1' (\x y -> c2w (f (w2c x) (w2c y))) ps)
+
+-- | 'foldr1' is a variant of 'foldr' that has no starting value argument,
+-- and thus must be applied to non-empty 'Buffer's
+foldr1 :: (Char -> Char -> Char) -> Buffer -> Char
+foldr1 f ps = w2c (L.foldr1 (\x y -> c2w (f (w2c x) (w2c y))) ps)
+{-# INLINE foldr1 #-}
+
+-- | Map a function over a 'Buffer' and concatenate the results
+concatMap :: (Char -> Buffer) -> Buffer -> Buffer
+concatMap f = L.concatMap (f . w2c)
+{-# INLINE concatMap #-}
+
+-- | Applied to a predicate and a Buffer, 'any' determines if
+-- any element of the 'Buffer' satisfies the predicate.
+any :: (Char -> Bool) -> Buffer -> Bool
+any f = L.any (f . w2c)
+{-# INLINE any #-}
+
+-- | Applied to a predicate and a 'Buffer', 'all' determines if
+-- all elements of the 'Buffer' satisfy the predicate.
+all :: (Char -> Bool) -> Buffer -> Bool
+all f = L.all (f . w2c)
+{-# INLINE all #-}
+
+-- | 'maximum' returns the maximum value from a 'Buffer'
+maximum :: Buffer -> Char
+maximum = w2c . L.maximum
+{-# INLINE maximum #-}
+
+-- | 'minimum' returns the minimum value from a 'Buffer'
+minimum :: Buffer -> Char
+minimum = w2c . L.minimum
+{-# INLINE minimum #-}
+
+-- ---------------------------------------------------------------------
+-- Building Buffers
+
+-- | 'scanl' is similar to 'foldl', but returns a list of successive
+-- reduced values from the left. This function will fuse.
+--
+-- > scanl f z [x1, x2, ...] == [z, z `f` x1, (z `f` x1) `f` x2, ...]
+--
+-- Note that
+--
+-- > last (scanl f z xs) == foldl f z xs.
+scanl :: (Char -> Char -> Char) -> Char -> Buffer -> Buffer
+scanl f z = L.scanl (\a b -> c2w (f (w2c a) (w2c b))) (c2w z)
+
+-- | The 'mapAccumL' function behaves like a combination of 'map' and
+-- 'foldl'; it applies a function to each element of a Buffer,
+-- passing an accumulating parameter from left to right, and returning a
+-- final value of this accumulator together with the new Buffer.
+mapAccumL :: (acc -> Char -> (acc, Char)) -> acc -> Buffer -> (acc, Buffer)
+mapAccumL f = L.mapAccumL (\a w -> case f a (w2c w) of (a',c) -> (a', c2w c))
+
+-- | The 'mapAccumR' function behaves like a combination of 'map' and
+-- 'foldr'; it applies a function to each element of a Buffer,
+-- passing an accumulating parameter from right to left, and returning a
+-- final value of this accumulator together with the new Buffer.
+mapAccumR :: (acc -> Char -> (acc, Char)) -> acc -> Buffer -> (acc, Buffer)
+mapAccumR f = L.mapAccumR (\acc w -> case f acc (w2c w) of (acc', c) -> (acc', c2w c))
+
+------------------------------------------------------------------------
+-- Generating and unfolding Buffers
+
+-- | @'iterate' f x@ returns an infinite Buffer of repeated applications
+-- of @f@ to @x@:
+--
+-- > iterate f x == [x, f x, f (f x), ...]
+--
+iterate :: (Char -> Char) -> Char -> Buffer
+iterate f = L.iterate (c2w . f . w2c) . c2w
+
+-- | @'repeat' x@ is an infinite Buffer, with @x@ the value of every
+-- element.
+--
+repeat :: Char -> Buffer
+repeat = L.repeat . c2w
+
+-- | /O(n)/ @'replicate' n x@ is a Buffer of length @n@ with @x@
+-- the value of every element.
+--
+replicate :: Int64 -> Char -> Buffer
+replicate w c = L.replicate w (c2w c)
+
+-- | /O(n)/ The 'unfoldr' function is analogous to the List \'unfoldr\'.
+-- 'unfoldr' builds a Buffer from a seed value.  The function takes
+-- the element and returns 'Nothing' if it is done producing the
+-- Buffer or returns 'Just' @(a,b)@, in which case, @a@ is a
+-- prepending to the Buffer and @b@ is used as the next element in a
+-- recursive call.
+unfoldr :: (a -> Maybe (Char, a)) -> a -> Buffer
+unfoldr f = L.unfoldr $ \a -> case f a of
+                                    Nothing      -> Nothing
+                                    Just (c, a') -> Just (c2w c, a')
+
+------------------------------------------------------------------------
+
+-- | 'takeWhile', applied to a predicate @p@ and a Buffer @xs@,
+-- returns the longest prefix (possibly empty) of @xs@ of elements that
+-- satisfy @p@.
+takeWhile :: (Char -> Bool) -> Buffer -> Buffer
+takeWhile f = L.takeWhile (f . w2c)
+{-# INLINE takeWhile #-}
+
+-- | 'dropWhile' @p xs@ returns the suffix remaining after 'takeWhile' @p xs@.
+dropWhile :: (Char -> Bool) -> Buffer -> Buffer
+dropWhile f = L.dropWhile (f . w2c)
+{-# INLINE dropWhile #-}
+
+-- | 'break' @p@ is equivalent to @'span' ('not' . p)@.
+break :: (Char -> Bool) -> Buffer -> (Buffer, Buffer)
+break f = L.break (f . w2c)
+{-# INLINE break #-}
+
+-- | 'span' @p xs@ breaks the Buffer into two segments. It is
+-- equivalent to @('takeWhile' p xs, 'dropWhile' p xs)@
+span :: (Char -> Bool) -> Buffer -> (Buffer, Buffer)
+span f = L.span (f . w2c)
+{-# INLINE span #-}
+
+{-
+-- | 'breakChar' breaks its Buffer argument at the first occurence
+-- of the specified Char. It is more efficient than 'break' as it is
+-- implemented with @memchr(3)@. I.e.
+-- 
+-- > break (=='c') "abcd" == breakChar 'c' "abcd"
+--
+breakChar :: Char -> Buffer -> (Buffer, Buffer)
+breakChar = L.breakByte . c2w
+{-# INLINE breakChar #-}
+
+-- | 'spanChar' breaks its Buffer argument at the first
+-- occurence of a Char other than its argument. It is more efficient
+-- than 'span (==)'
+--
+-- > span  (=='c') "abcd" == spanByte 'c' "abcd"
+--
+spanChar :: Char -> Buffer -> (Buffer, Buffer)
+spanChar = L.spanByte . c2w
+{-# INLINE spanChar #-}
+-}
+
+--
+-- TODO, more rules for breakChar*
+--
+
+-- | /O(n)/ Break a 'Buffer' into pieces separated by the byte
+-- argument, consuming the delimiter. I.e.
+--
+-- > split '\n' "a\nb\nd\ne" == ["a","b","d","e"]
+-- > split 'a'  "aXaXaXa"    == ["","X","X","X"]
+-- > split 'x'  "x"          == ["",""]
+-- 
+-- and
+--
+-- > intercalate [c] . split c == id
+-- > split == splitWith . (==)
+-- 
+-- As for all splitting functions in this library, this function does
+-- not copy the substrings, it just constructs new 'Buffers' that
+-- are slices of the original.
+--
+split :: Char -> Buffer -> [Buffer]
+split = L.split . c2w
+{-# INLINE split #-}
+
+-- | /O(n)/ Splits a 'Buffer' into components delimited by
+-- separators, where the predicate returns True for a separator element.
+-- The resulting components do not contain the separators.  Two adjacent
+-- separators result in an empty component in the output.  eg.
+--
+-- > splitWith (=='a') "aabbaca" == ["","","bb","c",""]
+--
+splitWith :: (Char -> Bool) -> Buffer -> [Buffer]
+splitWith f = L.splitWith (f . w2c)
+{-# INLINE splitWith #-}
+
+-- | The 'groupBy' function is the non-overloaded version of 'group'.
+groupBy :: (Char -> Char -> Bool) -> Buffer -> [Buffer]
+groupBy k = L.groupBy (\a b -> k (w2c a) (w2c b))
+
+-- | /O(1)/ 'Buffer' index (subscript) operator, starting from 0.
+index :: Buffer -> Int64 -> Char
+index = (w2c .) . L.index
+{-# INLINE index #-}
+
+-- | /O(n)/ The 'elemIndex' function returns the index of the first
+-- element in the given 'Buffer' which is equal (by memchr) to the
+-- query element, or 'Nothing' if there is no such element.
+elemIndex :: Char -> Buffer -> Maybe Int64
+elemIndex = L.elemIndex . c2w
+{-# INLINE elemIndex #-}
+
+-- | /O(n)/ The 'elemIndices' function extends 'elemIndex', by returning
+-- the indices of all elements equal to the query element, in ascending order.
+elemIndices :: Char -> Buffer -> [Int64]
+elemIndices = L.elemIndices . c2w
+{-# INLINE elemIndices #-}
+
+-- | The 'findIndex' function takes a predicate and a 'Buffer' and
+-- returns the index of the first element in the Buffer satisfying the predicate.
+findIndex :: (Char -> Bool) -> Buffer -> Maybe Int64
+findIndex f = L.findIndex (f . w2c)
+{-# INLINE findIndex #-}
+
+-- | The 'findIndices' function extends 'findIndex', by returning the
+-- indices of all elements satisfying the predicate, in ascending order.
+findIndices :: (Char -> Bool) -> Buffer -> [Int64]
+findIndices f = L.findIndices (f . w2c)
+
+-- | count returns the number of times its argument appears in the Buffer
+--
+-- > count      == length . elemIndices
+-- > count '\n' == length . lines
+--
+-- But more efficiently than using length on the intermediate list.
+count :: Char -> Buffer -> Int64
+count c = L.count (c2w c)
+
+-- | /O(n)/ 'elem' is the 'Buffer' membership predicate. This
+-- implementation uses @memchr(3)@.
+elem :: Char -> Buffer -> Bool
+elem c = L.elem (c2w c)
+{-# INLINE elem #-}
+
+-- | /O(n)/ 'notElem' is the inverse of 'elem'
+notElem :: Char -> Buffer -> Bool
+notElem c = L.notElem (c2w c)
+{-# INLINE notElem #-}
+
+-- | /O(n)/ 'filter', applied to a predicate and a Buffer,
+-- returns a Buffer containing those characters that satisfy the
+-- predicate.
+filter :: (Char -> Bool) -> Buffer -> Buffer
+filter f = L.filter (f . w2c)
+{-# INLINE filter #-}
+
+{-
+-- | /O(n)/ and /O(n\/c) space/ A first order equivalent of /filter .
+-- (==)/, for the common case of filtering a single Char. It is more
+-- efficient to use /filterChar/ in this case.
+--
+-- > filterChar == filter . (==)
+--
+-- filterChar is around 10x faster, and uses much less space, than its
+-- filter equivalent
+--
+filterChar :: Char -> Buffer -> Buffer
+filterChar c ps = replicate (count c ps) c
+{-# INLINE filterChar #-}
+
+{-# RULES
+  "Buffer specialise filter (== x)" forall x.
+      filter ((==) x) = filterChar x
+  #-}
+
+{-# RULES
+  "Buffer specialise filter (== x)" forall x.
+     filter (== x) = filterChar x
+  #-}
+-}
+
+-- | /O(n)/ The 'find' function takes a predicate and a Buffer,
+-- and returns the first element in matching the predicate, or 'Nothing'
+-- if there is no such element.
+find :: (Char -> Bool) -> Buffer -> Maybe Char
+find f ps = w2c `fmap` L.find (f . w2c) ps
+{-# INLINE find #-}
+
+{-
+-- | /O(n)/ A first order equivalent of /filter . (==)/, for the common
+-- case of filtering a single Char. It is more efficient to use
+-- filterChar in this case.
+--
+-- > filterChar == filter . (==)
+--
+-- filterChar is around 10x faster, and uses much less space, than its
+-- filter equivalent
+--
+filterChar :: Char -> Buffer -> Buffer
+filterChar c = L.filterByte (c2w c)
+{-# INLINE filterChar #-}
+
+-- | /O(n)/ A first order equivalent of /filter . (\/=)/, for the common
+-- case of filtering a single Char out of a list. It is more efficient
+-- to use /filterNotChar/ in this case.
+--
+-- > filterNotChar == filter . (/=)
+--
+-- filterNotChar is around 3x faster, and uses much less space, than its
+-- filter equivalent
+--
+filterNotChar :: Char -> Buffer -> Buffer
+filterNotChar c = L.filterNotByte (c2w c)
+{-# INLINE filterNotChar #-}
+-}
+
+-- | /O(n)/ 'zip' takes two Buffers and returns a list of
+-- corresponding pairs of Chars. If one input Buffer is short,
+-- excess elements of the longer Buffer are discarded. This is
+-- equivalent to a pair of 'unpack' operations, and so space
+-- usage may be large for multi-megabyte Buffers
+zip :: Buffer -> Buffer -> [(Char,Char)]
+zip ps qs
+    | L.null ps || L.null qs = []
+    | otherwise = (head ps, head qs) : zip (L.tail ps) (L.tail qs)
+
+-- | 'zipWith' generalises 'zip' by zipping with the function given as
+-- the first argument, instead of a tupling function.  For example,
+-- @'zipWith' (+)@ is applied to two Buffers to produce the list
+-- of corresponding sums.
+zipWith :: (Char -> Char -> a) -> Buffer -> Buffer -> [a]
+zipWith f = L.zipWith ((. w2c) . f . w2c)
+
+-- | 'lines' breaks a Buffer up into a list of Buffers at
+-- newline Chars. The resulting strings do not contain newlines.
+--
+-- As of bytestring 0.9.0.3, this function is stricter than its 
+-- list cousin.
+--
+lines :: Buffer -> [Buffer]
+lines Empty          = []
+lines (Chunk c0 cs0) = loop0 c0 cs0
+    where
+    -- this is a really performance sensitive function but the
+    -- chunked representation makes the general case a bit expensive
+    -- however assuming a large chunk size and normalish line lengths
+    -- we will find line endings much more frequently than chunk
+    -- endings so it makes sense to optimise for that common case.
+    -- So we partition into two special cases depending on whether we
+    -- are keeping back a list of chunks that will eventually be output
+    -- once we get to the end of the current line.
+
+    -- the common special case where we have no existing chunks of
+    -- the current line
+    loop0 :: S.Buffer -> Buffer -> [Buffer]
+    loop0 c cs =
+        case B.elemIndex (c2w '\n') c of
+            Nothing -> case cs of
+                           Empty  | B.null c  ->                 []
+                                  | otherwise -> Chunk c Empty : []
+                           (Chunk c' cs')
+                               | B.null c  -> loop0 c'     cs'
+                               | otherwise -> loop  c' [c] cs'
+
+            Just n | n /= 0    -> Chunk (B.unsafeTake n c) Empty
+                                : loop0 (B.unsafeDrop (n+1) c) cs
+                   | otherwise -> Empty
+                                : loop0 (B.unsafeTail c) cs
+
+    -- the general case when we are building a list of chunks that are
+    -- part of the same line
+    loop :: S.Buffer -> [S.Buffer] -> Buffer -> [Buffer]
+    loop c line cs =
+        case B.elemIndex (c2w '\n') c of
+            Nothing ->
+                case cs of
+                    Empty -> let c' = revChunks (c : line)
+                              in c' `seq` (c' : [])
+
+                    (Chunk c' cs') -> loop c' (c : line) cs'
+
+            Just n ->
+                let c' = revChunks (B.unsafeTake n c : line)
+                 in c' `seq` (c' : loop0 (B.unsafeDrop (n+1) c) cs)
+
+{-
+
+This function is too strict!  Consider,
+
+> prop_lazy =
+    (L.unpack . head . lazylines $ L.append (L.pack "a\nb\n") (error "failed"))
+  ==
+    "a"
+
+fails.  Here's a properly lazy version of 'lines' for lazy bytestrings
+
+    lazylines           :: L.Buffer -> [L.Buffer]
+    lazylines s
+        | L.null s  = []
+        | otherwise =
+            let (l,s') = L.break ((==) '\n') s
+            in l : if L.null s' then []
+                                else lazylines (L.tail s')
+
+we need a similarly lazy, but efficient version.
+
+-}
+
+
+-- | 'unlines' is an inverse operation to 'lines'.  It joins lines,
+-- after appending a terminating newline to each.
+unlines :: [Buffer] -> Buffer
+unlines [] = empty
+unlines ss = (concat $ List.intersperse nl ss) `append` nl -- half as much space
+    where nl = singleton '\n'
+
+-- | 'words' breaks a Buffer up into a list of words, which
+-- were delimited by Chars representing white space. And
+--
+-- > tokens isSpace = words
+--
+words :: Buffer -> [Buffer]
+words = List.filter (not . L.null) . L.splitWith isSpaceWord8
+{-# INLINE words #-}
+
+-- | The 'unwords' function is analogous to the 'unlines' function, on words.
+unwords :: [Buffer] -> Buffer
+unwords = intercalate (singleton ' ')
+{-# INLINE unwords #-}
+
+-- | readInt reads an Int from the beginning of the Buffer.  If
+-- there is no integer at the beginning of the string, it returns
+-- Nothing, otherwise it just returns the int read, and the rest of the
+-- string.
+
+{-
+-- Faster:
+
+data MaybeS = NothingS
+            | JustS {-# UNPACK #-} !Int {-# UNPACK #-} !Buffer
+-}
+
+readInt :: Buffer -> Maybe (Int, Buffer)
+{-# INLINE readInt #-}
+readInt Empty        = Nothing
+readInt (Chunk x xs) = case w2c (B.unsafeHead x) of
+    '-' -> loop True  0 0 (B.unsafeTail x) xs
+    '+' -> loop False 0 0 (B.unsafeTail x) xs
+    _   -> loop False 0 0 x xs
+
+    where loop :: Bool -> Int -> Int
+                -> S.Buffer -> Buffer -> Maybe (Int, Buffer)
+          STRICT5_(loop)
+          loop neg i n c cs
+              | B.null c = case cs of
+                             Empty          -> end  neg i n c  cs
+                             (Chunk c' cs') -> loop neg i n c' cs'
+              | otherwise =
+                  case B.unsafeHead c of
+                    w | w >= 0x30
+                     && w <= 0x39 -> loop neg (i+1)
+                                          (n * 10 + (fromIntegral w - 0x30))
+                                          (B.unsafeTail c) cs
+                      | otherwise -> end neg i n c cs
+
+          {-# INLINE end #-}
+          end _   0 _ _  _ = Nothing
+          end neg _ n c cs = e `seq` e
+                where n' = if neg then negate n else n
+                      c' = chunk c cs
+                      e  = n' `seq` c' `seq` Just $! (n',c')
+         --                  in n' `seq` c' `seq` JustS n' c'
+
+
+-- | readInteger reads an Integer from the beginning of the Buffer.  If
+-- there is no integer at the beginning of the string, it returns Nothing,
+-- otherwise it just returns the int read, and the rest of the string.
+readInteger :: Buffer -> Maybe (Integer, Buffer)
+readInteger Empty = Nothing
+readInteger (Chunk c0 cs0) =
+        case w2c (B.unsafeHead c0) of
+            '-' -> first (B.unsafeTail c0) cs0 >>= \(n, cs') -> return (-n, cs')
+            '+' -> first (B.unsafeTail c0) cs0
+            _   -> first c0 cs0
+
+    where first c cs
+              | B.null c = case cs of
+                  Empty          -> Nothing
+                  (Chunk c' cs') -> first' c' cs'
+              | otherwise = first' c cs
+
+          first' c cs = case B.unsafeHead c of
+              w | w >= 0x30 && w <= 0x39 -> Just $
+                  loop 1 (fromIntegral w - 0x30) [] (B.unsafeTail c) cs
+                | otherwise              -> Nothing
+
+          loop :: Int -> Int -> [Integer]
+               -> S.Buffer -> Buffer -> (Integer, Buffer)
+          STRICT5_(loop)
+          loop d acc ns c cs
+              | B.null c = case cs of
+                             Empty          -> combine d acc ns c cs
+                             (Chunk c' cs') -> loop d acc ns c' cs'
+              | otherwise =
+                  case B.unsafeHead c of
+                   w | w >= 0x30 && w <= 0x39 ->
+                       if d < 9 then loop (d+1)
+                                          (10*acc + (fromIntegral w - 0x30))
+                                          ns (B.unsafeTail c) cs
+                                else loop 1 (fromIntegral w - 0x30)
+                                          (fromIntegral acc : ns)
+                                          (B.unsafeTail c) cs
+                     | otherwise -> combine d acc ns c cs
+
+          combine _ acc [] c cs = end (fromIntegral acc) c cs
+          combine d acc ns c cs =
+              end (10^d * combine1 1000000000 ns + fromIntegral acc) c cs
+
+          combine1 _ [n] = n
+          combine1 b ns  = combine1 (b*b) $ combine2 b ns
+
+          combine2 b (n:m:ns) = let t = n+m*b in t `seq` (t : combine2 b ns)
+          combine2 _ ns       = ns
+
+          end n c cs = let c' = chunk c cs
+                        in c' `seq` (n, c')
+
+-- | Read an entire file /lazily/ into a 'Buffer'. Use 'text mode'
+-- on Windows to interpret newlines
+readFile :: FilePath -> IO Buffer
+readFile f = openFile f ReadMode >>= hGetContents
+
+-- | Write a 'Buffer' to a file.
+writeFile :: FilePath -> Buffer -> IO ()
+writeFile f txt = bracket (openFile f WriteMode) hClose
+    (\hdl -> hPut hdl txt)
+
+-- | Append a 'Buffer' to a file.
+appendFile :: FilePath -> Buffer -> IO ()
+appendFile f txt = bracket (openFile f AppendMode) hClose
+    (\hdl -> hPut hdl txt)
+
+
+-- ---------------------------------------------------------------------
+-- Internal utilities
+
+-- reverse a list of possibly-empty chunks into a lazy Buffer
+revChunks :: [S.Buffer] -> Buffer
+revChunks cs = List.foldl' (flip chunk) Empty cs
addfile ./Data/Buffer/Lazy/Internal.hs
hunk ./Data/Buffer/Lazy/Internal.hs 1
+{-# LANGUAGE CPP, ForeignFunctionInterface #-}
+-- We cannot actually specify all the language pragmas, see ghc ticket #
+-- If we could, these are what they would be:
+{- LANGUAGE DeriveDataTypeable -}
+{-# OPTIONS_HADDOCK hide #-}
+
+-- |
+-- Module      : Data.Buffer.Lazy.Internal
+-- License     : BSD-style
+-- Maintainer  : dons@galois.com, duncan@haskell.org
+-- Stability   : experimental
+-- Portability : portable
+-- 
+-- A module containing semi-public 'Buffer' internals. This exposes
+-- the 'Buffer' representation and low level construction functions.
+-- Modules which extend the 'Buffer' system will need to use this module
+-- while ideally most users will be able to make do with the public interface
+-- modules.
+--
+module Data.Buffer.Lazy.Internal (
+
+        -- * The lazy @Buffer@ type and representation
+        Buffer(..),     -- instances: Eq, Ord, Show, Read, Data, Typeable
+        chunk,
+        foldrChunks,
+        foldlChunks,
+
+        -- * Data type invariant and abstraction function
+        invariant,
+        checkInvariant,
+
+        -- * Chunk allocation sizes
+        defaultChunkSize,
+        smallChunkSize,
+        chunkOverhead
+
+  ) where
+
+import qualified Data.Buffer.Internal as S
+
+import Foreign.Storable (Storable(sizeOf))
+
+#if defined(__GLASGOW_HASKELL__)
+import Data.Typeable    (Typeable)
+#if __GLASGOW_HASKELL__ >= 610
+import Data.Data        (Data)
+#else
+import Data.Generics    (Data)
+#endif
+#endif
+
+-- | A space-efficient representation of a Word8 vector, supporting many
+-- efficient operations.  A 'Buffer' contains 8-bit characters only.
+--
+-- Instances of Eq, Ord, Read, Show, Data, Typeable
+--
+data Buffer = Empty | Chunk {-# UNPACK #-} !S.Buffer Buffer
+    deriving (Show, Read
+#if defined(__GLASGOW_HASKELL__)
+                        ,Data, Typeable
+#endif
+             )
+
+------------------------------------------------------------------------
+
+-- | The data type invariant:
+-- Every Buffer is either 'Empty' or consists of non-null 'S.Buffer's.
+-- All functions must preserve this, and the QC properties must check this.
+--
+invariant :: Buffer -> Bool
+invariant Empty                     = True
+invariant (Chunk (S.PS _ _ len) cs) = len > 0 && invariant cs
+
+-- | In a form that checks the invariant lazily.
+checkInvariant :: Buffer -> Buffer
+checkInvariant Empty = Empty
+checkInvariant (Chunk c@(S.PS _ _ len) cs)
+    | len > 0   = Chunk c (checkInvariant cs)
+    | otherwise = error $ "Data.Buffer.Lazy: invariant violation:"
+               ++ show (Chunk c cs)
+
+------------------------------------------------------------------------
+
+-- | Smart constructor for 'Chunk'. Guarantees the data type invariant.
+chunk :: S.Buffer -> Buffer -> Buffer
+chunk c@(S.PS _ _ len) cs | len == 0  = cs
+                          | otherwise = Chunk c cs
+{-# INLINE chunk #-}
+
+-- | Consume the chunks of a lazy Buffer with a natural right fold.
+foldrChunks :: (S.Buffer -> a -> a) -> a -> Buffer -> a
+foldrChunks f z = go
+  where go Empty        = z
+        go (Chunk c cs) = f c (go cs)
+{-# INLINE foldrChunks #-}
+
+-- | Consume the chunks of a lazy Buffer with a strict, tail-recursive,
+-- accumulating left fold.
+foldlChunks :: (a -> S.Buffer -> a) -> a -> Buffer -> a
+foldlChunks f z = go z
+  where go a _ | a `seq` False = undefined
+        go a Empty        = a
+        go a (Chunk c cs) = go (f a c) cs
+{-# INLINE foldlChunks #-}
+
+------------------------------------------------------------------------
+
+-- The representation uses lists of packed chunks. When we have to convert from
+-- a lazy list to the chunked representation, then by default we use this
+-- chunk size. Some functions give you more control over the chunk size.
+--
+-- Measurements here:
+--  http://www.cse.unsw.edu.au/~dons/tmp/chunksize_v_cache.png
+--
+-- indicate that a value around 0.5 to 1 x your L2 cache is best.
+-- The following value assumes people have something greater than 128k,
+-- and need to share the cache with other programs.
+
+-- | Currently set to 32k, less the memory management overhead
+defaultChunkSize :: Int
+defaultChunkSize = 32 * k - chunkOverhead
+   where k = 1024
+
+-- | Currently set to 4k, less the memory management overhead
+smallChunkSize :: Int
+smallChunkSize = 4 * k - chunkOverhead
+   where k = 1024
+
+-- | The memory management overhead. Currently this is tuned for GHC only.
+chunkOverhead :: Int
+chunkOverhead = 2 * sizeOf (undefined :: Int)
addfile ./Data/Buffer/Lazy/Word8.hs
hunk ./Data/Buffer/Lazy/Word8.hs 1
+{-# LANGUAGE CPP #-}
+{-# OPTIONS_GHC -fno-warn-incomplete-patterns #-}
+{-# OPTIONS_HADDOCK prune #-}
+
+-- |
+-- Module      : Data.Buffer.Lazy.Word8
+-- Copyright   : (c) Don Stewart 2006
+--               (c) Duncan Coutts 2006
+--               (c) Edward Kmett 2010
+-- License     : BSD-style
+--
+-- Maintainer  : ekmett@gmail.com
+-- Stability   : experimental
+-- Portability : portable
+-- 
+-- A time and space-efficient implementation of lazy byte vectors
+-- using lists of packed 'Word8' arrays, suitable for high performance
+-- use, both in terms of large data quantities, or high speed
+-- requirements. Byte vectors are encoded as lazy lists of strict 'Word8'
+-- arrays of bytes. They provide a means to manipulate large byte vectors
+-- without requiring the entire vector be resident in memory.
+--
+-- Some operations, such as concat, append, reverse and cons, have
+-- better complexity than their "Data.Buffer" equivalents, due to
+-- optimisations resulting from the list spine structure. And for other
+-- operations lazy Buffers are usually within a few percent of
+-- strict ones, but with better heap usage. For data larger than the
+-- available memory, or if you have tight memory constraints, this
+-- module will be the only option. The default chunk size is 64k, which
+-- should be good in most circumstances. For people with large L2
+-- caches, you may want to increase this to fit your cache.
+--
+-- This module is intended to be imported @qualified@, to avoid name
+-- clashes with "Prelude" functions.  eg.
+--
+-- > import qualified Data.Buffer.Lazy as B
+--
+-- Original GHC implementation by Bryan O\'Sullivan.
+-- Rewritten to use 'Data.Array.Unboxed.UArray' by Simon Marlow.
+-- Rewritten to support slices and use 'Foreign.ForeignPtr.ForeignPtr'
+-- by David Roundy.
+-- Polished and extended by Don Stewart.
+-- Lazy variant by Duncan Coutts and Don Stewart.
+--
+
+module Data.Buffer.Lazy.Word8 (
+
+        -- * The @Buffer@ type
+        Buffer,             -- instances: Eq, Ord, Show, Read, Data, Typeable
+
+        -- * Introducing and eliminating 'Buffer's
+        empty,                  -- :: Buffer
+        singleton,              -- :: Word8   -> Buffer
+        pack,                   -- :: [Word8] -> Buffer
+        unpack,                 -- :: Buffer -> [Word8]
+        fromChunks,             -- :: [Strict.Buffer] -> Buffer
+        toChunks,               -- :: Buffer -> [Strict.Buffer]
+
+        -- * Basic interface
+        cons,                   -- :: Word8 -> Buffer -> Buffer
+        cons',                  -- :: Word8 -> Buffer -> Buffer
+        snoc,                   -- :: Buffer -> Word8 -> Buffer
+        append,                 -- :: Buffer -> Buffer -> Buffer
+        head,                   -- :: Buffer -> Word8
+        uncons,                 -- :: Buffer -> Maybe (Word8, Buffer)
+        last,                   -- :: Buffer -> Word8
+        tail,                   -- :: Buffer -> Buffer
+        init,                   -- :: Buffer -> Buffer
+        null,                   -- :: Buffer -> Bool
+        length,                 -- :: Buffer -> Int64
+
+        -- * Transforming Buffers
+        map,                    -- :: (Word8 -> Word8) -> Buffer -> Buffer
+        reverse,                -- :: Buffer -> Buffer
+        intersperse,            -- :: Word8 -> Buffer -> Buffer
+        intercalate,            -- :: Buffer -> [Buffer] -> Buffer
+        transpose,              -- :: [Buffer] -> [Buffer]
+
+        -- * Reducing 'Buffer's (folds)
+        foldl,                  -- :: (a -> Word8 -> a) -> a -> Buffer -> a
+        foldl',                 -- :: (a -> Word8 -> a) -> a -> Buffer -> a
+        foldl1,                 -- :: (Word8 -> Word8 -> Word8) -> Buffer -> Word8
+        foldl1',                -- :: (Word8 -> Word8 -> Word8) -> Buffer -> Word8
+        foldr,                  -- :: (Word8 -> a -> a) -> a -> Buffer -> a
+        foldr1,                 -- :: (Word8 -> Word8 -> Word8) -> Buffer -> Word8
+
+        -- ** Special folds
+        concat,                 -- :: [Buffer] -> Buffer
+        concatMap,              -- :: (Word8 -> Buffer) -> Buffer -> Buffer
+        any,                    -- :: (Word8 -> Bool) -> Buffer -> Bool
+        all,                    -- :: (Word8 -> Bool) -> Buffer -> Bool
+        maximum,                -- :: Buffer -> Word8
+        minimum,                -- :: Buffer -> Word8
+
+        -- * Building Buffers
+        -- ** Scans
+        scanl,                  -- :: (Word8 -> Word8 -> Word8) -> Word8 -> Buffer -> Buffer
+--        scanl1,                 -- :: (Word8 -> Word8 -> Word8) -> Buffer -> Buffer
+--        scanr,                  -- :: (Word8 -> Word8 -> Word8) -> Word8 -> Buffer -> Buffer
+--        scanr1,                 -- :: (Word8 -> Word8 -> Word8) -> Buffer -> Buffer
+
+        -- ** Accumulating maps
+        mapAccumL,              -- :: (acc -> Word8 -> (acc, Word8)) -> acc -> Buffer -> (acc, Buffer)
+        mapAccumR,              -- :: (acc -> Word8 -> (acc, Word8)) -> acc -> Buffer -> (acc, Buffer)
+
+        -- ** Infinite Buffers
+        repeat,                 -- :: Word8 -> Buffer
+        replicate,              -- :: Int64 -> Word8 -> Buffer
+        cycle,                  -- :: Buffer -> Buffer
+        iterate,                -- :: (Word8 -> Word8) -> Word8 -> Buffer
+
+        -- ** Unfolding Buffers
+        unfoldr,                -- :: (a -> Maybe (Word8, a)) -> a -> Buffer
+
+        -- * Substrings
+
+        -- ** Breaking strings
+        take,                   -- :: Int64 -> Buffer -> Buffer
+        drop,                   -- :: Int64 -> Buffer -> Buffer
+        splitAt,                -- :: Int64 -> Buffer -> (Buffer, Buffer)
+        takeWhile,              -- :: (Word8 -> Bool) -> Buffer -> Buffer
+        dropWhile,              -- :: (Word8 -> Bool) -> Buffer -> Buffer
+        span,                   -- :: (Word8 -> Bool) -> Buffer -> (Buffer, Buffer)
+        break,                  -- :: (Word8 -> Bool) -> Buffer -> (Buffer, Buffer)
+        group,                  -- :: Buffer -> [Buffer]
+        groupBy,                -- :: (Word8 -> Word8 -> Bool) -> Buffer -> [Buffer]
+        inits,                  -- :: Buffer -> [Buffer]
+        tails,                  -- :: Buffer -> [Buffer]
+
+        -- ** Breaking into many substrings
+        split,                  -- :: Word8 -> Buffer -> [Buffer]
+        splitWith,              -- :: (Word8 -> Bool) -> Buffer -> [Buffer]
+
+        -- * Predicates
+        isPrefixOf,             -- :: Buffer -> Buffer -> Bool
+        isSuffixOf,             -- :: Buffer -> Buffer -> Bool
+--        isInfixOf,              -- :: Buffer -> Buffer -> Bool
+
+        -- ** Search for arbitrary substrings
+--        isSubstringOf,          -- :: Buffer -> Buffer -> Bool
+--        findSubstring,          -- :: Buffer -> Buffer -> Maybe Int
+--        findSubstrings,         -- :: Buffer -> Buffer -> [Int]
+
+        -- * Searching Buffers
+
+        -- ** Searching by equality
+        elem,                   -- :: Word8 -> Buffer -> Bool
+        notElem,                -- :: Word8 -> Buffer -> Bool
+
+        -- ** Searching with a predicate
+        find,                   -- :: (Word8 -> Bool) -> Buffer -> Maybe Word8
+        filter,                 -- :: (Word8 -> Bool) -> Buffer -> Buffer
+        partition,              -- :: (Word8 -> Bool) -> Buffer -> (Buffer, Buffer)
+
+        -- * Indexing Buffers
+        index,                  -- :: Buffer -> Int64 -> Word8
+        elemIndex,              -- :: Word8 -> Buffer -> Maybe Int64
+        elemIndices,            -- :: Word8 -> Buffer -> [Int64]
+        findIndex,              -- :: (Word8 -> Bool) -> Buffer -> Maybe Int64
+        findIndices,            -- :: (Word8 -> Bool) -> Buffer -> [Int64]
+        count,                  -- :: Word8 -> Buffer -> Int64
+
+        -- * Zipping and unzipping Buffers
+        zip,                    -- :: Buffer -> Buffer -> [(Word8,Word8)]
+        zipWith,                -- :: (Word8 -> Word8 -> c) -> Buffer -> Buffer -> [c]
+        unzip,                  -- :: [(Word8,Word8)] -> (Buffer,Buffer)
+
+        -- * Ordered Buffers
+--        sort,                   -- :: Buffer -> Buffer
+
+        -- * Low level conversions
+        -- ** Copying Buffers
+        copy,                   -- :: Buffer -> Buffer
+--        defrag,                -- :: Buffer -> Buffer
+
+        -- * I\/O with 'Buffer's
+
+        -- ** Standard input and output
+        getContents,            -- :: IO Buffer
+        putStr,                 -- :: Buffer -> IO ()
+        putStrLn,               -- :: Buffer -> IO ()
+        interact,               -- :: (Buffer -> Buffer) -> IO ()
+
+        -- ** Files
+        readFile,               -- :: FilePath -> IO Buffer
+        writeFile,              -- :: FilePath -> Buffer -> IO ()
+        appendFile,             -- :: FilePath -> Buffer -> IO ()
+
+        -- ** I\/O with Handles
+        hGetContents,           -- :: Handle -> IO Buffer
+        hGet,                   -- :: Handle -> Int -> IO Buffer
+        hGetNonBlocking,        -- :: Handle -> Int -> IO Buffer
+        hPut,                   -- :: Handle -> Buffer -> IO ()
+        hPutStr,                -- :: Handle -> Buffer -> IO ()
+
+  ) where
+
+import Prelude hiding
+    (reverse,head,tail,last,init,null,length,map,lines,foldl,foldr,unlines
+    ,concat,any,take,drop,splitAt,takeWhile,dropWhile,span,break,elem,filter,maximum
+    ,minimum,all,concatMap,foldl1,foldr1,scanl, scanl1, scanr, scanr1
+    ,repeat, cycle, interact, iterate,readFile,writeFile,appendFile,replicate
+    ,getContents,getLine,putStr,putStrLn ,zip,zipWith,unzip,notElem)
+
+import qualified Data.List as L  -- L for list/lazy
+import qualified Data.Buffer.Word8 as P  (Buffer) -- type name only
+import qualified Data.Buffer.Word8 as S  -- S for strict (hmm...)
+import qualified Data.Buffer.Internal as S
+import qualified Data.Buffer.Unsafe as S
+import Data.Buffer.Lazy.Internal
+
+import Data.Monoid              (Monoid(..))
+
+import Data.Word                (Word8)
+import Data.Int                 (Int64)
+import System.IO                (Handle,stdin,stdout,openBinaryFile,IOMode(..)
+                                ,hClose,hWaitForInput,hIsEOF)
+import System.IO.Error          (mkIOError, illegalOperationErrorType)
+import System.IO.Unsafe
+#ifndef __NHC__
+import Control.Exception        (bracket)
+#else
+import IO		        (bracket)
+#endif
+
+import Foreign.ForeignPtr       (withForeignPtr)
+import Foreign.Ptr
+import Foreign.Storable
+
+-- -----------------------------------------------------------------------------
+--
+-- Useful macros, until we have bang patterns
+--
+
+#define STRICT1(f) f a | a `seq` False = undefined
+#define STRICT2(f) f a b | a `seq` b `seq` False = undefined
+#define STRICT3(f) f a b c | a `seq` b `seq` c `seq` False = undefined
+#define STRICT4(f) f a b c d | a `seq` b `seq` c `seq` d `seq` False = undefined
+#define STRICT5(f) f a b c d e | a `seq` b `seq` c `seq` d `seq` e `seq` False = undefined
+
+-- -----------------------------------------------------------------------------
+
+instance Eq  Buffer
+    where (==)    = eq
+
+instance Ord Buffer
+    where compare = cmp
+
+instance Monoid Buffer where
+    mempty  = empty
+    mappend = append
+    mconcat = concat
+
+eq :: Buffer -> Buffer -> Bool
+eq Empty Empty = True
+eq Empty _     = False
+eq _     Empty = False
+eq (Chunk a as) (Chunk b bs) =
+  case compare (S.length a) (S.length b) of
+    LT -> a == (S.take (S.length a) b) && eq as (Chunk (S.drop (S.length a) b) bs)
+    EQ -> a == b                       && eq as bs
+    GT -> (S.take (S.length b) a) == b && eq (Chunk (S.drop (S.length b) a) as) bs
+
+cmp :: Buffer -> Buffer -> Ordering
+cmp Empty Empty = EQ
+cmp Empty _     = LT
+cmp _     Empty = GT
+cmp (Chunk a as) (Chunk b bs) =
+  case compare (S.length a) (S.length b) of
+    LT -> case compare a (S.take (S.length a) b) of
+            EQ     -> cmp as (Chunk (S.drop (S.length a) b) bs)
+            result -> result
+    EQ -> case compare a b of
+            EQ     -> cmp as bs
+            result -> result
+    GT -> case compare (S.take (S.length b) a) b of
+            EQ     -> cmp (Chunk (S.drop (S.length b) a) as) bs
+            result -> result
+
+-- -----------------------------------------------------------------------------
+-- Introducing and eliminating 'Buffer's
+
+-- | /O(1)/ The empty 'Buffer'
+empty :: Buffer
+empty = Empty
+{-# INLINE empty #-}
+
+-- | /O(1)/ Convert a 'Word8' into a 'Buffer'
+singleton :: Word8 -> Buffer
+singleton w = Chunk (S.singleton w) Empty
+{-# INLINE singleton #-}
+
+-- | /O(n)/ Convert a '[Word8]' into a 'Buffer'. 
+pack :: [Word8] -> Buffer
+pack ws = L.foldr (Chunk . S.pack) Empty (chunks defaultChunkSize ws)
+  where
+    chunks :: Int -> [a] -> [[a]]
+    chunks _    [] = []
+    chunks size xs = case L.splitAt size xs of
+                      (xs', xs'') -> xs' : chunks size xs''
+
+-- | /O(n)/ Converts a 'Buffer' to a '[Word8]'.
+unpack :: Buffer -> [Word8]
+unpack cs = L.concatMap S.unpack (toChunks cs)
+--TODO: we can do better here by integrating the concat with the unpack
+
+-- | /O(c)/ Convert a list of strict 'Buffer' into a lazy 'Buffer'
+fromChunks :: [P.Buffer] -> Buffer
+fromChunks cs = L.foldr chunk Empty cs
+
+-- | /O(n)/ Convert a lazy 'Buffer' into a list of strict 'Buffer'
+toChunks :: Buffer -> [P.Buffer]
+toChunks cs = foldrChunks (:) [] cs
+
+------------------------------------------------------------------------
+
+{-
+-- | /O(n)/ Convert a '[a]' into a 'Buffer' using some
+-- conversion function
+packWith :: (a -> Word8) -> [a] -> Buffer
+packWith k str = LPS $ L.map (P.packWith k) (chunk defaultChunkSize str)
+{-# INLINE packWith #-}
+{-# SPECIALIZE packWith :: (Char -> Word8) -> [Char] -> Buffer #-}
+
+-- | /O(n)/ Converts a 'Buffer' to a '[a]', using a conversion function.
+unpackWith :: (Word8 -> a) -> Buffer -> [a]
+unpackWith k (LPS ss) = L.concatMap (S.unpackWith k) ss
+{-# INLINE unpackWith #-}
+{-# SPECIALIZE unpackWith :: (Word8 -> Char) -> Buffer -> [Char] #-}
+-}
+
+-- ---------------------------------------------------------------------
+-- Basic interface
+
+-- | /O(1)/ Test whether a Buffer is empty.
+null :: Buffer -> Bool
+null Empty = True
+null _     = False
+{-# INLINE null #-}
+
+-- | /O(n\/c)/ 'length' returns the length of a Buffer as an 'Int64'
+length :: Buffer -> Int64
+length cs = foldlChunks (\n c -> n + fromIntegral (S.length c)) 0 cs
+{-# INLINE length #-}
+
+-- | /O(1)/ 'cons' is analogous to '(:)' for lists.
+--
+cons :: Word8 -> Buffer -> Buffer
+cons c cs = Chunk (S.singleton c) cs
+{-# INLINE cons #-}
+
+-- | /O(1)/ Unlike 'cons', 'cons\'' is
+-- strict in the Buffer that we are consing onto. More precisely, it forces
+-- the head and the first chunk. It does this because, for space efficiency, it
+-- may coalesce the new byte onto the first \'chunk\' rather than starting a
+-- new \'chunk\'.
+--
+-- So that means you can't use a lazy recursive contruction like this:
+--
+-- > let xs = cons\' c xs in xs
+--
+-- You can however use 'cons', as well as 'repeat' and 'cycle', to build
+-- infinite lazy Buffers.
+--
+cons' :: Word8 -> Buffer -> Buffer
+cons' w (Chunk c cs) | S.length c < 16 = Chunk (S.cons w c) cs
+cons' w cs                             = Chunk (S.singleton w) cs
+{-# INLINE cons' #-}
+
+-- | /O(n\/c)/ Append a byte to the end of a 'Buffer'
+snoc :: Buffer -> Word8 -> Buffer
+snoc cs w = foldrChunks Chunk (singleton w) cs
+{-# INLINE snoc #-}
+
+-- | /O(1)/ Extract the first element of a Buffer, which must be non-empty.
+head :: Buffer -> Word8
+head Empty       = errorEmptyList "head"
+head (Chunk c _) = S.unsafeHead c
+{-# INLINE head #-}
+
+-- | /O(1)/ Extract the head and tail of a Buffer, returning Nothing
+-- if it is empty.
+uncons :: Buffer -> Maybe (Word8, Buffer)
+uncons Empty = Nothing
+uncons (Chunk c cs)
+    = Just (S.unsafeHead c,
+            if S.length c == 1 then cs else Chunk (S.unsafeTail c) cs)
+{-# INLINE uncons #-}
+
+-- | /O(1)/ Extract the elements after the head of a Buffer, which must be
+-- non-empty.
+tail :: Buffer -> Buffer
+tail Empty          = errorEmptyList "tail"
+tail (Chunk c cs)
+  | S.length c == 1 = cs
+  | otherwise       = Chunk (S.unsafeTail c) cs
+{-# INLINE tail #-}
+
+-- | /O(n\/c)/ Extract the last element of a Buffer, which must be finite
+-- and non-empty.
+last :: Buffer -> Word8
+last Empty          = errorEmptyList "last"
+last (Chunk c0 cs0) = go c0 cs0
+  where go c Empty        = S.last c
+        go _ (Chunk c cs) = go c cs
+-- XXX Don't inline this. Something breaks with 6.8.2 (haven't investigated yet)
+
+-- | /O(n\/c)/ Return all the elements of a 'Buffer' except the last one.
+init :: Buffer -> Buffer
+init Empty          = errorEmptyList "init"
+init (Chunk c0 cs0) = go c0 cs0
+  where go c Empty | S.length c == 1 = Empty
+                   | otherwise       = Chunk (S.init c) Empty
+        go c (Chunk c' cs)           = Chunk c (go c' cs)
+
+-- | /O(n\/c)/ Append two Buffers
+append :: Buffer -> Buffer -> Buffer
+append xs ys = foldrChunks Chunk ys xs
+{-# INLINE append #-}
+
+-- ---------------------------------------------------------------------
+-- Transformations
+
+-- | /O(n)/ 'map' @f xs@ is the Buffer obtained by applying @f@ to each
+-- element of @xs@.
+map :: (Word8 -> Word8) -> Buffer -> Buffer
+map f s = go s
+    where
+        go Empty        = Empty
+        go (Chunk x xs) = Chunk y ys
+            where
+                y  = S.map f x
+                ys = go xs
+{-# INLINE map #-}
+
+-- | /O(n)/ 'reverse' @xs@ returns the elements of @xs@ in reverse order.
+reverse :: Buffer -> Buffer
+reverse cs0 = rev Empty cs0
+  where rev a Empty        = a
+        rev a (Chunk c cs) = rev (Chunk (S.reverse c) a) cs
+{-# INLINE reverse #-}
+
+-- | The 'intersperse' function takes a 'Word8' and a 'Buffer' and
+-- \`intersperses\' that byte between the elements of the 'Buffer'.
+-- It is analogous to the intersperse function on Lists.
+intersperse :: Word8 -> Buffer -> Buffer
+intersperse _ Empty        = Empty
+intersperse w (Chunk c cs) = Chunk (S.intersperse w c)
+                                   (foldrChunks (Chunk . intersperse') Empty cs)
+  where intersperse' :: P.Buffer -> P.Buffer
+        intersperse' (S.PS fp o l) =
+          S.unsafeCreate (2*l) $ \p' -> withForeignPtr fp $ \p -> do
+            poke p' w
+            S.c_intersperse (p' `plusPtr` 1) (p `plusPtr` o) (fromIntegral l) w
+
+-- | The 'transpose' function transposes the rows and columns of its
+-- 'Buffer' argument.
+transpose :: [Buffer] -> [Buffer]
+transpose css = L.map (\ss -> Chunk (S.pack ss) Empty)
+                      (L.transpose (L.map unpack css))
+--TODO: make this fast
+
+-- ---------------------------------------------------------------------
+-- Reducing 'Buffer's
+
+-- | 'foldl', applied to a binary operator, a starting value (typically
+-- the left-identity of the operator), and a Buffer, reduces the
+-- Buffer using the binary operator, from left to right.
+foldl :: (a -> Word8 -> a) -> a -> Buffer -> a
+foldl f z = go z
+  where go a Empty        = a
+        go a (Chunk c cs) = go (S.foldl f a c) cs
+{-# INLINE foldl #-}
+
+-- | 'foldl\'' is like 'foldl', but strict in the accumulator.
+foldl' :: (a -> Word8 -> a) -> a -> Buffer -> a
+foldl' f z = go z
+  where go a _ | a `seq` False = undefined
+        go a Empty        = a
+        go a (Chunk c cs) = go (S.foldl f a c) cs
+{-# INLINE foldl' #-}
+
+-- | 'foldr', applied to a binary operator, a starting value
+-- (typically the right-identity of the operator), and a Buffer,
+-- reduces the Buffer using the binary operator, from right to left.
+foldr :: (Word8 -> a -> a) -> a -> Buffer -> a
+foldr k z cs = foldrChunks (flip (S.foldr k)) z cs
+{-# INLINE foldr #-}
+
+-- | 'foldl1' is a variant of 'foldl' that has no starting value
+-- argument, and thus must be applied to non-empty 'Buffers'.
+-- This function is subject to array fusion.
+foldl1 :: (Word8 -> Word8 -> Word8) -> Buffer -> Word8
+foldl1 _ Empty        = errorEmptyList "foldl1"
+foldl1 f (Chunk c cs) = foldl f (S.unsafeHead c) (Chunk (S.unsafeTail c) cs)
+
+-- | 'foldl1\'' is like 'foldl1', but strict in the accumulator.
+foldl1' :: (Word8 -> Word8 -> Word8) -> Buffer -> Word8
+foldl1' _ Empty        = errorEmptyList "foldl1'"
+foldl1' f (Chunk c cs) = foldl' f (S.unsafeHead c) (Chunk (S.unsafeTail c) cs)
+
+-- | 'foldr1' is a variant of 'foldr' that has no starting value argument,
+-- and thus must be applied to non-empty 'Buffer's
+foldr1 :: (Word8 -> Word8 -> Word8) -> Buffer -> Word8
+foldr1 _ Empty          = errorEmptyList "foldr1"
+foldr1 f (Chunk c0 cs0) = go c0 cs0
+  where go c Empty         = S.foldr1 f c
+        go c (Chunk c' cs) = S.foldr  f (go c' cs) c
+
+-- ---------------------------------------------------------------------
+-- Special folds
+
+-- | /O(n)/ Concatenate a list of Buffers.
+concat :: [Buffer] -> Buffer
+concat css0 = to css0
+  where
+    go Empty        css = to css
+    go (Chunk c cs) css = Chunk c (go cs css)
+    to []               = Empty
+    to (cs:css)         = go cs css
+
+-- | Map a function over a 'Buffer' and concatenate the results
+concatMap :: (Word8 -> Buffer) -> Buffer -> Buffer
+concatMap _ Empty        = Empty
+concatMap f (Chunk c0 cs0) = to c0 cs0
+  where
+    go :: Buffer -> P.Buffer -> Buffer -> Buffer
+    go Empty        c' cs' = to c' cs'
+    go (Chunk c cs) c' cs' = Chunk c (go cs c' cs')
+
+    to :: P.Buffer -> Buffer -> Buffer
+    to c cs | S.null c  = case cs of
+        Empty          -> Empty
+        (Chunk c' cs') -> to c' cs'
+            | otherwise = go (f (S.unsafeHead c)) (S.unsafeTail c) cs
+
+-- | /O(n)/ Applied to a predicate and a Buffer, 'any' determines if
+-- any element of the 'Buffer' satisfies the predicate.
+any :: (Word8 -> Bool) -> Buffer -> Bool
+any f cs = foldrChunks (\c rest -> S.any f c || rest) False cs
+{-# INLINE any #-}
+-- todo fuse
+
+-- | /O(n)/ Applied to a predicate and a 'Buffer', 'all' determines
+-- if all elements of the 'Buffer' satisfy the predicate.
+all :: (Word8 -> Bool) -> Buffer -> Bool
+all f cs = foldrChunks (\c rest -> S.all f c && rest) True cs
+{-# INLINE all #-}
+-- todo fuse
+
+-- | /O(n)/ 'maximum' returns the maximum value from a 'Buffer'
+maximum :: Buffer -> Word8
+maximum Empty        = errorEmptyList "maximum"
+maximum (Chunk c cs) = foldlChunks (\n c' -> n `max` S.maximum c')
+                                   (S.maximum c) cs
+{-# INLINE maximum #-}
+
+-- | /O(n)/ 'minimum' returns the minimum value from a 'Buffer'
+minimum :: Buffer -> Word8
+minimum Empty        = errorEmptyList "minimum"
+minimum (Chunk c cs) = foldlChunks (\n c' -> n `min` S.minimum c')
+                                     (S.minimum c) cs
+{-# INLINE minimum #-}
+
+-- | The 'mapAccumL' function behaves like a combination of 'map' and
+-- 'foldl'; it applies a function to each element of a Buffer,
+-- passing an accumulating parameter from left to right, and returning a
+-- final value of this accumulator together with the new Buffer.
+mapAccumL :: (acc -> Word8 -> (acc, Word8)) -> acc -> Buffer -> (acc, Buffer)
+mapAccumL f s0 cs0 = go s0 cs0
+  where
+    go s Empty        = (s, Empty)
+    go s (Chunk c cs) = (s'', Chunk c' cs')
+        where (s',  c')  = S.mapAccumL f s c
+              (s'', cs') = go s' cs
+
+-- | The 'mapAccumR' function behaves like a combination of 'map' and
+-- 'foldr'; it applies a function to each element of a Buffer,
+-- passing an accumulating parameter from right to left, and returning a
+-- final value of this accumulator together with the new Buffer.
+mapAccumR :: (acc -> Word8 -> (acc, Word8)) -> acc -> Buffer -> (acc, Buffer)
+mapAccumR f s0 cs0 = go s0 cs0
+  where
+    go s Empty        = (s, Empty)
+    go s (Chunk c cs) = (s'', Chunk c' cs')
+        where (s'', c') = S.mapAccumR f s' c
+              (s', cs') = go s cs
+
+-- ---------------------------------------------------------------------
+-- Building Buffers
+
+-- | 'scanl' is similar to 'foldl', but returns a list of successive
+-- reduced values from the left. This function will fuse.
+--
+-- > scanl f z [x1, x2, ...] == [z, z `f` x1, (z `f` x1) `f` x2, ...]
+--
+-- Note that
+--
+-- > last (scanl f z xs) == foldl f z xs.
+scanl :: (Word8 -> Word8 -> Word8) -> Word8 -> Buffer -> Buffer
+scanl f z = snd . foldl k (z,singleton z)
+ where
+    k (c,acc) a = let n = f c a in (n, acc `snoc` n)
+{-# INLINE scanl #-}
+
+-- ---------------------------------------------------------------------
+-- Unfolds and replicates
+
+-- | @'iterate' f x@ returns an infinite Buffer of repeated applications
+-- of @f@ to @x@:
+--
+-- > iterate f x == [x, f x, f (f x), ...]
+--
+iterate :: (Word8 -> Word8) -> Word8 -> Buffer
+iterate f = unfoldr (\x -> case f x of x' -> x' `seq` Just (x', x'))
+
+-- | @'repeat' x@ is an infinite Buffer, with @x@ the value of every
+-- element.
+--
+repeat :: Word8 -> Buffer
+repeat w = cs where cs = Chunk (S.replicate smallChunkSize w) cs
+
+-- | /O(n)/ @'replicate' n x@ is a Buffer of length @n@ with @x@
+-- the value of every element.
+--
+replicate :: Int64 -> Word8 -> Buffer
+replicate n w
+    | n <= 0             = Empty
+    | n < fromIntegral smallChunkSize = Chunk (S.replicate (fromIntegral n) w) Empty
+    | r == 0             = cs -- preserve invariant
+    | otherwise          = Chunk (S.unsafeTake (fromIntegral r) c) cs
+ where
+    c      = S.replicate smallChunkSize w
+    cs     = nChunks q
+    (q, r) = quotRem n (fromIntegral smallChunkSize)
+    nChunks 0 = Empty
+    nChunks m = Chunk c (nChunks (m-1))
+
+-- | 'cycle' ties a finite Buffer into a circular one, or equivalently,
+-- the infinite repetition of the original Buffer.
+--
+cycle :: Buffer -> Buffer
+cycle Empty = errorEmptyList "cycle"
+cycle cs    = cs' where cs' = foldrChunks Chunk cs' cs
+
+-- | /O(n)/ The 'unfoldr' function is analogous to the List \'unfoldr\'.
+-- 'unfoldr' builds a Buffer from a seed value.  The function takes
+-- the element and returns 'Nothing' if it is done producing the
+-- Buffer or returns 'Just' @(a,b)@, in which case, @a@ is a
+-- prepending to the Buffer and @b@ is used as the next element in a
+-- recursive call.
+unfoldr :: (a -> Maybe (Word8, a)) -> a -> Buffer
+unfoldr f s0 = unfoldChunk 32 s0
+  where unfoldChunk n s =
+          case S.unfoldrN n f s of
+            (c, Nothing)
+              | S.null c  -> Empty
+              | otherwise -> Chunk c Empty
+            (c, Just s')  -> Chunk c (unfoldChunk (n*2) s')
+
+-- ---------------------------------------------------------------------
+-- Substrings
+
+-- | /O(n\/c)/ 'take' @n@, applied to a Buffer @xs@, returns the prefix
+-- of @xs@ of length @n@, or @xs@ itself if @n > 'length' xs@.
+take :: Int64 -> Buffer -> Buffer
+take i _ | i <= 0 = Empty
+take i cs0         = take' i cs0
+  where take' 0 _            = Empty
+        take' _ Empty        = Empty
+        take' n (Chunk c cs) =
+          if n < fromIntegral (S.length c)
+            then Chunk (S.take (fromIntegral n) c) Empty
+            else Chunk c (take' (n - fromIntegral (S.length c)) cs)
+
+-- | /O(n\/c)/ 'drop' @n xs@ returns the suffix of @xs@ after the first @n@
+-- elements, or @[]@ if @n > 'length' xs@.
+drop  :: Int64 -> Buffer -> Buffer
+drop i p | i <= 0 = p
+drop i cs0 = drop' i cs0
+  where drop' 0 cs           = cs
+        drop' _ Empty        = Empty
+        drop' n (Chunk c cs) =
+          if n < fromIntegral (S.length c)
+            then Chunk (S.drop (fromIntegral n) c) cs
+            else drop' (n - fromIntegral (S.length c)) cs
+
+-- | /O(n\/c)/ 'splitAt' @n xs@ is equivalent to @('take' n xs, 'drop' n xs)@.
+splitAt :: Int64 -> Buffer -> (Buffer, Buffer)
+splitAt i cs0 | i <= 0 = (Empty, cs0)
+splitAt i cs0 = splitAt' i cs0
+  where splitAt' 0 cs           = (Empty, cs)
+        splitAt' _ Empty        = (Empty, Empty)
+        splitAt' n (Chunk c cs) =
+          if n < fromIntegral (S.length c)
+            then (Chunk (S.take (fromIntegral n) c) Empty 
+                 ,Chunk (S.drop (fromIntegral n) c) cs)
+            else let (cs', cs'') = splitAt' (n - fromIntegral (S.length c)) cs
+                   in (Chunk c cs', cs'')
+
+
+-- | 'takeWhile', applied to a predicate @p@ and a Buffer @xs@,
+-- returns the longest prefix (possibly empty) of @xs@ of elements that
+-- satisfy @p@.
+takeWhile :: (Word8 -> Bool) -> Buffer -> Buffer
+takeWhile f cs0 = takeWhile' cs0
+  where takeWhile' Empty        = Empty
+        takeWhile' (Chunk c cs) =
+          case findIndexOrEnd (not . f) c of
+            0                  -> Empty
+            n | n < S.length c -> Chunk (S.take n c) Empty
+              | otherwise      -> Chunk c (takeWhile' cs)
+
+-- | 'dropWhile' @p xs@ returns the suffix remaining after 'takeWhile' @p xs@.
+dropWhile :: (Word8 -> Bool) -> Buffer -> Buffer
+dropWhile f cs0 = dropWhile' cs0
+  where dropWhile' Empty        = Empty
+        dropWhile' (Chunk c cs) =
+          case findIndexOrEnd (not . f) c of
+            n | n < S.length c -> Chunk (S.drop n c) cs
+              | otherwise      -> dropWhile' cs
+
+-- | 'break' @p@ is equivalent to @'span' ('not' . p)@.
+break :: (Word8 -> Bool) -> Buffer -> (Buffer, Buffer)
+break f cs0 = break' cs0
+  where break' Empty        = (Empty, Empty)
+        break' (Chunk c cs) =
+          case findIndexOrEnd f c of
+            0                  -> (Empty, Chunk c cs)
+            n | n < S.length c -> (Chunk (S.take n c) Empty
+                                  ,Chunk (S.drop n c) cs)
+              | otherwise      -> let (cs', cs'') = break' cs
+                                   in (Chunk c cs', cs'')
+
+--
+-- TODO
+--
+-- Add rules
+--
+
+{-
+-- | 'breakByte' breaks its Buffer argument at the first occurence
+-- of the specified byte. It is more efficient than 'break' as it is
+-- implemented with @memchr(3)@. I.e.
+-- 
+-- > break (=='c') "abcd" == breakByte 'c' "abcd"
+--
+breakByte :: Word8 -> Buffer -> (Buffer, Buffer)
+breakByte c (LPS ps) = case (breakByte' ps) of (a,b) -> (LPS a, LPS b)
+  where breakByte' []     = ([], [])
+        breakByte' (x:xs) =
+          case P.elemIndex c x of
+            Just 0  -> ([], x : xs)
+            Just n  -> (P.take n x : [], P.drop n x : xs)
+            Nothing -> let (xs', xs'') = breakByte' xs
+                        in (x : xs', xs'')
+
+-- | 'spanByte' breaks its Buffer argument at the first
+-- occurence of a byte other than its argument. It is more efficient
+-- than 'span (==)'
+--
+-- > span  (=='c') "abcd" == spanByte 'c' "abcd"
+--
+spanByte :: Word8 -> Buffer -> (Buffer, Buffer)
+spanByte c (LPS ps) = case (spanByte' ps) of (a,b) -> (LPS a, LPS b)
+  where spanByte' []     = ([], [])
+        spanByte' (x:xs) =
+          case P.spanByte c x of
+            (x', x'') | P.null x'  -> ([], x : xs)
+                      | P.null x'' -> let (xs', xs'') = spanByte' xs
+                                       in (x : xs', xs'')
+                      | otherwise  -> (x' : [], x'' : xs)
+-}
+
+-- | 'span' @p xs@ breaks the Buffer into two segments. It is
+-- equivalent to @('takeWhile' p xs, 'dropWhile' p xs)@
+span :: (Word8 -> Bool) -> Buffer -> (Buffer, Buffer)
+span p = break (not . p)
+
+-- | /O(n)/ Splits a 'Buffer' into components delimited by
+-- separators, where the predicate returns True for a separator element.
+-- The resulting components do not contain the separators.  Two adjacent
+-- separators result in an empty component in the output.  eg.
+--
+-- > splitWith (=='a') "aabbaca" == ["","","bb","c",""]
+-- > splitWith (=='a') []        == []
+--
+splitWith :: (Word8 -> Bool) -> Buffer -> [Buffer]
+splitWith _ Empty          = []
+splitWith p (Chunk c0 cs0) = comb [] (S.splitWith p c0) cs0
+
+  where comb :: [P.Buffer] -> [P.Buffer] -> Buffer -> [Buffer]
+        comb acc (s:[]) Empty        = revChunks (s:acc) : []
+        comb acc (s:[]) (Chunk c cs) = comb (s:acc) (S.splitWith p c) cs
+        comb acc (s:ss) cs           = revChunks (s:acc) : comb [] ss cs
+
+{-# INLINE splitWith #-}
+
+-- | /O(n)/ Break a 'Buffer' into pieces separated by the byte
+-- argument, consuming the delimiter. I.e.
+--
+-- > split '\n' "a\nb\nd\ne" == ["a","b","d","e"]
+-- > split 'a'  "aXaXaXa"    == ["","X","X","X",""]
+-- > split 'x'  "x"          == ["",""]
+-- 
+-- and
+--
+-- > intercalate [c] . split c == id
+-- > split == splitWith . (==)
+-- 
+-- As for all splitting functions in this library, this function does
+-- not copy the substrings, it just constructs new 'Buffers' that
+-- are slices of the original.
+--
+split :: Word8 -> Buffer -> [Buffer]
+split _ Empty     = []
+split w (Chunk c0 cs0) = comb [] (S.split w c0) cs0
+
+  where comb :: [P.Buffer] -> [P.Buffer] -> Buffer -> [Buffer]
+        comb acc (s:[]) Empty        = revChunks (s:acc) : []
+        comb acc (s:[]) (Chunk c cs) = comb (s:acc) (S.split w c) cs
+        comb acc (s:ss) cs           = revChunks (s:acc) : comb [] ss cs
+{-# INLINE split #-}
+
+{-
+-- | Like 'splitWith', except that sequences of adjacent separators are
+-- treated as a single separator. eg.
+-- 
+-- > tokens (=='a') "aabbaca" == ["bb","c"]
+--
+tokens :: (Word8 -> Bool) -> Buffer -> [Buffer]
+tokens f = L.filter (not.null) . splitWith f
+-}
+
+-- | The 'group' function takes a Buffer and returns a list of
+-- Buffers such that the concatenation of the result is equal to the
+-- argument.  Moreover, each sublist in the result contains only equal
+-- elements.  For example,
+--
+-- > group "Mississippi" = ["M","i","ss","i","ss","i","pp","i"]
+--
+-- It is a special case of 'groupBy', which allows the programmer to
+-- supply their own equality test.
+group :: Buffer -> [Buffer]
+group Empty          = []
+group (Chunk c0 cs0) = group' [] (S.group c0) cs0
+  where 
+    group' :: [P.Buffer] -> [P.Buffer] -> Buffer -> [Buffer]
+    group' acc@(s':_) ss@(s:_) cs
+      | S.unsafeHead s'
+     /= S.unsafeHead s             = revNonEmptyChunks    acc  : group' [] ss cs
+    group' acc (s:[]) Empty        = revNonEmptyChunks (s:acc) : []
+    group' acc (s:[]) (Chunk c cs) = group' (s:acc) (S.group c) cs
+    group' acc (s:ss) cs           = revNonEmptyChunks (s:acc) : group' [] ss cs
+
+{-
+TODO: check if something like this might be faster
+
+group :: Buffer -> [Buffer]
+group xs
+    | null xs   = []
+    | otherwise = ys : group zs
+    where
+        (ys, zs) = spanByte (unsafeHead xs) xs
+-}
+
+-- | The 'groupBy' function is the non-overloaded version of 'group'.
+--
+groupBy :: (Word8 -> Word8 -> Bool) -> Buffer -> [Buffer]
+groupBy _ Empty          = []
+groupBy k (Chunk c0 cs0) = groupBy' [] 0 (S.groupBy k c0) cs0
+  where
+    groupBy' :: [P.Buffer] -> Word8 -> [P.Buffer] -> Buffer -> [Buffer]
+    groupBy' acc@(_:_) c ss@(s:_) cs
+      | not (c `k` S.unsafeHead s)     = revNonEmptyChunks acc : groupBy' [] 0 ss cs
+    groupBy' acc _ (s:[]) Empty        = revNonEmptyChunks (s : acc) : []
+    groupBy' acc w (s:[]) (Chunk c cs) = groupBy' (s:acc) w' (S.groupBy k c) cs
+                                           where w' | L.null acc = S.unsafeHead s
+                                                    | otherwise  = w
+    groupBy' acc _ (s:ss) cs           = revNonEmptyChunks (s : acc) : groupBy' [] 0 ss cs
+
+{-
+TODO: check if something like this might be faster
+
+groupBy :: (Word8 -> Word8 -> Bool) -> Buffer -> [Buffer]
+groupBy k xs
+    | null xs   = []
+    | otherwise = take n xs : groupBy k (drop n xs)
+    where
+        n = 1 + findIndexOrEnd (not . k (head xs)) (tail xs)
+-}
+
+-- | /O(n)/ The 'intercalate' function takes a 'Buffer' and a list of
+-- 'Buffer's and concatenates the list after interspersing the first
+-- argument between each element of the list.
+intercalate :: Buffer -> [Buffer] -> Buffer
+intercalate s = concat . (L.intersperse s)
+
+-- ---------------------------------------------------------------------
+-- Indexing Buffers
+
+-- | /O(c)/ 'Buffer' index (subscript) operator, starting from 0.
+index :: Buffer -> Int64 -> Word8
+index _  i | i < 0  = moduleError "index" ("negative index: " ++ show i)
+index cs0 i         = index' cs0 i
+  where index' Empty     n = moduleError "index" ("index too large: " ++ show n)
+        index' (Chunk c cs) n
+          | n >= fromIntegral (S.length c) = 
+              index' cs (n - fromIntegral (S.length c))
+          | otherwise       = S.unsafeIndex c (fromIntegral n)
+
+-- | /O(n)/ The 'elemIndex' function returns the index of the first
+-- element in the given 'Buffer' which is equal to the query
+-- element, or 'Nothing' if there is no such element. 
+-- This implementation uses memchr(3).
+elemIndex :: Word8 -> Buffer -> Maybe Int64
+elemIndex w cs0 = elemIndex' 0 cs0
+  where elemIndex' _ Empty        = Nothing
+        elemIndex' n (Chunk c cs) =
+          case S.elemIndex w c of
+            Nothing -> elemIndex' (n + fromIntegral (S.length c)) cs
+            Just i  -> Just (n + fromIntegral i)
+
+{-
+-- | /O(n)/ The 'elemIndexEnd' function returns the last index of the
+-- element in the given 'Buffer' which is equal to the query
+-- element, or 'Nothing' if there is no such element. The following
+-- holds:
+--
+-- > elemIndexEnd c xs == 
+-- > (-) (length xs - 1) `fmap` elemIndex c (reverse xs)
+--
+elemIndexEnd :: Word8 -> Buffer -> Maybe Int
+elemIndexEnd ch (PS x s l) = inlinePerformIO $ withForeignPtr x $ \p ->
+    go (p `plusPtr` s) (l-1)
+  where
+    STRICT2(go)
+    go p i | i < 0     = return Nothing
+           | otherwise = do ch' <- peekByteOff p i
+                            if ch == ch'
+                                then return $ Just i
+                                else go p (i-1)
+-}
+-- | /O(n)/ The 'elemIndices' function extends 'elemIndex', by returning
+-- the indices of all elements equal to the query element, in ascending order.
+-- This implementation uses memchr(3).
+elemIndices :: Word8 -> Buffer -> [Int64]
+elemIndices w cs0 = elemIndices' 0 cs0
+  where elemIndices' _ Empty        = []
+        elemIndices' n (Chunk c cs) = L.map ((+n).fromIntegral) (S.elemIndices w c)
+                             ++ elemIndices' (n + fromIntegral (S.length c)) cs
+
+-- | count returns the number of times its argument appears in the Buffer
+--
+-- > count = length . elemIndices
+--
+-- But more efficiently than using length on the intermediate list.
+count :: Word8 -> Buffer -> Int64
+count w cs = foldlChunks (\n c -> n + fromIntegral (S.count w c)) 0 cs
+
+-- | The 'findIndex' function takes a predicate and a 'Buffer' and
+-- returns the index of the first element in the Buffer
+-- satisfying the predicate.
+findIndex :: (Word8 -> Bool) -> Buffer -> Maybe Int64
+findIndex k cs0 = findIndex' 0 cs0
+  where findIndex' _ Empty        = Nothing
+        findIndex' n (Chunk c cs) =
+          case S.findIndex k c of
+            Nothing -> findIndex' (n + fromIntegral (S.length c)) cs
+            Just i  -> Just (n + fromIntegral i)
+{-# INLINE findIndex #-}
+
+-- | /O(n)/ The 'find' function takes a predicate and a Buffer,
+-- and returns the first element in matching the predicate, or 'Nothing'
+-- if there is no such element.
+--
+-- > find f p = case findIndex f p of Just n -> Just (p ! n) ; _ -> Nothing
+--
+find :: (Word8 -> Bool) -> Buffer -> Maybe Word8
+find f cs0 = find' cs0
+  where find' Empty        = Nothing
+        find' (Chunk c cs) = case S.find f c of
+            Nothing -> find' cs
+            Just w  -> Just w
+{-# INLINE find #-}
+
+-- | The 'findIndices' function extends 'findIndex', by returning the
+-- indices of all elements satisfying the predicate, in ascending order.
+findIndices :: (Word8 -> Bool) -> Buffer -> [Int64]
+findIndices k cs0 = findIndices' 0 cs0
+  where findIndices' _ Empty        = []
+        findIndices' n (Chunk c cs) = L.map ((+n).fromIntegral) (S.findIndices k c)
+                             ++ findIndices' (n + fromIntegral (S.length c)) cs
+
+-- ---------------------------------------------------------------------
+-- Searching Buffers
+
+-- | /O(n)/ 'elem' is the 'Buffer' membership predicate.
+elem :: Word8 -> Buffer -> Bool
+elem w cs = case elemIndex w cs of Nothing -> False ; _ -> True
+
+-- | /O(n)/ 'notElem' is the inverse of 'elem'
+notElem :: Word8 -> Buffer -> Bool
+notElem w cs = not (elem w cs)
+
+-- | /O(n)/ 'filter', applied to a predicate and a Buffer,
+-- returns a Buffer containing those characters that satisfy the
+-- predicate.
+filter :: (Word8 -> Bool) -> Buffer -> Buffer
+filter p s = go s
+    where
+        go Empty        = Empty
+        go (Chunk x xs) = chunk (S.filter p x) (go xs)
+{-# INLINE filter #-}
+
+{-
+-- | /O(n)/ and /O(n\/c) space/ A first order equivalent of /filter .
+-- (==)/, for the common case of filtering a single byte. It is more
+-- efficient to use /filterByte/ in this case.
+--
+-- > filterByte == filter . (==)
+--
+-- filterByte is around 10x faster, and uses much less space, than its
+-- filter equivalent
+filterByte :: Word8 -> Buffer -> Buffer
+filterByte w ps = replicate (count w ps) w
+{-# INLINE filterByte #-}
+
+{-# RULES
+"Buffer specialise filter (== x)" forall x.
+  filter ((==) x) = filterByte x
+
+"Buffer specialise filter (== x)" forall x.
+ filter (== x) = filterByte x
+  #-}
+-}
+
+{-
+-- | /O(n)/ A first order equivalent of /filter . (\/=)/, for the common
+-- case of filtering a single byte out of a list. It is more efficient
+-- to use /filterNotByte/ in this case.
+--
+-- > filterNotByte == filter . (/=)
+--
+-- filterNotByte is around 2x faster than its filter equivalent.
+filterNotByte :: Word8 -> Buffer -> Buffer
+filterNotByte w (LPS xs) = LPS (filterMap (P.filterNotByte w) xs)
+-}
+
+-- | /O(n)/ The 'partition' function takes a predicate a Buffer and returns
+-- the pair of Buffers with elements which do and do not satisfy the
+-- predicate, respectively; i.e.,
+--
+-- > partition p bs == (filter p xs, filter (not . p) xs)
+--
+partition :: (Word8 -> Bool) -> Buffer -> (Buffer, Buffer)
+partition f p = (filter f p, filter (not . f) p)
+--TODO: use a better implementation
+
+-- ---------------------------------------------------------------------
+-- Searching for substrings
+
+-- | /O(n)/ The 'isPrefixOf' function takes two Buffers and returns 'True'
+-- iff the first is a prefix of the second.
+isPrefixOf :: Buffer -> Buffer -> Bool
+isPrefixOf Empty _  = True
+isPrefixOf _ Empty  = False
+isPrefixOf (Chunk x xs) (Chunk y ys)
+    | S.length x == S.length y = x == y  && isPrefixOf xs ys
+    | S.length x <  S.length y = x == yh && isPrefixOf xs (Chunk yt ys)
+    | otherwise                = xh == y && isPrefixOf (Chunk xt xs) ys
+  where (xh,xt) = S.splitAt (S.length y) x
+        (yh,yt) = S.splitAt (S.length x) y
+
+-- | /O(n)/ The 'isSuffixOf' function takes two Buffers and returns 'True'
+-- iff the first is a suffix of the second.
+-- 
+-- The following holds:
+--
+-- > isSuffixOf x y == reverse x `isPrefixOf` reverse y
+--
+isSuffixOf :: Buffer -> Buffer -> Bool
+isSuffixOf x y = reverse x `isPrefixOf` reverse y
+--TODO: a better implementation
+
+-- ---------------------------------------------------------------------
+-- Zipping
+
+-- | /O(n)/ 'zip' takes two Buffers and returns a list of
+-- corresponding pairs of bytes. If one input Buffer is short,
+-- excess elements of the longer Buffer are discarded. This is
+-- equivalent to a pair of 'unpack' operations.
+zip :: Buffer -> Buffer -> [(Word8,Word8)]
+zip = zipWith (,)
+
+-- | 'zipWith' generalises 'zip' by zipping with the function given as
+-- the first argument, instead of a tupling function.  For example,
+-- @'zipWith' (+)@ is applied to two Buffers to produce the list of
+-- corresponding sums.
+zipWith :: (Word8 -> Word8 -> a) -> Buffer -> Buffer -> [a]
+zipWith _ Empty     _  = []
+zipWith _ _      Empty = []
+zipWith f (Chunk a as) (Chunk b bs) = go a as b bs
+  where
+    go x xs y ys = f (S.unsafeHead x) (S.unsafeHead y)
+                 : to (S.unsafeTail x) xs (S.unsafeTail y) ys
+
+    to x Empty         _ _             | S.null x       = []
+    to _ _             y Empty         | S.null y       = []
+    to x xs            y ys            | not (S.null x)
+                                      && not (S.null y) = go x  xs y  ys
+    to x xs            _ (Chunk y' ys) | not (S.null x) = go x  xs y' ys
+    to _ (Chunk x' xs) y ys            | not (S.null y) = go x' xs y  ys
+    to _ (Chunk x' xs) _ (Chunk y' ys)                  = go x' xs y' ys
+
+-- | /O(n)/ 'unzip' transforms a list of pairs of bytes into a pair of
+-- Buffers. Note that this performs two 'pack' operations.
+unzip :: [(Word8,Word8)] -> (Buffer,Buffer)
+unzip ls = (pack (L.map fst ls), pack (L.map snd ls))
+{-# INLINE unzip #-}
+
+-- ---------------------------------------------------------------------
+-- Special lists
+
+-- | /O(n)/ Return all initial segments of the given 'Buffer', shortest first.
+inits :: Buffer -> [Buffer]
+inits = (Empty :) . inits'
+  where inits' Empty        = []
+        inits' (Chunk c cs) = L.map (\c' -> Chunk c' Empty) (L.tail (S.inits c))
+                           ++ L.map (Chunk c) (inits' cs)
+
+-- | /O(n)/ Return all final segments of the given 'Buffer', longest first.
+tails :: Buffer -> [Buffer]
+tails Empty         = Empty : []
+tails cs@(Chunk c cs')
+  | S.length c == 1 = cs : tails cs'
+  | otherwise       = cs : tails (Chunk (S.unsafeTail c) cs')
+
+-- ---------------------------------------------------------------------
+-- Low level constructors
+
+-- | /O(n)/ Make a copy of the 'Buffer' with its own storage.
+--   This is mainly useful to allow the rest of the data pointed
+--   to by the 'Buffer' to be garbage collected, for example
+--   if a large string has been read in, and only a small part of it
+--   is needed in the rest of the program.
+copy :: Buffer -> Buffer
+copy cs = foldrChunks (Chunk . S.copy) Empty cs
+--TODO, we could coalese small blocks here
+--FIXME: probably not strict enough, if we're doing this to avoid retaining
+-- the parent blocks then we'd better copy strictly.
+
+-- ---------------------------------------------------------------------
+
+-- TODO defrag func that concatenates block together that are below a threshold
+-- defrag :: Buffer -> Buffer
+
+-- ---------------------------------------------------------------------
+-- Lazy Buffer IO
+--
+-- Rule for when to close: is it expected to read the whole file?
+-- If so, close when done. 
+--
+
+-- | Read entire handle contents /lazily/ into a 'Buffer'. Chunks
+-- are read on demand, in at most @k@-sized chunks. It does not block
+-- waiting for a whole @k@-sized chunk, so if less than @k@ bytes are
+-- available then they will be returned immediately as a smaller chunk.
+--
+-- The handle is closed on EOF.
+--
+hGetContentsN :: Int -> Handle -> IO Buffer
+hGetContentsN k h = lazyRead -- TODO close on exceptions
+  where
+    lazyRead = unsafeInterleaveIO loop
+
+    loop = do
+        c <- S.hGetNonBlocking h k
+        --TODO: I think this should distinguish EOF from no data available
+        -- the underlying POSIX call makes this distincion, returning either
+        -- 0 or EAGAIN
+        if S.null c
+          then do eof <- hIsEOF h
+                  if eof then hClose h >> return Empty
+                         else hWaitForInput h (-1)
+                           >> loop
+          else do cs <- lazyRead
+                  return (Chunk c cs)
+
+-- | Read @n@ bytes into a 'Buffer', directly from the
+-- specified 'Handle', in chunks of size @k@.
+--
+hGetN :: Int -> Handle -> Int -> IO Buffer
+hGetN k h n | n > 0 = readChunks n
+  where
+    STRICT1(readChunks)
+    readChunks i = do
+        c <- S.hGet h (min k i)
+        case S.length c of
+            0 -> return Empty
+            m -> do cs <- readChunks (i - m)
+                    return (Chunk c cs)
+
+hGetN _ _ 0 = return Empty
+hGetN _ h n = illegalBufferSize h "hGet" n
+
+-- | hGetNonBlockingN is similar to 'hGetContentsN', except that it will never block
+-- waiting for data to become available, instead it returns only whatever data
+-- is available. Chunks are read on demand, in @k@-sized chunks.
+--
+hGetNonBlockingN :: Int -> Handle -> Int -> IO Buffer
+#if defined(__GLASGOW_HASKELL__)
+hGetNonBlockingN k h n | n > 0= readChunks n
+  where
+    STRICT1(readChunks)
+    readChunks i = do
+        c <- S.hGetNonBlocking h (min k i)
+        case S.length c of
+            0 -> return Empty
+            m -> do cs <- readChunks (i - m)
+                    return (Chunk c cs)
+
+hGetNonBlockingN _ _ 0 = return Empty
+hGetNonBlockingN _ h n = illegalBufferSize h "hGetNonBlocking" n
+#else
+hGetNonBlockingN = hGetN
+#endif
+
+illegalBufferSize :: Handle -> String -> Int -> IO a
+illegalBufferSize handle fn sz =
+    ioError (mkIOError illegalOperationErrorType msg (Just handle) Nothing)
+    --TODO: System.IO uses InvalidArgument here, but it's not exported :-(
+    where
+      msg = fn ++ ": illegal Buffer size " ++ showsPrec 9 sz []
+
+-- | Read entire handle contents /lazily/ into a 'Buffer'. Chunks
+-- are read on demand, using the default chunk size.
+--
+-- Once EOF is encountered, the Handle is closed.
+--
+hGetContents :: Handle -> IO Buffer
+hGetContents = hGetContentsN defaultChunkSize
+
+-- | Read @n@ bytes into a 'Buffer', directly from the specified 'Handle'.
+--
+hGet :: Handle -> Int -> IO Buffer
+hGet = hGetN defaultChunkSize
+
+-- | hGetNonBlocking is similar to 'hGet', except that it will never block
+-- waiting for data to become available, instead it returns only whatever data
+-- is available.
+#if defined(__GLASGOW_HASKELL__)
+hGetNonBlocking :: Handle -> Int -> IO Buffer
+hGetNonBlocking = hGetNonBlockingN defaultChunkSize
+#else
+hGetNonBlocking = hGet
+#endif
+
+-- | Read an entire file /lazily/ into a 'Buffer'.
+-- The Handle will be held open until EOF is encountered.
+--
+readFile :: FilePath -> IO Buffer
+readFile f = openBinaryFile f ReadMode >>= hGetContents
+
+-- | Write a 'Buffer' to a file.
+--
+writeFile :: FilePath -> Buffer -> IO ()
+writeFile f txt = bracket (openBinaryFile f WriteMode) hClose
+    (\hdl -> hPut hdl txt)
+
+-- | Append a 'Buffer' to a file.
+--
+appendFile :: FilePath -> Buffer -> IO ()
+appendFile f txt = bracket (openBinaryFile f AppendMode) hClose
+    (\hdl -> hPut hdl txt)
+
+-- | getContents. Equivalent to hGetContents stdin. Will read /lazily/
+--
+getContents :: IO Buffer
+getContents = hGetContents stdin
+
+-- | Outputs a 'Buffer' to the specified 'Handle'.
+--
+hPut :: Handle -> Buffer -> IO ()
+hPut h cs = foldrChunks (\c rest -> S.hPut h c >> rest) (return ()) cs
+
+-- | A synonym for @hPut@, for compatibility
+--
+hPutStr :: Handle -> Buffer -> IO ()
+hPutStr = hPut
+
+-- | Write a Buffer to stdout
+putStr :: Buffer -> IO ()
+putStr = hPut stdout
+
+-- | Write a Buffer to stdout, appending a newline byte
+--
+putStrLn :: Buffer -> IO ()
+putStrLn ps = hPut stdout ps >> hPut stdout (singleton 0x0a)
+
+-- | The interact function takes a function of type @Buffer -> Buffer@
+-- as its argument. The entire input from the standard input device is passed
+-- to this function as its argument, and the resulting string is output on the
+-- standard output device.
+--
+interact :: (Buffer -> Buffer) -> IO ()
+interact transformer = putStr . transformer =<< getContents
+
+-- ---------------------------------------------------------------------
+-- Internal utilities
+
+-- Common up near identical calls to `error' to reduce the number
+-- constant strings created when compiled:
+errorEmptyList :: String -> a
+errorEmptyList fun = moduleError fun "empty Buffer"
+
+moduleError :: String -> String -> a
+moduleError fun msg = error ("Data.Buffer.Lazy." ++ fun ++ ':':' ':msg)
+
+
+-- reverse a list of non-empty chunks into a lazy Buffer
+revNonEmptyChunks :: [P.Buffer] -> Buffer
+revNonEmptyChunks cs = L.foldl' (flip Chunk) Empty cs
+
+-- reverse a list of possibly-empty chunks into a lazy Buffer
+revChunks :: [P.Buffer] -> Buffer
+revChunks cs = L.foldl' (flip chunk) Empty cs
+
+-- | 'findIndexOrEnd' is a variant of findIndex, that returns the length
+-- of the string if no element is found, rather than Nothing.
+findIndexOrEnd :: (Word8 -> Bool) -> P.Buffer -> Int
+findIndexOrEnd k (S.PS x s l) = S.inlinePerformIO $ withForeignPtr x $ \f -> go (f `plusPtr` s) 0
+  where
+    STRICT2(go)
+    go ptr n | n >= l    = return l
+             | otherwise = do w <- peek ptr
+                              if k w
+                                then return n
+                                else go (ptr `plusPtr` 1) (n+1)
+{-# INLINE findIndexOrEnd #-}
addfile ./Data/Buffer/Unsafe.hs
hunk ./Data/Buffer/Unsafe.hs 1
+{-# LANGUAGE CPP #-}
+-- We cannot actually specify all the language pragmas, see ghc ticket #
+-- If we could, these are what they would be:
+{- LANGUAGE MagicHash -}
+
+-- |
+-- Module      : Data.Buffer.Unsafe
+-- License     : BSD-style
+-- Maintainer  : ekmett@gmail.com
+-- Stability   : experimental
+-- Portability : portable
+--
+-- A module containing unsafe 'Buffer' operations.
+--
+-- While these functions have a stable API and you may use these functions in
+-- applications, do carefully consider the documented pre-conditions;
+-- incorrect use can break referential transparency or worse.
+--
+module Data.Buffer.Unsafe (
+        __ * Construction
+		ps                      -- :: !!(ForeignPtr Word8) -> Int -> Int -> Buffer
+
+        -- * Unchecked access
+        unsafeHead,             -- :: Buffer -> Word8
+        unsafeTail,             -- :: Buffer -> Buffer
+        unsafeIndex,            -- :: Buffer -> Int -> Word8
+        unsafeTake,             -- :: Int -> Buffer -> Buffer
+        unsafeDrop,             -- :: Int -> Buffer -> Buffer
+        unsafeSplitAt,          -- :: Int -> Buffer -> (Buffer, Buffer)
+
+        -- * Low level interaction with CStrings
+        -- ** Using Buffers with functions for CStrings
+        unsafeUseAsCString,     -- :: Buffer -> (CString -> IO a) -> IO a
+        unsafeUseAsCStringLen,  -- :: Buffer -> (CStringLen -> IO a) -> IO a
+
+        -- ** Converting CStrings to Buffers
+        unsafePackCString,      -- :: CString -> IO Buffer
+        unsafePackAsciiString   -- :: CString -> IO Buffer
+        unsafePackCStringLen,   -- :: CStringLen -> IO Buffer
+        unsafePackAsciiCStringLen, -- :: CStringLen -> IO Buffer
+        unsafePackMallocCString,-- :: CString -> IO Buffer
+        unsafePackMallocAsciiCString -- CString -> IO Buffer
+
+#if defined(__GLASGOW_HASKELL__)
+        unsafePackAddress,          -- :: Addr# -> IO Buffer
+        unsafePackAsciiAddress,     -- :: Addr# -> IO Buffer
+        unsafePackAddressLen,       -- :: Int -> Addr# -> IO Buffer
+        unsafePackAsciiAddressLen   -- :: Int -> Addr# -> IO Buffer
+        unsafePackCStringFinalizer, -- :: Ptr Word8 -> Int -> IO () -> IO Buffer
+        unsafePackAsciiCStringFinalizer -- :: Ptr Word8 -> Int -> IO () -> IO Buffer
+        unsafeFinalize,             -- :: Buffer -> IO ()
+#endif
+
+  ) where
+
+import Data.Buffer.Internal
+
+import Foreign.ForeignPtr       (newForeignPtr_, newForeignPtr, withForeignPtr)
+import Foreign.Ptr              (Ptr, plusPtr, castPtr)
+
+import Foreign.Storable         (Storable(..))
+import Foreign.C.String         (CString, CStringLen)
+
+#ifndef __NHC__
+import Control.Exception        (assert)
+#endif
+
+import Data.Word                (Word8)
+
+#if defined(__GLASGOW_HASKELL__)
+import qualified Foreign.ForeignPtr as FC (finalizeForeignPtr)
+import qualified Foreign.Concurrent as FC (newForeignPtr)
+
+--import Data.Generics            (Data(..), Typeable(..))
+
+import GHC.Prim                 (Addr#)
+import GHC.Ptr                  (Ptr(..))
+#endif
+
+-- An alternative to Control.Exception (assert) for nhc98
+#ifdef __NHC__
+#define assert	assertS "__FILE__ : __LINE__"
+assertS :: String -> Bool -> a -> a
+assertS _ True  = id
+assertS s False = error ("assertion failed at "++s)
+#endif
+
+-- -----------------------------------------------------------------------------
+--
+-- Useful macros, until we have bang patterns
+--
+
+#define STRICT1(f) f a | a `seq` False = undefined
+#define STRICT2(f) f a b | a `seq` b `seq` False = undefined
+#define STRICT3(f) f a b c | a `seq` b `seq` c `seq` False = undefined
+#define STRICT4(f) f a b c d | a `seq` b `seq` c `seq` d `seq` False = undefined
+#define STRICT5(f) f a b c d e | a `seq` b `seq` c `seq` d `seq` e `seq` False = undefined
+
+-- ---------------------------------------------------------------------
+--
+-- Extensions to the basic interface
+--
+
+unsafeExtras :: Buffer -> Int -> Int
+unsafeExtras (PS x s l e) i = assert (i >= 0 && i <= l) $
+     let lmn = l - i in 
+     -- inlinePerformIO ?
+     unsafePerformIO $ withForeignPtr x $ \p -> 
+     if i > lmi
+     then e - go (p `plusPtr` (s + i)) lmi 0
+     else go (p `plusPtr` s) i 0
+    where
+        STRICT3(go)
+        go p 0 acc = acc
+        go p n acc = do
+        	w <- peekByteOff p n
+        	go p (n-1) $ acc `plusExtra` w 
+{-# INLINE unsafeExtras #-}     
+
+ps :: ForeignPtr Word8 -> Int -> Int -> Buffer
+ps x s l = PS x s l $ 
+    inlinePerformIO $ withForeignPtr x $ \p -> 
+        go (p `plusPtr` s) l 0
+    where 
+    	STRICT3(go)
+    	go p 0 acc = acc
+    	go p n acc = do
+    		w <- peekByteOff p n
+    		go p (n-1) $! acc `plusExtra` w
+{-# INLINE ps #-}
+
+-- | A variety of 'head' for non-empty Buffers. 'unsafeHead' omits the
+-- check for the empty case, so there is an obligation on the programmer
+-- to provide a proof that the Buffer is non-empty.
+unsafeHead :: Buffer -> Word8
+unsafeHead (PS x s l _) = assert (l > 0) $
+    inlinePerformIO $ withForeignPtr x $ \p -> peekByteOff p s
+{-# INLINE unsafeHead #-}
+
+-- | A variety of 'tail' for non-empty Buffers. 'unsafeTail' omits the
+-- check for the empty case. As with 'unsafeHead', the programmer must
+-- provide a separate proof that the Buffer is non-empty.
+unsafeTail :: Buffer -> Buffer
+unsafeTail (PS ps s l e) = assert (l > 0) $ 
+        PS ps (s+1) (1-1) $!   
+        e `minusExtra` (inlinePerformIO $ withForeignPtr ps $ \p -> peekByteOff p s)
+{-# INLINE unsafeTail #-}
+
+-- | Unsafe 'Buffer' index (subscript) operator, starting from 0, returning a 'Word8'
+-- This omits the bounds check, which means there is an accompanying
+-- obligation on the programmer to ensure the bounds are checked in some
+-- other way.
+unsafeIndex :: Buffer -> Int -> Word8
+unsafeIndex (PS x s l _) i = assert (i >= 0 && i < l) $
+    inlinePerformIO $ withForeignPtr x $ \p -> peekByteOff p (s+i)
+{-# INLINE unsafeIndex #-}
+
+-- | A variety of 'take' which omits the checks on @n@ so there is an
+-- obligation on the programmer to provide a proof that @0 <= n <= 'length' xs@.
+unsafeTake :: Int -> Buffer -> Buffer
+unsafeTake n ps@(PS x s l e) = assert (0 <= n && n <= l) $ 
+    PS x s n $ unsafeExtras ps n
+{-# INLINE unsafeTake #-}
+
+-- | A variety of 'drop' which omits the checks on @n@ so there is an
+-- obligation on the programmer to provide a proof that @0 <= n <= 'length' xs@.
+unsafeDrop  :: Int -> Buffer -> Buffer
+unsafeDrop n ps@(PS x s l e) = assert (0 <= n && n <= l) $ 
+    PS x (s+n) (l-n) $ e - unsafeExtras ps n
+{-# INLINE unsafeDrop #-}
+
+unsafeSplitAt :: Int -> Buffer -> Buffer
+unsafeSplitAt n ps@(PS x s l e) = assert (0 <= n && n <= l) $
+    let e' = unsafeExtras ps n
+    in (PS x s n e', PS x (s + n) (l - n) (e - e'))
+{-# INLINE unsafeSplitAt #-}
+
+
+#if defined(__GLASGOW_HASKELL__)
+-- | /O(n)/ Pack a null-terminated sequence of bytes, pointed to by an
+-- Addr\# (an arbitrary machine address assumed to point outside the
+-- garbage-collected heap) into a @Buffer@. A much faster way to
+-- create an Addr\# is with an unboxed string literal, than to pack a
+-- boxed string. A unboxed string literal is compiled to a static @char
+-- []@ by GHC. Establishing the length of the string requires a call to
+-- @strlen(3)@, so the Addr# must point to a null-terminated buffer (as
+-- is the case with "string"# literals in GHC). Use 'unsafePackAddressLen'
+-- if you know the length of the string statically.
+--
+-- An example:
+--
+-- > literalFS = unsafePackAddress "literal"#
+--
+-- This function is /unsafe/. If you modify the buffer pointed to by the
+-- original Addr# this modification will be reflected in the resulting
+-- @Buffer@, breaking referential transparency.
+--
+-- Note this also won't work if you Add# has embedded '\0' characters in
+-- the string (strlen will fail).
+--
+unsafePackAddress :: Addr# -> IO Buffer
+unsafePackAddress addr# = do
+    p <- newForeignPtr_ cstr
+    l <- c_strlen cstr
+    return $! ps p 0 (fromIntegral l)
+  where
+    cstr = Ptr addr#
+{-# INLINE unsafePackAddress #-}
+
+-- | /O(n)/ Pack a null-terminated sequence of bytes, pointed to by an
+-- Addr\# (an arbitrary machine address assumed to point outside the
+-- garbage-collected heap) into a @Buffer@. A much faster way to
+-- create an Addr\# is with an unboxed string literal, than to pack a
+-- boxed string. A unboxed string literal is compiled to a static @char
+-- []@ by GHC. Establishing the length of the string requires a call to
+-- @strlen(3)@, so the Addr# must point to a null-terminated buffer (as
+-- is the case with "string"# literals in GHC). Use 'unsafePackAddressLen'
+-- if you know the length of the string statically.
+--
+-- An example:
+--
+-- > literalFS = unsafePackAddress "literal"#
+--
+-- This function is /unsafe/ in two ways:
+--
+-- * if you modify the buffer pointed to by the
+-- original Addr# this modification will be reflected in the resulting
+-- @Buffer@, breaking referential transparency.
+--
+-- * the Addr# is assumed to point to memory such that no element exceeds 0x7f.
+-- 
+-- Note this also won't work if you Add# has embedded '\0' characters in
+-- the string (strlen will fail).
+--
+unsafePackAsciiAddress :: Addr# -> IO Buffer
+unsafePackAsciiAddress addr# = do
+    p <- newForeignPtr_ cstr
+    l <- c_strlen cstr
+    return $! PS p 0 (fromIntegral l) 0
+  where
+    cstr = Ptr addr#
+
+-- | /O(n)/ 'unsafePackAddressLen' provides constant-time construction of
+-- 'Buffers' which is ideal for string literals. It packs a sequence
+-- of bytes into a 'Buffer', given a raw 'Addr#' to the string, and
+-- the length of the string. Unlike 'unsafePackAddressLen' for a 'ByteString'
+-- this still has to scan the Addr# for high bytes.
+--
+-- This function is /unsafe/ in two ways:
+--
+-- * the length argument is assumed to be correct. If the length
+-- argument is incorrect, it is possible to overstep the end of the
+-- byte array.
+--
+-- * if the underying Addr# is later modified, this change will be
+-- reflected in resulting @Buffer@, breaking referential
+-- transparency.
+--
+-- If in doubt, don't use these functions.
+--
+unsafePackAddressLen :: Int -> Addr# -> IO Buffer
+unsafePackAddressLen len addr# = do
+    p <- newForeignPtr_ (Ptr addr#)
+    return $! ps p 0 len
+{-# INLINE unsafePackAddressLen #-}
+
+-- | /O(1)/ 'unsafePackAsciiAddressLen' provides constant-time construction of
+-- 'Buffers' which is ideal for string literals. It packs a sequence
+-- of bytes into a 'Buffer', given a raw 'Addr#' to the string, and
+-- the length of the string.
+--
+-- This function is /unsafe/ in three ways:
+--
+-- * the length argument is assumed to be correct. If the length
+-- argument is incorrect, it is possible to overstep the end of the
+-- byte array.
+--
+-- * if the underying Addr# is later modified, this change will be
+-- reflected in resulting @Buffer@, breaking referential
+-- transparency.
+--
+-- * the Addr# is assumed to point to memory such that no element exceeds 0x7f.
+-- 
+-- If in doubt, don't use these functions.
+--
+unsafePackAsciiAddressLen :: Int -> Addr# -> IO Buffer
+unsafePackAsciiAddressLen len addr# = do
+    p <- newForeignPtr_ (Ptr addr#)
+    return $! PS p 0 len 0
+{-# INLINE unsafePackAddressLen #-}
+
+-- | /O(n)/ Construct a 'Buffer' given a Ptr Word8 to a buffer, a
+-- length, and an IO action representing a finalizer. This function is
+-- not available on Hugs.
+--
+-- This function is /unsafe/, it is possible to break referential
+-- transparency by modifying the underlying buffer pointed to by the
+-- first argument. Any changes to the original buffer will be reflected
+-- in the resulting @Buffer@.
+--
+unsafePackCStringFinalizer :: Ptr Word8 -> Int -> IO () -> IO Buffer
+unsafePackCStringFinalizer p l f = do
+    fp <- FC.newForeignPtr p f
+    return $! ps fp 0 l
+    
+-- | /O(n)/ Construct a 'Buffer' given a Ptr Word8 to a buffer, a
+-- length, and an IO action representing a finalizer. This function is
+-- not available on Hugs.
+--
+-- This function is /unsafe/ in two ways:
+--
+-- * it is possible to break referential
+-- transparency by modifying the underlying buffer pointed to by the
+-- first argument. Any changes to the original buffer will be reflected
+-- in the resulting @Buffer@.
+-- 
+-- * the CString is assumed to point to memory such that no element exceeds 0x7f.
+--
+unsafePackAsciiCStringFinalizer :: Ptr Word8 -> Int -> IO () -> IO Buffer
+unsafePackAsciiCStringFinalizer p l f = do
+    fp <- FC.newForeignPtr p f
+    return $! PS fp 0 l 0
+
+-- | Explicitly run the finaliser associated with a 'Buffer'.
+-- References to this value after finalisation may generate invalid memory
+-- references.
+--
+-- This function is /unsafe/, as there may be other
+-- 'Buffers' referring to the same underlying pages. If you use
+-- this, you need to have a proof of some kind that all 'Buffer's
+-- ever generated from the underlying byte array are no longer live.
+--
+unsafeFinalize :: Buffer -> IO ()
+unsafeFinalize (PS p _ _ _) = FC.finalizeForeignPtr p
+
+#endif
+
+------------------------------------------------------------------------
+-- Packing CStrings into Buffers
+
+-- | /O(n)/ Build a @Buffer@ from a @CString@. This value will have /no/
+-- finalizer associated to it, and will not be garbage collected by
+-- Haskell. The Buffer length is calculated using /strlen(3)/,
+-- and thus the complexity is a /O(n)/.
+--
+-- This function is /unsafe/. If the @CString@ is later modified, this
+-- change will be reflected in the resulting @Buffer@, breaking
+-- referential transparency.
+
+unsafePackCString :: CString -> IO Buffer
+unsafePackCString cstr = do
+    fp <- newForeignPtr_ (castPtr cstr)
+    l <- c_strlen cstr
+    return $! ps fp 0 (fromIntegral l)
+
+-- | /O(n)/ Build a @Buffer@ from a @CStringLen@. This value will
+-- have /no/ finalizer associated with it, and will not be garbage
+-- collected by Haskell. This operation has /O(1)/ complexity as we
+-- already know the final size, so no /strlen(3)/ is required.
+--
+-- This funtion is /unsafe/. If the original @CStringLen@ is later
+-- modified, this change will be reflected in the resulting @Buffer@,
+-- breaking referential transparency.
+--
+unsafePackCStringLen :: CStringLen -> IO Buffer
+unsafePackCStringLen (ptr,len) = do
+    fp <- newForeignPtr_ (castPtr ptr)
+    return $! ps fp 0 (fromIntegral len)
+    
+-- | /O(1)/ Build a @Buffer@ from a @CStringLen@. This value will
+-- have /no/ finalizer associated with it, and will not be garbage
+-- collected by Haskell. This operation has /O(1)/ complexity as we
+-- already know the final size, so no /strlen(3)/ is required.
+--
+-- This funtion is /unsafe/ in two ways: 
+-- 
+-- * if the original @CStringLen@ is later
+-- modified, this change will be reflected in the resulting @Buffer@,
+-- breaking referential transparency.
+--
+-- * the CString is assumed to point to memory such that no element exceeds 0x7f.
+-- 
+unsafePackAsciiCStringLen :: CStringLen -> IO Buffer
+unsafePackAsciiCStringLen (ptr,len) = do
+    fp <- newForeignPtr_ (castPtr ptr)
+    return $! PS fp 0 (fromIntegral len) 0
+    
+-- | /O(n)/ Build a @Buffer@ from a malloced @CString@. This value will
+-- have a @free(3)@ finalizer associated to it.
+--
+-- This funtion is /unsafe/. If the original @CString@ is later
+-- modified, this change will be reflected in the resulting @Buffer@,
+-- breaking referential transparency.
+--
+-- This function is also unsafe if you call its finalizer twice,
+-- which will result in a /double free/ error, or if you pass it
+-- a CString not allocated with 'malloc'.
+--
+unsafePackMallocCString :: CString -> IO Buffer
+unsafePackMallocCString cstr = do
+    fp <- newForeignPtr c_free_finalizer (castPtr cstr)
+    len <- c_strlen cstr
+    return $! ps fp 0 (fromIntegral len)
+
+-- ---------------------------------------------------------------------
+
+-- | /O(1) construction/ Use a @Buffer@ with a function requiring a
+-- @CString@.
+--
+-- This function does zero copying, and merely unwraps a @Buffer@ to
+-- appear as a @CString@. It is /unsafe/ in two ways:
+--
+-- * After calling this function the @CString@ shares the underlying
+-- byte buffer with the original @Buffer@. Thus modifying the
+-- @CString@, either in C, or using poke, will cause the contents of the
+-- @Buffer@ to change, breaking referential transparency. Other
+-- @Buffers@ created by sharing (such as those produced via 'take'
+-- or 'drop') will also reflect these changes. Modifying the @CString@
+-- will break referential transparency. To avoid this, use
+-- @useAsCString@, which makes a copy of the original @Buffer@.
+--
+-- * @CStrings@ are often passed to functions that require them to be
+-- null-terminated. If the original @Buffer@ wasn't null terminated,
+-- neither will the @CString@ be. It is the programmers responsibility
+-- to guarantee that the @Buffer@ is indeed null terminated. If in
+-- doubt, use @useAsCString@.
+--
+unsafeUseAsCString :: Buffer -> (CString -> IO a) -> IO a
+unsafeUseAsCString (PS ps s _ _) ac = withForeignPtr ps $ \p -> ac (castPtr p `plusPtr` s)
+
+-- | /O(1) construction/ Use a @Buffer@ with a function requiring a
+-- @CStringLen@.
+-- 
+-- This function does zero copying, and merely unwraps a @Buffer@ to
+-- appear as a @CStringLen@. It is /unsafe/:
+--
+-- * After calling this function the @CStringLen@ shares the underlying
+-- byte buffer with the original @Buffer@. Thus modifying the
+-- @CStringLen@, either in C, or using poke, will cause the contents of the
+-- @Buffer@ to change, breaking referential transparency. Other
+-- @Buffers@ created by sharing (such as those produced via 'take'
+-- or 'drop') will also reflect these changes. Modifying the @CStringLen@
+-- will break referential transparency. To avoid this, use
+-- @useAsCStringLen@, which makes a copy of the original @Buffer@.
+--
+unsafeUseAsCStringLen :: Buffer -> (CStringLen -> IO a) -> IO a
+unsafeUseAsCStringLen (PS ps s l _) f = withForeignPtr ps $ \p -> f (castPtr p `plusPtr` s,l)
addfile ./Data/Buffer/Word8.hs
hunk ./Data/Buffer/Word8.hs 1
+{-# LANGUAGE CPP #-}
+-- We cannot actually specify all the language pragmas, see ghc ticket #
+-- If we could, these are what they would be:
+{- LANGUAGE MagicHash, UnboxedTuples,
+            NamedFieldPuns, BangPatterns, RecordWildCards -}
+{-# OPTIONS_HADDOCK prune #-}
+
+-- |
+-- Module      : Data.Buffer
+-- Copyright   : (c) The University of Glasgow 2001,
+--               (c) David Roundy 2003-2005,
+--               (c) Simon Marlow 2005
+--               (c) Bjorn Bringert 2006
+--               (c) Don Stewart 2005-2008
+--               (c) Edward Kmett 2009-2010
+--
+--               Array fusion code:
+--               (c) 2001,2002 Manuel M T Chakravarty & Gabriele Keller
+--               (c) 2006      Manuel M T Chakravarty & Roman Leshchinskiy
+--
+-- License     : BSD-style
+--
+-- Maintainer  : ekmett@gmail.com
+-- Stability   : experimental
+-- Portability : portable
+-- 
+-- A time and space-efficient implementation of byte vectors using
+-- packed Word8 arrays, suitable for high performance use, both in terms
+-- of large data quantities, or high speed requirements. Byte vectors
+-- are encoded as strict 'Word8' arrays of bytes, held in a 'ForeignPtr',
+-- and can be passed between C and Haskell with little effort.
+--
+-- This module is intended to be imported @qualified@, to avoid name
+-- clashes with "Prelude" functions.  eg.
+--
+-- > import qualified Data.Buffer as B
+--
+-- Original GHC implementation by Bryan O\'Sullivan.
+-- Rewritten to use 'Data.Array.Unboxed.UArray' by Simon Marlow.
+-- Rewritten to support slices and use 'ForeignPtr' by David Roundy.
+-- Polished and extended by Don Stewart.
+--
+
+module Data.Buffer.Word8 (
+
+        -- * The @Buffer@ type
+        Buffer,             -- abstract, instances: Eq, Ord, Show, Read, Data, Typeable, Monoid
+
+        -- * Introducing and eliminating 'Buffer's
+        empty,                  -- :: Buffer
+        singleton,              -- :: Word8   -> Buffer
+        pack,                   -- :: [Word8] -> Buffer
+        unpack,                 -- :: Buffer -> [Word8]
+
+        -- * Basic interface
+        cons,                   -- :: Word8 -> Buffer -> Buffer
+        snoc,                   -- :: Buffer -> Word8 -> Buffer
+        append,                 -- :: Buffer -> Buffer -> Buffer
+        head,                   -- :: Buffer -> Word8
+        uncons,                 -- :: Buffer -> Maybe (Word8, Buffer)
+        last,                   -- :: Buffer -> Word8
+        tail,                   -- :: Buffer -> Buffer
+        init,                   -- :: Buffer -> Buffer
+        null,                   -- :: Buffer -> Bool
+        length,                 -- :: Buffer -> Int
+
+        -- * Transforming Buffers
+        map,                    -- :: (Word8 -> Word8) -> Buffer -> Buffer
+        reverse,                -- :: Buffer -> Buffer
+        intersperse,            -- :: Word8 -> Buffer -> Buffer
+        intercalate,            -- :: Buffer -> [Buffer] -> Buffer
+        transpose,              -- :: [Buffer] -> [Buffer]
+
+        -- * Reducing 'Buffer's (folds)
+        foldl,                  -- :: (a -> Word8 -> a) -> a -> Buffer -> a
+        foldl',                 -- :: (a -> Word8 -> a) -> a -> Buffer -> a
+        foldl1,                 -- :: (Word8 -> Word8 -> Word8) -> Buffer -> Word8
+        foldl1',                -- :: (Word8 -> Word8 -> Word8) -> Buffer -> Word8
+
+        foldr,                  -- :: (Word8 -> a -> a) -> a -> Buffer -> a
+        foldr',                 -- :: (Word8 -> a -> a) -> a -> Buffer -> a
+        foldr1,                 -- :: (Word8 -> Word8 -> Word8) -> Buffer -> Word8
+        foldr1',                -- :: (Word8 -> Word8 -> Word8) -> Buffer -> Word8
+
+        -- ** Special folds
+        concat,                 -- :: [Buffer] -> Buffer
+        concatMap,              -- :: (Word8 -> Buffer) -> Buffer -> Buffer
+        any,                    -- :: (Word8 -> Bool) -> Buffer -> Bool
+        all,                    -- :: (Word8 -> Bool) -> Buffer -> Bool
+        maximum,                -- :: Buffer -> Word8
+        minimum,                -- :: Buffer -> Word8
+
+        -- * Building Buffers
+        -- ** Scans
+        scanl,                  -- :: (Word8 -> Word8 -> Word8) -> Word8 -> Buffer -> Buffer
+        scanl1,                 -- :: (Word8 -> Word8 -> Word8) -> Buffer -> Buffer
+        scanr,                  -- :: (Word8 -> Word8 -> Word8) -> Word8 -> Buffer -> Buffer
+        scanr1,                 -- :: (Word8 -> Word8 -> Word8) -> Buffer -> Buffer
+
+        -- ** Accumulating maps
+        mapAccumL,              -- :: (acc -> Word8 -> (acc, Word8)) -> acc -> Buffer -> (acc, Buffer)
+        mapAccumR,              -- :: (acc -> Word8 -> (acc, Word8)) -> acc -> Buffer -> (acc, Buffer)
+
+        -- ** Generating and unfolding Buffers
+        replicate,              -- :: Int -> Word8 -> Buffer
+        unfoldr,                -- :: (a -> Maybe (Word8, a)) -> a -> Buffer
+        unfoldrN,               -- :: Int -> (a -> Maybe (Word8, a)) -> a -> (Buffer, Maybe a)
+
+        -- * Substrings
+
+        -- ** Breaking strings
+        take,                   -- :: Int -> Buffer -> Buffer
+        drop,                   -- :: Int -> Buffer -> Buffer
+        splitAt,                -- :: Int -> Buffer -> (Buffer, Buffer)
+        takeWhile,              -- :: (Word8 -> Bool) -> Buffer -> Buffer
+        dropWhile,              -- :: (Word8 -> Bool) -> Buffer -> Buffer
+        span,                   -- :: (Word8 -> Bool) -> Buffer -> (Buffer, Buffer)
+        spanEnd,                -- :: (Word8 -> Bool) -> Buffer -> (Buffer, Buffer)
+        break,                  -- :: (Word8 -> Bool) -> Buffer -> (Buffer, Buffer)
+        breakEnd,               -- :: (Word8 -> Bool) -> Buffer -> (Buffer, Buffer)
+        group,                  -- :: Buffer -> [Buffer]
+        groupBy,                -- :: (Word8 -> Word8 -> Bool) -> Buffer -> [Buffer]
+        inits,                  -- :: Buffer -> [Buffer]
+        tails,                  -- :: Buffer -> [Buffer]
+
+        -- ** Breaking into many substrings
+        split,                  -- :: Word8 -> Buffer -> [Buffer]
+        splitWith,              -- :: (Word8 -> Bool) -> Buffer -> [Buffer]
+
+        -- * Predicates
+        isPrefixOf,             -- :: Buffer -> Buffer -> Bool
+        isSuffixOf,             -- :: Buffer -> Buffer -> Bool
+        isInfixOf,              -- :: Buffer -> Buffer -> Bool
+
+        -- ** Search for arbitrary substrings
+        breakSubstring,         -- :: Buffer -> Buffer -> (Buffer,Buffer)
+        findSubstring,          -- :: Buffer -> Buffer -> Maybe Int
+        findSubstrings,         -- :: Buffer -> Buffer -> [Int]
+
+        -- * Searching Buffers
+
+        -- ** Searching by equality
+        elem,                   -- :: Word8 -> Buffer -> Bool
+        notElem,                -- :: Word8 -> Buffer -> Bool
+
+        -- ** Searching with a predicate
+        find,                   -- :: (Word8 -> Bool) -> Buffer -> Maybe Word8
+        filter,                 -- :: (Word8 -> Bool) -> Buffer -> Buffer
+        partition,              -- :: (Word8 -> Bool) -> Buffer -> (Buffer, Buffer)
+
+        -- * Indexing Buffers
+        index,                  -- :: Buffer -> Int -> Word8
+        elemIndex,              -- :: Word8 -> Buffer -> Maybe Int
+        elemIndices,            -- :: Word8 -> Buffer -> [Int]
+        elemIndexEnd,           -- :: Word8 -> Buffer -> Maybe Int
+        findIndex,              -- :: (Word8 -> Bool) -> Buffer -> Maybe Int
+        findIndices,            -- :: (Word8 -> Bool) -> Buffer -> [Int]
+        count,                  -- :: Word8 -> Buffer -> Int
+
+        -- * Zipping and unzipping Buffers
+        zip,                    -- :: Buffer -> Buffer -> [(Word8,Word8)]
+        zipWith,                -- :: (Word8 -> Word8 -> c) -> Buffer -> Buffer -> [c]
+        unzip,                  -- :: [(Word8,Word8)] -> (Buffer,Buffer)
+
+        -- * Ordered Buffers
+        sort,                   -- :: Buffer -> Buffer
+
+        -- * Low level conversions
+        -- ** Copying Buffers
+        copy,                   -- :: Buffer -> Buffer
+
+        -- ** Packing 'CString's and pointers
+        packCString,            -- :: CString -> IO Buffer
+        packCStringLen,         -- :: CStringLen -> IO Buffer
+
+        -- ** Using Buffers as 'CString's
+        useAsCString,           -- :: Buffer -> (CString    -> IO a) -> IO a
+        useAsCStringLen,        -- :: Buffer -> (CStringLen -> IO a) -> IO a
+
+        -- * I\/O with 'Buffer's
+
+        -- ** Standard input and output
+        getLine,                -- :: IO Buffer
+        getContents,            -- :: IO Buffer
+        putStr,                 -- :: Buffer -> IO ()
+        putStrLn,               -- :: Buffer -> IO ()
+        interact,               -- :: (Buffer -> Buffer) -> IO ()
+
+        -- ** Files
+        readFile,               -- :: FilePath -> IO Buffer
+        writeFile,              -- :: FilePath -> Buffer -> IO ()
+        appendFile,             -- :: FilePath -> Buffer -> IO ()
+
+        -- ** I\/O with Handles
+        hGetLine,               -- :: Handle -> IO Buffer
+        hGetContents,           -- :: Handle -> IO Buffer
+        hGet,                   -- :: Handle -> Int -> IO Buffer
+        hGetNonBlocking,        -- :: Handle -> Int -> IO Buffer
+        hPut,                   -- :: Handle -> Buffer -> IO ()
+        hPutStr,                -- :: Handle -> Buffer -> IO ()
+        hPutStrLn,              -- :: Handle -> Buffer -> IO ()
+
+        breakByte
+  ) where
+
+import qualified Prelude as P
+import Prelude hiding           (reverse,head,tail,last,init,null
+                                ,length,map,lines,foldl,foldr,unlines
+                                ,concat,any,take,drop,splitAt,takeWhile
+                                ,dropWhile,span,break,elem,filter,maximum
+                                ,minimum,all,concatMap,foldl1,foldr1
+                                ,scanl,scanl1,scanr,scanr1
+                                ,readFile,writeFile,appendFile,replicate
+                                ,getContents,getLine,putStr,putStrLn,interact
+                                ,zip,zipWith,unzip,notElem)
+
+import Data.Buffer.Internal
+import Data.Buffer.Unsafe
+
+import qualified Data.List as List
+
+import Data.Word                (Word8)
+import Data.Maybe               (isJust, listToMaybe)
+
+-- Control.Exception.assert not available in yhc or nhc
+#ifndef __NHC__
+import Control.Exception        (finally, bracket, assert)
+#else
+import Control.Exception	(bracket, finally)
+#endif
+import Control.Monad            (when)
+
+import Foreign.C.String         (CString, CStringLen)
+import Foreign.C.Types          (CSize)
+import Foreign.ForeignPtr
+import Foreign.Marshal.Alloc    (allocaBytes, mallocBytes, reallocBytes, finalizerFree)
+import Foreign.Marshal.Array    (allocaArray)
+import Foreign.Ptr
+import Foreign.Storable         (Storable(..))
+
+-- hGetBuf and hPutBuf not available in yhc or nhc
+import System.IO                (stdin,stdout,hClose,hFileSize
+                                ,hGetBuf,hPutBuf,openBinaryFile
+                                ,IOMode(..))
+import System.IO.Error          (mkIOError, illegalOperationErrorType)
+
+import Data.Monoid              (Monoid, mempty, mappend, mconcat)
+
+#if !defined(__GLASGOW_HASKELL__)
+import System.IO.Unsafe
+import qualified System.Environment
+import qualified System.IO      (hGetLine)
+#endif
+
+#if defined(__GLASGOW_HASKELL__)
+
+import System.IO                (hGetBufNonBlocking)
+
+#if __GLASGOW_HASKELL__ >= 611
+import Data.IORef
+import GHC.IO.Handle.Internals
+import GHC.IO.Handle.Types
+import GHC.IO.Buffer
+import GHC.IO.BufferedIO as Buffered
+import GHC.IO hiding (finally)
+import Data.Char                (ord)
+import Foreign.Marshal.Utils    (copyBytes)
+#else
+import System.IO.Error          (isEOFError)
+import GHC.IOBase
+import GHC.Handle
+#endif
+
+import GHC.Prim                 (Word#, (+#), writeWord8OffAddr#)
+import GHC.Base                 (build)
+import GHC.Word hiding (Word8)
+import GHC.Ptr                  (Ptr(..))
+import GHC.ST                   (ST(..))
+
+#endif
+
+-- An alternative to Control.Exception (assert) for nhc98
+#ifdef __NHC__
+#define assert  assertS "__FILE__ : __LINE__"
+assertS :: String -> Bool -> a -> a
+assertS _ True  = id
+assertS s False = error ("assertion failed at "++s)
+#endif
+
+-- -----------------------------------------------------------------------------
+--
+-- Useful macros, until we have bang patterns
+--
+
+#define STRICT1(f) f a | a `seq` False = undefined
+#define STRICT2(f) f a b | a `seq` b `seq` False = undefined
+#define STRICT3(f) f a b c | a `seq` b `seq` c `seq` False = undefined
+#define STRICT4(f) f a b c d | a `seq` b `seq` c `seq` d `seq` False = undefined
+#define STRICT5(f) f a b c d e | a `seq` b `seq` c `seq` d `seq` e `seq` False = undefined
+
+-- -----------------------------------------------------------------------------
+
+instance Eq  Buffer where
+    (==)    = eq
+
+instance Ord Buffer where
+    compare = compareBytes
+
+instance Monoid Buffer where
+    mempty  = empty
+    mappend = append
+    mconcat = concat
+
+-- | /O(n)/ Equality on the 'Buffer' type.
+eq :: Buffer -> Buffer -> Bool
+eq a@(PS p s l x) b@(PS p' s' l' x')
+    | l /= l' || x /= x' = False    -- short cut on length and number of extra bytes
+    | p == p' && s == s' = True     -- short cut for the same string
+    | otherwise          = compareBytes a b == EQ
+{-# INLINE eq #-}
+-- ^ still needed
+
+-- | /O(n)/ 'compareBytes' provides an 'Ordering' for 'Buffers' supporting slices. 
+compareBytes :: Buffer -> Buffer -> Ordering
+compareBytes (PS x1 s1 l1 _) (PS x2 s2 l2 _)
+    | l1 == 0  && l2 == 0               = EQ  -- short cut for empty strings
+    | otherwise                         = inlinePerformIO $
+        withForeignPtr x1 $ \p1 ->
+        withForeignPtr x2 $ \p2 -> do
+            i <- memcmp (p1 `plusPtr` s1) (p2 `plusPtr` s2) (fromIntegral $ min l1 l2)
+            return $! case i `compare` 0 of
+                        EQ  -> l1 `compare` l2
+                        x   -> x
+
+{-
+
+-- Pure Haskell version
+
+compareBytes (PS fp1 off1 len1 _) (PS fp2 off2 len2 _)
+--    | len1 == 0  && len2 == 0                     = EQ  -- short cut for empty strings
+--    | fp1 == fp2 && off1 == off2 && len1 == len2  = EQ  -- short cut for the same string
+    | otherwise                                   = inlinePerformIO $
+    withForeignPtr fp1 $ \p1 ->
+        withForeignPtr fp2 $ \p2 ->
+            cmp (p1 `plusPtr` off1)
+                (p2 `plusPtr` off2) 0 len1 len2
+
+-- XXX todo.
+cmp :: Ptr Word8 -> Ptr Word8 -> Int -> Int -> Int-> IO Ordering
+cmp p1 p2 n len1 len2
+      | n == len1 = if n == len2 then return EQ else return LT
+      | n == len2 = return GT
+      | otherwise = do
+          a <- peekByteOff p1 n :: IO Word8
+          b <- peekByteOff p2 n
+          case a `compare` b of
+                EQ -> cmp p1 p2 (n+1) len1 len2
+                LT -> return LT
+                GT -> return GT
+-}
+
+-- -----------------------------------------------------------------------------
+-- Introducing and eliminating 'Buffer's
+
+-- | /O(1)/ The empty 'Buffer'
+empty :: Buffer
+empty = PS nullForeignPtr 0 0 0
+
+-- | /O(1)/ Convert a 'Word8' into a 'Buffer'
+singleton :: Word8 -> Buffer
+singleton c = unsafeCreate 1 $ \p -> poke p c
+{-# INLINE [1] singleton #-}
+
+-- Inline [1] for intercalate rule
+
+--
+-- XXX The use of unsafePerformIO in allocating functions (unsafeCreate) is critical!
+--
+-- Otherwise:
+--
+--  singleton 255 `compare` singleton 127
+--
+-- is compiled to:
+--
+--  case mallocBuffer 2 of 
+--      ForeignPtr f internals -> 
+--           case writeWord8OffAddr# f 0 255 of _ -> 
+--           case writeWord8OffAddr# f 0 127 of _ ->
+--           case eqAddr# f f of 
+--                  False -> case compare (GHC.Prim.plusAddr# f 0) 
+--                                        (GHC.Prim.plusAddr# f 0)
+--
+--
+
+-- | /O(n)/ Convert a '[Word8]' into a 'Buffer'. 
+--
+-- For applications with large numbers of string literals, pack can be a
+-- bottleneck. In such cases, consider using packAddress (GHC only).
+pack :: [Word8] -> Buffer
+
+#if !defined(__GLASGOW_HASKELL__)
+
+pack str = unsafeCreate' (P.length str) $ \p -> go p str 0
+    where
+        STRICT3(go)
+        go _ [] acc    = return acc
+        go p (x:xs) acc = poke p x >> go (p `plusPtr` 1) xs (acc `plusExtra` x) -- less space than pokeElemOff
+
+#else /* hack away */
+
+pack str = unsafeCreate' (P.length str) $ \(Ptr p) -> stToIO (go p 0# str 0#)
+    where
+        go _ _ [] acc       = return (I# acc)
+        go p i (W8# c:cs) acc = writeByte p i c >> go p (i +# 1#) cs (if x >=# 0x80# && x <# 0xC0 then acc +# 1 else acc)
+
+        writeByte p i c = ST $ \s# ->
+            case writeWord8OffAddr# p i c s# of s2# -> (# s2#, () #)
+
+#endif
+
+-- | /O(n)/ Converts a 'Buffer' to a '[Word8]'.
+unpack :: Buffer -> [Word8]
+
+#if !defined(__GLASGOW_HASKELL__)
+
+unpack (PS _  _ 0 _) = []
+unpack (PS ps s l _) = inlinePerformIO $ withForeignPtr ps $ \p ->
+        go (p `plusPtr` s) (l - 1) []
+    where
+        STRICT3(go)
+        go p 0 acc = peek p          >>= \e -> return (e : acc)
+        go p n acc = peekByteOff p n >>= \e -> go p (n-1) (e : acc)
+{-# INLINE unpack #-}
+
+#else
+
+unpack ps = build (unpackFoldr ps)
+{-# INLINE unpack #-}
+
+--
+-- Have unpack fuse with good list consumers
+--
+-- critical this isn't strict in the acc
+-- as it will break in the presence of list fusion. this is a known
+-- issue with seq and build/foldr rewrite rules, which rely on lazy
+-- demanding to avoid bottoms in the list.
+--
+unpackFoldr :: Buffer -> (Word8 -> a -> a) -> a -> a
+unpackFoldr (PS fp off len _) f ch = withPtr fp $ \p -> do
+    let loop q n    _   | q `seq` n `seq` False = undefined -- n.b.
+        loop _ (-1) acc = return acc
+        loop q n    acc = do
+           a <- peekByteOff q n
+           loop q (n-1) (a `f` acc)
+    loop (p `plusPtr` off) (len-1) ch
+{-# INLINE [0] unpackFoldr #-}
+
+unpackList :: Buffer -> [Word8]
+unpackList (PS fp off len _) = withPtr fp $ \p -> do
+    let STRICT3(loop)
+        loop _ (-1) acc = return acc
+        loop q n acc = do
+           a <- peekByteOff q n
+           loop q (n-1) (a : acc)
+    loop (p `plusPtr` off) (len-1) []
+
+{-# RULES
+"Buffer unpack-list" [1]  forall p  .
+    unpackFoldr p (:) [] = unpackList p
+ #-}
+
+#endif
+
+-- ---------------------------------------------------------------------
+-- Basic interface
+
+-- | /O(1)/ Test whether a Buffer is empty.
+null :: Buffer -> Bool
+null (PS _ _ l _) = assert (l >= 0) $ l <= 0
+{-# INLINE null #-}
+
+-- ---------------------------------------------------------------------
+-- | /O(1)/ 'length' returns the length of a Buffer as an 'Int'.
+length :: Buffer -> Int
+length (PS _ _ l _) = assert (l >= 0) $ l
+{-# INLINE length #-}
+
+------------------------------------------------------------------------
+
+-- | /O(n)/ 'cons' is analogous to (:) for lists, but of different
+-- complexity, as it requires a memcpy.
+cons :: Word8 -> Buffer -> Buffer
+cons c (PS x s l e) = unsafeCreate' (l+1) $ \p -> withForeignPtr x $ \f -> do
+        poke p c
+        memcpy (p `plusPtr` 1) (f `plusPtr` s) (fromIntegral l)
+        return $! if c >= 0x80 && c < 0xC0 then e + 1 else e
+{-# INLINE cons #-}
+
+-- | /O(n)/ Append a byte to the end of a 'Buffer'
+snoc :: Buffer -> Word8 -> Buffer
+snoc (PS x s l e) c = unsafeCreate' (l+1) $ \p -> withForeignPtr x $ \f -> do
+        memcpy p (f `plusPtr` s) (fromIntegral l)
+        poke (p `plusPtr` l) c
+        return $! if c >= 0x80 then e + 1 else e
+{-# INLINE snoc #-}
+
+-- todo fuse
+
+-- | /O(1)/ Extract the first element of a Buffer, which must be non-empty.
+-- An exception will be thrown in the case of an empty Buffer.
+head :: Buffer -> Word8
+head (PS x s l _)
+    | l <= 0    = errorEmptyList "head"
+    | otherwise = inlinePerformIO $ withForeignPtr x $ \p -> peekByteOff p s
+{-# INLINE head #-}
+
+-- | /O(1)/ Extract the elements after the head of a Buffer, which must be non-empty.
+-- An exception will be thrown in the case of an empty Buffer.
+tail :: Buffer -> Buffer
+tail (PS p s l e)
+    | l <= 0    = errorEmptyList "tail"
+    | otherwise = PS p (s+1) (l-1) $!
+        if e == 0 || (inlinePerformIO $ withForeignPtr ps $ \p -> peekByteOff p s) < 0x80
+        then e
+        else e - 1       
+{-# INLINE tail #-}
+
+-- | /O(1)/ Extract the head and tail of a Buffer, returning Nothing
+-- if it is empty.
+uncons :: Buffer -> Maybe (Word8, Buffer)
+uncons (PS x s l e)
+    | l <= 0    = Nothing   
+    | otherwise = let h = inlinePerformIO $ withForeignPtr x
+                                        $ \p -> peekByteOff p s in
+                  Just (h, PS x (s+1) (l-1) $! if h < 0x80 then e else e - 1)
+{-# INLINE uncons #-}
+
+-- | /O(1)/ Extract the last element of a Buffer, which must be finite and non-empty.
+-- An exception will be thrown in the case of an empty Buffer.
+last :: Buffer -> Word8
+last (PS x s l _)
+    | l <= 0   = errorEmptyList "last"
+    | otherwise = inlinePerformIO $ withForeignPtr x $ \p -> peekByteOff p (s+l-1)
+{-# INLINE last #-}
+
+-- | /O(1)/ Return all the elements of a 'Buffer' except the last one.
+-- An exception will be thrown in the case of an empty Buffer.
+init :: Buffer -> Buffer
+init ps@(PS p s l e)
+    | null ps   = errorEmptyList "init"
+    | otherwise = PS p s (l-1) $!
+        if e == 0 || (inlinePerformIO $ withForeignPtr ps $ \p -> peekByteOff p (s+l-1)) < 0x80
+        then e
+        else e - 1   
+{-# INLINE init #-}
+
+-- | /O(n)/ Append two Buffers
+append :: Buffer -> Buffer -> Buffer
+append xs ys | null xs   = ys
+             | null ys   = xs
+             | otherwise = concat [xs,ys]
+{-# INLINE append #-}
+
+-- ---------------------------------------------------------------------
+-- Transformations
+
+-- EAK: is inlinePerformIO correct here? create' _does_ perform allocation
+
+-- | /O(n)/ 'map' @f xs@ is the Buffer obtained by applying @f@ to each
+-- element of @xs@. This function is subject to array fusion.
+map :: (Word8 -> Word8) -> Buffer -> Buffer
+map f (PS fp s len) = inlinePerformIO $ withForeignPtr fp $ \a ->
+    create' len $ map_ 0 (a `plusPtr` s) 0
+  where
+    map_ :: Int -> Ptr Word8 -> Ptr Word8 -> Int -> IO Int
+    STRICT4(map_)
+    map_ n p1 p2 acc
+       | n >= len = return acc
+       | otherwise = do
+            x <- peekByteOff p1 n
+            let x' = f x
+            pokeByteOff p2 n x'
+            map_ (n+1) p1 p2 $!
+                if x' < 0x80 
+                then acc 
+                else acc + 1
+            
+{-# INLINE map #-}
+
+-- | /O(n)/ 'reverse' @xs@ efficiently returns the elements of @xs@ in reverse order.
+reverse :: Buffer -> Buffer
+reverse (PS x s l e) = unsafeCreate' l $ \p -> withForeignPtr x $ \f -> do
+        c_reverse p (f `plusPtr` s) (fromIntegral l)
+        return e
+
+-- | /O(n)/ The 'intersperse' function takes a 'Word8' and a
+-- 'Buffer' and \`intersperses\' that byte between the elements of
+-- the 'Buffer'.  It is analogous to the intersperse function on
+-- Lists.
+intersperse :: Word8 -> Buffer -> Buffer
+intersperse c ps@(PS x s l e)
+    | length ps < 2  = ps
+    | otherwise      = unsafeCreate' (2*l-1) $ \p -> withForeignPtr x $ \f -> do
+        c_intersperse p (f `plusPtr` s) (fromIntegral l) c
+        return $!
+            if c >= 0x80
+            then e + l - 1
+            else e
+
+-- | The 'transpose' function transposes the rows and columns of its
+-- 'Buffer' argument.
+transpose :: [Buffer] -> [Buffer]
+transpose ps = P.map pack (List.transpose (P.map unpack ps))
+
+-- ---------------------------------------------------------------------
+-- Reducing 'Buffer's
+
+-- | 'foldl', applied to a binary operator, a starting value (typically
+-- the left-identity of the operator), and a Buffer, reduces the
+-- Buffer using the binary operator, from left to right.
+--
+-- This function is subject to array fusion.
+--
+foldl :: (a -> Word8 -> a) -> a -> Buffer -> a
+foldl f v (PS x s l _) = inlinePerformIO $ withForeignPtr x $ \ptr ->
+        lgo v (ptr `plusPtr` s) (ptr `plusPtr` (s+l))
+    where
+        STRICT3(lgo)
+        lgo z p q | p == q    = return z
+                  | otherwise = do c <- peek p
+                                   lgo (f z c) (p `plusPtr` 1) q
+{-# INLINE foldl #-}
+
+-- | 'foldl\'' is like 'foldl', but strict in the accumulator.
+-- However, for Buffers, all left folds are strict in the accumulator.
+--
+foldl' :: (a -> Word8 -> a) -> a -> Buffer -> a
+foldl' = foldl
+{-# INLINE foldl' #-}
+
+-- | 'foldr', applied to a binary operator, a starting value
+-- (typically the right-identity of the operator), and a Buffer,
+-- reduces the Buffer using the binary operator, from right to left.
+foldr :: (Word8 -> a -> a) -> a -> Buffer -> a
+foldr k v (PS x s l _) = inlinePerformIO $ withForeignPtr x $ \ptr ->
+        go v (ptr `plusPtr` (s+l-1)) (ptr `plusPtr` (s-1))
+    where
+        STRICT3(go)
+        go z p q | p == q    = return z
+                 | otherwise = do c  <- peek p
+                                  go (c `k` z) (p `plusPtr` (-1)) q -- tail recursive
+{-# INLINE foldr #-}
+
+-- | 'foldr\'' is like 'foldr', but strict in the accumulator.
+foldr' :: (Word8 -> a -> a) -> a -> Buffer -> a
+foldr' k v (PS x s l _) = inlinePerformIO $ withForeignPtr x $ \ptr ->
+        go v (ptr `plusPtr` (s+l-1)) (ptr `plusPtr` (s-1))
+    where
+        STRICT3(go)
+        go z p q | p == q    = return z
+                 | otherwise = do c  <- peek p
+                                  go (c `k` z) (p `plusPtr` (-1)) q -- tail recursive
+{-# INLINE foldr' #-}
+
+-- | 'foldl1' is a variant of 'foldl' that has no starting value
+-- argument, and thus must be applied to non-empty 'Buffers'.
+-- This function is subject to array fusion. 
+-- An exception will be thrown in the case of an empty Buffer.
+foldl1 :: (Word8 -> Word8 -> Word8) -> Buffer -> Word8
+foldl1 f ps
+    | null ps   = errorEmptyList "foldl1"
+    | otherwise = foldl f (unsafeHead ps) (unsafeTail ps)
+{-# INLINE foldl1 #-}
+
+-- | 'foldl1\'' is like 'foldl1', but strict in the accumulator.
+-- An exception will be thrown in the case of an empty Buffer.
+foldl1' :: (Word8 -> Word8 -> Word8) -> Buffer -> Word8
+foldl1' f ps
+    | null ps   = errorEmptyList "foldl1'"
+    | otherwise = foldl' f (unsafeHead ps) (unsafeTail ps)
+{-# INLINE foldl1' #-}
+
+-- | 'foldr1' is a variant of 'foldr' that has no starting value argument,
+-- and thus must be applied to non-empty 'Buffer's
+-- An exception will be thrown in the case of an empty Buffer.
+foldr1 :: (Word8 -> Word8 -> Word8) -> Buffer -> Word8
+foldr1 f ps
+    | null ps        = errorEmptyList "foldr1"
+    | otherwise      = foldr f (last ps) (init ps)
+{-# INLINE foldr1 #-}
+
+-- | 'foldr1\'' is a variant of 'foldr1', but is strict in the
+-- accumulator.
+foldr1' :: (Word8 -> Word8 -> Word8) -> Buffer -> Word8
+foldr1' f ps
+    | null ps        = errorEmptyList "foldr1"
+    | otherwise      = foldr' f (last ps) (init ps)
+{-# INLINE foldr1' #-}
+
+-- ---------------------------------------------------------------------
+-- Special folds
+
+-- EAK: TODO: pick up here and keep hacking
+
+-- | /O(n)/ Concatenate a list of Buffers.
+concat :: [Buffer] -> Buffer
+concat []     = empty
+concat [ps]   = ps
+concat xs     = unsafeCreate len $ \ptr -> go xs ptr
+  where len = P.sum . P.map length $ xs
+        STRICT2(go)
+        go []            _   = return ()
+        go (PS p s l:ps) ptr = do
+                withForeignPtr p $ \fp -> memcpy ptr (fp `plusPtr` s) (fromIntegral l)
+                go ps (ptr `plusPtr` l)
+
+-- | Map a function over a 'Buffer' and concatenate the results
+concatMap :: (Word8 -> Buffer) -> Buffer -> Buffer
+concatMap f = concat . foldr ((:) . f) []
+
+-- foldr (append . f) empty
+
+-- | /O(n)/ Applied to a predicate and a Buffer, 'any' determines if
+-- any element of the 'Buffer' satisfies the predicate.
+any :: (Word8 -> Bool) -> Buffer -> Bool
+any _ (PS _ _ 0) = False
+any f (PS x s l) = inlinePerformIO $ withForeignPtr x $ \ptr ->
+        go (ptr `plusPtr` s) (ptr `plusPtr` (s+l))
+    where
+        STRICT2(go)
+        go p q | p == q    = return False
+               | otherwise = do c <- peek p
+                                if f c then return True
+                                       else go (p `plusPtr` 1) q
+{-# INLINE any #-}
+
+-- todo fuse
+
+-- | /O(n)/ Applied to a predicate and a 'Buffer', 'all' determines
+-- if all elements of the 'Buffer' satisfy the predicate.
+all :: (Word8 -> Bool) -> Buffer -> Bool
+all _ (PS _ _ 0) = True
+all f (PS x s l) = inlinePerformIO $ withForeignPtr x $ \ptr ->
+        go (ptr `plusPtr` s) (ptr `plusPtr` (s+l))
+    where
+        STRICT2(go)
+        go p q | p == q     = return True  -- end of list
+               | otherwise  = do c <- peek p
+                                 if f c
+                                    then go (p `plusPtr` 1) q
+                                    else return False
+{-# INLINE all #-}
+
+------------------------------------------------------------------------
+
+-- | /O(n)/ 'maximum' returns the maximum value from a 'Buffer'
+-- This function will fuse.
+-- An exception will be thrown in the case of an empty Buffer.
+maximum :: Buffer -> Word8
+maximum xs@(PS x s l)
+    | null xs   = errorEmptyList "maximum"
+    | otherwise = inlinePerformIO $ withForeignPtr x $ \p ->
+                      c_maximum (p `plusPtr` s) (fromIntegral l)
+{-# INLINE maximum #-}
+
+-- | /O(n)/ 'minimum' returns the minimum value from a 'Buffer'
+-- This function will fuse.
+-- An exception will be thrown in the case of an empty Buffer.
+minimum :: Buffer -> Word8
+minimum xs@(PS x s l)
+    | null xs   = errorEmptyList "minimum"
+    | otherwise = inlinePerformIO $ withForeignPtr x $ \p ->
+                      c_minimum (p `plusPtr` s) (fromIntegral l)
+{-# INLINE minimum #-}
+
+------------------------------------------------------------------------
+
+-- | The 'mapAccumL' function behaves like a combination of 'map' and
+-- 'foldl'; it applies a function to each element of a Buffer,
+-- passing an accumulating parameter from left to right, and returning a
+-- final value of this accumulator together with the new list.
+mapAccumL :: (acc -> Word8 -> (acc, Word8)) -> acc -> Buffer -> (acc, Buffer)
+mapAccumL f acc (PS fp o len) = inlinePerformIO $ withForeignPtr fp $ \a -> do
+    gp   <- mallocBuffer len
+    acc' <- withForeignPtr gp $ \p -> mapAccumL_ acc 0 (a `plusPtr` o) p
+    return $! (acc', PS gp 0 len)
+  where
+    STRICT4(mapAccumL_)
+    mapAccumL_ s n p1 p2
+       | n >= len = return s
+       | otherwise = do
+            x <- peekByteOff p1 n
+            let (s', y) = f s x
+            pokeByteOff p2 n y
+            mapAccumL_ s' (n+1) p1 p2
+{-# INLINE mapAccumL #-}
+
+-- | The 'mapAccumR' function behaves like a combination of 'map' and
+-- 'foldr'; it applies a function to each element of a Buffer,
+-- passing an accumulating parameter from right to left, and returning a
+-- final value of this accumulator together with the new Buffer.
+mapAccumR :: (acc -> Word8 -> (acc, Word8)) -> acc -> Buffer -> (acc, Buffer)
+mapAccumR f acc (PS fp o len) = inlinePerformIO $ withForeignPtr fp $ \a -> do
+    gp   <- mallocBuffer len
+    acc' <- withForeignPtr gp $ \p -> mapAccumR_ acc (len-1) (a `plusPtr` o) p
+    return $! (acc', PS gp 0 len)
+  where
+    STRICT4(mapAccumR_)
+    mapAccumR_ s n p q
+       | n <  0    = return s
+       | otherwise = do
+            x  <- peekByteOff p n
+            let (s', y) = f s x
+            pokeByteOff q n y
+            mapAccumR_ s' (n-1) p q
+{-# INLINE mapAccumR #-}
+
+-- ---------------------------------------------------------------------
+-- Building Buffers
+
+-- | 'scanl' is similar to 'foldl', but returns a list of successive
+-- reduced values from the left. This function will fuse.
+--
+-- > scanl f z [x1, x2, ...] == [z, z `f` x1, (z `f` x1) `f` x2, ...]
+--
+-- Note that
+--
+-- > last (scanl f z xs) == foldl f z xs.
+--
+scanl :: (Word8 -> Word8 -> Word8) -> Word8 -> Buffer -> Buffer
+
+scanl f v (PS fp s len) = inlinePerformIO $ withForeignPtr fp $ \a ->
+    create (len+1) $ \q -> do
+        poke q v
+        scanl_ v 0 (a `plusPtr` s) (q `plusPtr` 1)
+  where
+    STRICT4(scanl_)
+    scanl_ z n p q
+        | n >= len  = return ()
+        | otherwise = do
+            x <- peekByteOff p n
+            let z' = f z x
+            pokeByteOff q n z'
+            scanl_ z' (n+1) p q
+{-# INLINE scanl #-}
+
+    -- n.b. haskell's List scan returns a list one bigger than the
+    -- input, so we need to snoc here to get some extra space, however,
+    -- it breaks map/up fusion (i.e. scanl . map no longer fuses)
+
+-- | 'scanl1' is a variant of 'scanl' that has no starting value argument.
+-- This function will fuse.
+--
+-- > scanl1 f [x1, x2, ...] == [x1, x1 `f` x2, ...]
+scanl1 :: (Word8 -> Word8 -> Word8) -> Buffer -> Buffer
+scanl1 f ps
+    | null ps   = empty
+    | otherwise = scanl f (unsafeHead ps) (unsafeTail ps)
+{-# INLINE scanl1 #-}
+
+-- | scanr is the right-to-left dual of scanl.
+scanr :: (Word8 -> Word8 -> Word8) -> Word8 -> Buffer -> Buffer
+scanr f v (PS fp s len) = inlinePerformIO $ withForeignPtr fp $ \a ->
+    create (len+1) $ \q -> do
+        poke (q `plusPtr` len) v
+        scanr_ v (len-1) (a `plusPtr` s) q
+  where
+    STRICT4(scanr_)
+    scanr_ z n p q
+        | n <  0    = return ()
+        | otherwise = do
+            x <- peekByteOff p n
+            let z' = f x z
+            pokeByteOff q n z'
+            scanr_ z' (n-1) p q
+{-# INLINE scanr #-}
+
+-- | 'scanr1' is a variant of 'scanr' that has no starting value argument.
+scanr1 :: (Word8 -> Word8 -> Word8) -> Buffer -> Buffer
+scanr1 f ps
+    | null ps   = empty
+    | otherwise = scanr f (last ps) (init ps) -- todo, unsafe versions
+{-# INLINE scanr1 #-}
+
+-- ---------------------------------------------------------------------
+-- Unfolds and replicates
+
+-- | /O(n)/ 'replicate' @n x@ is a Buffer of length @n@ with @x@
+-- the value of every element. The following holds:
+--
+-- > replicate w c = unfoldr w (\u -> Just (u,u)) c
+--
+-- This implemenation uses @memset(3)@
+replicate :: Int -> Word8 -> Buffer
+replicate w c
+    | w <= 0    = empty
+    | otherwise = unsafeCreate w $ \ptr ->
+                      memset ptr c (fromIntegral w) >> return ()
+
+-- | /O(n)/, where /n/ is the length of the result.  The 'unfoldr' 
+-- function is analogous to the List \'unfoldr\'.  'unfoldr' builds a 
+-- Buffer from a seed value.  The function takes the element and 
+-- returns 'Nothing' if it is done producing the Buffer or returns 
+-- 'Just' @(a,b)@, in which case, @a@ is the next byte in the string, 
+-- and @b@ is the seed value for further production.
+--
+-- Examples:
+--
+-- >    unfoldr (\x -> if x <= 5 then Just (x, x + 1) else Nothing) 0
+-- > == pack [0, 1, 2, 3, 4, 5]
+--
+unfoldr :: (a -> Maybe (Word8, a)) -> a -> Buffer
+unfoldr f = concat . unfoldChunk 32 64
+  where unfoldChunk n n' x =
+          case unfoldrN n f x of
+            (s, Nothing) -> s : []
+            (s, Just x') -> s : unfoldChunk n' (n+n') x'
+{-# INLINE unfoldr #-}
+
+-- | /O(n)/ Like 'unfoldr', 'unfoldrN' builds a Buffer from a seed
+-- value.  However, the length of the result is limited by the first
+-- argument to 'unfoldrN'.  This function is more efficient than 'unfoldr'
+-- when the maximum length of the result is known.
+--
+-- The following equation relates 'unfoldrN' and 'unfoldr':
+--
+-- > snd (unfoldrN n f s) == take n (unfoldr f s)
+--
+unfoldrN :: Int -> (a -> Maybe (Word8, a)) -> a -> (Buffer, Maybe a)
+unfoldrN i f x0
+    | i < 0     = (empty, Just x0)
+    | otherwise = unsafePerformIO $ createAndTrim' i $ \p -> go p x0 0
+  where STRICT3(go)
+        go p x n =
+          case f x of
+            Nothing      -> return (0, n, Nothing)
+            Just (w,x')
+             | n == i    -> return (0, n, Just x)
+             | otherwise -> do poke p w
+                               go (p `plusPtr` 1) x' (n+1)
+{-# INLINE unfoldrN #-}
+
+-- ---------------------------------------------------------------------
+-- Substrings
+
+-- | /O(1)/ 'take' @n@, applied to a Buffer @xs@, returns the prefix
+-- of @xs@ of length @n@, or @xs@ itself if @n > 'length' xs@.
+take :: Int -> Buffer -> Buffer
+take n ps@(PS x s l)
+    | n <= 0    = empty
+    | n >= l    = ps
+    | otherwise = PS x s n
+{-# INLINE take #-}
+
+-- | /O(1)/ 'drop' @n xs@ returns the suffix of @xs@ after the first @n@
+-- elements, or @[]@ if @n > 'length' xs@.
+drop  :: Int -> Buffer -> Buffer
+drop n ps@(PS x s l)
+    | n <= 0    = ps
+    | n >= l    = empty
+    | otherwise = PS x (s+n) (l-n)
+{-# INLINE drop #-}
+
+-- | /O(1)/ 'splitAt' @n xs@ is equivalent to @('take' n xs, 'drop' n xs)@.
+splitAt :: Int -> Buffer -> (Buffer, Buffer)
+splitAt n ps@(PS x s l)
+    | n <= 0    = (empty, ps)
+    | n >= l    = (ps, empty)
+    | otherwise = (PS x s n, PS x (s+n) (l-n))
+{-# INLINE splitAt #-}
+
+-- | 'takeWhile', applied to a predicate @p@ and a Buffer @xs@,
+-- returns the longest prefix (possibly empty) of @xs@ of elements that
+-- satisfy @p@.
+takeWhile :: (Word8 -> Bool) -> Buffer -> Buffer
+takeWhile f ps = unsafeTake (findIndexOrEnd (not . f) ps) ps
+{-# INLINE takeWhile #-}
+
+-- | 'dropWhile' @p xs@ returns the suffix remaining after 'takeWhile' @p xs@.
+dropWhile :: (Word8 -> Bool) -> Buffer -> Buffer
+dropWhile f ps = unsafeDrop (findIndexOrEnd (not . f) ps) ps
+{-# INLINE dropWhile #-}
+
+-- instead of findIndexOrEnd, we could use memchr here.
+
+-- | 'break' @p@ is equivalent to @'span' ('not' . p)@.
+--
+-- Under GHC, a rewrite rule will transform break (==) into a
+-- call to the specialised breakByte:
+--
+-- > break ((==) x) = breakByte x
+-- > break (==x) = breakByte x
+--
+break :: (Word8 -> Bool) -> Buffer -> (Buffer, Buffer)
+break p ps = case findIndexOrEnd p ps of n -> (unsafeTake n ps, unsafeDrop n ps)
+#if __GLASGOW_HASKELL__ 
+{-# INLINE [1] break #-}
+#endif
+
+#if __GLASGOW_HASKELL__ >= 606
+-- This RULE LHS is not allowed by ghc-6.4
+{-# RULES
+"Buffer specialise break (x==)" forall x.
+    break ((==) x) = breakByte x
+"Buffer specialise break (==x)" forall x.
+    break (==x) = breakByte x
+  #-}
+#endif
+
+-- INTERNAL:
+
+-- | 'breakByte' breaks its Buffer argument at the first occurence
+-- of the specified byte. It is more efficient than 'break' as it is
+-- implemented with @memchr(3)@. I.e.
+-- 
+-- > break (=='c') "abcd" == breakByte 'c' "abcd"
+--
+breakByte :: Word8 -> Buffer -> (Buffer, Buffer)
+breakByte c p = case elemIndex c p of
+    Nothing -> (p,empty)
+    Just n  -> (unsafeTake n p, unsafeDrop n p)
+{-# INLINE breakByte #-}
+
+-- | 'breakEnd' behaves like 'break' but from the end of the 'Buffer'
+-- 
+-- breakEnd p == spanEnd (not.p)
+breakEnd :: (Word8 -> Bool) -> Buffer -> (Buffer, Buffer)
+breakEnd  p ps = splitAt (findFromEndUntil p ps) ps
+
+-- | 'span' @p xs@ breaks the Buffer into two segments. It is
+-- equivalent to @('takeWhile' p xs, 'dropWhile' p xs)@
+span :: (Word8 -> Bool) -> Buffer -> (Buffer, Buffer)
+span p ps = break (not . p) ps
+#if __GLASGOW_HASKELL__
+{-# INLINE [1] span #-}
+#endif
+
+-- | 'spanByte' breaks its Buffer argument at the first
+-- occurence of a byte other than its argument. It is more efficient
+-- than 'span (==)'
+--
+-- > span  (=='c') "abcd" == spanByte 'c' "abcd"
+--
+spanByte :: Word8 -> Buffer -> (Buffer, Buffer)
+spanByte c ps@(PS x s l) = inlinePerformIO $ withForeignPtr x $ \p ->
+    go (p `plusPtr` s) 0
+  where
+    STRICT2(go)
+    go p i | i >= l    = return (ps, empty)
+           | otherwise = do c' <- peekByteOff p i
+                            if c /= c'
+                                then return (unsafeTake i ps, unsafeDrop i ps)
+                                else go p (i+1)
+{-# INLINE spanByte #-}
+
+#if __GLASGOW_HASKELL__ >= 606
+-- This RULE LHS is not allowed by ghc-6.4
+{-# RULES
+"Buffer specialise span (x==)" forall x.
+    span ((==) x) = spanByte x
+"Buffer specialise span (==x)" forall x.
+    span (==x) = spanByte x
+  #-}
+#endif
+
+-- | 'spanEnd' behaves like 'span' but from the end of the 'Buffer'.
+-- We have
+--
+-- > spanEnd (not.isSpace) "x y z" == ("x y ","z")
+--
+-- and
+--
+-- > spanEnd (not . isSpace) ps
+-- >    == 
+-- > let (x,y) = span (not.isSpace) (reverse ps) in (reverse y, reverse x) 
+--
+spanEnd :: (Word8 -> Bool) -> Buffer -> (Buffer, Buffer)
+spanEnd  p ps = splitAt (findFromEndUntil (not.p) ps) ps
+
+-- | /O(n)/ Splits a 'Buffer' into components delimited by
+-- separators, where the predicate returns True for a separator element.
+-- The resulting components do not contain the separators.  Two adjacent
+-- separators result in an empty component in the output.  eg.
+--
+-- > splitWith (=='a') "aabbaca" == ["","","bb","c",""]
+-- > splitWith (=='a') []        == []
+--
+splitWith :: (Word8 -> Bool) -> Buffer -> [Buffer]
+
+#if defined(__GLASGOW_HASKELL__)
+splitWith _pred (PS _  _   0) = []
+splitWith pred_ (PS fp off len) = splitWith0 pred# off len fp
+  where pred# c# = pred_ (W8# c#)
+
+        STRICT4(splitWith0)
+        splitWith0 pred' off' len' fp' = withPtr fp $ \p ->
+            splitLoop pred' p 0 off' len' fp'
+
+        splitLoop :: (Word# -> Bool)
+                  -> Ptr Word8
+                  -> Int -> Int -> Int
+                  -> ForeignPtr Word8
+                  -> IO [Buffer]
+
+        splitLoop pred' p idx' off' len' fp'
+            | idx' >= len'  = return [PS fp' off' idx']
+            | otherwise = do
+                w <- peekElemOff p (off'+idx')
+                if pred' (case w of W8# w# -> w#)
+                   then return (PS fp' off' idx' :
+                              splitWith0 pred' (off'+idx'+1) (len'-idx'-1) fp')
+                   else splitLoop pred' p (idx'+1) off' len' fp'
+{-# INLINE splitWith #-}
+
+#else
+splitWith _ (PS _ _ 0) = []
+splitWith p ps = loop p ps
+    where
+        STRICT2(loop)
+        loop q qs = if null rest then [chunk]
+                                 else chunk : loop q (unsafeTail rest)
+            where (chunk,rest) = break q qs
+#endif
+
+-- | /O(n)/ Break a 'Buffer' into pieces separated by the byte
+-- argument, consuming the delimiter. I.e.
+--
+-- > split '\n' "a\nb\nd\ne" == ["a","b","d","e"]
+-- > split 'a'  "aXaXaXa"    == ["","X","X","X",""]
+-- > split 'x'  "x"          == ["",""]
+-- 
+-- and
+--
+-- > intercalate [c] . split c == id
+-- > split == splitWith . (==)
+-- 
+-- As for all splitting functions in this library, this function does
+-- not copy the substrings, it just constructs new 'Buffers' that
+-- are slices of the original.
+--
+split :: Word8 -> Buffer -> [Buffer]
+split _ (PS _ _ 0) = []
+split w (PS x s l) = loop 0
+    where
+        STRICT1(loop)
+        loop n =
+            let q = inlinePerformIO $ withForeignPtr x $ \p ->
+                      memchr (p `plusPtr` (s+n))
+                             w (fromIntegral (l-n))
+            in if q == nullPtr
+                then [PS x (s+n) (l-n)]
+                else let i = inlinePerformIO $ withForeignPtr x $ \p ->
+                               return (q `minusPtr` (p `plusPtr` s))
+                      in PS x (s+n) (i-n) : loop (i+1)
+
+{-# INLINE split #-}
+
+{-
+-- slower. but stays inside Haskell.
+split _ (PS _  _   0) = []
+split (W8# w#) (PS fp off len) = splitWith' off len fp
+    where
+        splitWith' off' len' fp' = withPtr fp $ \p ->
+            splitLoop p 0 off' len' fp'
+
+        splitLoop :: Ptr Word8
+                  -> Int -> Int -> Int
+                  -> ForeignPtr Word8
+                  -> IO [Buffer]
+
+        STRICT5(splitLoop)
+        splitLoop p idx' off' len' fp'
+            | idx' >= len'  = return [PS fp' off' idx']
+            | otherwise = do
+                (W8# x#) <- peekElemOff p (off'+idx')
+                if word2Int# w# ==# word2Int# x#
+                   then return (PS fp' off' idx' :
+                              splitWith' (off'+idx'+1) (len'-idx'-1) fp')
+                   else splitLoop p (idx'+1) off' len' fp'
+-}
+
+{-
+-- | Like 'splitWith', except that sequences of adjacent separators are
+-- treated as a single separator. eg.
+-- 
+-- > tokens (=='a') "aabbaca" == ["bb","c"]
+--
+tokens :: (Word8 -> Bool) -> Buffer -> [Buffer]
+tokens f = P.filter (not.null) . splitWith f
+{-# INLINE tokens #-}
+-}
+
+-- | The 'group' function takes a Buffer and returns a list of
+-- Buffers such that the concatenation of the result is equal to the
+-- argument.  Moreover, each sublist in the result contains only equal
+-- elements.  For example,
+--
+-- > group "Mississippi" = ["M","i","ss","i","ss","i","pp","i"]
+--
+-- It is a special case of 'groupBy', which allows the programmer to
+-- supply their own equality test. It is about 40% faster than 
+-- /groupBy (==)/
+group :: Buffer -> [Buffer]
+group xs
+    | null xs   = []
+    | otherwise = ys : group zs
+    where
+        (ys, zs) = spanByte (unsafeHead xs) xs
+
+-- | The 'groupBy' function is the non-overloaded version of 'group'.
+groupBy :: (Word8 -> Word8 -> Bool) -> Buffer -> [Buffer]
+groupBy k xs
+    | null xs   = []
+    | otherwise = unsafeTake n xs : groupBy k (unsafeDrop n xs)
+    where
+        n = 1 + findIndexOrEnd (not . k (unsafeHead xs)) (unsafeTail xs)
+
+-- | /O(n)/ The 'intercalate' function takes a 'Buffer' and a list of
+-- 'Buffer's and concatenates the list after interspersing the first
+-- argument between each element of the list.
+intercalate :: Buffer -> [Buffer] -> Buffer
+intercalate s = concat . (List.intersperse s)
+{-# INLINE [1] intercalate #-}
+
+{-# RULES
+"Buffer specialise intercalate c -> intercalateByte" forall c s1 s2 .
+    intercalate (singleton c) (s1 : s2 : []) = intercalateWithByte c s1 s2
+  #-}
+
+-- | /O(n)/ intercalateWithByte. An efficient way to join to two Buffers
+-- with a char. Around 4 times faster than the generalised join.
+--
+intercalateWithByte :: Word8 -> Buffer -> Buffer -> Buffer
+intercalateWithByte c f@(PS ffp s l) g@(PS fgp t m) = unsafeCreate len $ \ptr ->
+    withForeignPtr ffp $ \fp ->
+    withForeignPtr fgp $ \gp -> do
+        memcpy ptr (fp `plusPtr` s) (fromIntegral l)
+        poke (ptr `plusPtr` l) c
+        memcpy (ptr `plusPtr` (l + 1)) (gp `plusPtr` t) (fromIntegral m)
+    where
+      len = length f + length g + 1
+{-# INLINE intercalateWithByte #-}
+
+-- ---------------------------------------------------------------------
+-- Indexing Buffers
+
+-- | /O(1)/ 'Buffer' index (subscript) operator, starting from 0.
+index :: Buffer -> Int -> Word8
+index ps n
+    | n < 0          = moduleError "index" ("negative index: " ++ show n)
+    | n >= length ps = moduleError "index" ("index too large: " ++ show n
+                                         ++ ", length = " ++ show (length ps))
+    | otherwise      = ps `unsafeIndex` n
+{-# INLINE index #-}
+
+-- | /O(n)/ The 'elemIndex' function returns the index of the first
+-- element in the given 'Buffer' which is equal to the query
+-- element, or 'Nothing' if there is no such element. 
+-- This implementation uses memchr(3).
+elemIndex :: Word8 -> Buffer -> Maybe Int
+elemIndex c (PS x s l) = inlinePerformIO $ withForeignPtr x $ \p -> do
+    let p' = p `plusPtr` s
+    q <- memchr p' c (fromIntegral l)
+    return $! if q == nullPtr then Nothing else Just $! q `minusPtr` p'
+{-# INLINE elemIndex #-}
+
+-- | /O(n)/ The 'elemIndexEnd' function returns the last index of the
+-- element in the given 'Buffer' which is equal to the query
+-- element, or 'Nothing' if there is no such element. The following
+-- holds:
+--
+-- > elemIndexEnd c xs == 
+-- > (-) (length xs - 1) `fmap` elemIndex c (reverse xs)
+--
+elemIndexEnd :: Word8 -> Buffer -> Maybe Int
+elemIndexEnd ch (PS x s l) = inlinePerformIO $ withForeignPtr x $ \p ->
+    go (p `plusPtr` s) (l-1)
+  where
+    STRICT2(go)
+    go p i | i < 0     = return Nothing
+           | otherwise = do ch' <- peekByteOff p i
+                            if ch == ch'
+                                then return $ Just i
+                                else go p (i-1)
+{-# INLINE elemIndexEnd #-}
+
+-- | /O(n)/ The 'elemIndices' function extends 'elemIndex', by returning
+-- the indices of all elements equal to the query element, in ascending order.
+-- This implementation uses memchr(3).
+elemIndices :: Word8 -> Buffer -> [Int]
+elemIndices w (PS x s l) = loop 0
+    where
+        STRICT1(loop)
+        loop n = let q = inlinePerformIO $ withForeignPtr x $ \p ->
+                           memchr (p `plusPtr` (n+s))
+                                                w (fromIntegral (l - n))
+                 in if q == nullPtr
+                        then []
+                        else let i = inlinePerformIO $ withForeignPtr x $ \p ->
+                                       return (q `minusPtr` (p `plusPtr` s))
+                             in i : loop (i+1)
+{-# INLINE elemIndices #-}
+
+{-
+-- much slower
+elemIndices :: Word8 -> Buffer -> [Int]
+elemIndices c ps = loop 0 ps
+   where STRICT2(loop)
+         loop _ ps' | null ps'            = []
+         loop n ps' | c == unsafeHead ps' = n : loop (n+1) (unsafeTail ps')
+                    | otherwise           = loop (n+1) (unsafeTail ps')
+-}
+
+-- | count returns the number of times its argument appears in the Buffer
+--
+-- > count = length . elemIndices
+--
+-- But more efficiently than using length on the intermediate list.
+count :: Word8 -> Buffer -> Int
+count w (PS x s m) = inlinePerformIO $ withForeignPtr x $ \p ->
+    fmap fromIntegral $ c_count (p `plusPtr` s) (fromIntegral m) w
+{-# INLINE count #-}
+
+{-
+--
+-- around 30% slower
+--
+count w (PS x s m) = inlinePerformIO $ withForeignPtr x $ \p ->
+     go (p `plusPtr` s) (fromIntegral m) 0
+    where
+        go :: Ptr Word8 -> CSize -> Int -> IO Int
+        STRICT3(go)
+        go p l i = do
+            q <- memchr p w l
+            if q == nullPtr
+                then return i
+                else do let k = fromIntegral $ q `minusPtr` p
+                        go (q `plusPtr` 1) (l-k-1) (i+1)
+-}
+
+-- | The 'findIndex' function takes a predicate and a 'Buffer' and
+-- returns the index of the first element in the Buffer
+-- satisfying the predicate.
+findIndex :: (Word8 -> Bool) -> Buffer -> Maybe Int
+findIndex k (PS x s l) = inlinePerformIO $ withForeignPtr x $ \f -> go (f `plusPtr` s) 0
+  where
+    STRICT2(go)
+    go ptr n | n >= l    = return Nothing
+             | otherwise = do w <- peek ptr
+                              if k w
+                                then return (Just n)
+                                else go (ptr `plusPtr` 1) (n+1)
+{-# INLINE findIndex #-}
+
+-- | The 'findIndices' function extends 'findIndex', by returning the
+-- indices of all elements satisfying the predicate, in ascending order.
+findIndices :: (Word8 -> Bool) -> Buffer -> [Int]
+findIndices p ps = loop 0 ps
+   where
+     STRICT2(loop)
+     loop n qs | null qs           = []
+               | p (unsafeHead qs) = n : loop (n+1) (unsafeTail qs)
+               | otherwise         =     loop (n+1) (unsafeTail qs)
+
+-- ---------------------------------------------------------------------
+-- Searching Buffers
+
+-- | /O(n)/ 'elem' is the 'Buffer' membership predicate.
+elem :: Word8 -> Buffer -> Bool
+elem c ps = case elemIndex c ps of Nothing -> False ; _ -> True
+{-# INLINE elem #-}
+
+-- | /O(n)/ 'notElem' is the inverse of 'elem'
+notElem :: Word8 -> Buffer -> Bool
+notElem c ps = not (elem c ps)
+{-# INLINE notElem #-}
+
+-- | /O(n)/ 'filter', applied to a predicate and a Buffer,
+-- returns a Buffer containing those characters that satisfy the
+-- predicate. This function is subject to array fusion.
+filter :: (Word8 -> Bool) -> Buffer -> Buffer
+filter k ps@(PS x s l)
+    | null ps   = ps
+    | otherwise = unsafePerformIO $ createAndTrim l $ \p -> withForeignPtr x $ \f -> do
+        t <- go (f `plusPtr` s) p (f `plusPtr` (s + l))
+        return $! t `minusPtr` p -- actual length
+    where
+        STRICT3(go)
+        go f t end | f == end  = return t
+                   | otherwise = do
+                        w <- peek f
+                        if k w
+                            then poke t w >> go (f `plusPtr` 1) (t `plusPtr` 1) end
+                            else             go (f `plusPtr` 1) t               end
+{-# INLINE filter #-}
+
+{-
+--
+-- | /O(n)/ A first order equivalent of /filter . (==)/, for the common
+-- case of filtering a single byte. It is more efficient to use
+-- /filterByte/ in this case.
+--
+-- > filterByte == filter . (==)
+--
+-- filterByte is around 10x faster, and uses much less space, than its
+-- filter equivalent
+--
+filterByte :: Word8 -> Buffer -> Buffer
+filterByte w ps = replicate (count w ps) w
+{-# INLINE filterByte #-}
+
+{-# RULES
+"Buffer specialise filter (== x)" forall x.
+    filter ((==) x) = filterByte x
+"Buffer specialise filter (== x)" forall x.
+    filter (== x) = filterByte x
+  #-}
+-}
+
+-- | /O(n)/ The 'find' function takes a predicate and a Buffer,
+-- and returns the first element in matching the predicate, or 'Nothing'
+-- if there is no such element.
+--
+-- > find f p = case findIndex f p of Just n -> Just (p ! n) ; _ -> Nothing
+--
+find :: (Word8 -> Bool) -> Buffer -> Maybe Word8
+find f p = case findIndex f p of
+                    Just n -> Just (p `unsafeIndex` n)
+                    _      -> Nothing
+{-# INLINE find #-}
+
+{-
+--
+-- fuseable, but we don't want to walk the whole array.
+-- 
+find k = foldl findEFL Nothing
+    where findEFL a@(Just _) _ = a
+          findEFL _          c | k c       = Just c
+                               | otherwise = Nothing
+-}
+
+-- | /O(n)/ The 'partition' function takes a predicate a Buffer and returns
+-- the pair of Buffers with elements which do and do not satisfy the
+-- predicate, respectively; i.e.,
+--
+-- > partition p bs == (filter p xs, filter (not . p) xs)
+--
+partition :: (Word8 -> Bool) -> Buffer -> (Buffer, Buffer)
+partition p bs = (filter p bs, filter (not . p) bs)
+--TODO: use a better implementation
+
+-- ---------------------------------------------------------------------
+-- Searching for substrings
+
+-- | /O(n)/ The 'isPrefixOf' function takes two Buffers and returns 'True'
+-- iff the first is a prefix of the second.
+isPrefixOf :: Buffer -> Buffer -> Bool
+isPrefixOf (PS x1 s1 l1) (PS x2 s2 l2)
+    | l1 == 0   = True
+    | l2 < l1   = False
+    | otherwise = inlinePerformIO $ withForeignPtr x1 $ \p1 ->
+        withForeignPtr x2 $ \p2 -> do
+            i <- memcmp (p1 `plusPtr` s1) (p2 `plusPtr` s2) (fromIntegral l1)
+            return $! i == 0
+
+-- | /O(n)/ The 'isSuffixOf' function takes two Buffers and returns 'True'
+-- iff the first is a suffix of the second.
+-- 
+-- The following holds:
+--
+-- > isSuffixOf x y == reverse x `isPrefixOf` reverse y
+--
+-- However, the real implemenation uses memcmp to compare the end of the
+-- string only, with no reverse required..
+isSuffixOf :: Buffer -> Buffer -> Bool
+isSuffixOf (PS x1 s1 l1) (PS x2 s2 l2)
+    | l1 == 0   = True
+    | l2 < l1   = False
+    | otherwise = inlinePerformIO $ withForeignPtr x1 $ \p1 ->
+        withForeignPtr x2 $ \p2 -> do
+            i <- memcmp (p1 `plusPtr` s1) (p2 `plusPtr` s2 `plusPtr` (l2 - l1)) (fromIntegral l1)
+            return $! i == 0
+
+-- | Check whether one string is a substring of another. @isInfixOf
+-- p s@ is equivalent to @not (null (findSubstrings p s))@.
+isInfixOf :: Buffer -> Buffer -> Bool
+isInfixOf p s = isJust (findSubstring p s)
+
+-- | Break a string on a substring, returning a pair of the part of the
+-- string prior to the match, and the rest of the string.
+--
+-- The following relationships hold:
+--
+-- > break (== c) l == breakSubstring (singleton c) l
+--
+-- and:
+--
+-- > findSubstring s l ==
+-- >    if null s then Just 0
+-- >              else case breakSubstring s l of
+-- >                       (x,y) | null y    -> Nothing
+-- >                             | otherwise -> Just (length x)
+--
+-- For example, to tokenise a string, dropping delimiters:
+--
+-- > tokenise x y = h : if null t then [] else tokenise x (drop (length x) t)
+-- >     where (h,t) = breakSubstring x y
+--
+-- To skip to the first occurence of a string:
+-- 
+-- > snd (breakSubstring x y) 
+--
+-- To take the parts of a string before a delimiter:
+--
+-- > fst (breakSubstring x y) 
+--
+breakSubstring :: Buffer -- ^ String to search for
+               -> Buffer -- ^ String to search in
+               -> (Buffer,Buffer) -- ^ Head and tail of string broken at substring
+
+breakSubstring pat src = search 0 src
+  where
+    STRICT2(search)
+    search n s
+        | null s             = (src,empty)      -- not found
+        | pat `isPrefixOf` s = (take n src,s)
+        | otherwise          = search (n+1) (unsafeTail s)
+
+-- | Get the first index of a substring in another string,
+--   or 'Nothing' if the string is not found.
+--   @findSubstring p s@ is equivalent to @listToMaybe (findSubstrings p s)@.
+findSubstring :: Buffer -- ^ String to search for.
+              -> Buffer -- ^ String to seach in.
+              -> Maybe Int
+findSubstring f i = listToMaybe (findSubstrings f i)
+
+{-# DEPRECATED findSubstring "findSubstring is deprecated in favour of breakSubstring." #-}
+
+{-
+findSubstring pat str = search 0 str
+    where
+        STRICT2(search)
+        search n s
+            = let x = pat `isPrefixOf` s
+              in
+                if null s
+                    then if x then Just n else Nothing
+                    else if x then Just n
+                              else     search (n+1) (unsafeTail s)
+-}
+
+-- | Find the indexes of all (possibly overlapping) occurances of a
+-- substring in a string.
+--
+findSubstrings :: Buffer -- ^ String to search for.
+               -> Buffer -- ^ String to seach in.
+               -> [Int]
+findSubstrings pat str
+    | null pat         = [0 .. length str]
+    | otherwise        = search 0 str
+  where
+    STRICT2(search)
+    search n s
+        | null s             = []
+        | pat `isPrefixOf` s = n : search (n+1) (unsafeTail s)
+        | otherwise          =     search (n+1) (unsafeTail s)
+
+{-# DEPRECATED findSubstrings "findSubstrings is deprecated in favour of breakSubstring." #-}
+
+{-
+{- This function uses the Knuth-Morris-Pratt string matching algorithm.  -}
+
+findSubstrings pat@(PS _ _ m) str@(PS _ _ n) = search 0 0
+  where
+      patc x = pat `unsafeIndex` x
+      strc x = str `unsafeIndex` x
+
+      -- maybe we should make kmpNext a UArray before using it in search?
+      kmpNext = listArray (0,m) (-1:kmpNextL pat (-1))
+      kmpNextL p _ | null p = []
+      kmpNextL p j = let j' = next (unsafeHead p) j + 1
+                         ps = unsafeTail p
+                         x = if not (null ps) && unsafeHead ps == patc j'
+                                then kmpNext Array.! j' else j'
+                        in x:kmpNextL ps j'
+      search i j = match ++ rest -- i: position in string, j: position in pattern
+        where match = if j == m then [(i - j)] else []
+              rest = if i == n then [] else search (i+1) (next (strc i) j + 1)
+      next c j | j >= 0 && (j == m || c /= patc j) = next c (kmpNext Array.! j)
+               | otherwise = j
+-}
+
+-- ---------------------------------------------------------------------
+-- Zipping
+
+-- | /O(n)/ 'zip' takes two Buffers and returns a list of
+-- corresponding pairs of bytes. If one input Buffer is short,
+-- excess elements of the longer Buffer are discarded. This is
+-- equivalent to a pair of 'unpack' operations.
+zip :: Buffer -> Buffer -> [(Word8,Word8)]
+zip ps qs
+    | null ps || null qs = []
+    | otherwise = (unsafeHead ps, unsafeHead qs) : zip (unsafeTail ps) (unsafeTail qs)
+
+-- | 'zipWith' generalises 'zip' by zipping with the function given as
+-- the first argument, instead of a tupling function.  For example,
+-- @'zipWith' (+)@ is applied to two Buffers to produce the list of
+-- corresponding sums. 
+zipWith :: (Word8 -> Word8 -> a) -> Buffer -> Buffer -> [a]
+zipWith f ps qs
+    | null ps || null qs = []
+    | otherwise = f (unsafeHead ps) (unsafeHead qs) : zipWith f (unsafeTail ps) (unsafeTail qs)
+
+--
+-- | A specialised version of zipWith for the common case of a
+-- simultaneous map over two Buffers, to build a 3rd. Rewrite rules
+-- are used to automatically covert zipWith into zipWith' when a pack is
+-- performed on the result of zipWith.
+--
+zipWith' :: (Word8 -> Word8 -> Word8) -> Buffer -> Buffer -> Buffer
+zipWith' f (PS fp s l) (PS fq t m) = inlinePerformIO $
+    withForeignPtr fp $ \a ->
+    withForeignPtr fq $ \b ->
+    create len $ zipWith_ 0 (a `plusPtr` s) (b `plusPtr` t)
+  where
+    zipWith_ :: Int -> Ptr Word8 -> Ptr Word8 -> Ptr Word8 -> IO ()
+    STRICT4(zipWith_)
+    zipWith_ n p1 p2 r
+       | n >= len = return ()
+       | otherwise = do
+            x <- peekByteOff p1 n
+            y <- peekByteOff p2 n
+            pokeByteOff r n (f x y)
+            zipWith_ (n+1) p1 p2 r
+
+    len = min l m
+{-# INLINE zipWith' #-}
+
+{-# RULES
+"Buffer specialise zipWith" forall (f :: Word8 -> Word8 -> Word8) p q .
+    zipWith f p q = unpack (zipWith' f p q)
+  #-}
+
+-- | /O(n)/ 'unzip' transforms a list of pairs of bytes into a pair of
+-- Buffers. Note that this performs two 'pack' operations.
+unzip :: [(Word8,Word8)] -> (Buffer,Buffer)
+unzip ls = (pack (P.map fst ls), pack (P.map snd ls))
+{-# INLINE unzip #-}
+
+-- ---------------------------------------------------------------------
+-- Special lists
+
+-- | /O(n)/ Return all initial segments of the given 'Buffer', shortest first.
+inits :: Buffer -> [Buffer]
+inits (PS x s l) = [PS x s n | n <- [0..l]]
+
+-- | /O(n)/ Return all final segments of the given 'Buffer', longest first.
+tails :: Buffer -> [Buffer]
+tails p | null p    = [empty]
+        | otherwise = p : tails (unsafeTail p)
+
+-- less efficent spacewise: tails (PS x s l) = [PS x (s+n) (l-n) | n <- [0..l]]
+
+-- ---------------------------------------------------------------------
+-- ** Ordered 'Buffer's
+
+-- | /O(n)/ Sort a Buffer efficiently, using counting sort.
+sort :: Buffer -> Buffer
+sort (PS input s l) = unsafeCreate l $ \p -> allocaArray 256 $ \arr -> do
+
+    _ <- memset (castPtr arr) 0 (256 * fromIntegral (sizeOf (undefined :: CSize)))
+    withForeignPtr input (\x -> countOccurrences arr (x `plusPtr` s) l)
+
+    let STRICT2(go)
+        go 256 _   = return ()
+        go i   ptr = do n <- peekElemOff arr i
+                        when (n /= 0) $ memset ptr (fromIntegral i) n >> return ()
+                        go (i + 1) (ptr `plusPtr` (fromIntegral n))
+    go 0 p
+  where
+    -- | Count the number of occurrences of each byte.
+    -- Used by 'sort'
+    --
+    countOccurrences :: Ptr CSize -> Ptr Word8 -> Int -> IO ()
+    STRICT3(countOccurrences)
+    countOccurrences counts str len = go 0
+     where
+        STRICT1(go)
+        go i | i == len    = return ()
+             | otherwise = do k <- fromIntegral `fmap` peekElemOff str i
+                              x <- peekElemOff counts k
+                              pokeElemOff counts k (x + 1)
+                              go (i + 1)
+
+{-
+sort :: Buffer -> Buffer
+sort (PS x s l) = unsafeCreate l $ \p -> withForeignPtr x $ \f -> do
+        memcpy p (f `plusPtr` s) l
+        c_qsort p l -- inplace
+-}
+
+-- The 'sortBy' function is the non-overloaded version of 'sort'.
+--
+-- Try some linear sorts: radix, counting
+-- Or mergesort.
+--
+-- sortBy :: (Word8 -> Word8 -> Ordering) -> Buffer -> Buffer
+-- sortBy f ps = undefined
+
+-- ---------------------------------------------------------------------
+-- Low level constructors
+
+-- | /O(n) construction/ Use a @Buffer@ with a function requiring a
+-- null-terminated @CString@.  The @CString@ will be freed
+-- automatically. This is a memcpy(3).
+useAsCString :: Buffer -> (CString -> IO a) -> IO a
+useAsCString (PS fp o l) action = do
+ allocaBytes (l+1) $ \buf ->
+   withForeignPtr fp $ \p -> do
+     memcpy buf (p `plusPtr` o) (fromIntegral l)
+     pokeByteOff buf l (0::Word8)
+     action (castPtr buf)
+
+-- | /O(n) construction/ Use a @Buffer@ with a function requiring a @CStringLen@.
+-- As for @useAsCString@ this function makes a copy of the original @Buffer@.
+useAsCStringLen :: Buffer -> (CStringLen -> IO a) -> IO a
+useAsCStringLen p@(PS _ _ l) f = useAsCString p $ \cstr -> f (cstr,l)
+
+------------------------------------------------------------------------
+
+-- | /O(n)./ Construct a new @Buffer@ from a @CString@. The
+-- resulting @Buffer@ is an immutable copy of the original
+-- @CString@, and is managed on the Haskell heap. The original
+-- @CString@ must be null terminated.
+packCString :: CString -> IO Buffer
+packCString cstr = do
+    len <- c_strlen cstr
+    packCStringLen (cstr, fromIntegral len)
+
+-- | /O(n)./ Construct a new @Buffer@ from a @CStringLen@. The
+-- resulting @Buffer@ is an immutable copy of the original @CStringLen@.
+-- The @Buffer@ is a normal Haskell value and will be managed on the
+-- Haskell heap.
+packCStringLen :: CStringLen -> IO Buffer
+packCStringLen (cstr, len) | len >= 0 = create len $ \p ->
+    memcpy p (castPtr cstr) (fromIntegral len)
+packCStringLen (_, len) =
+    moduleError "packCStringLen" ("negative length: " ++ show len)
+
+------------------------------------------------------------------------
+
+-- | /O(n)/ Make a copy of the 'Buffer' with its own storage. 
+-- This is mainly useful to allow the rest of the data pointed
+-- to by the 'Buffer' to be garbage collected, for example
+-- if a large string has been read in, and only a small part of it 
+-- is needed in the rest of the program.
+-- 
+copy :: Buffer -> Buffer
+copy (PS x s l) = unsafeCreate l $ \p -> withForeignPtr x $ \f ->
+    memcpy p (f `plusPtr` s) (fromIntegral l)
+
+-- ---------------------------------------------------------------------
+-- Line IO
+
+-- | Read a line from stdin.
+getLine :: IO Buffer
+getLine = hGetLine stdin
+
+-- | Read a line from a handle
+
+hGetLine :: Handle -> IO Buffer
+
+#if !defined(__GLASGOW_HASKELL__)
+
+hGetLine h = System.IO.hGetLine h >>= return . pack . P.map c2w
+
+#elif __GLASGOW_HASKELL__ >= 611
+
+hGetLine h =
+  wantReadableHandle_ "Data.Buffer.hGetLine" h $
+    \ h_@Handle__{haByteBuffer} -> do
+      flushCharReadBuffer h_
+      buf <- readIORef haByteBuffer
+      if isEmptyBuffer buf
+         then fill h_ buf 0 []
+         else haveBuf h_ buf 0 []
+ where
+
+  fill h_@Handle__{haByteBuffer,haDevice} buf len xss =
+    len `seq` do
+    (r,buf') <- Buffered.fillReadBuffer haDevice buf
+    if r == 0
+       then do writeIORef haByteBuffer buf{ bufR=0, bufL=0 }
+               if len > 0
+                  then mkBigPS len xss
+                  else ioe_EOF
+       else haveBuf h_ buf' len xss
+
+  haveBuf h_@Handle__{haByteBuffer}
+          buf@Buffer{ bufRaw=raw, bufR=w, bufL=r }
+          len xss =
+    do
+        off <- findEOL r w raw
+        let new_len = len + off - r
+        xs <- mkPS raw r off
+
+      -- if eol == True, then off is the offset of the '\n'
+      -- otherwise off == w and the buffer is now empty.
+        if off /= w
+            then do if (w == off + 1)
+                            then writeIORef haByteBuffer buf{ bufL=0, bufR=0 }
+                            else writeIORef haByteBuffer buf{ bufL = off + 1 }
+                    mkBigPS new_len (xs:xss)
+            else do
+                 fill h_ buf{ bufL=0, bufR=0 } new_len (xs:xss)
+
+  -- find the end-of-line character, if there is one
+  findEOL r w raw
+        | r == w = return w
+        | otherwise =  do
+            c <- readWord8Buf raw r
+            if c == fromIntegral (ord '\n')
+                then return r -- NB. not r+1: don't include the '\n'
+                else findEOL (r+1) w raw
+
+mkPS :: RawBuffer Word8 -> Int -> Int -> IO Buffer
+mkPS buf start end =
+ create len $ \p ->
+   withRawBuffer buf $ \pbuf -> do
+   copyBytes p (pbuf `plusPtr` start) len
+ where
+   len = end - start
+
+#else
+-- GHC 6.10 and older, pre-Unicode IO library
+
+hGetLine h = wantReadableHandle "Data.Buffer.hGetLine" h $ \ handle_ -> do
+    case haBufferMode handle_ of
+       NoBuffering -> error "no buffering"
+       _other      -> hGetLineBuffered handle_
+
+ where
+    hGetLineBuffered handle_ = do
+        let ref = haBuffer handle_
+        buf <- readIORef ref
+        hGetLineBufferedLoop handle_ ref buf 0 []
+
+    hGetLineBufferedLoop handle_ ref
+            buf@Buffer{ bufRPtr=r, bufWPtr=w, bufBuf=raw } len xss =
+        len `seq` do
+        off <- findEOL r w raw
+        let new_len = len + off - r
+        xs <- mkPS raw r off
+
+      -- if eol == True, then off is the offset of the '\n'
+      -- otherwise off == w and the buffer is now empty.
+        if off /= w
+            then do if (w == off + 1)
+                            then writeIORef ref buf{ bufRPtr=0, bufWPtr=0 }
+                            else writeIORef ref buf{ bufRPtr = off + 1 }
+                    mkBigPS new_len (xs:xss)
+            else do
+                 maybe_buf <- maybeFillReadBuffer (haFD handle_) True (haIsStream handle_)
+                                    buf{ bufWPtr=0, bufRPtr=0 }
+                 case maybe_buf of
+                    -- Nothing indicates we caught an EOF, and we may have a
+                    -- partial line to return.
+                    Nothing -> do
+                         writeIORef ref buf{ bufRPtr=0, bufWPtr=0 }
+                         if new_len > 0
+                            then mkBigPS new_len (xs:xss)
+                            else ioe_EOF
+                    Just new_buf ->
+                         hGetLineBufferedLoop handle_ ref new_buf new_len (xs:xss)
+
+    -- find the end-of-line character, if there is one
+    findEOL r w raw
+        | r == w = return w
+        | otherwise =  do
+            (c,r') <- readCharFromBuffer raw r
+            if c == '\n'
+                then return r -- NB. not r': don't include the '\n'
+                else findEOL r' w raw
+
+    maybeFillReadBuffer fd is_line is_stream buf = catch
+        (do buf' <- fillReadBuffer fd is_line is_stream buf
+            return (Just buf'))
+        (\e -> if isEOFError e then return Nothing else ioError e)
+
+-- TODO, rewrite to use normal memcpy
+mkPS :: RawBuffer -> Int -> Int -> IO Buffer
+mkPS buf start end =
+    let len = end - start
+    in create len $ \p -> do
+        memcpy_ptr_baoff p buf (fromIntegral start) (fromIntegral len)
+        return ()
+
+#endif
+
+mkBigPS :: Int -> [Buffer] -> IO Buffer
+mkBigPS _ [ps] = return ps
+mkBigPS _ pss = return $! concat (P.reverse pss)
+
+-- ---------------------------------------------------------------------
+-- Block IO
+
+-- | Outputs a 'Buffer' to the specified 'Handle'.
+hPut :: Handle -> Buffer -> IO ()
+hPut _ (PS _  _ 0) = return ()
+hPut h (PS ps s l) = withForeignPtr ps $ \p-> hPutBuf h (p `plusPtr` s) l
+
+-- | A synonym for @hPut@, for compatibility 
+hPutStr :: Handle -> Buffer -> IO ()
+hPutStr = hPut
+
+-- | Write a Buffer to a handle, appending a newline byte
+hPutStrLn :: Handle -> Buffer -> IO ()
+hPutStrLn h ps
+    | length ps < 1024 = hPut h (ps `snoc` 0x0a)
+    | otherwise        = hPut h ps >> hPut h (singleton (0x0a)) -- don't copy
+
+-- | Write a Buffer to stdout
+putStr :: Buffer -> IO ()
+putStr = hPut stdout
+
+-- | Write a Buffer to stdout, appending a newline byte
+putStrLn :: Buffer -> IO ()
+putStrLn = hPutStrLn stdout
+
+------------------------------------------------------------------------
+-- Low level IO
+
+-- | Read a 'Buffer' directly from the specified 'Handle'.  This
+-- is far more efficient than reading the characters into a 'String'
+-- and then using 'pack'. First argument is the Handle to read from, 
+-- and the second is the number of bytes to read. It returns the bytes
+-- read, up to n, or EOF.
+--
+-- 'hGet' is implemented in terms of 'hGetBuf'.
+--
+-- If the handle is a pipe or socket, and the writing end
+-- is closed, 'hGet' will behave as if EOF was reached.
+--
+hGet :: Handle -> Int -> IO Buffer
+hGet h i
+    | i >  0    = createAndTrim i $ \p -> hGetBuf h p i
+    | i == 0    = return empty
+    | otherwise = illegalBufferSize h "hGet" i
+
+-- | hGetNonBlocking is identical to 'hGet', except that it will never block
+-- waiting for data to become available, instead it returns only whatever data
+-- is available.
+--
+hGetNonBlocking :: Handle -> Int -> IO Buffer
+#if defined(__GLASGOW_HASKELL__)
+hGetNonBlocking h i
+    | i >  0    = createAndTrim i $ \p -> hGetBufNonBlocking h p i
+    | i == 0    = return empty
+    | otherwise = illegalBufferSize h "hGetNonBlocking" i
+#else
+hGetNonBlocking = hGet
+#endif
+
+illegalBufferSize :: Handle -> String -> Int -> IO a
+illegalBufferSize handle fn sz =
+    ioError (mkIOError illegalOperationErrorType msg (Just handle) Nothing)
+    --TODO: System.IO uses InvalidArgument here, but it's not exported :-(
+    where
+      msg = fn ++ ": illegal Buffer size " ++ showsPrec 9 sz []
+
+
+-- | Read entire handle contents strictly into a 'Buffer'.
+--
+-- This function reads chunks at a time, doubling the chunksize on each
+-- read. The final buffer is then realloced to the appropriate size. For
+-- files > half of available memory, this may lead to memory exhaustion.
+-- Consider using 'readFile' in this case.
+--
+-- As with 'hGet', the string representation in the file is assumed to
+-- be ISO-8859-1.
+--
+-- The Handle is closed once the contents have been read,
+-- or if an exception is thrown.
+--
+hGetContents :: Handle -> IO Buffer
+hGetContents h = always (hClose h) $ do -- strict, so hClose
+    let start_size = 1024
+    p <- mallocBytes start_size
+    i <- hGetBuf h p start_size
+    if i < start_size
+        then do p' <- reallocBytes p i
+                fp <- newForeignPtr finalizerFree p'
+                return $! PS fp 0 i
+        else f p start_size
+    where
+        always = flip finally
+        f p s = do
+            let s' = 2 * s
+            p' <- reallocBytes p s'
+            i  <- hGetBuf h (p' `plusPtr` s) s
+            if i < s
+                then do let i' = s + i
+                        p'' <- reallocBytes p' i'
+                        fp  <- newForeignPtr finalizerFree p''
+                        return $! PS fp 0 i'
+                else f p' s'
+
+-- | getContents. Read stdin strictly. Equivalent to hGetContents stdin
+-- The 'Handle' is closed after the contents have been read.
+--
+getContents :: IO Buffer
+getContents = hGetContents stdin
+
+-- | The interact function takes a function of type @Buffer -> Buffer@
+-- as its argument. The entire input from the standard input device is passed
+-- to this function as its argument, and the resulting string is output on the
+-- standard output device.
+--
+interact :: (Buffer -> Buffer) -> IO ()
+interact transformer = putStr . transformer =<< getContents
+
+-- | Read an entire file strictly into a 'Buffer'.  This is far more
+-- efficient than reading the characters into a 'String' and then using
+-- 'pack'.  It also may be more efficient than opening the file and
+-- reading it using hGet. Files are read using 'binary mode' on Windows,
+-- for 'text mode' use the Char8 version of this function.
+--
+readFile :: FilePath -> IO Buffer
+readFile f = bracket (openBinaryFile f ReadMode) hClose
+    (\h -> hFileSize h >>= hGet h . fromIntegral)
+
+-- | Write a 'Buffer' to a file.
+writeFile :: FilePath -> Buffer -> IO ()
+writeFile f txt = bracket (openBinaryFile f WriteMode) hClose
+    (\h -> hPut h txt)
+
+-- | Append a 'Buffer' to a file.
+appendFile :: FilePath -> Buffer -> IO ()
+appendFile f txt = bracket (openBinaryFile f AppendMode) hClose
+    (\h -> hPut h txt)
+
+-- ---------------------------------------------------------------------
+-- Internal utilities
+
+-- | 'findIndexOrEnd' is a variant of findIndex, that returns the length
+-- of the string if no element is found, rather than Nothing.
+findIndexOrEnd :: (Word8 -> Bool) -> Buffer -> Int
+findIndexOrEnd k (PS x s l) = inlinePerformIO $ withForeignPtr x $ \f -> go (f `plusPtr` s) 0
+  where
+    STRICT2(go)
+    go ptr n | n >= l    = return l
+             | otherwise = do w <- peek ptr
+                              if k w
+                                then return n
+                                else go (ptr `plusPtr` 1) (n+1)
+{-# INLINE findIndexOrEnd #-}
+
+-- | Perform an operation with a temporary Buffer
+withPtr :: ForeignPtr a -> (Ptr a -> IO b) -> b
+withPtr fp io = inlinePerformIO (withForeignPtr fp io)
+{-# INLINE withPtr #-}
+
+-- Common up near identical calls to `error' to reduce the number
+-- constant strings created when compiled:
+errorEmptyList :: String -> a
+errorEmptyList fun = moduleError fun "empty Buffer"
+{-# NOINLINE errorEmptyList #-}
+
+moduleError :: String -> String -> a
+moduleError fun msg = error ("Data.Buffer." ++ fun ++ ':':' ':msg)
+{-# NOINLINE moduleError #-}
+
+-- Find from the end of the string using predicate
+findFromEndUntil :: (Word8 -> Bool) -> Buffer -> Int
+STRICT2(findFromEndUntil)
+findFromEndUntil f ps@(PS x s l) =
+    if null ps then 0
+    else if f (last ps) then l
+         else findFromEndUntil f (PS x s (l-1))
addfile ./LICENSE
hunk ./LICENSE 1
+Copyright (c) Don Stewart 2005-2009
+          (c) Duncan Coutts 2006-2009
+          (c) David Roundy 2003-2005
+          (c) Edward Kmett 2009-2010.
+
+All rights reserved.
+
+Redistribution and use in source and binary forms, with or without
+modification, are permitted provided that the following conditions
+are met:
+1. Redistributions of source code must retain the above copyright
+   notice, this list of conditions and the following disclaimer.
+2. Redistributions in binary form must reproduce the above copyright
+   notice, this list of conditions and the following disclaimer in the
+   documentation and/or other materials provided with the distribution.
+3. Neither the name of the author nor the names of his contributors
+   may be used to endorse or promote products derived from this software
+   without specific prior written permission.
+
+THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
+ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHORS OR CONTRIBUTORS BE LIABLE
+FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
+OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
+LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
+OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
+SUCH DAMAGE.
addfile ./README
hunk ./README 1
+s------------------------------------------------------------------------
+               ByteString : Fast, packed strings of bytes
+------------------------------------------------------------------------
+
+This library provides the Data.ByteString library -- strict and lazy
+byte arrays manipulable as strings -- providing very time and space
+efficient string and IO operations.
+
+For very large data requirements, or constraints on heap size,
+Data.ByteString.Lazy is provided, a lazy list of bytestring chunks.
+Efficient processing of multi-gigabyte data can be achieved this way.
+
+Requirements:
+        > Cabal
+        > GHC 6.4 or greater, or hugs
+
+Building:
+        > runhaskell Setup.lhs configure --prefix=/f/g
+        > runhaskell Setup.lhs build
+        > runhaskell Setup.lhs install
+
+After installation, you can run the testsuite as follows:
+    
+        > cd tests ; make
+    or
+        > cd tests ; make hugs
+
+For the full test and benchmark suite, you need GHC and Hugs:
+
+        > cd tests ; make everything
+
+Authors:
+    ByteString was derived from the GHC PackedString library,
+    originally written by Bryan O'Sullivan, and then by Simon Marlow.
+    It was adapted, and greatly extended for darcs by David Roundy, and
+    others. Don Stewart cleaned up and further extended the implementation.
+    Duncan Coutts wrote much of the .Lazy code. Don, Duncan and Roman
+    Leshchinskiy wrote the fusion system.
+
+------------------------------------------------------------------------
+
+Performance, some random numbers (with GHC):
+
+This table compares the performance of common operations ByteString,
+from various string libraries.
+
+Size of test data: 21256k, Linux 3.2Ghz P4
+
+                          FPS7       SPS     PS      [a]    
+++                        0.028      !       !       1.288   
+length                    0.000      0.000   0.000   0.131   
+pack                      0.303      0.502   0.337   -       
+unpack                    3.319*     1.630   7.445   -       
+compare                   0.000      0.000   0.000   0.000   
+index                     0.000      0.000   0.000   0.000   
+map                       2.762*     2.917   4.813   7.286   
+filter                    0.304      2.805   0.954   0.305   
+take                      0.000      0.000   0.024   0.005   
+drop                      0.000      0.000   11.768  0.130   
+takeWhile                 0.000      1.498   0.000   0.000   
+dropWhile                 0.000      1.985   8.447   0.130   
+span                      0.000      9.289   11.144  0.131   
+break                     0.000      9.383   11.268  0.133   
+lines                     0.052      1.114   1.367   2.790   
+unlines                   0.048      !       !       10.950  
+words                     1.344      2.128   5.644   4.184   
+unwords                   0.016      !       !       1.305   
+reverse                   0.024      12.997  13.018  1.622   
+concat                    0.000      12.701  11.459  1.163   
+cons                      0.016      2.064   8.358   0.131   
+empty                     0.000      0.000   0.000   0.000   
+head                      0.000      0.000   0.000   0.000   
+tail                      0.000      0.000   14.490  0.130   
+elem                      0.000      1.490   0.001   0.000   
+last                      0.000      -       -       0.143   
+init                      0.000      -       -       1.147   
+inits                     0.414      -       -       !       
+tails                     0.460      -       -       1.136   
+intersperse               0.040      -       -       10.517  
+any                       0.000      -       -       0.000   
+all                       0.000      -       -       0.000   
+sort                      0.168      -       -       !
+maximum                   0.024      -       -       0.183
+minimum                   0.025      -       -       0.185
+replicate                 0.000      -       -       0.053   
+findIndex                 0.096
+find                      0.120      -       -       0.000   
+elemIndex                 0.000      -       -       0.000   
+elemIndicies              0.008      -       -       0.314   
+foldl                     0.148
+spanEnd                   0.000
+snoc                      0.016
+filterChar                0.031      
+filterNotChar             0.124
+join                      0.016      
+split                     0.032      
+findIndices               0.408      
+splitAt                   0.000      
+lineIndices               0.029      
+breakOn                   0.000      
+breakSpace                0.000 
+splitWith                 0.329 
+dropSpace                 0.000 
+dropSpaceEnd              0.000 
+joinWithChar              0.017
+join /                    0.016 
+zip                       0.960 
+zipWith                   0.892 
+isSubstringOf             0.039 
+isPrefixOf                0.000 
+isSuffixOf                0.000
+count                     0.021
+
+Key: FPS6 = FPS 0.6
+     SPS  = Simon Marlow's packedstring prototype
+     PS   = Data.PackedString
+     [a]  = [Char]
+
+     -    = no function exists
+     !    = stack or memory exhaustion
+
+------------------------------------------------------------------------
+
+== Stress testing really big strings
+
+Doing some stress testing of FPS, here are some results for 0.5G strings.
+
+3.2Ghz box, 2G physical mem.
+
+Size of test data: 524288k
+Size of test data: 524288k
+                Char8   Word8
+
+Effectively O(1) or O(m) where m < n
+    all             0.000   0.000   
+    any             0.000   0.004   
+    break           0.000   0.000   
+    breakChar       0.000   0.000   
+    breakSpace      0.000   
+    compare         0.000   
+    concat          0.000   
+    drop            0.000   
+    dropSpace       0.000   
+    dropSpaceEnd    0.000   
+    dropWhile       0.000   0.000   
+    elem            0.000   0.000   
+    elemIndex       0.000   0.000   
+    elemIndexLast   0.000   0.000   
+    empty           0.000   
+    head            0.000   0.000   
+    index           0.000   0.000   
+    init            0.000   
+    last            0.000   0.000   
+    length          0.000   
+    notElem         0.000   0.000   
+    span            0.000   0.000   
+    spanChar        0.000   0.000   
+    spanEnd         0.000   0.000   
+    splitAt         0.000   
+    tail            0.000   
+    take            0.000   
+    takeWhile       0.000   0.000   
+    isPrefixOf      0.000   
+    isSuffixOf      0.000   
+    addr1           0.000   
+    addr2           0.000   
+
+O(n)
+    ++              0.676   
+    map             6.080   5.868   
+    cons            0.396   0.396   
+    snoc            0.400   0.400   
+    find            3.240   
+    split           1.204   1.200   
+    lines           2.000   
+    foldl           3.804   
+    unwords         0.552   
+    reverse         0.884   
+    findIndex       3.128   
+    filterChar      0.756   0.732   
+    filter/='f'     8.265   7.012   
+    filterNotChar   4.456   3.388   
+    join            0.400   
+    sort            4.344   
+    maximum         0.776   0.764   
+    minimum         0.772   0.776   
+    replicate       0.008   0.000   
+    elemIndices     0.240   0.240   
+    lineIndices     1.092   
+    joinWithChar    0.400   0.400   
+    isSubstringOf   0.052   
+    count           0.748   
+
+slow O(n)
+    words           38.722  
+    group           77.261  
+    groupBy         96.226  
+    inits           32.430  
+    tails           23.225  
+    findIndices     13.841  15.825  
+    splitWith       18.445  19.225  
+    zip             33.926  
+    zipWith         33.562  
+
+
addfile ./Setup.hs
hunk ./Setup.hs 1
+import Distribution.Simple
+main = defaultMain
addfile ./TODO
hunk ./TODO 1
+TODO:
+
+    * back port streams fusion code.
+    * show instance for LPS
+    * stress testing
+    * strictness testing
+    * rewrite C code to Haskell
+    * eliminate use of -fno-warn-orphans
+
+
+Todo items
+----------
+
+* check that api again.
+    - in particular, unsafeHead/Tail for Char8?
+    - scanr,scanr1... in Char8
+
+* would it make sense to move the IO bits into a different module too?
+        - System.IO.ByteString
+        - Data.ByteString.IO
+
+* can we avoid joinWithByte? 
+        - Hard. Can't do it easily with a rule.
+
+* think about Data.ByteString.hGetLines. is it needed in the presence of
+    the cheap "lines =<< Data.ByteString.Lazy.getContents" ?
+
+* unchunk, Data.ByteString.Lazy -> [Data.ByteString]
+    -  and that'd work for any Lazy.ByteString, not just hGetContents >>= lines
+
+* consider if lazy hGetContents should use non-blocking reads. This should
+    allow messaging style applications (eg communication over pipes, sockets)
+    to use lazy ByteStrings. I think that at the moment since we demand 64k
+    it'd just block. With a messaging style app you've got to be careful not
+    to demand more data than is available, hence using non-blocking read
+    should do the right thing. And in the disk file case it doesn't change
+    anything anyway, you can always get a full chunk.
+
+* think about lazy hGetContents and IO exceptions
+
+* consider dropping map' as ghc-6.5 optimises map much better so there's now
+  little difference between them (15% rather than 40%) and with the new fusion
+  system we may be able to get even closer. Look at the benchmarks for filter'
+  to see if we can do the same there.
+
+* It might be nice to have a trim MutableByteArray primitive that can release
+  the tail of an array back to the GC. This would save copying in cases where
+  we choose to realloc to save space. This combined with GC-movable strings
+  might improve fragmentation / space usage for the many small strings case.
+
+* if we can be sure there is very little variance then it might be interesting to look 
+ into the cases where we're doing slightly worse eg the map/up, filter/up cases
+ and why we're doing so much better in the up/up case!?  that one makes no sense
+ since we should be doing the exact same thing as the old loopU for the up/up
+ case
+
+* then there are the strictness issues eg our current foldl & foldr are
+  arguably too strict we could fuse unpack/unpackWith if they wern't so strict
+
+* look at shrinking the chunk size, based on our cache testing.
+
+* think about horizontal fusion (esp. when considering nofib code)
+
+* fuseable reverse.
+
+* 'reverse' is very common in list code, but unnecessary in bytestring
+  code, since it takes a symmertric view.
+    look to eliminate it with rules. loopUp . reverse --> loopDown
+
+* work out how robust the rules are .
+
+* benchmark against C string library benchmarks
+
+* work out if we can convince ghc to remove NoAccs in map and filter.
+
+* Implement Lazy:
+    scanl1
+    partition
+    unzip
+
+* fix documentation in Fusion.hs
+
+* Prelude Data.ByteString.Lazy> List.groupBy (/=) $ [97,99,103,103]
+  [[97,99,103,103]]
+  Prelude Data.ByteString.Lazy> groupBy (/=) $ pack [97,99,103,103]
+  [LPS ["ac","g"],LPS ["g"]]
addfile ./buffer.cabal
hunk ./buffer.cabal 1
+Name:                buffer
+Version:             0.0.1
+Synopsis:            Fast, packed, strict and lazy byte array fingertrees with fast character indexing
+Description:
+    A time and space-efficient implementation of byte vectors using
+    packed Word8 arrays, suitable for high performance use, both in terms
+    of large data quantities, or high speed requirements. Byte vectors
+    are encoded as strict 'Word8' arrays of bytes, and lazy lists of
+    strict chunks, held in a 'ForeignPtr', and can be passed between C
+    and Haskell with little effort. Based on Data.ByteString with minor 
+    additions to track the number of (potential) UTF8 multibyte tail bytes 
+    present in a given buffer.
+    .
+    Test coverage data for this library is available at:
+        <http://code.haskell.org/~dons/tests/bytestring/hpc_index.html>
+
+License:             BSD3
+License-file:        LICENSE
+Category:            Data
+Copyright:           Copyright (c) Don Stewart   2005-2009,
+                               (c) Duncan Coutts 2006-2009,
+                               (c) David Roundy  2003-2005.
+                               (c) Edward Kmett  2009-2010
+Author:              Edward Kmett, Don Stewart, Duncan Coutts
+Maintainer:          Edward Kmett <ekmett@gmail.com>
+Homepage:            http://www.comonad.com/
+Tested-With:         GHC==6.10.4
+Build-Type:          Simple
+Cabal-Version:       >= 1.2.3
+extra-source-files:  README TODO
+
+library
+  build-depends:     base < 5
+
+  if impl(ghc >= 6.10)
+    build-depends:   ghc-prim, base >= 4
+
+  exposed-modules:   Data.Buffer
+                     Data.Buffer.Unsafe
+                     Data.Buffer.Internal
+                     Data.Buffer.Lazy
+                     Data.Buffer.Lazy.Internal
+                     Data.Buffer.Fusion
+
+  extensions:        CPP, ForeignFunctionInterface
+
+  if impl(ghc)
+      extensions:   UnliftedFFITypes,
+                    MagicHash,
+                    UnboxedTuples,
+                    DeriveDataTypeable
+                    ScopedTypeVariables
+  if impl(ghc >= 6.11)
+      extensions:   NamedFieldPuns
+
+  --TODO: eliminate orphan instances:
+  ghc-options:      -Wall -fno-warn-orphans
+                    -O2
+                    -funbox-strict-fields 
+                    -fno-method-sharing
+                    -fmax-simplifier-iterations10
+  if impl(ghc >= 6.6)
+    ghc-options:    -fdicts-cheap
+
+  c-sources:         cbits/fpstring.c
+  include-dirs:      include
+  includes:          fpstring.h
+  install-includes:  fpstring.h
+
+  nhc98-options:     -K4M -K3M
+  if impl(ghc <= 6.4.2)
+    cc-options:     -DSLOW_FOREIGN_PTR
+
adddir ./cbits
addfile ./cbits/fpstring.c
hunk ./cbits/fpstring.c 1
+s/*
+ * Copyright (c) 2003 David Roundy
+ * Copyright (c) 2005-6 Don Stewart
+ *
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ * 3. Neither the names of the authors or the names of any contributors
+ *    may be used to endorse or promote products derived from this software
+ *    without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
+ * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED. IN NO EVENT SHALL THE AUTHORS OR CONTRIBUTORS BE LIABLE
+ * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
+ * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
+ * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
+ * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
+ * SUCH DAMAGE.
+ */
+
+#include "bfpstring.h"
+
+/* copy a string in reverse */
+void bfps_reverse(unsigned char *q, unsigned char *p, unsigned long n) {
+    p += n-1;
+    while (n-- != 0)
+        *q++ = *p--;
+}
+
+/* duplicate a string, interspersing the character through the elements
+   of the duplicated string */
+void bfps_intersperse(unsigned char *q,
+                     unsigned char *p,
+                     unsigned long n,
+                     unsigned char c) {
+
+    while (n > 1) {
+        *q++ = *p++;
+        *q++ = c;
+        n--;
+    }
+    if (n == 1)
+        *q = *p;
+}
+
+/* find maximum char in a packed string */
+unsigned char bfps_maximum(unsigned char *p, unsigned long len) {
+    unsigned char *q, c = *p;
+    for (q = p; q < p + len; q++)
+        if (*q > c)
+            c = *q;
+    return c;
+}
+
+/* find minimum char in a packed string */
+unsigned char bfps_minimum(unsigned char *p, unsigned long  len) {
+    unsigned char *q, c = *p;
+    for (q = p; q < p + len; q++)
+        if (*q < c)
+            c = *q;
+    return c;
+}
+
+/* count the number of occurences of a char in a string */
+unsigned long bfps_count(unsigned char *p, unsigned long len, unsigned char w) {
+    unsigned long c;
+    for (c = 0; len-- != 0; ++p)
+        if (*p == w)
+            ++c;
+    return c;
+}
+
+unsigned long bfps_count_extras(unsigned char *p, unsigned long len, unsigned char w) { 
+    unsigned long c;
+    for (c = 0; len-- != 0; ++p)
+        if (*p >= 0x80)
+            ++c;
+    return c;        
+}
adddir ./include
addfile ./include/fpstring.h
hunk ./include/fpstring.h 1
+
+void bfps_reverse(unsigned char *dest, unsigned char *from, unsigned long  len);
+void bfps_intersperse(unsigned char *dest, unsigned char *from, unsigned long  len, unsigned char c);
+unsigned char bfps_maximum(unsigned char *p, unsigned long  len);
+unsigned char bfps_minimum(unsigned char *p, unsigned long  len);
+unsigned long bfps_count(unsigned char *p, unsigned long  len, unsigned char w);
+unsigned long bfps_count_extras(unsigned char *p, unsigned long  len, unsigned char w);