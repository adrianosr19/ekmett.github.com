[working towards ropes
ekmett@gmail.com**20100319040539
 Ignore-this: 7685789e6811b7106cf7dff8fbec82b1
] adddir ./Data/Buffer/Internal
adddir ./Data/Buffer/Rope
addfile ./Data/Buffer.hs
hunk ./Data/Buffer.hs 1
+-- We cannot actually specify all the language pragmas, see ghc ticket #
+-- If we could, these are what they would be:
+{- LANGUAGE MagicHash, UnboxedTuples,
+            NamedFieldPuns, BangPatterns, RecordWildCards -}
+{- OPTIONS_HADDOCK prune -}
+
+-- |
+-- Module      : Data.Buffer
+-- Copyright   : (c) The University of Glasgow 2001,
+--               (c) David Roundy 2003-2005,
+--               (c) Simon Marlow 2005
+--               (c) Bjorn Bringert 2006
+--               (c) Don Stewart 2005-2008
+--               (c) Edward Kmett 2009-2010
+--
+--               Array fusion code:
+--               (c) 2001,2002 Manuel M T Chakravarty & Gabriele Keller
+--               (c) 2006      Manuel M T Chakravarty & Roman Leshchinskiy
+--
+-- License     : BSD-style
+--
+-- Maintainer  : ekmett@gmail.com
+-- Stability   : experimental
+-- Portability : portable
+-- 
+-- A time and space-efficient implementation of byte vectors using
+-- packed Word8 arrays, suitable for high performance use, both in terms
+-- of large data quantities, or high speed requirements. Byte vectors
+-- are encoded as strict 'Word8' arrays of bytes, held in a 'ForeignPtr',
+-- and can be passed between C and Haskell with little effort.
+--
+-- This module is intended to be imported @qualified@, to avoid name
+-- clashes with "Prelude" functions.  eg.
+--
+-- > import qualified Data.Buffer as B
+--
+-- Original GHC implementation by Bryan O\'Sullivan.
+-- Rewritten to use 'Data.Array.Unboxed.UArray' by Simon Marlow.
+-- Rewritten to support slices and use 'ForeignPtr' by David Roundy.
+-- Polished and extended by Don Stewart.
+--
+-- Excludes a number of methods that change meaning based on contents. 
+-- Look in "Data.Buffer.Word8" or "Data.Buffer.Char" for:
+-- 
+-- > sort      :: Buffer -> Buffer
+-- > null      :: Buffer -> Bool
+-- > tail      :: Buffer -> Buffer
+-- > init      :: Buffer -> Buffer
+-- > length    :: Buffer -> Int
+-- > take      :: Int -> Buffer -> Buffer
+-- > drop      :: Int -> Buffer -> Buffer
+-- > group     :: Buffer -> [Buffer]
+-- > inits     :: Buffer -> [Buffer]
+-- > tails     :: Buffer -> [Buffer]
+-- > lines     :: Buffer -> Buffer
+-- > reverse   :: Buffer -> Buffer
+-- > words     :: Buffer -> Buffer
+-- > transpose :: [Buffer] -> [Buffer]
+-- > take      :: Int -> Buffer -> Buffer 
+-- > drop      :: Int -> Buffer -> Buffer
+-- > splitAt   :: Int -> Buffer -> (Buffer, Buffer)
+
+module Data.Buffer (
+    -- * Unambiguous methods
+    null,               -- :: Buffer -> Bool
+    empty,              -- :: Buffer
+    concat,             -- :: [Buffer] -> Buffer
+    unlines,            -- :: [Buffer] -> Buffer
+    unwords,            -- :: [Buffer] -> Buffer
+    intercalate,        -- :: Buffer -> [Buffer] -> Buffer
+
+    -- * Reading from @Buffer@s
+    readInt,                -- :: Buffer -> Maybe (Int, Buffer)     -- ViewL Buffer Int
+    readInteger,            -- :: Buffer -> Maybe (Integer, Buffer) -- ViewL Buffer Integer
+
+    -- ** Searching for substrings
+    isPrefixOf,             -- :: Buffer -> Buffer -> Bool
+    isSuffixOf,             -- :: Buffer -> Buffer -> Bool
+    isSubstringOf,          -- :: Buffer -> Buffer -> Bool
+
+    -- ** Packing CStrings and pointers
+    packCString,            -- :: CString -> Buffer
+    packCStringLen,         -- :: CString -> Buffer
+    packMallocCString,      -- :: CString -> Buffer
+
+    -- ** Using Buffers as CStrings
+    useAsCString,           -- :: Buffer -> (CString -> IO a) -> IO a
+    useAsCStringLen,        -- :: Buffer -> (CStringLen -> IO a) -> IO a
+
+    -- * Copying Buffers
+    copy,                   -- :: Buffer -> Buffer
+    copyCString,            -- :: CString -> IO Buffer
+    copyCStringLen,         -- :: CStringLen -> IO Buffer
+
+    -- * I\/O with @Buffer@s
+
+    -- ** Standard input and output
+    getLine,                -- :: IO Buffer
+    getContents,            -- :: IO Buffer
+    putStr,                 -- :: Buffer -> IO ()
+    putStrLn,               -- :: Buffer -> IO ()
+    interact,               -- :: (Buffer -> Buffer) -> IO ()
+
+    -- ** Files
+    readFile,               -- :: FilePath -> IO Buffer
+    writeFile,              -- :: FilePath -> Buffer -> IO ()
+    appendFile,             -- :: FilePath -> Buffer -> IO ()
+
+    -- ** I\/O with Handles
+    hGetLine,               -- :: Handle -> IO Buffer
+    hGetNonBlocking,        -- :: Handle -> Int -> IO Buffer
+    hGetContents,           -- :: Handle -> IO Buffer   
+    hGet,                   -- :: Handle -> Int -> IO Buffer
+    hPut,                   -- :: Handle -> Buffer -> IO () 
+    hPutStr,                -- :: Handle -> Buffer -> IO ()
+    hPutStrLn,              -- :: Handle -> Buffer -> IO () 
+    packAddress,            -- :: Addr# -> Buffer
+    unsafePackAddress,      -- :: Int -> Addr# -> Buffer
+
+
+    singleton,      -- :: Buffered e =>  Buffered e => e -> Buffer
+
+    viewl,          -- :: Buffered e => Buffer -> ViewL Buffer e
+    viewr,          -- :: Buffered e => Buffer -> ViewR Buffer e
+
+    uncons,         -- :: Buffered e => Buffer -> Maybe (e, Buffer)
+    unsnoc,         -- :: Buffered e => Buffer -> Maybe (Buffer, e)
+    
+    pack,           -- :: Buffered e => [e] -> Buffer
+    unpack,         -- :: Buffered e => Buffer -> [e]
+
+    cons,           -- :: Buffered e => e -> Buffer -> Buffer
+    snoc,           -- :: Buffered e => Buffer -> e -> Buffer
+
+    head,           -- :: Buffered e => Buffer -> e
+    last,           -- :: Buffered e => Buffer -> e
+
+    foldl,          -- :: Buffered e => (a -> e -> a) -> a -> Buffer -> a
+    foldl',         -- :: Buffered e => (a -> e -> a) -> a -> Buffer -> a
+    foldl1,         -- :: Buffered e => (e -> e -> e) -> Buffer -> e
+    foldl1',        -- :: Buffered e => (e -> e -> e) -> Buffer -> e
+
+    foldr,          -- :: Buffered e => (e -> a -> e) -> a -> Buffer -> a
+    foldr',         -- :: Buffered e => (e -> a -> a) -> a -> Buffer -> a
+    foldr1,         -- :: Buffered e => (e -> e -> e) -> Buffer -> e
+    foldr1',        -- :: Buffered e => (e -> e -> e) -> Buffer -> e
+
+    concatMap,      -- :: Buffered e => (e -> Buffer) -> Buffer -> Buffer
+
+    any,            -- :: Buffered e => (e -> Bool) -> Buffer -> Buffer
+    all,            -- :: Buffered e => (e -> Bool) -> Buffer -> BUffer
+
+    maximum,        -- :: Buffered e => Buffer -> e
+    minimum,        -- :: Buffered e => Buffer -> e
+
+    scanl,          -- :: Buffered e =>(e -> e -> e) -> e -> Buffer -> Buffer
+    scanl1,         -- :: Buffered e => (e -> e -> e) -> Buffer -> Buffer
+    scanr,          -- :: Buffered e => (e -> e -> e) -> e -> Buffer -> Buffer
+    scanr1,         -- :: Buffered e => (e -> e -> e) -> Buffer -> Buffer
+
+    mapAccumL,      -- :: Buffered e => (acc -> e -> (acc, e)) -> acc -> Buffer -> (acc, Buffer)
+    mapAccumR,      -- :: Buffered e => (acc -> e -> (acc, e)) -> acc -> Buffer -> (acc, Buffer)
+
+    mapIndexed,     -- :: Buffered e => (Int -> e -> e) -> Buffer -> Buffer
+
+    replicate,      -- :: Buffered e => Int -> e -> Buffer
+
+    unfoldr,        -- :: Buffered e => (a -> Maybe (e, a)) -> a -> Buffer
+    unfoldrN,       -- :: Buffered e => Int -> (a -> Maybe (e, a)) -> a -> (Buffer, Maybe a)
+
+    takeWhile,      -- :: Buffered e => (e -> Bool) -> Buffer -> Buffer
+    dropWhile,      -- :: Buffered e => (e -> Bool) -> Buffer -> Buffer
+
+    span,           -- :: Buffered e => (e -> Bool) -> Buffer -> (Buffer, Buffer)
+    spanEnd,        -- :: Buffered e => (e -> Bool) -> Buffer -> (Buffer, Buffer)
+
+    break,          -- :: Buffered e => (e -> Bool) -> Buffer -> (Buffer, Buffer)
+    breakEnd,       -- :: Buffered e => (e -> Bool) -> Buffer -> (Buffer, Buffer)
+
+    groupBy,        -- :: Buffered e => (e -> e -> Bool) -> Buffer -> [Buffer]
+
+    split,          -- :: Buffered e => e -> Buffer -> Buffer
+    splitWith,      -- :: Buffered e => (e -> Bool) -> Buffer -> Buffer
+    intersperse,    -- :: Buffered e => e -> Buffer -> Buffer
+
+    elem,           -- :: Buffered e => e -> Buffer -> Bool
+    notElem,        -- :: Buffered e => e -> Buffer -> Bool
+     
+    find,           -- :: Buffered e => (e -> Bool) -> Buffer -> Maybe e
+    filter,         -- :: Buffered e => (e -> Bool) -> Buffer -> Buffer
+
+    index,          -- :: Buffered e => Buffer -> Int -> e
+
+    elemIndex,      -- :: Buffered e => e -> Buffer -> Maybe Int
+    elemIndices,    -- :: Buffered e => e -> Buffer -> [Int]
+    elemIndexEnd,   -- :: Buffered e => e -> Buffer -> Maybe Int
+
+    findIndex,      -- :: Buffered e => (e -> Bool) -> Buffer -> Maybe Int
+    findIndices,    -- :: Buffered e => e -> Buffer -> [Int]
+
+    count,          -- :: Buffered e => e -> Buffer -> Int
+
+    zip,            -- :: Buffered e => Buffer -> Buffer -> [(e,e)]
+    zipWith,        -- :: Buffered e => (e -> e -> a) -> Buffer -> Buffer -> [a]
+    unzip           -- :: Buffered e => [(e,e)] -> (Buffer,Buffer)
+  ) where
+
+
+import Prelude hiding
+    (reverse,head,tail,last,init,null,length,map,lines,foldl,foldr,unlines
+    ,concat,any,take,drop,splitAt,takeWhile,dropWhile,span,break,elem,filter,maximum
+    ,minimum,all,concatMap,foldl1,foldr1,scanl, scanl1, scanr, scanr1
+    ,repeat, cycle, interact, iterate,readFile,writeFile,appendFile,replicate
+    ,getContents,getLine,putStr,putStrLn ,zip,zipWith,unzip,notElem)
+
+import Data.Buffer.Word8 (
+    null, empty, concat, unlines, unwords, intercalate, isPrefixOf, packCString,
+    packCStringLen, packMallocCString, useAsCString, useAsCStringLen, copy, 
+    copyCString, copyCStringLen, getLine, getContents, putStr, putStrLn, 
+    interact, readFile, writeFile, appendFile, hGetLine, hGetNonBlocking, 
+    hGetContents, hGet, hPut, hPutStr, hPutStrLn, packAddress, unsafePackAddress, 
+    null, empty, readInt, readInteger)
+
+import qualified Data.Buffer.Word8 as W
+import qualified Data.Buffer.Char as C
+
+import Data.Buffer.View
+import Data.Buffer.Internal (null, empty)
+
+class Ord e => Buffered e where
+
+    singleton :: e -> Buffer
+
+    viewl :: Buffer -> ViewL Buffer e
+    viewr :: Buffer -> ViewR Buffer e
+
+    uncons :: Buffer -> Maybe (e, Buffer)
+    unsnoc :: Buffer -> Maybe (Buffer, e)
+    
+    pack :: [e] -> Buffer
+    unpack :: Buffer -> [e]
+
+    cons :: e -> Buffer -> Buffer
+    snoc :: Buffer -> e -> Buffer
+
+    head :: Buffer -> e
+    last :: Buffer -> e
+
+    foldl :: (a -> e -> a) -> a -> Buffer -> a
+    foldl' :: (a -> e -> a) -> a -> Buffer -> a
+    foldl1 :: (e -> e -> e) -> Buffer -> e
+    foldl1' :: (e -> e -> e) -> Buffer -> e
+
+    foldr :: (e -> a -> e) -> a -> Buffer -> a
+    foldr' :: (e -> a -> a) -> a -> Buffer -> a
+    foldr1 :: (e -> e -> e) -> Buffer -> e
+    foldr1' :: (e -> e -> e) -> Buffer -> e
+
+    concatMap :: (e -> Buffer) -> Buffer -> Buffer
+
+    any :: (e -> Bool) -> Buffer -> Buffer
+
+    all :: (e -> Bool) -> Buffer -> BUffer
+
+    maximum :: Buffer -> e
+    minimum :: Buffer -> e
+
+    scanl ::(e -> e -> e) -> e -> Buffer -> Buffer
+    scanl1 :: (e -> e -> e) -> Buffer -> Buffer
+    scanr :: (e -> e -> e) -> e -> Buffer -> Buffer
+    scanr1 :: (e -> e -> e) -> Buffer -> Buffer
+
+    mapAccumL :: (acc -> e -> (acc, e)) -> acc -> Buffer -> (acc, Buffer)
+    mapAccumR :: (acc -> e -> (acc, e)) -> acc -> Buffer -> (acc, Buffer)
+
+    mapIndexed :: (Int -> e -> e) -> Buffer -> Buffer
+
+    replicate :: Int -> e -> Buffer
+
+    unfoldr :: (a -> Maybe (e, a)) -> a -> Buffer
+    unfoldrN :: Int -> (a -> Maybe (e, a)) -> a -> (Buffer, Maybe a)
+
+    takeWhile :: (e -> Bool) -> Buffer -> Buffer
+    dropWhile :: (e -> Bool) -> Buffer -> Buffer
+
+    span :: (e -> Bool) -> Buffer -> (Buffer, Buffer)
+    spanEnd :: (e -> Bool) -> Buffer -> (Buffer, Buffer)
+
+    break :: (e -> Bool) -> Buffer -> (Buffer, Buffer)
+    breakEnd :: (e -> Bool) -> Buffer -> (Buffer, Buffer)
+
+    groupBy :: (e -> e -> Bool) -> Buffer -> [Buffer]
+
+    split :: e -> Buffer -> Buffer
+    splitWith :: (e -> Bool) -> Buffer -> Buffer
+    intersperse :: e -> Buffer -> Buffer
+
+    elem :: e -> Buffer -> Bool
+    notElem :: e -> Buffer -> Bool
+     
+    find :: (e -> Bool) -> Buffer -> Maybe e
+    filter :: (e -> Bool) -> Buffer -> Buffer
+
+    index :: Buffer -> Int -> e
+
+    elemIndex :: e -> Buffer -> Maybe Int
+    elemIndices :: e -> Buffer -> [Int]
+    elemIndexEnd :: e -> Buffer -> Maybe Int
+
+    findIndex :: (e -> Bool) -> Buffer -> Maybe Int
+    findIndices :: e -> Buffer -> [Int]
+
+    count :: e -> Buffer -> Int
+
+    zip :: Buffer -> Buffer -> [(e,e)]
+    zip as bs = zip (unpack as) (unpack bs)
+
+    zipWith :: (e -> e -> a) -> Buffer -> Buffer -> [a]
+    zipWith f as bs = P.zipWith f (unpack as) (unpack bs)
+
+    unzip :: [(e,e)] -> (Buffer, Buffer)
+    unzip ls = (pack (P.map fst ls), pack (P.map snd ls))
+
+
+instance Buffered Word8 where
+    singleton = W.singleton
+
+    viewl = W.viewl
+    viewr = W.viewr
+
+    uncons = W.uncons
+    unsnoc = W.unsnoc
+
+    head = W.head
+    last = W.last
+
+    cons = W.cons
+    snoc = W.snoc
+
+    foldl = W.foldl
+    foldl' = W.foldl'
+    foldl1 = W.foldl1
+    foldl1' = W.foldl1'
+
+    foldr = W.foldr
+    foldr' = W.foldr'
+    foldr1 = W.foldr1
+    foldr1' = W.foldr1'
+
+    concatMap = W.concatMap
+
+    any = W.any
+    all = W.all
+
+    minimum = W.minimum
+    maximum = W.maximum
+
+    scanl = W.scanl
+    scanl1 = W.scanl1
+    scanr = W.scanr
+    scanr1 = W.scanr1
+    
+    mapAccumL = W.mapAccumL
+    mapAccumR = W.mapAccumR
+    
+    mapIndexed = W.mapIndexed
+
+    replicate = W.replicate
+    unfoldr = W.unfoldr
+    unfoldrN = W.unfoldN
+    takeWhile = W.takeWhile
+    dropWhile = W.dropWhile
+    span = W.span
+    spanEnd = W.spanEnd
+
+    break = W.break
+    breakEnd = W.breakEnd
+    groupBy = W.groupBy
+
+    split = W.split
+    splitWith = W.splitWith
+    
+    intersperse = W.intersperse
+
+    elem = W.elem
+    notElem = W.notElem
+     
+    find = W.find
+    filter = W.filter
+    index = W.index 
+
+    elemIndex = W.elemIndex
+    elemIndices = W.elemIndices
+    elemIndexEnd = W.elemIndexEnd 
+
+    findIndex = W.findIndex 
+    findIndices = W.findIndices
+
+    count = W.count
+    zip = W.zip
+    zipWith = W.zipWith
+    unzip = W.unzip
+
+{-
+
+instance Buffered Char where
+    singleton = C.singleton
+
+    viewl = C.viewl
+    viewr = C.viewr
+
+    uncons = C.uncons
+    unsnoc = C.unsnoc
+
+    head = C.head
+    last = C.last
+
+    foldl = C.foldl
+    foldl' = C.foldl'
+    foldl1 = C.foldl1
+    foldl1' = C.foldl1'
+
+    foldr = C.foldr
+    foldr' = C.foldr'
+    foldr1 = C.foldr1
+    foldr1' = C.foldr1'
+
+    concatMap = C.concatMap
+
+    any = C.any
+    all = C.all
+
+    minimum = C.minimum
+    maximum = C.maximum
+
+    scanl = C.scanl
+    scanl1 = C.scanl1
+    scanr = C.scanr
+    scanr1 = C.scanr1
+    
+    mapAccumL = C.mapAccumL
+    mapAccumR = C.mapAccumR
+    
+    mapIndexed = C.mapIndexed
+
+    replicate = C.replicate
+    unfoldr = C.unfoldr
+    unfoldrN = C.unfoldN
+    takeChile = C.takeChile
+    dropChile = C.dropChile
+    span = C.span
+    spanEnd = C.spanEnd
+
+    break = C.break
+    breakEnd = C.breakEnd
+    groupBy = C.groupBy
+
+    split = C.split
+    splitCith = C.splitCith
+    
+    intersperse = C.intersperse
+
+    elem = C.elem
+    notElem = C.notElem
+     
+    find = C.find
+    filter = C.filter
+    index = C.index 
+
+    elemIndex = C.elemIndex
+    elemIndices = C.elemIndices
+    elemIndexEnd = C.elemIndexEnd 
+
+    findIndex = C.findIndex 
+    findIndices = C.findIndices
+
+    count = C.count
+    zip = C.zip
+    zipCith = C.zipCith
+    unzip = C.unzip
+
+-}
hunk ./Data/Buffer/Internal.hs 1
-s{-# LANGUAGE CPP, ForeignFunctionInterface #-}
+{-# LANGUAGE CPP, ForeignFunctionInterface #-}
hunk ./Data/Buffer/Internal.hs 30
-        createAndTrim,          -- :: Int -> (Ptr Word8 -> IO Int) -> IO  Buffer
+        create',                -- :: Int -> (Ptr Word8 -> IO Int) -> IO Buffer
+        createAndTrim,          -- :: Int -> (Ptr Word8 -> IO Int) -> IO Buffer
hunk ./Data/Buffer/Internal.hs 33
-        unsafeCreate,           -- :: Int -> (Ptr Word8 -> IO ()) ->  Buffer
+        unsafeCreate,           -- :: Int -> (Ptr Word8 -> IO ()) -> Buffer
+        unsafeCreate',          -- :: Int -> (Ptr Word8 -> IO Int) -> Buffer
hunk ./Data/Buffer/Internal.hs 60
+        c_count_extras,         -- :: Ptr Word8 -> CInt -> Word8 -> IO CInt
hunk ./Data/Buffer/Internal.hs 67
-        w2c, c2w, isSpaceWord8, isSpaceChar8
+        w2c, c2w, isSpaceWord8, isSpaceChar8,
hunk ./Data/Buffer/Internal.hs 69
-        -- * UTF8 multibyte tail counting
-        extra, minusExtra, plusExtra 
+        -- * Smart Constructor
+        ps, -- :: !!(ForeignPtr Word8) -> Int -> Int -> Buffer
+        ps0, -- :: Buffer -> Int -> Int -> Buffer
hunk ./Data/Buffer/Internal.hs 73
+        -- * UTF8 multibyte tail counting
+        extra,      -- :: Word8 -> Int
+        extras,     -- :: ForeignPtr Word8 -> Int -> Int -> Int
+        minusExtra, -- :: Int -> Word8 -> Int
+        plusExtra   -- :: Int -> Word8 -> Int
hunk ./Data/Buffer/Internal.hs 92
+import qualified Data.ByteString as B
hunk ./Data/Buffer/Internal.hs 161
+-- 
+-- a couple of classes that we use extensively in the rope implementation
+--
+
+#include "measure.h"
+
+instance Measured Buffer where
+    measureU (PS _ _ l e) = PACK(l, e)
+
+instance Sized Buffer where
+    sizeU (PS _ _ l _) = UNBOX(l)
+
+
+-- -----------------------------------------------------------------------------
hunk ./Data/Buffer/Internal.hs 182
-                     {-# UNPACK #-} !Int                -- offset
-                     {-# UNPACK #-} !Int                -- length
-                     {-# UNPACK #-} !Int                -- extras
+                     {-# UNPACK #-} !Int            -- offset
+                     {-# UNPACK #-} !Int            -- length
+                     {-# UNPACK #-} !Int            -- extras
hunk ./Data/Buffer/Internal.hs 188
-                     
+
+instance Measured Buffer where
+    measure (PS _ _ l e) = (# l, e #)
+
+instance Sized Buffer where
+    size (PS _ _ l _) = l
+
+instance Valid Buffer where
+    valid (PS x s l e) = l >= 0 && e >= 0 && e <= l && e == inlinePerformIO (withForeignPtr x $ \p -> go (p `plusPtr` s) 0 0)
+    where
+        STRICT3(go)
+        go _ 0 acc = return acc
+        go p n acc = do
+            w <- peekByteOff p n
+            go p (n-1) $ acc `plusExtra` w
+
+-- | Smart constructor that builds a 'Buffer' using the same arguments required to build a 'ByteString' by
+-- just counting the multibyte tail bytes for you.
+-- TODO: replace internal 'go' with a call to 'c_count_extras'
+ps :: ForeignPtr Word8 -> Int -> Int -> Buffer
+ps x s l = PS x s l (extras x s l)
+{-# INLINE ps #-}
+
+extras :: ForeignPtr Word8 -> Int -> Int -> Int
+extras p s l = fromIntegral $ inlinePerformIO $ withForeignPtr x $ \p -> c_count_extras (p `plusPtr` s) (fromIntegral l)
+
+-- | /O(n)/ - Conversion from a strict 'ByteString'
+fromByteString :: ByteString -> Buffer
+fromByteString (B.PS x s l) = ps x s l
+
+-- | /O(1)/ - Conversion to a strict 'ByteString'
+toByteString :: Buffer -> ByteString
+toByteString (PS x s l _) = B.PS x s l
+
+-- | Exploit the fact that if out 'parent' Buffer doesn't have any multibyte tail bytes
+-- then neither can we. This could work smarter by exploiting the size of the interval
+-- to determine if it makes more sense to excise parts of the parents tail byte count,
+-- but for the common case, this should suffice.
+ps0 :: Buffer -> Int -> Int -> Buffer
+ps0 (PS x _ _ 0) s l = PS x s l 0
+ps0 (PS x _ _ _) s l = ps x s l
+{-# INLINE ps0 #-}
+
hunk ./Data/Buffer/Internal.hs 233
+STRICT1(extra)
hunk ./Data/Buffer/Internal.hs 237
+
hunk ./Data/Buffer/Internal.hs 239
+STRICT2(minusExtra)
hunk ./Data/Buffer/Internal.hs 245
+STRICT2(plusExtra)
hunk ./Data/Buffer/Internal.hs 249
-
+-- HACK. TODO: unpack via UTF8B
hunk ./Data/Buffer/Internal.hs 251
-    showsPrec p ps r = showsPrec p (unpackWith w2c ps) r
+    showsPrec p pr r = showsPrec p (unpackWith w2c pr) r
hunk ./Data/Buffer/Internal.hs 253
+-- HACK. TODO: repack via UTF8B
hunk ./Data/Buffer/Internal.hs 260
-unpackWith k (PS ps s l _) = inlinePerformIO $ withForeignPtr ps $ \p ->
+unpackWith k (PS x s l _) = inlinePerformIO $ withForeignPtr x $ \p ->
hunk ./Data/Buffer/Internal.hs 276
-        go p (x:xs) = do
+        go p (x:xs) acc = do
hunk ./Data/Buffer/Internal.hs 297
--- | /O(1)/ Build a Buffer from a ForeignPtr.
+-- | /O(n)/ Build a Buffer from a ForeignPtr.
hunk ./Data/Buffer/Internal.hs 307
-fromForeignPtr fp s l = PS fp s l
+fromForeignPtr fp s l = ps fp s l
hunk ./Data/Buffer/Internal.hs 312
-toForeignPtr (PS ps s l) = (ps, s, l)
+toForeignPtr (PS x s l _) = (x, s, l)
hunk ./Data/Buffer/Internal.hs 326
--- is less than the estimated size.
+-- is less than the estimated size. The action must also return an accurate count of the multibyte tail bytes
hunk ./Data/Buffer/Internal.hs 329
-{-# INLINE unsafeCreate #-}
+{-# INLINE unsafeCreate' #-}
hunk ./Data/Buffer/Internal.hs 347
--- | Create Buffer of size @l@ and use action @f@ to fill it's contents and count the high bits.
+-- | Create Buffer of size @l@ and use action @f@ to fill it's contents and count the multibyte tail bytes
+-- The safety of this method relies on the correctness of the returned multibyte tail byte count.
hunk ./Data/Buffer/Internal.hs 353
-    return $! PS fp 0 1 h 
+    return $! PS fp 0 l h 
hunk ./Data/Buffer/Internal.hs 380
-            then return $! (PS fp 0 l, res)
-            else do ps <- create l' $ \p' ->
-                            memcpy p' (p `plusPtr` off) (fromIntegral l')
-                    return $! (ps, res)
+            then return $! (ps fp 0 l, res)
+            else do q <- create l' $ \p' -> memcpy p' (p `plusPtr` off) (fromIntegral l')
+                    return $! (q, res)
addfile ./Data/Buffer/Internal/Classes.hs
hunk ./Data/Buffer/Internal/Classes.hs 1
+{-# LANGUAGE CPP #-}
+-- We cannot actually specify all the language pragmas, see ghc ticket #
+-- If we could, these are what they would be:
+{- LANGUAGE MagicHash, UnboxedTuples #-}
+{-# OPTIONS_HADDOCK prune #-}
+
+-- |
+-- Module      : Data.Buffer.Internal.Classes
+-- Copyright   : c) Edward Kmett 2010
+-- License     : BSD-style
+--
+-- Maintainer  : ekmett@gmail.com
+-- Stability   : experimental
+-- Portability : portable
+-- 
+-- NB: the types for measure' and size' vary across platforms. Use measure and size where possible
+
+module Data.Buffer.Internal.Classes (
+    Measured, measure, measureU, 
+    Sized, size, sizeU,
+    Valid, valid
+    ) where
+
+#include "measure.h"
+
+class Measured a where
+    -- | /O(1)/ The number of bytes in the sequence and the number of multibyte tail bytes present as well
+    measureU :: a -> TUPLE(INT,INT)
+
+measure :: a -> (Int, Int)
+measure a = (sa, ea) where MEASURED(a)
+
+chars :: a -> Int
+chars = sa - ea where MEASURED(a)
+
+class Sized a where
+    -- | /O(1)/ The number of elements in the sequence.
+    sizeU :: a -> INT
+
+size :: a -> Int
+size a = BOX (sizeU a)
+
+class Valid a where
+    -- | Sanity check to make sure invariants are all met. 
+    -- No use of the public portion of the API should be able to cause this to return False.
+    valid :: a -> Bool
addfile ./Data/Buffer/Internal/FingerTree.hs
hunk ./Data/Buffer/Internal/FingerTree.hs 1
+{-# LANGUAGE CPP #-}
+-- We cannot actually specify all the language pragmas, see ghc ticket #
+-- If we could, these are what they would be:
+{- LANGUAGE MagicHash, UnboxedTuples, NamedFieldPuns, BangPatterns, RecordWildCards -}
+{-# OPTIONS_HADDOCK prune #-}
+
+-- |
+-- Module      : Data.Buffer.Internal.FingerTree
+-- Copyright   : (c) Edward Kmett 2010
+--               (c) Ross Paterson 2005
+-- License     : BSD-style
+-- Maintainer  : ekmett@gmail.com
+-- Stability   : experimental
+-- Portability : portable
+-- 
+-- General purpose finite sequences.
+-- Apart from being finite and having strict operations, sequences
+-- also differ from lists in supporting a wider variety of operations
+-- efficiently.
+--
+-- An amortized running time is given for each operation, with /n/ referring
+-- to the length of the sequence and /i/ being the integral index used by
+-- some operations.  These bounds hold even in a persistent (shared) setting.
+--
+-- The implementation uses 2-3 finger trees annotated with sizes,
+-- as described in section 4.2 of
+--
+--    * Ralf Hinze and Ross Paterson,
+--  \"Finger trees: a simple general-purpose data structure\",
+--  /Journal of Functional Programming/ 16:2 (2006) pp 197-217.
+--  <http://www.soi.city.ac.uk/~ross/papers/FingerTree.html>
+--
+-- /Note/: Many of these operations have the same names as similar
+-- operations on lists in the "Prelude".  The ambiguity may be resolved
+-- using either qualification or the @hiding@ clause.
+--
+-- This module provides potentially unsafe access to the guts of the Rope
+-- implementation
+-----------------------------------------------------------------------------
+
+#include "measure.h"
+
+module Data.Buffer.Internal.FingerTree (
+    FingerTree(..),
+    Node(..),
+    Digit(..),
+    -- * Construction
+    empty,        -- :: FingerTree a
+    singleton,    -- :: Measured a => a -> FingerTree a
+    cons,         -- :: Measured a => a -> FingerTree a -> FingerTree a
+    snoc,         -- :: Measured a => FingerTree a -> a -> FingerTree a
+    append,       -- :: Measured a => FingerTree a -> FingerTree a -> FingerTree a
+    fromList,     -- :: Measured a => [a] -> FingerTree a
+
+    -- ** Queries
+    null,         -- :: FingerTree a -> Bool
+    viewl,        -- :: Measured a => FingerTree a -> ViewL (FingerTree a) a
+    viewr         -- :: Measured a => FingerTree a -> ViewR (FingerTree a) a
+    ) where
+
+import Prelude hiding (
+    null, length, take, drop, splitAt, foldl, foldl1, foldr, foldr1,
+    reverse)
+import qualified Data.List (foldl')
+import Control.Applicative (Applicative(..), (<$>))
+import Control.Monad (MonadPlus(..))
+import Data.Monoid (Monoid(..))
+import Data.Foldable
+import Data.Traversable
+#ifndef __GLASGOW_HASKELL__
+import Data.Typeable (Typeable, typeOf, typeOfDefault)
+#endif
+import Data.Typeable (TyCon, Typeable1(..), mkTyCon, mkTyConApp )
+
+#ifdef __GLASGOW_HASKELL__
+import Text.Read (Lexeme(Ident), lexP, parens, prec,
+    readPrec, readListPrec, readListPrecDefault)
+import Data.Data (Data(..), DataType, Constr, Fixity(..),
+                             mkConstr, mkDataType, constrIndex, gcast1)
+#endif
+
+#if TESTING
+import Control.Monad (liftM, liftM3, liftM4)
+import Test.QuickCheck
+#endif
+
+infixr 5 `consTree`
+infixl 5 `snocTree`
+
+infixr 5 `append`
+infixr 5 `cons`, :<
+infixl 5 `snoc`, :>
+
+class Valid a where
+    valid :: a -> Bool
+
+data FingerTree a
+    = Empty
+    | Single a
+    | Deep {-# UNPACK #-} !Int {-# UNPACK #-} !Int !(Digit a) (FingerTree (Node a)) !(Digit a)
+#if TESTING
+    deriving Show
+#endif
+
+instance Monoid (FingerTree a) where
+    mempty = empty
+    mappend = append
+
+instance Measured a => Measured (FingerTree a) where
+    {-# SPECIALIZE instance Measured (FingerTree Buffer) #-}
+    {-# SPECIALIZE instance Measured (FingerTree (Node a)) #-}
+    measureU Empty = 0
+    measureU (Single x) = measureU x
+    measureU (Deep v w _ _ _) = PACK(v, w)
+
+instance Sized a => Sized (FingerTree a) where
+    {-# SPECIALIZE instance Sized (FingerTree Buffer) #-}
+    {-# SPECIALIZE instance Sized (FingerTree (Node a)) #-}
+    sizeU Empty = 0
+    sizeU (Single x) = sizeU x
+    sizeU (Deep v _ _ _ _) = UNBOX(v)
+
+instance Foldable FingerTree where
+    foldr _ z Empty = z
+    foldr f z (Single x) = x `f` z
+    foldr f z (Deep _ _ pr m sf) =
+        foldr f (foldr (flip (foldr f)) (foldr f z sf) m) pr
+
+    foldl _ z Empty = z
+    foldl f z (Single x) = z `f` x
+    foldl f z (Deep _ _ pr m sf) =
+        foldl f (foldl (foldl f) (foldl f z pr) m) sf
+
+    foldr1 _ Empty = error "foldr1: empty sequence"
+    foldr1 _ (Single x) = x
+    foldr1 f (Deep _ _ pr m sf) =
+        foldr f (foldr (flip (foldr f)) (foldr1 f sf) m) pr
+
+    foldl1 _ Empty = error "foldl1: empty sequence"
+    foldl1 _ (Single x) = x
+    foldl1 f (Deep _ _ pr m sf) =
+        foldl f (foldl (foldl f) (foldl1 f pr) m) sf
+
+    foldMap f Empty = mempty
+    foldMap f (Single x) = f x 
+    foldMap f (Deep _ _ pr m sf) = foldMap f pr `mappend` foldMap (foldMap f) m `mappend` foldMap f sf
+
+-- | Like 'traverse', but with a more constrained type.
+traverse' :: (Measured a1, Measured a2, Applicative f) =>
+    (a1 -> f a2) -> FingerTree a1 -> f (FingerTree a2)
+traverse' = traverseTree
+
+traverseTree :: (Measured a2, Applicative f) =>
+    (a1 -> f a2) -> FingerTree a1 -> f (FingerTree a2)
+traverseTree _ Empty = pure Empty
+traverseTree f (Single x) = Single <$> f x
+traverseTree f (Deep _ _ pr m sf) =
+    deep <$> traverseDigit f pr <*> traverseTree (traverseNode f) m <*> traverseDigit f sf
+
+traverseNode :: (Measured a2, Applicative f) =>
+    (a1 -> f a2) -> Node a1 -> f (Node a2)
+traverseNode f (Node2 _ _ a b) = node2 <$> f a <*> f b
+traverseNode f (Node3 _ _ a b c) = node3 <$> f a <*> f b <*> f c
+
+traverseDigit :: (Applicative f) => (a -> f b) -> Digit a -> f (Digit b)
+traverseDigit f (One a) = One <$> f a
+traverseDigit f (Two a b) = Two <$> f a <*> f b
+traverseDigit f (Three a b c) = Three <$> f a <*> f b <*> f c
+traverseDigit f (Four a b c d) = Four <$> f a <*> f b <*> f c <*> f d
+
+{-# INLINE deep #-}
+{-# SPECIALIZE deep :: Digit Buffer -> FingerTree (Node Buffer) -> Digit Buffer -> FingerTree Buffer #-}
+{-# SPECIALIZE deep :: Digit (Node a) -> FingerTree (Node (Node a)) -> Digit (Node a) -> FingerTree (Node a) #-}
+deep        :: Measured a => Digit a -> FingerTree (Node a) -> Digit a -> FingerTree a
+deep pr m sf = Deep (spr + sm + ssf) (epr + em + esf) pr m sf
+    where MEASURED(pr,m,sf)
+
+-- Digits
+
+data Digit a
+    = One a
+    | Two a a
+    | Three a a a
+    | Four a a a a
+#if TESTING
+    deriving Show
+#endif
+
+instance Foldable Digit where
+    foldr f z (One a) = a `f` z
+    foldr f z (Two a b) = a `f` (b `f` z)
+    foldr f z (Three a b c) = a `f` (b `f` (c `f` z))
+    foldr f z (Four a b c d) = a `f` (b `f` (c `f` (d `f` z)))
+
+    foldl f z (One a) = z `f` a
+    foldl f z (Two a b) = (z `f` a) `f` b
+    foldl f z (Three a b c) = ((z `f` a) `f` b) `f` c
+    foldl f z (Four a b c d) = (((z `f` a) `f` b) `f` c) `f` d
+
+    foldr1 _ (One a) = a
+    foldr1 f (Two a b) = a `f` b
+    foldr1 f (Three a b c) = a `f` (b `f` c)
+    foldr1 f (Four a b c d) = a `f` (b `f` (c `f` d))
+
+    foldl1 _ (One a) = a
+    foldl1 f (Two a b) = a `f` b
+    foldl1 f (Three a b c) = (a `f` b) `f` c
+    foldl1 f (Four a b c d) = ((a `f` b) `f` c) `f` d
+
+    foldMap f (One a) = f a
+    foldMap f (Two a b) = f a `mappend` f b
+    foldMap f (Three a b c) = f a `mappend` f b `mappend` f c
+    foldMap f (Four a b c d) = (f a `mappend` f b) `mappend` (f c `mappend` f d)
+    
+instance Functor Digit where
+    fmap = fmapDefault
+
+instance Traversable Digit where
+    traverse f (One a) = One <$> f a
+    traverse f (Two a b) = Two <$> f a <*> f b
+    traverse f (Three a b c) = Three <$> f a <*> f b <*> f c
+    traverse f (Four a b c d) = Four <$> f a <*> f b <*> f c <*> f d
+
+instance Measured a => Measured (Digit a) where
+    {-# SPECIALIZE instance Measured (Digit Buffer) #-}
+    {-# SPECIALIZE instance Measured (Digit (Node a)) #-}
+    measureU (One a) = measureU a
+    measureU (Two a b) = PACK(sa + sb, ea + eb)
+        where MEASURED(a,b)
+    measureU (Two a b) = PACK(sa + sb + sc, ea + eb + ec)
+        where MEASURED(a,b,c)
+    measureU (Two a b) = PAIR(sa + sb + sc + sd, ea + eb + ec + ed)
+        where MEASURED(a,b,c,d)
+
+instance Sized a => Sized (Digit a) where
+    {-# SPECIALIZE instance Sized (Digit Buffer) #-}
+    {-# SPECIALIZE instance Sized (Digit (Node a)) #-}
+    sizeU (One a) = sizeU a
+    sizeU (Two a b) = sizeU a PLUS sizeU b
+    sizeU (Three a b c) = sizeU a PLUS sizeU b PLUS sizeU c
+    sizeU (Four a b c d) = sizeU a PLUS sizeU b PLUS sizeU c PLUS sizeU d
+
+{-# SPECIALIZE digitToTree :: Digit Buffer -> FingerTree Buffer #-}
+{-# SPECIALIZE digitToTree :: Digit (Node a) -> FingerTree (Node a) #-}
+digitToTree :: Measured a => Digit a -> FingerTree a
+digitToTree (One a) = Single a
+digitToTree (Two a b) = deep (One a) Empty (One b)
+digitToTree (Three a b c) = deep (Two a b) Empty (One c)
+digitToTree (Four a b c d) = deep (Two a b) Empty (Two c d)
+
+-- Nodes
+
+data Node a
+    = Node2 {-# UNPACK #-} !Int {-# UNPACK #-} !Int a a
+    | Node3 {-# UNPACK #-} !Int {-# UNPACK #-} !Int a a a
+#if TESTING
+    deriving Show
+#endif
+
+instance Foldable Node where
+    foldr f z (Node2 _ _ a b) = a `f` (b `f` z)
+    foldr f z (Node3 _ _ a b c) = a `f` (b `f` (c `f` z))
+
+    foldl f z (Node2 _ _ a b) = (z `f` a) `f` b
+    foldl f z (Node3 _ _ a b c) = ((z `f` a) `f` b) `f` c
+
+    foldMap f (Node2 _ _ a b) = f a `mappend` f b
+    foldMap f (Node2 _ _ a b c) = f a `mappend` f b `mappend` f c
+
+instance Measured (Node a) where
+    measureU (Node2 v e _ _) = PAIR(v, e)
+    measureU (Node3 v e _ _) = PAIR(v, e)
+
+instance Sized (Node a) where
+    sizeU (Node2 v _ _ _)  = UNBOX(v)
+    sizeU (Node3 v _ _ _ _) = UNBOX(v)
+
+{-# INLINE node2 #-}
+{-# SPECIALIZE node2 :: Elem a -> Elem a -> Node Buffer #-}
+{-# SPECIALIZE node2 :: Node a -> Node a -> Node (Node a) #-}
+node2     :: Measured a => a -> a -> Node a
+node2 a b =  Node2 (sa + sb) (xa + xb) a b
+    where MEASURED(a,b)
+
+{-# INLINE node3 #-}
+{-# SPECIALIZE node3 :: Elem a -> Elem a -> Elem a -> Node Buffer #-}
+{-# SPECIALIZE node3 :: Node a -> Node a -> Node a -> Node (Node a) #-}
+node3       :: Measured a => a -> a -> a -> Node a
+node3 a b c =  Node3 (sa + sb + sc) (xa + xb + xc) a b c
+    where MEASURED(a,b,c)
+
+nodeToDigit :: Node a -> Digit a
+nodeToDigit (Node2 _ _ a b) = Two a b
+nodeToDigit (Node3 _ _ a b c) = Three a b c
+
+-- Elements
+
+instance Measured Buffer where
+    measureU (PS _ _ l e) = PACK(l, e)
+
+instance Sized Buffer where
+    sizeU (PS _ _ l _) = UNBOX(l)
+
+------------------------------------------------------------------------
+-- Construction
+------------------------------------------------------------------------
+
+-- | /O(1)/. The empty sequence.
+empty :: FingerTree a 
+empty =  Empty
+
+-- | /O(1)/. A singleton sequence.
+singleton :: a -> FingerTree a
+singleton =  Single
+
+-- | /O(1)/. Add an element to the left end of a sequence.
+-- Mnemonic: a triangle with the single element at the pointy end.
+{-# SPECIALIZE cons :: Buffer -> FingerTree Buffer -> FingerTree Buffer #-}
+{-# SPECIALIZE cons :: Node a -> FingerTree (Node a) -> FingerTree (Node a) #-}
+cons    :: Measured a => a -> FingerTree a -> FingerTree a
+cons a Empty = Single a
+cons a (Single b) = deep (One a) Empty (One b)
+cons a (Deep s x (Four b c d e) m sf) = m `seq` 
+    Deep (sa + s) (xa + x) (Two a b) (node3 c d e `cons` m) sf
+    where MEASURED(a)
+cons a (Deep s x (Three b c d) m sf) = 
+    Deep (sa + s) (xa + x) (Four a b c d) m sf
+    where MEASURED(a)
+cons a (Deep s x (Two b c) m sf) = 
+    Deep (sa + s) (xa + x) (Three a b c) m sf
+    where MEASURED(a)
+cons a (Deep s x (One b) m sf) = 
+    Deep (sa + s) (xa + x) (Two a b) m sf
+    where MEASURED(a)
+    
+-- | /O(1)/. Add an element to the right end of a sequence.
+-- Mnemonic: a triangle with the single element at the pointy end.
+{-# SPECIALIZE snoc :: FingerTree Buffer -> Buffer -> FingerTree Buffer #-}
+{-# SPECIALIZE snoc :: FingerTree (Node a) -> Node a -> FingerTree (Node a) #-}
+snoc :: Measured a => FingerTree a -> a -> FingerTree a
+snoc Empty a    =  Single a
+snoc (Single a) b   =  deep (One a) Empty (One b)
+snoc (Deep s x pr m (Four a b c d)) e = m `seq`
+    Deep (s + se) (x + ee) pr (m `snoc` node3 a b c) (Two d e)
+    where MEASUED(e)
+snoc (Deep s x pr m (Three a b c)) d =
+    Deep (s + sd) (x + xd) pr m (Four a b c d)
+    where MEASURED(d)
+snoc (Deep s x pr m (Two a b)) c =
+    Deep (s + sc) (x + xc) pr m (Three a b c)
+    where MEASURED(c)
+snoc (Deep s x pr m (One a)) b =
+    Deep (s + sb) (x + xb) pr m (Two a b)
+    where MEASURED(b)
+
+-- | /O(log(min(n1,n2)))/. Concatenate two sequences.
+-- The appendTree/addDigits gunk below is machine generated
+append :: FingerTree Buffer -> FingerTree Buffer -> FingerTree Buffer
+append Empty xs =
+    xs
+append xs Empty =
+    xs
+append (Single x) xs =
+    x `consTree` xs
+append xs (Single x) =
+    xs `snocTree` x
+append (Deep s1 x1 pr1 m1 sf1) (Deep s2 x2 pr2 m2 sf2) =
+    Deep (s1 + s2) (x1 + x2) pr1 (addDigits0 m1 sf1 pr2 m2) sf2
+
+addDigits0 :: FingerTree (Node Buffer) -> Digit Buffer -> Digit Buffer -> FingerTree (Node Buffer) -> FingerTree (Node Buffer)
+addDigits0 m1 (One a) (One b) m2 =
+    appendTree1 m1 (node2 a b) m2
+addDigits0 m1 (One a) (Two b c) m2 =
+    appendTree1 m1 (node3 a b c) m2
+addDigits0 m1 (One a) (Three b c d) m2 =
+    appendTree2 m1 (node2 a b) (node2 c d) m2
+addDigits0 m1 (One a) (Four b c d e) m2 =
+    appendTree2 m1 (node3 a b c) (node2 d e) m2
+addDigits0 m1 (Two a b) (One c) m2 =
+    appendTree1 m1 (node3 a b c) m2
+addDigits0 m1 (Two a b) (Two c d) m2 =
+    appendTree2 m1 (node2 a b) (node2 c d) m2
+addDigits0 m1 (Two a b) (Three c d e) m2 =
+    appendTree2 m1 (node3 a b c) (node2 d e) m2
+addDigits0 m1 (Two a b) (Four c d e f) m2 =
+    appendTree2 m1 (node3 a b c) (node3 d e f) m2
+addDigits0 m1 (Three a b c) (One d) m2 =
+    appendTree2 m1 (node2 a b) (node2 c d) m2
+addDigits0 m1 (Three a b c) (Two d e) m2 =
+    appendTree2 m1 (node3 a b c) (node2 d e) m2
+addDigits0 m1 (Three a b c) (Three d e f) m2 =
+    appendTree2 m1 (node3 a b c) (node3 d e f) m2
+addDigits0 m1 (Three a b c) (Four d e f g) m2 =
+    appendTree3 m1 (node3 a b c) (node2 d e) (node2 f g) m2
+addDigits0 m1 (Four a b c d) (One e) m2 =
+    appendTree2 m1 (node3 a b c) (node2 d e) m2
+addDigits0 m1 (Four a b c d) (Two e f) m2 =
+    appendTree2 m1 (node3 a b c) (node3 d e f) m2
+addDigits0 m1 (Four a b c d) (Three e f g) m2 =
+    appendTree3 m1 (node3 a b c) (node2 d e) (node2 f g) m2
+addDigits0 m1 (Four a b c d) (Four e f g h) m2 =
+    appendTree3 m1 (node3 a b c) (node3 d e f) (node2 g h) m2
+
+appendTree1 :: FingerTree (Node a) -> Node a -> FingerTree (Node a) -> FingerTree (Node a)
+appendTree1 Empty a xs =
+    a `consTree` xs
+appendTree1 xs a Empty =
+    xs `snocTree` a
+appendTree1 (Single x) a xs =
+    x `consTree` a `consTree` xs
+appendTree1 xs a (Single x) =
+    xs `snocTree` a `snocTree` x
+appendTree1 (Deep s1 x1 pr1 m1 sf1) a (Deep s2 x2 pr2 m2 sf2) =
+    Deep (s1 + sa + s2) (x1 + xa + x2) pr1 (addDigits1 m1 sf1 a pr2 m2) sf2
+    where MEASURED(a)
+
+addDigits1 :: FingerTree (Node (Node a)) -> Digit (Node a) -> Node a -> Digit (Node a) -> FingerTree (Node (Node a)) -> FingerTree (Node (Node a))
+addDigits1 m1 (One a) b (One c) m2 =
+    appendTree1 m1 (node3 a b c) m2
+addDigits1 m1 (One a) b (Two c d) m2 =
+    appendTree2 m1 (node2 a b) (node2 c d) m2
+addDigits1 m1 (One a) b (Three c d e) m2 =
+    appendTree2 m1 (node3 a b c) (node2 d e) m2
+addDigits1 m1 (One a) b (Four c d e f) m2 =
+    appendTree2 m1 (node3 a b c) (node3 d e f) m2
+addDigits1 m1 (Two a b) c (One d) m2 =
+    appendTree2 m1 (node2 a b) (node2 c d) m2
+addDigits1 m1 (Two a b) c (Two d e) m2 =
+    appendTree2 m1 (node3 a b c) (node2 d e) m2
+addDigits1 m1 (Two a b) c (Three d e f) m2 =
+    appendTree2 m1 (node3 a b c) (node3 d e f) m2
+addDigits1 m1 (Two a b) c (Four d e f g) m2 =
+    appendTree3 m1 (node3 a b c) (node2 d e) (node2 f g) m2
+addDigits1 m1 (Three a b c) d (One e) m2 =
+    appendTree2 m1 (node3 a b c) (node2 d e) m2
+addDigits1 m1 (Three a b c) d (Two e f) m2 =
+    appendTree2 m1 (node3 a b c) (node3 d e f) m2
+addDigits1 m1 (Three a b c) d (Three e f g) m2 =
+    appendTree3 m1 (node3 a b c) (node2 d e) (node2 f g) m2
+addDigits1 m1 (Three a b c) d (Four e f g h) m2 =
+    appendTree3 m1 (node3 a b c) (node3 d e f) (node2 g h) m2
+addDigits1 m1 (Four a b c d) e (One f) m2 =
+    appendTree2 m1 (node3 a b c) (node3 d e f) m2
+addDigits1 m1 (Four a b c d) e (Two f g) m2 =
+    appendTree3 m1 (node3 a b c) (node2 d e) (node2 f g) m2
+addDigits1 m1 (Four a b c d) e (Three f g h) m2 =
+    appendTree3 m1 (node3 a b c) (node3 d e f) (node2 g h) m2
+addDigits1 m1 (Four a b c d) e (Four f g h i) m2 =
+    appendTree3 m1 (node3 a b c) (node3 d e f) (node3 g h i) m2
+
+appendTree2 :: FingerTree (Node a) -> Node a -> Node a -> FingerTree (Node a) -> FingerTree (Node a)
+appendTree2 Empty a b xs =
+    a `consTree` b `consTree` xs
+appendTree2 xs a b Empty =
+    xs `snocTree` a `snocTree` b
+appendTree2 (Single x) a b xs =
+    x `consTree` a `consTree` b `consTree` xs
+appendTree2 xs a b (Single x) =
+    xs `snocTree` a `snocTree` b `snocTree` x
+appendTree2 (Deep s1 e1 pr1 m1 sf1) a b (Deep s2 e2 pr2 m2 sf2) =
+    Deep (s1 + sa + sb + s2) (e1 + ea + eb + e2) pr1 (addDigits2 m1 sf1 a b pr2 m2) sf2
+    where MEASURED(a,b)
+
+addDigits2 :: FingerTree (Node (Node a)) -> Digit (Node a) -> Node a -> Node a -> Digit (Node a) -> FingerTree (Node (Node a)) -> FingerTree (Node (Node a))
+addDigits2 m1 (One a) b c (One d) m2 =
+    appendTree2 m1 (node2 a b) (node2 c d) m2
+addDigits2 m1 (One a) b c (Two d e) m2 =
+    appendTree2 m1 (node3 a b c) (node2 d e) m2
+addDigits2 m1 (One a) b c (Three d e f) m2 =
+    appendTree2 m1 (node3 a b c) (node3 d e f) m2
+addDigits2 m1 (One a) b c (Four d e f g) m2 =
+    appendTree3 m1 (node3 a b c) (node2 d e) (node2 f g) m2
+addDigits2 m1 (Two a b) c d (One e) m2 =
+    appendTree2 m1 (node3 a b c) (node2 d e) m2
+addDigits2 m1 (Two a b) c d (Two e f) m2 =
+    appendTree2 m1 (node3 a b c) (node3 d e f) m2
+addDigits2 m1 (Two a b) c d (Three e f g) m2 =
+    appendTree3 m1 (node3 a b c) (node2 d e) (node2 f g) m2
+addDigits2 m1 (Two a b) c d (Four e f g h) m2 =
+    appendTree3 m1 (node3 a b c) (node3 d e f) (node2 g h) m2
+addDigits2 m1 (Three a b c) d e (One f) m2 =
+    appendTree2 m1 (node3 a b c) (node3 d e f) m2
+addDigits2 m1 (Three a b c) d e (Two f g) m2 =
+    appendTree3 m1 (node3 a b c) (node2 d e) (node2 f g) m2
+addDigits2 m1 (Three a b c) d e (Three f g h) m2 =
+    appendTree3 m1 (node3 a b c) (node3 d e f) (node2 g h) m2
+addDigits2 m1 (Three a b c) d e (Four f g h i) m2 =
+    appendTree3 m1 (node3 a b c) (node3 d e f) (node3 g h i) m2
+addDigits2 m1 (Four a b c d) e f (One g) m2 =
+    appendTree3 m1 (node3 a b c) (node2 d e) (node2 f g) m2
+addDigits2 m1 (Four a b c d) e f (Two g h) m2 =
+    appendTree3 m1 (node3 a b c) (node3 d e f) (node2 g h) m2
+addDigits2 m1 (Four a b c d) e f (Three g h i) m2 =
+    appendTree3 m1 (node3 a b c) (node3 d e f) (node3 g h i) m2
+addDigits2 m1 (Four a b c d) e f (Four g h i j) m2 =
+    appendTree4 m1 (node3 a b c) (node3 d e f) (node2 g h) (node2 i j) m2
+
+appendTree3 :: FingerTree (Node a) -> Node a -> Node a -> Node a -> FingerTree (Node a) -> FingerTree (Node a)
+appendTree3 Empty a b c xs =
+    a `consTree` b `consTree` c `consTree` xs
+appendTree3 xs a b c Empty =
+    xs `snocTree` a `snocTree` b `snocTree` c
+appendTree3 (Single x) a b c xs =
+    x `consTree` a `consTree` b `consTree` c `consTree` xs
+appendTree3 xs a b c (Single x) =
+    xs `snocTree` a `snocTree` b `snocTree` c `snocTree` x
+appendTree3 (Deep s1 x1 pr1 m1 sf1) a b c (Deep s2 x2 pr2 m2 sf2) =
+    Deep (s1 + sa + sb + sc + s2) (x1 + xa + xb + xc + x2) pr1 (addDigits3 m1 sf1 a b c pr2 m2) sf2
+    where MEASURED(a,b,c)
+
+addDigits3 :: FingerTree (Node (Node a)) -> Digit (Node a) -> Node a -> Node a -> Node a -> Digit (Node a) -> FingerTree (Node (Node a)) -> FingerTree (Node (Node a))
+addDigits3 m1 (One a) b c d (One e) m2 =
+    appendTree2 m1 (node3 a b c) (node2 d e) m2
+addDigits3 m1 (One a) b c d (Two e f) m2 =
+    appendTree2 m1 (node3 a b c) (node3 d e f) m2
+addDigits3 m1 (One a) b c d (Three e f g) m2 =
+    appendTree3 m1 (node3 a b c) (node2 d e) (node2 f g) m2
+addDigits3 m1 (One a) b c d (Four e f g h) m2 =
+    appendTree3 m1 (node3 a b c) (node3 d e f) (node2 g h) m2
+addDigits3 m1 (Two a b) c d e (One f) m2 =
+    appendTree2 m1 (node3 a b c) (node3 d e f) m2
+addDigits3 m1 (Two a b) c d e (Two f g) m2 =
+    appendTree3 m1 (node3 a b c) (node2 d e) (node2 f g) m2
+addDigits3 m1 (Two a b) c d e (Three f g h) m2 =
+    appendTree3 m1 (node3 a b c) (node3 d e f) (node2 g h) m2
+addDigits3 m1 (Two a b) c d e (Four f g h i) m2 =
+    appendTree3 m1 (node3 a b c) (node3 d e f) (node3 g h i) m2
+addDigits3 m1 (Three a b c) d e f (One g) m2 =
+    appendTree3 m1 (node3 a b c) (node2 d e) (node2 f g) m2
+addDigits3 m1 (Three a b c) d e f (Two g h) m2 =
+    appendTree3 m1 (node3 a b c) (node3 d e f) (node2 g h) m2
+addDigits3 m1 (Three a b c) d e f (Three g h i) m2 =
+    appendTree3 m1 (node3 a b c) (node3 d e f) (node3 g h i) m2
+addDigits3 m1 (Three a b c) d e f (Four g h i j) m2 =
+    appendTree4 m1 (node3 a b c) (node3 d e f) (node2 g h) (node2 i j) m2
+addDigits3 m1 (Four a b c d) e f g (One h) m2 =
+    appendTree3 m1 (node3 a b c) (node3 d e f) (node2 g h) m2
+addDigits3 m1 (Four a b c d) e f g (Two h i) m2 =
+    appendTree3 m1 (node3 a b c) (node3 d e f) (node3 g h i) m2
+addDigits3 m1 (Four a b c d) e f g (Three h i j) m2 =
+    appendTree4 m1 (node3 a b c) (node3 d e f) (node2 g h) (node2 i j) m2
+addDigits3 m1 (Four a b c d) e f g (Four h i j k) m2 =
+    appendTree4 m1 (node3 a b c) (node3 d e f) (node3 g h i) (node2 j k) m2
+
+appendTree4 :: FingerTree (Node a) -> Node a -> Node a -> Node a -> Node a -> FingerTree (Node a) -> FingerTree (Node a)
+appendTree4 Empty a b c d xs =
+    a `consTree` b `consTree` c `consTree` d `consTree` xs
+appendTree4 xs a b c d Empty =
+    xs `snocTree` a `snocTree` b `snocTree` c `snocTree` d
+appendTree4 (Single x) a b c d xs =
+    x `consTree` a `consTree` b `consTree` c `consTree` d `consTree` xs
+appendTree4 xs a b c d (Single x) =
+    xs `snocTree` a `snocTree` b `snocTree` c `snocTree` d `snocTree` x
+appendTree4 (Deep s1 x1 pr1 m1 sf1) a b c d (Deep s2 x2 pr2 m2 sf2) =
+    Deep (s1 + sa + sb + sc + sd + s2) (x1 + xa + xb + xc + xd + x2) pr1 (addDigits4 m1 sf1 a b c d pr2 m2) sf2
+    where MEASURED(a,b,c,d)
+
+addDigits4 :: FingerTree (Node (Node a)) -> Digit (Node a) -> Node a -> Node a -> Node a -> Node a -> Digit (Node a) -> FingerTree (Node (Node a)) -> FingerTree (Node (Node a))
+addDigits4 m1 (One a) b c d e (One f) m2 =
+    appendTree2 m1 (node3 a b c) (node3 d e f) m2
+addDigits4 m1 (One a) b c d e (Two f g) m2 =
+    appendTree3 m1 (node3 a b c) (node2 d e) (node2 f g) m2
+addDigits4 m1 (One a) b c d e (Three f g h) m2 =
+    appendTree3 m1 (node3 a b c) (node3 d e f) (node2 g h) m2
+addDigits4 m1 (One a) b c d e (Four f g h i) m2 =
+    appendTree3 m1 (node3 a b c) (node3 d e f) (node3 g h i) m2
+addDigits4 m1 (Two a b) c d e f (One g) m2 =
+    appendTree3 m1 (node3 a b c) (node2 d e) (node2 f g) m2
+addDigits4 m1 (Two a b) c d e f (Two g h) m2 =
+    appendTree3 m1 (node3 a b c) (node3 d e f) (node2 g h) m2
+addDigits4 m1 (Two a b) c d e f (Three g h i) m2 =
+    appendTree3 m1 (node3 a b c) (node3 d e f) (node3 g h i) m2
+addDigits4 m1 (Two a b) c d e f (Four g h i j) m2 =
+    appendTree4 m1 (node3 a b c) (node3 d e f) (node2 g h) (node2 i j) m2
+addDigits4 m1 (Three a b c) d e f g (One h) m2 =
+    appendTree3 m1 (node3 a b c) (node3 d e f) (node2 g h) m2
+addDigits4 m1 (Three a b c) d e f g (Two h i) m2 =
+    appendTree3 m1 (node3 a b c) (node3 d e f) (node3 g h i) m2
+addDigits4 m1 (Three a b c) d e f g (Three h i j) m2 =
+    appendTree4 m1 (node3 a b c) (node3 d e f) (node2 g h) (node2 i j) m2
+addDigits4 m1 (Three a b c) d e f g (Four h i j k) m2 =
+    appendTree4 m1 (node3 a b c) (node3 d e f) (node3 g h i) (node2 j k) m2
+addDigits4 m1 (Four a b c d) e f g h (One i) m2 =
+    appendTree3 m1 (node3 a b c) (node3 d e f) (node3 g h i) m2
+addDigits4 m1 (Four a b c d) e f g h (Two i j) m2 =
+    appendTree4 m1 (node3 a b c) (node3 d e f) (node2 g h) (node2 i j) m2
+addDigits4 m1 (Four a b c d) e f g h (Three i j k) m2 =
+    appendTree4 m1 (node3 a b c) (node3 d e f) (node3 g h i) (node2 j k) m2
+addDigits4 m1 (Four a b c d) e f g h (Four i j k l) m2 =
+    appendTree4 m1 (node3 a b c) (node3 d e f) (node3 g h i) (node3 j k l) m2
+
+------------------------------------------------------------------------
+-- Deconstruction
+------------------------------------------------------------------------
+
+-- | /O(1)/. Is this the empty sequence?
+null       :: FingerTree a-> Bool
+null Empty = True
+null _     =  False
+
+-- Views
+
+-- | /O(1)/. Analyse the left end of a sequence.
+{-# SPECIALIZE viewl :: FingerTree Buffer -> ViewL (FingerTree Buffer) Buffer #-}
+{-# SPECIALIZE viewl :: FingerTree (Node a) -> ViewL (FingerTree (Node a) (Node a) #-}
+viewl   :: Measured a => FingerTree a -> ViewL (FingerTree a) a
+viewl Empty             = EmptyL 
+viewl (Single a)        = a :< Empty
+viewl (Deep s e (One a) m sf) = a :< case viewl m of
+    Nothing2    -> digitToTree sf
+    b :< m'  -> Deep (s - sa) (e - ea) (nodeToDigit b) m' sf)
+    where MEASURED(a)
+viewl (Deep s e (Two a b) m sf) =
+    a :< Deep (s - sa) (e - ea) (One b) m sf
+    where MEASURED(a)
+viewl (Deep s e (Three a b c) m sf) =
+    a :< Deep (s - sa) (e - ea) (Two b c) m sf
+    where MEASURED(a)
+viewl (Deep s e (Four a b c d) m sf) =
+    a :< Deep (s - sa) (e - ea) (Three b c d) m sf
+    where MEASURED(a)
+
+-- | /O(1)/. Analyse the right end of a sequence.
+{-# SPECIALIZE viewrTree :: FingerTree Buffer -> ViewR (FingerTree Buffer) Buffer #-}
+{-# SPECIALIZE viewrTree :: FingerTree (Node a) -> ViewR (FingerTree (Node a)) (Node a) #-}
+viewr :: Measured a => FingerTree a -> ViewR (FingerTree a) a
+viewr Empty = EmptyR
+viewr (Single z) = Empty :> z
+viewr (Deep s e pr m (One z)) = (case viewr m of
+    EmptyR   -> digitToTree pr
+    m' :> y  -> Deep (s - sz) (e - ez) pr m' (nodeToDigit y)) :> z
+    where MEASURED(z)
+viewr (Deep s e pr m (Two y z)) =
+    Deep (s - sz) (e - ez) pr m (One y) :> z
+    where MEASURED(z)
+viewr (Deep s e pr m (Three x y z)) =
+    Deep (s - sz) (e - ez) pr m (Two x y) :> z
+    where MEASURED(z)
+viewr (Deep s e pr m (Four w x y z)) =
+    Deep (s - sz) (e - ez) pr m (Three w x y) :> z
+    where MEASURED(z)
+
+{-# SPECIALIZE deepL :: Maybe (Digit Buffer) -> FingerTree (Node Buffer) -> Digit Buffer -> FingerTree Buffer #-}
+{-# SPECIALIZE deepL :: Maybe (Digit (Node a)) -> FingerTree (Node (Node a)) -> Digit (Node a) -> FingerTree (Node a) #-}
+deepL :: Measured a => Maybe (Digit a) -> FingerTree (Node a) -> Digit a -> FingerTree a
+deepL Nothing m sf  = case viewlTree m of
+    EmptyL -> digitToTree sf
+    a :< m' -> Deep (sm + ssf) (em + esf) (nodeToDigit a) m' sf
+    where MEASURED(m,sf)
+deepL (Just pr) m sf = deep pr m sf
+
+{-# SPECIALIZE deepR :: Digit Buffer -> FingerTree (Node Buffer) -> Maybe (Digit Buffer) -> FingerTree Buffer #-}
+{-# SPECIALIZE deepR :: Digit (Node a) -> FingerTree (Node (Node a)) -> Maybe (Digit (Node a)) -> FingerTree (Node a) #-}
+deepR :: Measured a => Digit a -> FingerTree (Node a) -> Maybe (Digit a) -> FingerTree a
+deepR pr m Nothing  = case viewrTree m of
+    EmptyR -> digitToTree pr
+    m' :< a -> Deep (spr + sm) (epr + em) pr m' (nodeToDigit a)
+    where MEASURED(pr,m)
+deepR pr m (Just sf) = deep pr m sf
+
+------------------------------------------------------------------------
+-- Lists
+------------------------------------------------------------------------
+
+-- | /O(n)/. Create a sequence from a finite list of elements.
+-- There is a function 'toList' in the opposite direction for all
+-- instances of the 'Foldable' class, including 'Rope'.
+fromList :: Measured a => [a] -> FingerTree a
+fromList = foldr cons empty
+
+#if TESTING
+
+------------------------------------------------------------------------
+-- QuickCheck
+------------------------------------------------------------------------
+
+instance (Arbitrary a, Measured a) => Arbitrary (FingerTree a) where
+    arbitrary = liftM Roperbitrary
+    coarbitrary (Rope x) = coarbitrary x
+
+instance Arbitrary a => Arbitrary Buffer where
+    arbitrary = liftM Elem arbitrary
+    coarbitrary (Elem x) = coarbitrary x
+
+instance (Arbitrary a, Measured a) => Arbitrary (FingerTree a) where
+    arbitrary = sized arb
+      where arb :: (Arbitrary a, Measured a) => Int -> Gen (FingerTree a)
+        arb 0 = return Empty
+        arb 1 = liftM Single arbitrary
+        arb n = liftM3 deep arbitrary (arb (n `div` 2)) arbitrary
+
+    coarbitrary Empty = variant 0
+    coarbitrary (Single x) = variant 1 . coarbitrary x
+    coarbitrary (Deep _ _ pr m sf) =
+        variant 2 . coarbitrary pr . coarbitrary m . coarbitrary sf
+
+instance (Arbitrary a, Measured a) => Arbitrary (Node a) where
+    arbitrary = oneof [
+            liftM2 node2 arbitrary arbitrary,
+            liftM3 node3 arbitrary arbitrary arbitrary]
+
+    coarbitrary (Node2 _ _ a b) = variant 0 . coarbitrary a . coarbitrary b
+    coarbitrary (Node3 _ _ a b c) =
+        variant 1 . coarbitrary a . coarbitrary b . coarbitrary c
+
+instance Arbitrary a => Arbitrary (Digit a) where
+    arbitrary = oneof [
+            liftM One arbitrary,
+            liftM2 Two arbitrary arbitrary,
+            liftM3 Three arbitrary arbitrary arbitrary,
+            liftM4 Four arbitrary arbitrary arbitrary arbitrary]
+
+    coarbitrary (One a) = variant 0 . coarbitrary a
+    coarbitrary (Two a b) = variant 1 . coarbitrary a . coarbitrary b
+    coarbitrary (Three a b c) =
+        variant 2 . coarbitrary a . coarbitrary b . coarbitrary c
+    coarbitrary (Four a b c d) =
+        variant 3 . coarbitrary a . coarbitrary b . coarbitrary c . coarbitrary d
+#endif
+
+------------------------------------------------------------------------
+-- Valid trees
+------------------------------------------------------------------------
+
+instance Valid Buffer where
+    valid _ = True
+
+instance (Measured a, Valid a) => Valid (FingerTree a) where
+    valid Empty = True
+    valid (Single x) = valid x
+    valid (Deep s e pr m sf) =
+        s == spr + sm + ssf && e == epr + em + esf && e >= 0 && e <= s && valid pr && valid m && valid sf
+        where MEASURED(pr,m,sf)
+
+instance (Measured a, Valid a) => Valid (Node a) where
+    valid (Node2 s e a b) = s == s == sa + sb && e == ea + eb && e >= 0 && e <= s && valid a && valid b
+        where MEASURED(a,b)
+    valid (Node3 s e a b c) = s == sa+ sb + sc && e == ea + eb + ec && e >= 0 && e <= s && valid a && valid b && valid c
+
+instance Valid a => Valid (Digit a) where
+    valid (One a) = valid a
+    valid (Two a b) = valid a && valid b
+    valid (Three a b c) = valid a && valid b && valid c
+    valid (Four a b c d) = valid a && valid b && valid c && valid d
+
addfile ./Data/Buffer/Lazy.hs
hunk ./Data/Buffer/Lazy.hs 1
+-- We cannot actually specify all the language pragmas, see ghc ticket #
+-- If we could, these are what they would be:
+{- LANGUAGE MagicHash, UnboxedTuples,
+            NamedFieldPuns, BangPatterns, RecordWildCards -}
+{- OPTIONS_HADDOCK prune -}
+
+-- |
+-- Module      : Data.Buffer.Lazy
+-- Copyright   : (c) The University of Glasgow 2001,
+--               (c) David Roundy 2003-2005,
+--               (c) Simon Marlow 2005
+--               (c) Bjorn Bringert 2006
+--               (c) Don Stewart 2005-2008
+--               (c) Edward Kmett 2009-2010
+--
+--               Array fusion code:
+--               (c) 2001,2002 Manuel M T Chakravarty & Gabriele Keller
+--               (c) 2006      Manuel M T Chakravarty & Roman Leshchinskiy
+--
+-- License     : BSD-style
+--
+-- Maintainer  : ekmett@gmail.com
+-- Stability   : experimental
+-- Portability : portable
+-- 
+-- A time and space-efficient implementation of byte vectors using
+-- packed Word8 arrays, suitable for high performance use, both in terms
+-- of large data quantities, or high speed requirements. Byte vectors
+-- are encoded as strict 'Word8' arrays of bytes, held in a 'ForeignPtr',
+-- and can be passed between C and Haskell with little effort.
+--
+-- This module is intended to be imported @qualified@, to avoid name
+-- clashes with "Prelude" functions.  eg.
+--
+-- > import qualified Data.Buffer as B
+--
+-- Original GHC implementation by Bryan O\'Sullivan.
+-- Rewritten to use 'Data.Array.Unboxed.UArray' by Simon Marlow.
+-- Rewritten to support slices and use 'ForeignPtr' by David Roundy.
+-- Polished and extended by Don Stewart.
+--
+
+module Data.Buffer.Lazy (
+        module Data.Buffer.Lazy.Word8
+  ) where
+
+import Data.Buffer.Lazy.Word8
hunk ./Data/Buffer/Lazy/Internal.hs 36
-
hunk ./Data/Buffer/Lazy/Internal.hs 38
+import Data.Buffer.Internal.Classes
hunk ./Data/Buffer/Lazy/Internal.hs 69
---
-invariant :: Buffer -> Bool
-invariant Empty                     = True
-invariant (Chunk (S.PS _ _ len) cs) = len > 0 && invariant cs
+-- Furthermore, the number of multibyte tail bytes must be non negative and cannot
+-- exceed the total number of bytes
+
+instance Valid Buffer where
+    valid Empty = True
+    valid (Chunk c@(S.PS _ _ len _) cs) = len > 0 && valid c && valid cs
+
hunk ./Data/Buffer/Lazy/Internal.hs 80
-checkInvariant (Chunk c@(S.PS _ _ len) cs)
-    | len > 0   = Chunk c (checkInvariant cs)
+checkInvariant (Chunk c@(S.PS _ _ len e) cs)
+    | len > 0 && e >= 0 && e <= len  = Chunk c (checkInvariant cs)
hunk ./Data/Buffer/Lazy/Internal.hs 89
-chunk c@(S.PS _ _ len) cs | len == 0  = cs
-                          | otherwise = Chunk c cs
+chunk c@(S.PS _ _ len _) cs | len == 0  = cs
+                            | otherwise = Chunk c cs
hunk ./Data/Buffer/Lazy/Word8.hs 47
-
hunk ./Data/Buffer/Lazy/Word8.hs 450
-        intersperse' (S.PS fp o l) =
-          S.unsafeCreate (2*l) $ \p' -> withForeignPtr fp $ \p -> do
+        intersperse' (S.PS fp o l e) =
+          S.unsafeCreate' (2*l) $ \p' -> withForeignPtr fp $ \p -> do
hunk ./Data/Buffer/Lazy/Word8.hs 454
+            return $! e + l * S.extra w
hunk ./Data/Buffer/Lazy/Word8.hs 1332
-findIndexOrEnd k (S.PS x s l) = S.inlinePerformIO $ withForeignPtr x $ \f -> go (f `plusPtr` s) 0
+findIndexOrEnd k (S.PS x s l _) = S.inlinePerformIO $ withForeignPtr x $ \f -> go (f `plusPtr` s) 0
addfile ./Data/Buffer/Rope/Char.hs
hunk ./Data/Buffer/Rope/Char.hs 1
+{-# LANGUAGE CPP #-}
+{-# OPTIONS_GHC -fno-warn-incomplete-patterns #-}
+{-# OPTIONS_HADDOCK prune #-}
+
+-- |
+-- Module      : Data.Buffer.Rope.Char
+-- Copyright   : (c) Don Stewart 2006
+--               (c) Duncan Coutts 2006
+--               (c) Edward Kmett 2010
+-- License     : BSD-style
+--
+-- Maintainer  : ekmett@gmail.com
+-- Stability   : experimental
+-- Portability : portable
+-- 
+-- Some operations, such as concat, append, reverse and cons, have
+-- better complexity than their "Data.Buffer" equivalents, due to
+-- optimisations resulting from the fingertree spine. 
+--
+-- This module is intended to be imported @qualified@, to avoid name
+-- clashes with "Prelude" functions.  eg.
+--
+-- > import qualified Data.Buffer.Rope.Word8 as R
+--
+-- Original GHC implementation by Bryan O\'Sullivan.
+-- Rewritten to use 'Data.Array.Unboxed.UArray' by Simon Marlow.
+-- Rewritten to support slices and use 'Foreign.ForeignPtr.ForeignPtr'
+-- by David Roundy.
+-- Polished and extended by Don Stewart.
+-- Lazy variant by Duncan Coutts and Don Stewart.
+-- A number of FingerTree algorithms are by Ross Paterson and Louis Wasserman
+-- Converted to use a fingertree by Edward Kmett
+
+module Data.Buffer.Rope.Char (
+        -- * The @Buffer@ type
+        Rope,                   -- instances: Eq, Ord, Show, Read, Data, Typeable
+
+        -- * Introducing and eliminating 'Buffer's
+        empty,                  -- :: Rope
+        singleton,              -- :: Char -> Rope
+        pack,                   -- :: String -> Rope
+        unpack,                 -- :: Rope -> String
+        fromChunks,             -- :: [Buffer] -> Rope
+        toChunks,               -- :: Rope -> [Buffer]
+
+        -- * Basic interface
+        cons,                   -- :: Char -> Rope -> Rope
+        snoc,                   -- :: Rope -> Char -> Rope
+        append,                 -- :: Rope -> Rope -> Rope
+        head,                   -- :: Rope -> Char
+        uncons,                 -- :: Rope -> Maybe (Char, Rope)
+        last,                   -- :: Rope -> Char
+        tail,                   -- :: Rope -> Rope
+        init,                   -- :: Rope -> Rope
+        null,                   -- :: Rope -> Bool
+        length,                 -- :: Rope -> Int
+
+        -- * Transforming 'Rope's
+        map,                    -- :: (Char -> Char) -> Rope -> Rope
+        reverse,                -- :: Rope -> Rope
+        intersperse,            -- :: Char -> Rope -> Rope
+        intercalate,            -- :: Rope -> [Rope] -> Rope
+        transpose,              -- :: [Rope] -> [Rope]
+
+        -- * Reducing 'Rope's (folds)
+        foldl,                  -- :: (a -> Char -> a) -> a -> Rope -> a
+        foldl',                 -- :: (a -> Char -> a) -> a -> Rope -> a
+        foldl1,                 -- :: (Char -> Char -> Char) -> Rope -> Char
+        foldl1',                -- :: (Char -> Char -> Char) -> Rope -> Char
+        foldr,                  -- :: (Char -> a -> a) -> a -> Rope -> a
+        foldr1,                 -- :: (Char -> Char -> Char) -> Rope -> Char
+
+        -- ** Special folds
+        concat,                 -- :: [Rope] -> Rope
+        concatMap,              -- :: (Char -> Rope) -> Rope -> Rope
+        any,                    -- :: (Char -> Bool) -> Rope -> Bool
+        all,                    -- :: (Char -> Bool) -> Rope -> Bool
+        maximum,                -- :: Rope -> Char
+        minimum,                -- :: Rope -> Char
+
+        -- * Building 'Rope's
+        -- ** Scans
+        scanl,                  -- :: (Char -> Char -> Char) -> Char -> Rope -> Rope
+        scanl1,                 -- :: (Char -> Char -> Char) -> Rope -> Rope
+        scanr,                  -- :: (Char -> Char -> Char) -> Char -> Rope -> Rope
+        scanr1,                 -- :: (Char -> Char -> Char) -> Rope -> Rope
+
+        -- ** Accumulating maps
+        mapAccumL,              -- :: (acc -> Char -> (acc, Char)) -> acc -> Rope -> (acc, Rope)
+        mapAccumR,              -- :: (acc -> Char -> (acc, Char)) -> acc -> Rope -> (acc, Rope)
+
+        -- ** Replicated 'Rope's
+        replicate,              -- :: Int -> Char -> Rope
+        replicateBuffer,        -- :: Int -> Buffer -> Rope
+
+        -- ** Unfolding Buffers
+        unfoldr,                -- :: (a -> Maybe (Char, a)) -> a -> Rope
+
+        -- * Substrings
+
+        -- ** Breaking strings
+        take,                   -- :: Int -> Rope -> Rope
+        drop,                   -- :: Int -> Rope -> Rope
+        splitAt,                -- :: Int -> Rope -> (Rope, Rope)
+
+        takeWhile,              -- :: (Char -> Bool) -> Rope -> Rope
+        dropWhile,              -- :: (Char -> Bool) -> Rope -> Rope
+        span,                   -- :: (Char -> Bool) -> Rope -> (Rope, Rope)
+        break,                  -- :: (Char -> Bool) -> Rope -> (Rope, Rope)
+
+        group,                  -- :: Rope -> [Rope]
+        groupBy,                -- :: (Char -> Char -> Bool) -> Rope -> [Rope]
+        inits,                  -- :: Rope -> [Rope]
+        tails,                  -- :: Rope -> [Rope]
+
+        -- ** Breaking into many substrings
+        split,                  -- :: Char -> Rope -> [Rope]
+        splitWith,              -- :: (Char -> Bool) -> Rope -> [Rope]
+
+        -- * Predicates
+        isPrefixOf,             -- :: Rope -> Rope -> Bool
+        isSuffixOf,             -- :: Rope -> Rope -> Bool
+
+        -- * Searching Ropes
+
+        -- ** Searching by equality
+        elem,                   -- :: Char -> Rope -> Bool
+        notElem,                -- :: Char -> Rope -> Bool
+
+        -- ** Searching with a predicate
+        find,                   -- :: (Char -> Bool) -> Rope -> Maybe Char
+        filter,                 -- :: (Char -> Bool) -> Rope -> Rope
+        partition,              -- :: (Char -> Bool) -> Rope -> (Rope, Rope)
+
+        -- * Indexing Ropes
+        index,                  -- :: Rope -> Int -> Char
+        elemIndex,              -- :: Char -> Rope -> Maybe Int
+        elemIndices,            -- :: Char -> Rope -> [Int]
+        findIndex,              -- :: (Char -> Bool) -> Rope -> Maybe Int
+        findIndices,            -- :: (Char -> Bool) -> Rope -> [Int]
+        count,                  -- :: Char -> Rope -> Int
+
+        -- * Zipping and unzipping Ropes
+        zip,                    -- :: Rope -> Rope -> [(Char, Char)]
+        zipWith,                -- :: (Char -> Char -> c) -> Rope -> Rope -> [c]
+        unzip,                  -- :: [(Char,Char)] -> (Rope, Rope)
+
+        -- * Ordered Ropes
+--        sort,                   -- :: Rope -> Rope
+
+        -- * Low level conversions
+        -- ** Copying Ropes
+        copy,                   -- :: Rope -> Rope
+--        defrag,                -- :: Rope -> Rope
+
+        -- * I\/O with 'Rope's
+
+        -- ** Standard input and output
+        getContents,            -- :: IO Rope
+        putStr,                 -- :: Rope -> IO ()
+        putStrLn,               -- :: Rope -> IO ()
+        interact,               -- :: (Rope -> Rope) -> IO ()
+
+        -- ** Files
+        readFile,               -- :: FilePath -> IO Rope
+        writeFile,              -- :: FilePath -> Rope -> IO ()
+        appendFile,             -- :: FilePath -> Rope -> IO ()
+
+        -- ** I\/O with Handles
+        hGetContents,           -- :: Handle -> IO Rope
+        hGet,                   -- :: Handle -> Int -> IO Rope
+        hGetNonBlocking,        -- :: Handle -> Int -> IO Rope
+        hPut,                   -- :: Handle -> Rope -> IO ()
+        hPutStr,                -- :: Handle -> Rope -> IO ()
+
+  ) where
+
+import Prelude hiding
+    (reverse,head,tail,last,init,null,length,map,lines,foldl,foldr,unlines
+    ,concat,any,take,drop,splitAt,takeWhile,dropWhile,span,break,elem,filter,maximum
+    ,minimum,all,concatMap,foldl1,foldr1,scanl, scanl1, scanr, scanr1
+    ,repeat, cycle, interact, iterate,readFile,writeFile,appendFile,replicate
+    ,getContents,getLine,putStr,putStrLn ,zip,zipWith,unzip,notElem)
+
+import qualified Data.List as L  -- L for list/lazy
+import qualified Data.Buffer.Word8 as P  (Buffer) -- type name only
+import qualified Data.Buffer.Word8 as S  -- S for strict (hmm...)
+import qualified Data.Buffer.Char as C
+import qualified Data.Buffer.Internal as S
+import qualified Data.Buffer.Unsafe as S
+import Data.Buffer.Lazy.Internal
+
+import Data.Monoid              (Monoid(..))
+
+import Data.Word                (Word8)
+import Data.Int                 (Int64)
+import System.IO                (Handle,stdin,stdout,openBinaryFile,IOMode(..)
+                                ,hClose,hWaitForInput,hIsEOF)
+import System.IO.Error          (mkIOError, illegalOperationErrorType)
+import System.IO.Unsafe
+#ifndef __NHC__
+import Control.Exception        (bracket)
+#else
+import IO		        (bracket)
+#endif
+
+import Foreign.ForeignPtr       (withForeignPtr)
+import Foreign.Ptr
+import Foreign.Storable
+
+-- -----------------------------------------------------------------------------
+--
+-- Useful macros, until we have bang patterns
+--
+
+#define STRICT1(f) f a | a `seq` False = undefined
+#define STRICT2(f) f a b | a `seq` b `seq` False = undefined
+#define STRICT3(f) f a b c | a `seq` b `seq` c `seq` False = undefined
+#define STRICT4(f) f a b c d | a `seq` b `seq` c `seq` d `seq` False = undefined
+#define STRICT5(f) f a b c d e | a `seq` b `seq` c `seq` d `seq` e `seq` False = undefined
+
+-- -----------------------------------------------------------------------------
+
+instance Eq  Buffer
+    where (==)    = eq
+
+instance Ord Buffer
+    where compare = cmp
+
+instance Monoid Buffer where
+    mempty  = empty
+    mappend = append
+    mconcat = concat
+
+eq :: Buffer -> Buffer -> Bool
+eq Empty Empty = True
+eq Empty _     = False
+eq _     Empty = False
+eq (Chunk a as) (Chunk b bs) =
+  case compare (S.length a) (S.length b) of
+    LT -> a == (S.take (S.length a) b) && eq as (Chunk (S.drop (S.length a) b) bs)
+    EQ -> a == b                       && eq as bs
+    GT -> (S.take (S.length b) a) == b && eq (Chunk (S.drop (S.length b) a) as) bs
+
+cmp :: Buffer -> Buffer -> Ordering
+cmp Empty Empty = EQ
+cmp Empty _     = LT
+cmp _     Empty = GT
+cmp (Chunk a as) (Chunk b bs) =
+  case compare (S.length a) (S.length b) of
+    LT -> case compare a (S.take (S.length a) b) of
+            EQ     -> cmp as (Chunk (S.drop (S.length a) b) bs)
+            result -> result
+    EQ -> case compare a b of
+            EQ     -> cmp as bs
+            result -> result
+    GT -> case compare (S.take (S.length b) a) b of
+            EQ     -> cmp (Chunk (S.drop (S.length b) a) as) bs
+            result -> result
+
+-- -----------------------------------------------------------------------------
+-- Introducing and eliminating 'Buffer's
+
+-- | /O(1)/ The empty 'Buffer'
+empty :: Buffer
+empty = Empty
+{-# INLINE empty #-}
+
+-- | /O(1)/ Convert a 'Word8' into a 'Buffer'
+singleton :: Word8 -> Buffer
+singleton w = Chunk (S.singleton w) Empty
+{-# INLINE singleton #-}
+
+-- | /O(n)/ Convert a '[Word8]' into a 'Buffer'. 
+pack :: [Word8] -> Buffer
+pack ws = L.foldr (Chunk . S.pack) Empty (chunks defaultChunkSize ws)
+  where
+    chunks :: Int -> [a] -> [[a]]
+    chunks _    [] = []
+    chunks size xs = case L.splitAt size xs of
+                      (xs', xs'') -> xs' : chunks size xs''
+
+-- | /O(n)/ Converts a 'Buffer' to a '[Word8]'.
+unpack :: Buffer -> [Word8]
+unpack cs = L.concatMap S.unpack (toChunks cs)
+--TODO: we can do better here by integrating the concat with the unpack
+
+-- | /O(c)/ Convert a list of strict 'Buffer' into a lazy 'Buffer'
+fromChunks :: [P.Buffer] -> Buffer
+fromChunks cs = L.foldr chunk Empty cs
+
+-- | /O(n)/ Convert a lazy 'Buffer' into a list of strict 'Buffer'
+toChunks :: Buffer -> [P.Buffer]
+toChunks cs = foldrChunks (:) [] cs
+
+------------------------------------------------------------------------
+
+{-
+-- | /O(n)/ Convert a '[a]' into a 'Buffer' using some
+-- conversion function
+packWith :: (a -> Word8) -> [a] -> Buffer
+packWith k str = LPS $ L.map (P.packWith k) (chunk defaultChunkSize str)
+{-# INLINE packWith #-}
+{-# SPECIALIZE packWith :: (Char -> Word8) -> [Char] -> Buffer #-}
+
+-- | /O(n)/ Converts a 'Buffer' to a '[a]', using a conversion function.
+unpackWith :: (Word8 -> a) -> Buffer -> [a]
+unpackWith k (LPS ss) = L.concatMap (S.unpackWith k) ss
+{-# INLINE unpackWith #-}
+{-# SPECIALIZE unpackWith :: (Word8 -> Char) -> Buffer -> [Char] #-}
+-}
+
+-- ---------------------------------------------------------------------
+-- Basic interface
+
+-- | /O(1)/ Test whether a Buffer is empty.
+null :: Buffer -> Bool
+null Empty = True
+null _     = False
+{-# INLINE null #-}
+
+-- | /O(n\/c)/ 'length' returns the length of a Buffer as an 'Int64'
+length :: Buffer -> Int64
+length cs = foldlChunks (\n c -> n + fromIntegral (S.length c)) 0 cs
+{-# INLINE length #-}
+
+-- | /O(1)/ 'cons' is analogous to '(:)' for lists.
+--
+cons :: Word8 -> Buffer -> Buffer
+cons c cs = Chunk (S.singleton c) cs
+{-# INLINE cons #-}
+
+-- | /O(1)/ Unlike 'cons', 'cons\'' is
+-- strict in the Buffer that we are consing onto. More precisely, it forces
+-- the head and the first chunk. It does this because, for space efficiency, it
+-- may coalesce the new byte onto the first \'chunk\' rather than starting a
+-- new \'chunk\'.
+--
+-- So that means you can't use a lazy recursive contruction like this:
+--
+-- > let xs = cons\' c xs in xs
+--
+-- You can however use 'cons', as well as 'repeat' and 'cycle', to build
+-- infinite lazy Buffers.
+--
+cons' :: Word8 -> Buffer -> Buffer
+cons' w (Chunk c cs) | S.length c < 16 = Chunk (S.cons w c) cs
+cons' w cs                             = Chunk (S.singleton w) cs
+{-# INLINE cons' #-}
+
+-- | /O(n\/c)/ Append a byte to the end of a 'Buffer'
+snoc :: Buffer -> Word8 -> Buffer
+snoc cs w = foldrChunks Chunk (singleton w) cs
+{-# INLINE snoc #-}
+
+-- | /O(1)/ Extract the first element of a Buffer, which must be non-empty.
+head :: Buffer -> Word8
+head Empty       = errorEmptyList "head"
+head (Chunk c _) = S.unsafeHead c
+{-# INLINE head #-}
+
+-- | /O(1)/ Extract the head and tail of a Buffer, returning Nothing
+-- if it is empty.
+uncons :: Buffer -> Maybe (Word8, Buffer)
+uncons Empty = Nothing
+uncons (Chunk c cs)
+    = Just (S.unsafeHead c,
+            if S.length c == 1 then cs else Chunk (S.unsafeTail c) cs)
+{-# INLINE uncons #-}
+
+-- | /O(1)/ Extract the elements after the head of a Buffer, which must be
+-- non-empty.
+tail :: Buffer -> Buffer
+tail Empty          = errorEmptyList "tail"
+tail (Chunk c cs)
+  | S.length c == 1 = cs
+  | otherwise       = Chunk (S.unsafeTail c) cs
+{-# INLINE tail #-}
+
+-- | /O(n\/c)/ Extract the last element of a Buffer, which must be finite
+-- and non-empty.
+last :: Buffer -> Word8
+last Empty          = errorEmptyList "last"
+last (Chunk c0 cs0) = go c0 cs0
+  where go c Empty        = S.last c
+        go _ (Chunk c cs) = go c cs
+-- XXX Don't inline this. Something breaks with 6.8.2 (haven't investigated yet)
+
+-- | /O(n\/c)/ Return all the elements of a 'Buffer' except the last one.
+init :: Buffer -> Buffer
+init Empty          = errorEmptyList "init"
+init (Chunk c0 cs0) = go c0 cs0
+  where go c Empty | S.length c == 1 = Empty
+                   | otherwise       = Chunk (S.init c) Empty
+        go c (Chunk c' cs)           = Chunk c (go c' cs)
+
+-- | /O(n\/c)/ Append two Buffers
+append :: Buffer -> Buffer -> Buffer
+append xs ys = foldrChunks Chunk ys xs
+{-# INLINE append #-}
+
+-- ---------------------------------------------------------------------
+-- Transformations
+
+-- | /O(n)/ 'map' @f xs@ is the Buffer obtained by applying @f@ to each
+-- element of @xs@.
+map :: (Word8 -> Word8) -> Buffer -> Buffer
+map f s = go s
+    where
+        go Empty        = Empty
+        go (Chunk x xs) = Chunk y ys
+            where
+                y  = S.map f x
+                ys = go xs
+{-# INLINE map #-}
+
+-- | /O(n)/ 'reverse' @xs@ returns the elements of @xs@ in reverse order.
+reverse :: Buffer -> Buffer
+reverse cs0 = rev Empty cs0
+  where rev a Empty        = a
+        rev a (Chunk c cs) = rev (Chunk (S.reverse c) a) cs
+{-# INLINE reverse #-}
+
+-- | The 'intersperse' function takes a 'Word8' and a 'Buffer' and
+-- \`intersperses\' that byte between the elements of the 'Buffer'.
+-- It is analogous to the intersperse function on Lists.
+intersperse :: Word8 -> Buffer -> Buffer
+intersperse _ Empty        = Empty
+intersperse w (Chunk c cs) = Chunk (S.intersperse w c)
+                                   (foldrChunks (Chunk . intersperse') Empty cs)
+  where intersperse' :: P.Buffer -> P.Buffer
+        intersperse' (S.PS fp o l e) =
+          S.unsafeCreate' (2*l) $ \p' -> withForeignPtr fp $ \p -> do
+            poke p' w
+            S.c_intersperse (p' `plusPtr` 1) (p `plusPtr` o) (fromIntegral l) w
+            return $! e + l * S.extra w
+
+-- | The 'transpose' function transposes the rows and columns of its
+-- 'Buffer' argument.
+transpose :: [Buffer] -> [Buffer]
+transpose css = L.map (\ss -> Chunk (S.pack ss) Empty)
+                      (L.transpose (L.map unpack css))
+--TODO: make this fast
+
+-- ---------------------------------------------------------------------
+-- Reducing 'Buffer's
+
+-- | 'foldl', applied to a binary operator, a starting value (typically
+-- the left-identity of the operator), and a Buffer, reduces the
+-- Buffer using the binary operator, from left to right.
+foldl :: (a -> Word8 -> a) -> a -> Buffer -> a
+foldl f z = go z
+  where go a Empty        = a
+        go a (Chunk c cs) = go (S.foldl f a c) cs
+{-# INLINE foldl #-}
+
+-- | 'foldl\'' is like 'foldl', but strict in the accumulator.
+foldl' :: (a -> Word8 -> a) -> a -> Buffer -> a
+foldl' f z = go z
+  where go a _ | a `seq` False = undefined
+        go a Empty        = a
+        go a (Chunk c cs) = go (S.foldl f a c) cs
+{-# INLINE foldl' #-}
+
+-- | 'foldr', applied to a binary operator, a starting value
+-- (typically the right-identity of the operator), and a Buffer,
+-- reduces the Buffer using the binary operator, from right to left.
+foldr :: (Word8 -> a -> a) -> a -> Buffer -> a
+foldr k z cs = foldrChunks (flip (S.foldr k)) z cs
+{-# INLINE foldr #-}
+
+-- | 'foldl1' is a variant of 'foldl' that has no starting value
+-- argument, and thus must be applied to non-empty 'Buffers'.
+-- This function is subject to array fusion.
+foldl1 :: (Word8 -> Word8 -> Word8) -> Buffer -> Word8
+foldl1 _ Empty        = errorEmptyList "foldl1"
+foldl1 f (Chunk c cs) = foldl f (S.unsafeHead c) (Chunk (S.unsafeTail c) cs)
+
+-- | 'foldl1\'' is like 'foldl1', but strict in the accumulator.
+foldl1' :: (Word8 -> Word8 -> Word8) -> Buffer -> Word8
+foldl1' _ Empty        = errorEmptyList "foldl1'"
+foldl1' f (Chunk c cs) = foldl' f (S.unsafeHead c) (Chunk (S.unsafeTail c) cs)
+
+-- | 'foldr1' is a variant of 'foldr' that has no starting value argument,
+-- and thus must be applied to non-empty 'Buffer's
+foldr1 :: (Word8 -> Word8 -> Word8) -> Buffer -> Word8
+foldr1 _ Empty          = errorEmptyList "foldr1"
+foldr1 f (Chunk c0 cs0) = go c0 cs0
+  where go c Empty         = S.foldr1 f c
+        go c (Chunk c' cs) = S.foldr  f (go c' cs) c
+
+-- ---------------------------------------------------------------------
+-- Special folds
+
+-- | /O(n)/ Concatenate a list of Buffers.
+concat :: [Buffer] -> Buffer
+concat css0 = to css0
+  where
+    go Empty        css = to css
+    go (Chunk c cs) css = Chunk c (go cs css)
+    to []               = Empty
+    to (cs:css)         = go cs css
+
+-- | Map a function over a 'Buffer' and concatenate the results
+concatMap :: (Word8 -> Buffer) -> Buffer -> Buffer
+concatMap _ Empty        = Empty
+concatMap f (Chunk c0 cs0) = to c0 cs0
+  where
+    go :: Buffer -> P.Buffer -> Buffer -> Buffer
+    go Empty        c' cs' = to c' cs'
+    go (Chunk c cs) c' cs' = Chunk c (go cs c' cs')
+
+    to :: P.Buffer -> Buffer -> Buffer
+    to c cs | S.null c  = case cs of
+        Empty          -> Empty
+        (Chunk c' cs') -> to c' cs'
+            | otherwise = go (f (S.unsafeHead c)) (S.unsafeTail c) cs
+
+-- | /O(n)/ Applied to a predicate and a Buffer, 'any' determines if
+-- any element of the 'Buffer' satisfies the predicate.
+any :: (Word8 -> Bool) -> Buffer -> Bool
+any f cs = foldrChunks (\c rest -> S.any f c || rest) False cs
+{-# INLINE any #-}
+-- todo fuse
+
+-- | /O(n)/ Applied to a predicate and a 'Buffer', 'all' determines
+-- if all elements of the 'Buffer' satisfy the predicate.
+all :: (Word8 -> Bool) -> Buffer -> Bool
+all f cs = foldrChunks (\c rest -> S.all f c && rest) True cs
+{-# INLINE all #-}
+-- todo fuse
+
+-- | /O(n)/ 'maximum' returns the maximum value from a 'Buffer'
+maximum :: Buffer -> Word8
+maximum Empty        = errorEmptyList "maximum"
+maximum (Chunk c cs) = foldlChunks (\n c' -> n `max` S.maximum c')
+                                   (S.maximum c) cs
+{-# INLINE maximum #-}
+
+-- | /O(n)/ 'minimum' returns the minimum value from a 'Buffer'
+minimum :: Buffer -> Word8
+minimum Empty        = errorEmptyList "minimum"
+minimum (Chunk c cs) = foldlChunks (\n c' -> n `min` S.minimum c')
+                                     (S.minimum c) cs
+{-# INLINE minimum #-}
+
+-- | The 'mapAccumL' function behaves like a combination of 'map' and
+-- 'foldl'; it applies a function to each element of a Buffer,
+-- passing an accumulating parameter from left to right, and returning a
+-- final value of this accumulator together with the new Buffer.
+mapAccumL :: (acc -> Word8 -> (acc, Word8)) -> acc -> Buffer -> (acc, Buffer)
+mapAccumL f s0 cs0 = go s0 cs0
+  where
+    go s Empty        = (s, Empty)
+    go s (Chunk c cs) = (s'', Chunk c' cs')
+        where (s',  c')  = S.mapAccumL f s c
+              (s'', cs') = go s' cs
+
+-- | The 'mapAccumR' function behaves like a combination of 'map' and
+-- 'foldr'; it applies a function to each element of a Buffer,
+-- passing an accumulating parameter from right to left, and returning a
+-- final value of this accumulator together with the new Buffer.
+mapAccumR :: (acc -> Word8 -> (acc, Word8)) -> acc -> Buffer -> (acc, Buffer)
+mapAccumR f s0 cs0 = go s0 cs0
+  where
+    go s Empty        = (s, Empty)
+    go s (Chunk c cs) = (s'', Chunk c' cs')
+        where (s'', c') = S.mapAccumR f s' c
+              (s', cs') = go s cs
+
+-- ---------------------------------------------------------------------
+-- Building Buffers
+
+-- | 'scanl' is similar to 'foldl', but returns a list of successive
+-- reduced values from the left. This function will fuse.
+--
+-- > scanl f z [x1, x2, ...] == [z, z `f` x1, (z `f` x1) `f` x2, ...]
+--
+-- Note that
+--
+-- > last (scanl f z xs) == foldl f z xs.
+scanl :: (Word8 -> Word8 -> Word8) -> Word8 -> Buffer -> Buffer
+scanl f z = snd . foldl k (z,singleton z)
+ where
+    k (c,acc) a = let n = f c a in (n, acc `snoc` n)
+{-# INLINE scanl #-}
+
+-- ---------------------------------------------------------------------
+-- Unfolds and replicates
+
+-- | @'iterate' f x@ returns an infinite Buffer of repeated applications
+-- of @f@ to @x@:
+--
+-- > iterate f x == [x, f x, f (f x), ...]
+--
+iterate :: (Word8 -> Word8) -> Word8 -> Buffer
+iterate f = unfoldr (\x -> case f x of x' -> x' `seq` Just (x', x'))
+
+-- | @'repeat' x@ is an infinite Buffer, with @x@ the value of every
+-- element.
+--
+repeat :: Word8 -> Buffer
+repeat w = cs where cs = Chunk (S.replicate smallChunkSize w) cs
+
+-- | /O(n)/ @'replicate' n x@ is a Buffer of length @n@ with @x@
+-- the value of every element.
+--
+replicate :: Int64 -> Word8 -> Buffer
+replicate n w
+    | n <= 0             = Empty
+    | n < fromIntegral smallChunkSize = Chunk (S.replicate (fromIntegral n) w) Empty
+    | r == 0             = cs -- preserve invariant
+    | otherwise          = Chunk (S.unsafeTake (fromIntegral r) c) cs
+ where
+    c      = S.replicate smallChunkSize w
+    cs     = nChunks q
+    (q, r) = quotRem n (fromIntegral smallChunkSize)
+    nChunks 0 = Empty
+    nChunks m = Chunk c (nChunks (m-1))
+
+-- | 'cycle' ties a finite Buffer into a circular one, or equivalently,
+-- the infinite repetition of the original Buffer.
+--
+cycle :: Buffer -> Buffer
+cycle Empty = errorEmptyList "cycle"
+cycle cs    = cs' where cs' = foldrChunks Chunk cs' cs
+
+-- | /O(n)/ The 'unfoldr' function is analogous to the List \'unfoldr\'.
+-- 'unfoldr' builds a Buffer from a seed value.  The function takes
+-- the element and returns 'Nothing' if it is done producing the
+-- Buffer or returns 'Just' @(a,b)@, in which case, @a@ is a
+-- prepending to the Buffer and @b@ is used as the next element in a
+-- recursive call.
+unfoldr :: (a -> Maybe (Word8, a)) -> a -> Buffer
+unfoldr f s0 = unfoldChunk 32 s0
+  where unfoldChunk n s =
+          case S.unfoldrN n f s of
+            (c, Nothing)
+              | S.null c  -> Empty
+              | otherwise -> Chunk c Empty
+            (c, Just s')  -> Chunk c (unfoldChunk (n*2) s')
+
+-- ---------------------------------------------------------------------
+-- Substrings
+
+-- | /O(n\/c)/ 'take' @n@, applied to a Buffer @xs@, returns the prefix
+-- of @xs@ of length @n@, or @xs@ itself if @n > 'length' xs@.
+take :: Int64 -> Buffer -> Buffer
+take i _ | i <= 0 = Empty
+take i cs0         = take' i cs0
+  where take' 0 _            = Empty
+        take' _ Empty        = Empty
+        take' n (Chunk c cs) =
+          if n < fromIntegral (S.length c)
+            then Chunk (S.take (fromIntegral n) c) Empty
+            else Chunk c (take' (n - fromIntegral (S.length c)) cs)
+
+-- | /O(n\/c)/ 'drop' @n xs@ returns the suffix of @xs@ after the first @n@
+-- elements, or @[]@ if @n > 'length' xs@.
+drop  :: Int64 -> Buffer -> Buffer
+drop i p | i <= 0 = p
+drop i cs0 = drop' i cs0
+  where drop' 0 cs           = cs
+        drop' _ Empty        = Empty
+        drop' n (Chunk c cs) =
+          if n < fromIntegral (S.length c)
+            then Chunk (S.drop (fromIntegral n) c) cs
+            else drop' (n - fromIntegral (S.length c)) cs
+
+-- | /O(n\/c)/ 'splitAt' @n xs@ is equivalent to @('take' n xs, 'drop' n xs)@.
+splitAt :: Int64 -> Buffer -> (Buffer, Buffer)
+splitAt i cs0 | i <= 0 = (Empty, cs0)
+splitAt i cs0 = splitAt' i cs0
+  where splitAt' 0 cs           = (Empty, cs)
+        splitAt' _ Empty        = (Empty, Empty)
+        splitAt' n (Chunk c cs) =
+          if n < fromIntegral (S.length c)
+            then (Chunk (S.take (fromIntegral n) c) Empty 
+                 ,Chunk (S.drop (fromIntegral n) c) cs)
+            else let (cs', cs'') = splitAt' (n - fromIntegral (S.length c)) cs
+                   in (Chunk c cs', cs'')
+
+
+-- | 'takeWhile', applied to a predicate @p@ and a Buffer @xs@,
+-- returns the longest prefix (possibly empty) of @xs@ of elements that
+-- satisfy @p@.
+takeWhile :: (Word8 -> Bool) -> Buffer -> Buffer
+takeWhile f cs0 = takeWhile' cs0
+  where takeWhile' Empty        = Empty
+        takeWhile' (Chunk c cs) =
+          case findIndexOrEnd (not . f) c of
+            0                  -> Empty
+            n | n < S.length c -> Chunk (S.take n c) Empty
+              | otherwise      -> Chunk c (takeWhile' cs)
+
+-- | 'dropWhile' @p xs@ returns the suffix remaining after 'takeWhile' @p xs@.
+dropWhile :: (Word8 -> Bool) -> Buffer -> Buffer
+dropWhile f cs0 = dropWhile' cs0
+  where dropWhile' Empty        = Empty
+        dropWhile' (Chunk c cs) =
+          case findIndexOrEnd (not . f) c of
+            n | n < S.length c -> Chunk (S.drop n c) cs
+              | otherwise      -> dropWhile' cs
+
+-- | 'break' @p@ is equivalent to @'span' ('not' . p)@.
+break :: (Word8 -> Bool) -> Buffer -> (Buffer, Buffer)
+break f cs0 = break' cs0
+  where break' Empty        = (Empty, Empty)
+        break' (Chunk c cs) =
+          case findIndexOrEnd f c of
+            0                  -> (Empty, Chunk c cs)
+            n | n < S.length c -> (Chunk (S.take n c) Empty
+                                  ,Chunk (S.drop n c) cs)
+              | otherwise      -> let (cs', cs'') = break' cs
+                                   in (Chunk c cs', cs'')
+
+--
+-- TODO
+--
+-- Add rules
+--
+
+{-
+-- | 'breakByte' breaks its Buffer argument at the first occurence
+-- of the specified byte. It is more efficient than 'break' as it is
+-- implemented with @memchr(3)@. I.e.
+-- 
+-- > break (=='c') "abcd" == breakByte 'c' "abcd"
+--
+breakByte :: Word8 -> Buffer -> (Buffer, Buffer)
+breakByte c (LPS ps) = case (breakByte' ps) of (a,b) -> (LPS a, LPS b)
+  where breakByte' []     = ([], [])
+        breakByte' (x:xs) =
+          case P.elemIndex c x of
+            Just 0  -> ([], x : xs)
+            Just n  -> (P.take n x : [], P.drop n x : xs)
+            Nothing -> let (xs', xs'') = breakByte' xs
+                        in (x : xs', xs'')
+
+-- | 'spanByte' breaks its Buffer argument at the first
+-- occurence of a byte other than its argument. It is more efficient
+-- than 'span (==)'
+--
+-- > span  (=='c') "abcd" == spanByte 'c' "abcd"
+--
+spanByte :: Word8 -> Buffer -> (Buffer, Buffer)
+spanByte c (LPS ps) = case (spanByte' ps) of (a,b) -> (LPS a, LPS b)
+  where spanByte' []     = ([], [])
+        spanByte' (x:xs) =
+          case P.spanByte c x of
+            (x', x'') | P.null x'  -> ([], x : xs)
+                      | P.null x'' -> let (xs', xs'') = spanByte' xs
+                                       in (x : xs', xs'')
+                      | otherwise  -> (x' : [], x'' : xs)
+-}
+
+-- | 'span' @p xs@ breaks the Buffer into two segments. It is
+-- equivalent to @('takeWhile' p xs, 'dropWhile' p xs)@
+span :: (Word8 -> Bool) -> Buffer -> (Buffer, Buffer)
+span p = break (not . p)
+
+-- | /O(n)/ Splits a 'Buffer' into components delimited by
+-- separators, where the predicate returns True for a separator element.
+-- The resulting components do not contain the separators.  Two adjacent
+-- separators result in an empty component in the output.  eg.
+--
+-- > splitWith (=='a') "aabbaca" == ["","","bb","c",""]
+-- > splitWith (=='a') []        == []
+--
+splitWith :: (Word8 -> Bool) -> Buffer -> [Buffer]
+splitWith _ Empty          = []
+splitWith p (Chunk c0 cs0) = comb [] (S.splitWith p c0) cs0
+
+  where comb :: [P.Buffer] -> [P.Buffer] -> Buffer -> [Buffer]
+        comb acc (s:[]) Empty        = revChunks (s:acc) : []
+        comb acc (s:[]) (Chunk c cs) = comb (s:acc) (S.splitWith p c) cs
+        comb acc (s:ss) cs           = revChunks (s:acc) : comb [] ss cs
+
+{-# INLINE splitWith #-}
+
+-- | /O(n)/ Break a 'Buffer' into pieces separated by the byte
+-- argument, consuming the delimiter. I.e.
+--
+-- > split '\n' "a\nb\nd\ne" == ["a","b","d","e"]
+-- > split 'a'  "aXaXaXa"    == ["","X","X","X",""]
+-- > split 'x'  "x"          == ["",""]
+-- 
+-- and
+--
+-- > intercalate [c] . split c == id
+-- > split == splitWith . (==)
+-- 
+-- As for all splitting functions in this library, this function does
+-- not copy the substrings, it just constructs new 'Buffers' that
+-- are slices of the original.
+--
+split :: Word8 -> Buffer -> [Buffer]
+split _ Empty     = []
+split w (Chunk c0 cs0) = comb [] (S.split w c0) cs0
+
+  where comb :: [P.Buffer] -> [P.Buffer] -> Buffer -> [Buffer]
+        comb acc (s:[]) Empty        = revChunks (s:acc) : []
+        comb acc (s:[]) (Chunk c cs) = comb (s:acc) (S.split w c) cs
+        comb acc (s:ss) cs           = revChunks (s:acc) : comb [] ss cs
+{-# INLINE split #-}
+
+{-
+-- | Like 'splitWith', except that sequences of adjacent separators are
+-- treated as a single separator. eg.
+-- 
+-- > tokens (=='a') "aabbaca" == ["bb","c"]
+--
+tokens :: (Word8 -> Bool) -> Buffer -> [Buffer]
+tokens f = L.filter (not.null) . splitWith f
+-}
+
+-- | The 'group' function takes a Buffer and returns a list of
+-- Buffers such that the concatenation of the result is equal to the
+-- argument.  Moreover, each sublist in the result contains only equal
+-- elements.  For example,
+--
+-- > group "Mississippi" = ["M","i","ss","i","ss","i","pp","i"]
+--
+-- It is a special case of 'groupBy', which allows the programmer to
+-- supply their own equality test.
+group :: Buffer -> [Buffer]
+group Empty          = []
+group (Chunk c0 cs0) = group' [] (S.group c0) cs0
+  where 
+    group' :: [P.Buffer] -> [P.Buffer] -> Buffer -> [Buffer]
+    group' acc@(s':_) ss@(s:_) cs
+      | S.unsafeHead s'
+     /= S.unsafeHead s             = revNonEmptyChunks    acc  : group' [] ss cs
+    group' acc (s:[]) Empty        = revNonEmptyChunks (s:acc) : []
+    group' acc (s:[]) (Chunk c cs) = group' (s:acc) (S.group c) cs
+    group' acc (s:ss) cs           = revNonEmptyChunks (s:acc) : group' [] ss cs
+
+{-
+TODO: check if something like this might be faster
+
+group :: Buffer -> [Buffer]
+group xs
+    | null xs   = []
+    | otherwise = ys : group zs
+    where
+        (ys, zs) = spanByte (unsafeHead xs) xs
+-}
+
+-- | The 'groupBy' function is the non-overloaded version of 'group'.
+--
+groupBy :: (Word8 -> Word8 -> Bool) -> Buffer -> [Buffer]
+groupBy _ Empty          = []
+groupBy k (Chunk c0 cs0) = groupBy' [] 0 (S.groupBy k c0) cs0
+  where
+    groupBy' :: [P.Buffer] -> Word8 -> [P.Buffer] -> Buffer -> [Buffer]
+    groupBy' acc@(_:_) c ss@(s:_) cs
+      | not (c `k` S.unsafeHead s)     = revNonEmptyChunks acc : groupBy' [] 0 ss cs
+    groupBy' acc _ (s:[]) Empty        = revNonEmptyChunks (s : acc) : []
+    groupBy' acc w (s:[]) (Chunk c cs) = groupBy' (s:acc) w' (S.groupBy k c) cs
+                                           where w' | L.null acc = S.unsafeHead s
+                                                    | otherwise  = w
+    groupBy' acc _ (s:ss) cs           = revNonEmptyChunks (s : acc) : groupBy' [] 0 ss cs
+
+{-
+TODO: check if something like this might be faster
+
+groupBy :: (Word8 -> Word8 -> Bool) -> Buffer -> [Buffer]
+groupBy k xs
+    | null xs   = []
+    | otherwise = take n xs : groupBy k (drop n xs)
+    where
+        n = 1 + findIndexOrEnd (not . k (head xs)) (tail xs)
+-}
+
+-- | /O(n)/ The 'intercalate' function takes a 'Buffer' and a list of
+-- 'Buffer's and concatenates the list after interspersing the first
+-- argument between each element of the list.
+intercalate :: Buffer -> [Buffer] -> Buffer
+intercalate s = concat . (L.intersperse s)
+
+-- ---------------------------------------------------------------------
+-- Indexing Buffers
+
+-- | /O(c)/ 'Buffer' index (subscript) operator, starting from 0.
+index :: Buffer -> Int64 -> Word8
+index _  i | i < 0  = moduleError "index" ("negative index: " ++ show i)
+index cs0 i         = index' cs0 i
+  where index' Empty     n = moduleError "index" ("index too large: " ++ show n)
+        index' (Chunk c cs) n
+          | n >= fromIntegral (S.length c) = 
+              index' cs (n - fromIntegral (S.length c))
+          | otherwise       = S.unsafeIndex c (fromIntegral n)
+
+-- | /O(n)/ The 'elemIndex' function returns the index of the first
+-- element in the given 'Buffer' which is equal to the query
+-- element, or 'Nothing' if there is no such element. 
+-- This implementation uses memchr(3).
+elemIndex :: Word8 -> Buffer -> Maybe Int64
+elemIndex w cs0 = elemIndex' 0 cs0
+  where elemIndex' _ Empty        = Nothing
+        elemIndex' n (Chunk c cs) =
+          case S.elemIndex w c of
+            Nothing -> elemIndex' (n + fromIntegral (S.length c)) cs
+            Just i  -> Just (n + fromIntegral i)
+
+{-
+-- | /O(n)/ The 'elemIndexEnd' function returns the last index of the
+-- element in the given 'Buffer' which is equal to the query
+-- element, or 'Nothing' if there is no such element. The following
+-- holds:
+--
+-- > elemIndexEnd c xs == 
+-- > (-) (length xs - 1) `fmap` elemIndex c (reverse xs)
+--
+elemIndexEnd :: Word8 -> Buffer -> Maybe Int
+elemIndexEnd ch (PS x s l) = inlinePerformIO $ withForeignPtr x $ \p ->
+    go (p `plusPtr` s) (l-1)
+  where
+    STRICT2(go)
+    go p i | i < 0     = return Nothing
+           | otherwise = do ch' <- peekByteOff p i
+                            if ch == ch'
+                                then return $ Just i
+                                else go p (i-1)
+-}
+-- | /O(n)/ The 'elemIndices' function extends 'elemIndex', by returning
+-- the indices of all elements equal to the query element, in ascending order.
+-- This implementation uses memchr(3).
+elemIndices :: Word8 -> Buffer -> [Int64]
+elemIndices w cs0 = elemIndices' 0 cs0
+  where elemIndices' _ Empty        = []
+        elemIndices' n (Chunk c cs) = L.map ((+n).fromIntegral) (S.elemIndices w c)
+                             ++ elemIndices' (n + fromIntegral (S.length c)) cs
+
+-- | count returns the number of times its argument appears in the Buffer
+--
+-- > count = length . elemIndices
+--
+-- But more efficiently than using length on the intermediate list.
+count :: Word8 -> Buffer -> Int64
+count w cs = foldlChunks (\n c -> n + fromIntegral (S.count w c)) 0 cs
+
+-- | The 'findIndex' function takes a predicate and a 'Buffer' and
+-- returns the index of the first element in the Buffer
+-- satisfying the predicate.
+findIndex :: (Word8 -> Bool) -> Buffer -> Maybe Int64
+findIndex k cs0 = findIndex' 0 cs0
+  where findIndex' _ Empty        = Nothing
+        findIndex' n (Chunk c cs) =
+          case S.findIndex k c of
+            Nothing -> findIndex' (n + fromIntegral (S.length c)) cs
+            Just i  -> Just (n + fromIntegral i)
+{-# INLINE findIndex #-}
+
+-- | /O(n)/ The 'find' function takes a predicate and a Buffer,
+-- and returns the first element in matching the predicate, or 'Nothing'
+-- if there is no such element.
+--
+-- > find f p = case findIndex f p of Just n -> Just (p ! n) ; _ -> Nothing
+--
+find :: (Word8 -> Bool) -> Buffer -> Maybe Word8
+find f cs0 = find' cs0
+  where find' Empty        = Nothing
+        find' (Chunk c cs) = case S.find f c of
+            Nothing -> find' cs
+            Just w  -> Just w
+{-# INLINE find #-}
+
+-- | The 'findIndices' function extends 'findIndex', by returning the
+-- indices of all elements satisfying the predicate, in ascending order.
+findIndices :: (Word8 -> Bool) -> Buffer -> [Int64]
+findIndices k cs0 = findIndices' 0 cs0
+  where findIndices' _ Empty        = []
+        findIndices' n (Chunk c cs) = L.map ((+n).fromIntegral) (S.findIndices k c)
+                             ++ findIndices' (n + fromIntegral (S.length c)) cs
+
+-- ---------------------------------------------------------------------
+-- Searching Buffers
+
+-- | /O(n)/ 'elem' is the 'Buffer' membership predicate.
+elem :: Word8 -> Buffer -> Bool
+elem w cs = case elemIndex w cs of Nothing -> False ; _ -> True
+
+-- | /O(n)/ 'notElem' is the inverse of 'elem'
+notElem :: Word8 -> Buffer -> Bool
+notElem w cs = not (elem w cs)
+
+-- | /O(n)/ 'filter', applied to a predicate and a Buffer,
+-- returns a Buffer containing those characters that satisfy the
+-- predicate.
+filter :: (Word8 -> Bool) -> Buffer -> Buffer
+filter p s = go s
+    where
+        go Empty        = Empty
+        go (Chunk x xs) = chunk (S.filter p x) (go xs)
+{-# INLINE filter #-}
+
+{-
+-- | /O(n)/ and /O(n\/c) space/ A first order equivalent of /filter .
+-- (==)/, for the common case of filtering a single byte. It is more
+-- efficient to use /filterByte/ in this case.
+--
+-- > filterByte == filter . (==)
+--
+-- filterByte is around 10x faster, and uses much less space, than its
+-- filter equivalent
+filterByte :: Word8 -> Buffer -> Buffer
+filterByte w ps = replicate (count w ps) w
+{-# INLINE filterByte #-}
+
+{-# RULES
+"Buffer specialise filter (== x)" forall x.
+  filter ((==) x) = filterByte x
+
+"Buffer specialise filter (== x)" forall x.
+ filter (== x) = filterByte x
+  #-}
+-}
+
+{-
+-- | /O(n)/ A first order equivalent of /filter . (\/=)/, for the common
+-- case of filtering a single byte out of a list. It is more efficient
+-- to use /filterNotByte/ in this case.
+--
+-- > filterNotByte == filter . (/=)
+--
+-- filterNotByte is around 2x faster than its filter equivalent.
+filterNotByte :: Word8 -> Buffer -> Buffer
+filterNotByte w (LPS xs) = LPS (filterMap (P.filterNotByte w) xs)
+-}
+
+-- | /O(n)/ The 'partition' function takes a predicate a Buffer and returns
+-- the pair of Buffers with elements which do and do not satisfy the
+-- predicate, respectively; i.e.,
+--
+-- > partition p bs == (filter p xs, filter (not . p) xs)
+--
+partition :: (Word8 -> Bool) -> Buffer -> (Buffer, Buffer)
+partition f p = (filter f p, filter (not . f) p)
+--TODO: use a better implementation
+
+-- ---------------------------------------------------------------------
+-- Searching for substrings
+
+-- | /O(n)/ The 'isPrefixOf' function takes two Buffers and returns 'True'
+-- iff the first is a prefix of the second.
+isPrefixOf :: Buffer -> Buffer -> Bool
+isPrefixOf Empty _  = True
+isPrefixOf _ Empty  = False
+isPrefixOf (Chunk x xs) (Chunk y ys)
+    | S.length x == S.length y = x == y  && isPrefixOf xs ys
+    | S.length x <  S.length y = x == yh && isPrefixOf xs (Chunk yt ys)
+    | otherwise                = xh == y && isPrefixOf (Chunk xt xs) ys
+  where (xh,xt) = S.splitAt (S.length y) x
+        (yh,yt) = S.splitAt (S.length x) y
+
+-- | /O(n)/ The 'isSuffixOf' function takes two Buffers and returns 'True'
+-- iff the first is a suffix of the second.
+-- 
+-- The following holds:
+--
+-- > isSuffixOf x y == reverse x `isPrefixOf` reverse y
+--
+isSuffixOf :: Buffer -> Buffer -> Bool
+isSuffixOf x y = reverse x `isPrefixOf` reverse y
+--TODO: a better implementation
+
+-- ---------------------------------------------------------------------
+-- Zipping
+
+-- | /O(n)/ 'zip' takes two Buffers and returns a list of
+-- corresponding pairs of bytes. If one input Buffer is short,
+-- excess elements of the longer Buffer are discarded. This is
+-- equivalent to a pair of 'unpack' operations.
+zip :: Buffer -> Buffer -> [(Word8,Word8)]
+zip = zipWith (,)
+
+-- | 'zipWith' generalises 'zip' by zipping with the function given as
+-- the first argument, instead of a tupling function.  For example,
+-- @'zipWith' (+)@ is applied to two Buffers to produce the list of
+-- corresponding sums.
+zipWith :: (Word8 -> Word8 -> a) -> Buffer -> Buffer -> [a]
+zipWith _ Empty     _  = []
+zipWith _ _      Empty = []
+zipWith f (Chunk a as) (Chunk b bs) = go a as b bs
+  where
+    go x xs y ys = f (S.unsafeHead x) (S.unsafeHead y)
+                 : to (S.unsafeTail x) xs (S.unsafeTail y) ys
+
+    to x Empty         _ _             | S.null x       = []
+    to _ _             y Empty         | S.null y       = []
+    to x xs            y ys            | not (S.null x)
+                                      && not (S.null y) = go x  xs y  ys
+    to x xs            _ (Chunk y' ys) | not (S.null x) = go x  xs y' ys
+    to _ (Chunk x' xs) y ys            | not (S.null y) = go x' xs y  ys
+    to _ (Chunk x' xs) _ (Chunk y' ys)                  = go x' xs y' ys
+
+-- | /O(n)/ 'unzip' transforms a list of pairs of bytes into a pair of
+-- Buffers. Note that this performs two 'pack' operations.
+unzip :: [(Word8,Word8)] -> (Buffer,Buffer)
+unzip ls = (pack (L.map fst ls), pack (L.map snd ls))
+{-# INLINE unzip #-}
+
+-- ---------------------------------------------------------------------
+-- Special lists
+
+-- | /O(n)/ Return all initial segments of the given 'Buffer', shortest first.
+inits :: Buffer -> [Buffer]
+inits = (Empty :) . inits'
+  where inits' Empty        = []
+        inits' (Chunk c cs) = L.map (\c' -> Chunk c' Empty) (L.tail (S.inits c))
+                           ++ L.map (Chunk c) (inits' cs)
+
+-- | /O(n)/ Return all final segments of the given 'Buffer', longest first.
+tails :: Buffer -> [Buffer]
+tails Empty         = Empty : []
+tails cs@(Chunk c cs')
+  | S.length c == 1 = cs : tails cs'
+  | otherwise       = cs : tails (Chunk (S.unsafeTail c) cs')
+
+-- ---------------------------------------------------------------------
+-- Low level constructors
+
+-- | /O(n)/ Make a copy of the 'Buffer' with its own storage.
+--   This is mainly useful to allow the rest of the data pointed
+--   to by the 'Buffer' to be garbage collected, for example
+--   if a large string has been read in, and only a small part of it
+--   is needed in the rest of the program.
+copy :: Buffer -> Buffer
+copy cs = foldrChunks (Chunk . S.copy) Empty cs
+--TODO, we could coalese small blocks here
+--FIXME: probably not strict enough, if we're doing this to avoid retaining
+-- the parent blocks then we'd better copy strictly.
+
+-- ---------------------------------------------------------------------
+
+-- TODO defrag func that concatenates block together that are below a threshold
+-- defrag :: Buffer -> Buffer
+
+-- ---------------------------------------------------------------------
+-- Lazy Buffer IO
+--
+-- Rule for when to close: is it expected to read the whole file?
+-- If so, close when done. 
+--
+
+-- | Read entire handle contents /lazily/ into a 'Buffer'. Chunks
+-- are read on demand, in at most @k@-sized chunks. It does not block
+-- waiting for a whole @k@-sized chunk, so if less than @k@ bytes are
+-- available then they will be returned immediately as a smaller chunk.
+--
+-- The handle is closed on EOF.
+--
+hGetContentsN :: Int -> Handle -> IO Buffer
+hGetContentsN k h = lazyRead -- TODO close on exceptions
+  where
+    lazyRead = unsafeInterleaveIO loop
+
+    loop = do
+        c <- S.hGetNonBlocking h k
+        --TODO: I think this should distinguish EOF from no data available
+        -- the underlying POSIX call makes this distincion, returning either
+        -- 0 or EAGAIN
+        if S.null c
+          then do eof <- hIsEOF h
+                  if eof then hClose h >> return Empty
+                         else hWaitForInput h (-1)
+                           >> loop
+          else do cs <- lazyRead
+                  return (Chunk c cs)
+
+-- | Read @n@ bytes into a 'Buffer', directly from the
+-- specified 'Handle', in chunks of size @k@.
+--
+hGetN :: Int -> Handle -> Int -> IO Buffer
+hGetN k h n | n > 0 = readChunks n
+  where
+    STRICT1(readChunks)
+    readChunks i = do
+        c <- S.hGet h (min k i)
+        case S.length c of
+            0 -> return Empty
+            m -> do cs <- readChunks (i - m)
+                    return (Chunk c cs)
+
+hGetN _ _ 0 = return Empty
+hGetN _ h n = illegalBufferSize h "hGet" n
+
+-- | hGetNonBlockingN is similar to 'hGetContentsN', except that it will never block
+-- waiting for data to become available, instead it returns only whatever data
+-- is available. Chunks are read on demand, in @k@-sized chunks.
+--
+hGetNonBlockingN :: Int -> Handle -> Int -> IO Buffer
+#if defined(__GLASGOW_HASKELL__)
+hGetNonBlockingN k h n | n > 0= readChunks n
+  where
+    STRICT1(readChunks)
+    readChunks i = do
+        c <- S.hGetNonBlocking h (min k i)
+        case S.length c of
+            0 -> return Empty
+            m -> do cs <- readChunks (i - m)
+                    return (Chunk c cs)
+
+hGetNonBlockingN _ _ 0 = return Empty
+hGetNonBlockingN _ h n = illegalBufferSize h "hGetNonBlocking" n
+#else
+hGetNonBlockingN = hGetN
+#endif
+
+illegalBufferSize :: Handle -> String -> Int -> IO a
+illegalBufferSize handle fn sz =
+    ioError (mkIOError illegalOperationErrorType msg (Just handle) Nothing)
+    --TODO: System.IO uses InvalidArgument here, but it's not exported :-(
+    where
+      msg = fn ++ ": illegal Buffer size " ++ showsPrec 9 sz []
+
+-- | Read entire handle contents /lazily/ into a 'Buffer'. Chunks
+-- are read on demand, using the default chunk size.
+--
+-- Once EOF is encountered, the Handle is closed.
+--
+hGetContents :: Handle -> IO Buffer
+hGetContents = hGetContentsN defaultChunkSize
+
+-- | Read @n@ bytes into a 'Buffer', directly from the specified 'Handle'.
+--
+hGet :: Handle -> Int -> IO Buffer
+hGet = hGetN defaultChunkSize
+
+-- | hGetNonBlocking is similar to 'hGet', except that it will never block
+-- waiting for data to become available, instead it returns only whatever data
+-- is available.
+#if defined(__GLASGOW_HASKELL__)
+hGetNonBlocking :: Handle -> Int -> IO Buffer
+hGetNonBlocking = hGetNonBlockingN defaultChunkSize
+#else
+hGetNonBlocking = hGet
+#endif
+
+-- | Read an entire file /lazily/ into a 'Buffer'.
+-- The Handle will be held open until EOF is encountered.
+--
+readFile :: FilePath -> IO Buffer
+readFile f = openBinaryFile f ReadMode >>= hGetContents
+
+-- | Write a 'Buffer' to a file.
+--
+writeFile :: FilePath -> Buffer -> IO ()
+writeFile f txt = bracket (openBinaryFile f WriteMode) hClose
+    (\hdl -> hPut hdl txt)
+
+-- | Append a 'Buffer' to a file.
+--
+appendFile :: FilePath -> Buffer -> IO ()
+appendFile f txt = bracket (openBinaryFile f AppendMode) hClose
+    (\hdl -> hPut hdl txt)
+
+-- | getContents. Equivalent to hGetContents stdin. Will read /lazily/
+--
+getContents :: IO Buffer
+getContents = hGetContents stdin
+
+-- | Outputs a 'Buffer' to the specified 'Handle'.
+--
+hPut :: Handle -> Buffer -> IO ()
+hPut h cs = foldrChunks (\c rest -> S.hPut h c >> rest) (return ()) cs
+
+-- | A synonym for @hPut@, for compatibility
+--
+hPutStr :: Handle -> Buffer -> IO ()
+hPutStr = hPut
+
+-- | Write a Buffer to stdout
+putStr :: Buffer -> IO ()
+putStr = hPut stdout
+
+-- | Write a Buffer to stdout, appending a newline byte
+--
+putStrLn :: Buffer -> IO ()
+putStrLn ps = hPut stdout ps >> hPut stdout (singleton 0x0a)
+
+-- | The interact function takes a function of type @Buffer -> Buffer@
+-- as its argument. The entire input from the standard input device is passed
+-- to this function as its argument, and the resulting string is output on the
+-- standard output device.
+--
+interact :: (Buffer -> Buffer) -> IO ()
+interact transformer = putStr . transformer =<< getContents
+
+-- ---------------------------------------------------------------------
+-- Internal utilities
+
+-- Common up near identical calls to `error' to reduce the number
+-- constant strings created when compiled:
+errorEmptyList :: String -> a
+errorEmptyList fun = moduleError fun "empty Buffer"
+
+moduleError :: String -> String -> a
+moduleError fun msg = error ("Data.Buffer.Lazy." ++ fun ++ ':':' ':msg)
+
+
+-- reverse a list of non-empty chunks into a lazy Buffer
+revNonEmptyChunks :: [P.Buffer] -> Buffer
+revNonEmptyChunks cs = L.foldl' (flip Chunk) Empty cs
+
+-- reverse a list of possibly-empty chunks into a lazy Buffer
+revChunks :: [P.Buffer] -> Buffer
+revChunks cs = L.foldl' (flip chunk) Empty cs
+
+-- | 'findIndexOrEnd' is a variant of findIndex, that returns the length
+-- of the string if no element is found, rather than Nothing.
+findIndexOrEnd :: (Word8 -> Bool) -> P.Buffer -> Int
+findIndexOrEnd k (S.PS x s l _) = S.inlinePerformIO $ withForeignPtr x $ \f -> go (f `plusPtr` s) 0
+  where
+    STRICT2(go)
+    go ptr n | n >= l    = return l
+             | otherwise = do w <- peek ptr
+                              if k w
+                                then return n
+                                else go (ptr `plusPtr` 1) (n+1)
+{-# INLINE findIndexOrEnd #-}
addfile ./Data/Buffer/Rope/Internal.hs
hunk ./Data/Buffer/Rope/Internal.hs 1
+{-# LANGUAGE CPP, ForeignFunctionInterface #-}
+-- We cannot actually specify all the language pragmas, see ghc ticket #
+-- If we could, these are what they would be:
+{- LANGUAGE DeriveDataTypeable -}
+{-# OPTIONS_HADDOCK hide #-}
+
+-- |
+-- Module      : Data.Buffer.Rope.Internal
+-- License     : BSD-style
+-- Maintainer  : ekmett@gmail.com
+-- Stability   : experimental
+-- Portability : portable
+-- 
+-- A module containing semi-public 'Rope' internals. This exposes
+-- the 'Buffer' representation and low level construction functions.
+-- Modules which extend the 'Rope' system will need to use this module
+-- while ideally most users will be able to make do with the public interface
+-- modules.
+
+module Data.Buffer.Rope.Internal (
+        Rope(..)
+        empty,      -- :: Rope
+        fromBuffer, -- :: Buffer -> Rope
+
+        -- * Buffer allocation sizes
+        defaultChunkSize, -- :: Int
+        smallChunkSize,   -- :: Int
+        extraChunkSize,   -- :: Int 
+        chunkOverhead     -- :: Int
+  ) where
+
+#define STRICT1(f) f a | a `seq` False = undefined
+#define STRICT2(f) f a b | a `seq` b `seq` False = undefined
+#define STRICT3(f) f a b c | a `seq` b `seq` c `seq` False = undefined
+#define STRICT4(f) f a b c d | a `seq` b `seq` c `seq` d `seq` False = undefined
+#define STRICT5(f) f a b c d e | a `seq` b `seq` c `seq` d `seq` e `seq` False = undefined
+#define STRICT6(g) g a b c d e f | a `seq` b `seq` c `seq` d `seq` e `seq` f `seq` False = undefined
+
+import Data.Buffer.Internal.Classes
+import qualified Data.Buffer.Internal as S
+
+import Foreign.Storable (Storable(sizeOf))
+
+#if defined(__GLASGOW_HASKELL__)
+import Data.Typeable    (Typeable)
+#if __GLASGOW_HASKELL__ >= 610
+import Data.Data        (Data)
+#else
+import Data.Generics    (Data)
+#endif
+#endif
+
+-- | A space-efficient representation of a Word8 vector, supporting many
+-- efficient operations.  A 'Buffer' contains 8-bit characters only.
+--
+-- Instances of Eq, Ord, Read, Show, Data, Typeable
+
+-- TODO: provide a custom Data instance that abstracts over this as a container of bytes
+data Rope = Rope (FingerTree Buffer)
+#if defined(__GLASGOW_HASKELL__)
+      deriving (Data, Typeable)
+#endif
+
+------------------------------------------------------------------------
+
+-- | The data type invariant:
+-- Every Buffer is either 'Empty' or consists of non-null 'S.Buffer's.
+-- All functions must preserve this, and the QC properties must check this.
+-- Furthermore, the number of multibyte tail bytes must be non negative and cannot
+-- exceed the total number of bytes
+
+instance Valid Rope where
+    valid (Rope t) = valid t
+
+instance Monoid Rope where
+    mempty = Rope mempty
+    Rope a `mappend` Rope b = Rope (a `mappend` b)
+
+-- | Smart constructor for 'Chunk'. Guarantees the data type invariant.
+consBuffer :: Buffer -> Rope -> Rope
+consBuffer c (Rope cs) = Rope (singleton c `F.append` cs) 
+{-# INLINE consBuffer #-}
+
+-- | Smart constructor for 'Chunk'. Guarantees the data type invariant.
+snocBuffer :: Rope -> Buffer -> Rope
+snocBuffer (Rope cs) c = Rope (cs `F.append` singleton c)
+{-# INLINE snocBuffer #-}
+
+-- | we want to split up a buffer to meet the following ideal conditions before inserting it into a fingertree
+-- the empty string results in no output buffers
+-- if we only have a small enough chunk left or it contains no extra characters, just emit it. 
+-- after that, scan looking for the largest all ascii ([0..7f]) chunk that you can find. If you find more than extraChunkSize
+-- bytes in that form, emit it, otherwise, convert what you've seen into an exotic chunk that is exactly your extraChunkSize and start over
+
+-- this ensures that we can insert arbitrarily large chunks that support O(1) indexing, and that the chunks that require
+-- O(n) indexing are significantly smaller.`
+
+instance ToRope Buffer 
+    toRope (PS x s l e) = Rope (foldr F.cons F.empty (run e x s l))
+    where STRICT4(run)
+          run x s l e
+            | l < extraChunkSize || e == 0 = 
+                if l == 0
+                then []
+                else [PS x s l e]
+            | otherwise = inlinePerformIO $ withForeignPtr x $ \p -> walk e x p s l s
+
+          STRICT6(walk)
+          walk e x p s l i = assert (i < l) $! do -- non-zero e => we can't make it to the end of the string without seeing a high byte
+              c <- peekByteOff p i 
+              case () of 
+              _ | c <= 0x80           -> walk e x p s l (i+1)
+                | l' > extraChunkSize -> return $! PS x s l' 0              : run x i                  (l-l')             e
+                | otherwise           -> return $! PS x s extraChunkSize e' : run x (s+extraChunkSize) (l-extraChunkSize) (e-e')
+             where l' = i - s
+                   e' = extras x i (extraChunkSize - l')
+
+class ToRope a where
+    toRope :: a -> Rope
+    cons :: a -> Rope -> Rope
+    snoc :: Rope -> a -> Rope
+
+class FromRope a where
+    fromRope :: Rope -> a
+    viewl :: Rope -> ViewL a
+    viewr :: Rope -> ViewR a
+
+uncons :: FromRope a => Rope -> Maybe (a, Rope)
+uncons r = case viewl r of
+    a :< as -> Just (a,as)
+    EmptyL -> Nothing
+{-# INLINE uncons #-}
+
+unsnoc :: FromRope a => Rope -> Maybe (Rope, a)
+unsnoc r = case viewr r of
+    as :> a -> Just (as,a)
+    EmptyR -> Nothing
+{-# INLINE unsnoc #-}
+
+toLazy :: Rope -> L.Buffer
+toLazy r = L.fromChunks (toList r)
+{-# INLINE toLazyBuffer #-}
+
+
+-- | Consume the chunks of a lazy Buffer with a natural right fold.
+foldrChunks :: (Buffer -> a -> a) -> a -> Rope -> a
+foldrChunks f z (Rope r) = go r 
+  where go Empty        = z
+        go (Chunk c cs) = f c (go cs)
+{-# INLINE foldrChunks #-}
+
+-- | Consume the chunks of a lazy Buffer with a strict, tail-recursive,
+-- accumulating left fold.
+foldlChunks :: (a -> Buffer -> a) -> a -> Rope -> a
+foldlChunks f z (Rope r) = go z
+  where STRICT2(go)
+        go a Empty        = a
+        go a (Chunk c cs) = go (f a c) cs
+{-# INLINE foldlChunks #-}
+
+------------------------------------------------------------------------
+
+-- The representation chunks. When we have to convert from
+-- a lazy list to the chunked representation, then by default we use this
+-- chunk size. Some functions give you more control over the chunk size.
+--
+-- Measurements here:
+--  http://www.cse.unsw.edu.au/~dons/tmp/chunksize_v_cache.png
+--
+-- indicate that a value around 0.5 to 1 x your L2 cache is best.
+-- The following value assumes people have something greater than 128k,
+-- and need to share the cache with other programs.
+
+-- | Currently set to 32k, less the memory management overhead
+defaultChunkSize :: Int
+defaultChunkSize = 32 * k - chunkOverhead
+   where k = 1024
+-- | Currently set to 4k, less the memory management overhead
+
+smallChunkSize :: Int
+smallChunkSize = 4 * k - chunkOverhead
+   where k = 1024
+
+-- when adding chunks to the tree that have multibyte tails, very small strings favor fast splitting/indexing.
+-- | Currently set to try to fit in a cache line, less the memory management overhead
+extraChunkSize :: Int
+extraChunkSize = 128 - chunkOverhead
+
+-- | The memory management overhead. Currently this is tuned for GHC only.
+chunkOverhead :: Int
+chunkOverhead = 2 * sizeOf (undefined :: Int)
addfile ./Data/Buffer/Rope/Word8.hs
hunk ./Data/Buffer/Rope/Word8.hs 1
+{-# LANGUAGE CPP #-}
+{-# OPTIONS_GHC -fno-warn-incomplete-patterns #-}
+{-# OPTIONS_HADDOCK prune #-}
+
+-- |
+-- Module      : Data.Buffer.Rope.Word8
+-- Copyright   : (c) Don Stewart 2006
+--               (c) Duncan Coutts 2006
+--               (c) Edward Kmett 2010
+-- License     : BSD-style
+--
+-- Maintainer  : ekmett@gmail.com
+-- Stability   : experimental
+-- Portability : portable
+-- 
+-- Some operations, such as concat, append, reverse and cons, have
+-- better complexity than their "Data.Buffer" equivalents, due to
+-- optimisations resulting from the fingertree spine. 
+--
+-- This module is intended to be imported @qualified@, to avoid name
+-- clashes with "Prelude" functions.  eg.
+--
+-- > import qualified Data.Buffer.Rope.Word8 as R
+--
+-- Original GHC implementation by Bryan O\'Sullivan.
+-- Rewritten to use 'Data.Array.Unboxed.UArray' by Simon Marlow.
+-- Rewritten to support slices and use 'Foreign.ForeignPtr.ForeignPtr'
+-- by David Roundy.
+-- Polished and extended by Don Stewart.
+-- Lazy variant by Duncan Coutts and Don Stewart.
+-- A number of FingerTree algorithms are by Ross Paterson and Louis Wasserman
+-- Converted to use a fingertree by Edward Kmett
+
+module Data.Buffer.Rope.Word8 (
+        -- * The @Buffer@ type
+        Rope,                   -- instances: Eq, Ord, Show, Read, Data, Typeable
+
+        -- * Introducing and eliminating 'Buffer's
+        empty,                  -- :: Rope
+        singleton,              -- :: Word8   -> Rope
+        pack,                   -- :: [Word8] -> Rope
+        unpack,                 -- :: Rope -> [Word8]
+        fromChunks,             -- :: [Buffer] -> Rope
+        toChunks,               -- :: Rope -> [Buffer]
+
+        -- * Basic interface
+        cons,                   -- :: Word8 -> Rope -> Rope
+        snoc,                   -- :: Rope -> Word8 -> Rope
+        append,                 -- :: Rope -> Rope -> Rope
+        head,                   -- :: Rope -> Word8
+        uncons,                 -- :: Rope -> Maybe (Word8, Rope)
+        last,                   -- :: Rope -> Word8
+        tail,                   -- :: Rope -> Rope
+        init,                   -- :: Rope -> Rope
+        null,                   -- :: Rope -> Bool
+        length,                 -- :: Rope -> Int
+
+        -- * Transforming Buffers
+        map,                    -- :: (Word8 -> Word8) -> Rope -> Rope
+        reverse,                -- :: Rope -> Rope
+        intersperse,            -- :: Word8 -> Rope -> Rope
+        intercalate,            -- :: Rope -> [Rope] -> Rope
+        transpose,              -- :: [Rope] -> [Rope]
+
+        -- * Reducing 'Buffer's (folds)
+        foldl,                  -- :: (a -> Word8 -> a) -> a -> Rope -> a
+        foldl',                 -- :: (a -> Word8 -> a) -> a -> Rope -> a
+        foldl1,                 -- :: (Word8 -> Word8 -> Word8) -> Rope -> Word8
+        foldl1',                -- :: (Word8 -> Word8 -> Word8) -> Rope -> Word8
+        foldr,                  -- :: (Word8 -> a -> a) -> a -> Rope -> a
+        foldr1,                 -- :: (Word8 -> Word8 -> Word8) -> Rope -> Word8
+
+        -- ** Special folds
+        concat,                 -- :: [Rope] -> Rope
+        concatMap,              -- :: (Word8 -> Rope) -> Rope -> Rope
+        any,                    -- :: (Word8 -> Bool) -> Rope -> Bool
+        all,                    -- :: (Word8 -> Bool) -> Rope -> Bool
+        maximum,                -- :: Rope -> Word8
+        minimum,                -- :: Rope -> Word8
+
+        -- * Building Buffers
+        -- ** Scans
+        scanl,                  -- :: (Word8 -> Word8 -> Word8) -> Word8 -> Rope -> Rope
+        scanl1,                 -- :: (Word8 -> Word8 -> Word8) -> Rope -> Rope
+        scanr,                  -- :: (Word8 -> Word8 -> Word8) -> Word8 -> Rope -> Rope
+        scanr1,                 -- :: (Word8 -> Word8 -> Word8) -> Rope -> Rope
+
+        -- ** Accumulating maps
+        mapAccumL,              -- :: (acc -> Word8 -> (acc, Word8)) -> acc -> Rope -> (acc, Rope)
+        mapAccumR,              -- :: (acc -> Word8 -> (acc, Word8)) -> acc -> Rope -> (acc, Rope)
+
+        -- ** Infinite Buffers
+        replicate,              -- :: Int -> Word8 -> Rope
+        replicateBuffer,        -- :: Int -> Buffer -> Rope
+
+        -- ** Unfolding Buffers
+        unfoldr,                -- :: (a -> Maybe (Word8, a)) -> a -> Rope
+
+        -- * Substrings
+
+        -- ** Breaking strings
+        take,                   -- :: Int -> Rope -> Rope
+        drop,                   -- :: Int -> Rope -> Rope
+        splitAt,                -- :: Int -> Rope -> (Rope, Rope)
+
+        takeWhile,              -- :: (Word8 -> Bool) -> Rope -> Rope
+        dropWhile,              -- :: (Word8 -> Bool) -> Rope -> Rope
+        span,                   -- :: (Word8 -> Bool) -> Rope -> (Rope, Rope)
+        break,                  -- :: (Word8 -> Bool) -> Rope -> (Rope, Rope)
+
+        group,                  -- :: Rope -> [Rope]
+        groupBy,                -- :: (Word8 -> Word8 -> Bool) -> Rope -> [Rope]
+        inits,                  -- :: Rope -> [Rope]
+        tails,                  -- :: Rope -> [Rope]
+
+        -- ** Breaking into many substrings
+        split,                  -- :: Word8 -> Rope -> [Rope]
+        splitWith,              -- :: (Word8 -> Bool) -> Rope -> [Rope]
+
+        -- * Predicates
+        isPrefixOf,             -- :: Rope -> Rope -> Bool
+        isSuffixOf,             -- :: Rope -> Rope -> Bool
+
+        -- * Searching Ropes
+
+        -- ** Searching by equality
+        elem,                   -- :: Word8 -> Rope -> Bool
+        notElem,                -- :: Word8 -> Rope -> Bool
+
+        -- ** Searching with a predicate
+        find,                   -- :: (Word8 -> Bool) -> Rope -> Maybe Word8
+        filter,                 -- :: (Word8 -> Bool) -> Rope -> Rope
+        partition,              -- :: (Word8 -> Bool) -> Rope -> (Rope, Rope)
+
+        -- * Indexing Ropes
+        index,                  -- :: Rope -> Int -> Word8
+        elemIndex,              -- :: Word8 -> Rope -> Maybe Int
+        elemIndices,            -- :: Word8 -> Rope -> [Int]
+        findIndex,              -- :: (Word8 -> Bool) -> Rope -> Maybe Int
+        findIndices,            -- :: (Word8 -> Bool) -> Rope -> [Int]
+        count,                  -- :: Word8 -> Rope -> Int
+
+        -- * Zipping and unzipping Ropes
+        zip,                    -- :: Rope -> Rope -> [(Word8, Word8)]
+        zipWith,                -- :: (Word8 -> Word8 -> c) -> Rope -> Rope -> [c]
+        unzip,                  -- :: [(Word8,Word8)] -> (Rope, Rope)
+
+        -- * Ordered Ropes
+--        sort,                   -- :: Rope -> Rope
+
+        -- * Low level conversions
+        -- ** Copying Ropes
+        copy,                   -- :: Rope -> Rope
+--        defrag,                -- :: Rope -> Rope
+
+        -- * I\/O with 'Rope's
+
+        -- ** Standard input and output
+        getContents,            -- :: IO Rope
+        putStr,                 -- :: Rope -> IO ()
+        putStrLn,               -- :: Rope -> IO ()
+        interact,               -- :: (Rope -> Rope) -> IO ()
+
+        -- ** Files
+        readFile,               -- :: FilePath -> IO Rope
+        writeFile,              -- :: FilePath -> Rope -> IO ()
+        appendFile,             -- :: FilePath -> Rope -> IO ()
+
+        -- ** I\/O with Handles
+        hGetContents,           -- :: Handle -> IO Rope
+        hGet,                   -- :: Handle -> Int -> IO Rope
+        hGetNonBlocking,        -- :: Handle -> Int -> IO Rope
+        hPut,                   -- :: Handle -> Rope -> IO ()
+        hPutStr,                -- :: Handle -> Rope -> IO ()
+
+  ) where
+
+import Prelude hiding
+    (reverse,head,tail,last,init,null,length,map,lines,foldl,foldr,unlines
+    ,concat,any,take,drop,splitAt,takeWhile,dropWhile,span,break,elem,filter,maximum
+    ,minimum,all,concatMap,foldl1,foldr1,scanl, scanl1, scanr, scanr1
+    ,repeat, cycle, interact, iterate,readFile,writeFile,appendFile,replicate
+    ,getContents,getLine,putStr,putStrLn ,zip,zipWith,unzip,notElem)
+
+import qualified Data.List as L  -- L for list/lazy
+import qualified Data.Buffer.Word8 as P  (Buffer) -- type name only
+import qualified Data.Buffer.Word8 as S  -- S for strict (hmm...)
+import qualified Data.Buffer.Internal as S
+import qualified Data.Buffer.Unsafe as S
+import Data.Buffer.Lazy.Internal
+
+import Data.Monoid              (Monoid(..))
+
+import Data.Word                (Word8)
+import Data.Int                 (Int64)
+import System.IO                (Handle,stdin,stdout,openBinaryFile,IOMode(..)
+                                ,hClose,hWaitForInput,hIsEOF)
+import System.IO.Error          (mkIOError, illegalOperationErrorType)
+import System.IO.Unsafe
+#ifndef __NHC__
+import Control.Exception        (bracket)
+#else
+import IO		        (bracket)
+#endif
+
+import Foreign.ForeignPtr       (withForeignPtr)
+import Foreign.Ptr
+import Foreign.Storable
+
+-- -----------------------------------------------------------------------------
+--
+-- Useful macros, until we have bang patterns
+--
+
+#define STRICT1(f) f a | a `seq` False = undefined
+#define STRICT2(f) f a b | a `seq` b `seq` False = undefined
+#define STRICT3(f) f a b c | a `seq` b `seq` c `seq` False = undefined
+#define STRICT4(f) f a b c d | a `seq` b `seq` c `seq` d `seq` False = undefined
+#define STRICT5(f) f a b c d e | a `seq` b `seq` c `seq` d `seq` e `seq` False = undefined
+
+-- -----------------------------------------------------------------------------
+
+instance Eq  Buffer
+    where (==)    = eq
+
+instance Ord Buffer
+    where compare = cmp
+
+instance Monoid Buffer where
+    mempty  = empty
+    mappend = append
+    mconcat = concat
+
+eq :: Buffer -> Buffer -> Bool
+eq Empty Empty = True
+eq Empty _     = False
+eq _     Empty = False
+eq (Chunk a as) (Chunk b bs) =
+  case compare (S.length a) (S.length b) of
+    LT -> a == (S.take (S.length a) b) && eq as (Chunk (S.drop (S.length a) b) bs)
+    EQ -> a == b                       && eq as bs
+    GT -> (S.take (S.length b) a) == b && eq (Chunk (S.drop (S.length b) a) as) bs
+
+cmp :: Buffer -> Buffer -> Ordering
+cmp Empty Empty = EQ
+cmp Empty _     = LT
+cmp _     Empty = GT
+cmp (Chunk a as) (Chunk b bs) =
+  case compare (S.length a) (S.length b) of
+    LT -> case compare a (S.take (S.length a) b) of
+            EQ     -> cmp as (Chunk (S.drop (S.length a) b) bs)
+            result -> result
+    EQ -> case compare a b of
+            EQ     -> cmp as bs
+            result -> result
+    GT -> case compare (S.take (S.length b) a) b of
+            EQ     -> cmp (Chunk (S.drop (S.length b) a) as) bs
+            result -> result
+
+-- -----------------------------------------------------------------------------
+-- Introducing and eliminating 'Buffer's
+
+-- | /O(1)/ The empty 'Buffer'
+empty :: Buffer
+empty = Empty
+{-# INLINE empty #-}
+
+-- | /O(1)/ Convert a 'Word8' into a 'Buffer'
+singleton :: Word8 -> Buffer
+singleton w = Chunk (S.singleton w) Empty
+{-# INLINE singleton #-}
+
+-- | /O(n)/ Convert a '[Word8]' into a 'Buffer'. 
+pack :: [Word8] -> Buffer
+pack ws = L.foldr (Chunk . S.pack) Empty (chunks defaultChunkSize ws)
+  where
+    chunks :: Int -> [a] -> [[a]]
+    chunks _    [] = []
+    chunks size xs = case L.splitAt size xs of
+                      (xs', xs'') -> xs' : chunks size xs''
+
+-- | /O(n)/ Converts a 'Buffer' to a '[Word8]'.
+unpack :: Buffer -> [Word8]
+unpack cs = L.concatMap S.unpack (toChunks cs)
+--TODO: we can do better here by integrating the concat with the unpack
+
+-- | /O(c)/ Convert a list of strict 'Buffer' into a lazy 'Buffer'
+fromChunks :: [P.Buffer] -> Buffer
+fromChunks cs = L.foldr chunk Empty cs
+
+-- | /O(n)/ Convert a lazy 'Buffer' into a list of strict 'Buffer'
+toChunks :: Buffer -> [P.Buffer]
+toChunks cs = foldrChunks (:) [] cs
+
+------------------------------------------------------------------------
+
+{-
+-- | /O(n)/ Convert a '[a]' into a 'Buffer' using some
+-- conversion function
+packWith :: (a -> Word8) -> [a] -> Buffer
+packWith k str = LPS $ L.map (P.packWith k) (chunk defaultChunkSize str)
+{-# INLINE packWith #-}
+{-# SPECIALIZE packWith :: (Char -> Word8) -> [Char] -> Buffer #-}
+
+-- | /O(n)/ Converts a 'Buffer' to a '[a]', using a conversion function.
+unpackWith :: (Word8 -> a) -> Buffer -> [a]
+unpackWith k (LPS ss) = L.concatMap (S.unpackWith k) ss
+{-# INLINE unpackWith #-}
+{-# SPECIALIZE unpackWith :: (Word8 -> Char) -> Buffer -> [Char] #-}
+-}
+
+-- ---------------------------------------------------------------------
+-- Basic interface
+
+-- | /O(1)/ Test whether a Buffer is empty.
+null :: Buffer -> Bool
+null Empty = True
+null _     = False
+{-# INLINE null #-}
+
+-- | /O(n\/c)/ 'length' returns the length of a Buffer as an 'Int64'
+length :: Buffer -> Int64
+length cs = foldlChunks (\n c -> n + fromIntegral (S.length c)) 0 cs
+{-# INLINE length #-}
+
+-- | /O(1)/ 'cons' is analogous to '(:)' for lists.
+--
+cons :: Word8 -> Buffer -> Buffer
+cons c cs = Chunk (S.singleton c) cs
+{-# INLINE cons #-}
+
+-- | /O(1)/ Unlike 'cons', 'cons\'' is
+-- strict in the Buffer that we are consing onto. More precisely, it forces
+-- the head and the first chunk. It does this because, for space efficiency, it
+-- may coalesce the new byte onto the first \'chunk\' rather than starting a
+-- new \'chunk\'.
+--
+-- So that means you can't use a lazy recursive contruction like this:
+--
+-- > let xs = cons\' c xs in xs
+--
+-- You can however use 'cons', as well as 'repeat' and 'cycle', to build
+-- infinite lazy Buffers.
+--
+cons' :: Word8 -> Buffer -> Buffer
+cons' w (Chunk c cs) | S.length c < 16 = Chunk (S.cons w c) cs
+cons' w cs                             = Chunk (S.singleton w) cs
+{-# INLINE cons' #-}
+
+-- | /O(n\/c)/ Append a byte to the end of a 'Buffer'
+snoc :: Buffer -> Word8 -> Buffer
+snoc cs w = foldrChunks Chunk (singleton w) cs
+{-# INLINE snoc #-}
+
+-- | /O(1)/ Extract the first element of a Buffer, which must be non-empty.
+head :: Buffer -> Word8
+head Empty       = errorEmptyList "head"
+head (Chunk c _) = S.unsafeHead c
+{-# INLINE head #-}
+
+-- | /O(1)/ Extract the head and tail of a Buffer, returning Nothing
+-- if it is empty.
+uncons :: Buffer -> Maybe (Word8, Buffer)
+uncons Empty = Nothing
+uncons (Chunk c cs)
+    = Just (S.unsafeHead c,
+            if S.length c == 1 then cs else Chunk (S.unsafeTail c) cs)
+{-# INLINE uncons #-}
+
+-- | /O(1)/ Extract the elements after the head of a Buffer, which must be
+-- non-empty.
+tail :: Buffer -> Buffer
+tail Empty          = errorEmptyList "tail"
+tail (Chunk c cs)
+  | S.length c == 1 = cs
+  | otherwise       = Chunk (S.unsafeTail c) cs
+{-# INLINE tail #-}
+
+-- | /O(n\/c)/ Extract the last element of a Buffer, which must be finite
+-- and non-empty.
+last :: Buffer -> Word8
+last Empty          = errorEmptyList "last"
+last (Chunk c0 cs0) = go c0 cs0
+  where go c Empty        = S.last c
+        go _ (Chunk c cs) = go c cs
+-- XXX Don't inline this. Something breaks with 6.8.2 (haven't investigated yet)
+
+-- | /O(n\/c)/ Return all the elements of a 'Buffer' except the last one.
+init :: Buffer -> Buffer
+init Empty          = errorEmptyList "init"
+init (Chunk c0 cs0) = go c0 cs0
+  where go c Empty | S.length c == 1 = Empty
+                   | otherwise       = Chunk (S.init c) Empty
+        go c (Chunk c' cs)           = Chunk c (go c' cs)
+
+-- | /O(n\/c)/ Append two Buffers
+append :: Buffer -> Buffer -> Buffer
+append xs ys = foldrChunks Chunk ys xs
+{-# INLINE append #-}
+
+-- ---------------------------------------------------------------------
+-- Transformations
+
+-- | /O(n)/ 'map' @f xs@ is the Buffer obtained by applying @f@ to each
+-- element of @xs@.
+map :: (Word8 -> Word8) -> Buffer -> Buffer
+map f s = go s
+    where
+        go Empty        = Empty
+        go (Chunk x xs) = Chunk y ys
+            where
+                y  = S.map f x
+                ys = go xs
+{-# INLINE map #-}
+
+-- | /O(n)/ 'reverse' @xs@ returns the elements of @xs@ in reverse order.
+reverse :: Buffer -> Buffer
+reverse cs0 = rev Empty cs0
+  where rev a Empty        = a
+        rev a (Chunk c cs) = rev (Chunk (S.reverse c) a) cs
+{-# INLINE reverse #-}
+
+-- | The 'intersperse' function takes a 'Word8' and a 'Buffer' and
+-- \`intersperses\' that byte between the elements of the 'Buffer'.
+-- It is analogous to the intersperse function on Lists.
+intersperse :: Word8 -> Buffer -> Buffer
+intersperse _ Empty        = Empty
+intersperse w (Chunk c cs) = Chunk (S.intersperse w c)
+                                   (foldrChunks (Chunk . intersperse') Empty cs)
+  where intersperse' :: P.Buffer -> P.Buffer
+        intersperse' (S.PS fp o l e) =
+          S.unsafeCreate' (2*l) $ \p' -> withForeignPtr fp $ \p -> do
+            poke p' w
+            S.c_intersperse (p' `plusPtr` 1) (p `plusPtr` o) (fromIntegral l) w
+            return $! e + l * S.extra w
+
+-- | The 'transpose' function transposes the rows and columns of its
+-- 'Buffer' argument.
+transpose :: [Buffer] -> [Buffer]
+transpose css = L.map (\ss -> Chunk (S.pack ss) Empty)
+                      (L.transpose (L.map unpack css))
+--TODO: make this fast
+
+-- ---------------------------------------------------------------------
+-- Reducing 'Buffer's
+
+-- | 'foldl', applied to a binary operator, a starting value (typically
+-- the left-identity of the operator), and a Buffer, reduces the
+-- Buffer using the binary operator, from left to right.
+foldl :: (a -> Word8 -> a) -> a -> Buffer -> a
+foldl f z = go z
+  where go a Empty        = a
+        go a (Chunk c cs) = go (S.foldl f a c) cs
+{-# INLINE foldl #-}
+
+-- | 'foldl\'' is like 'foldl', but strict in the accumulator.
+foldl' :: (a -> Word8 -> a) -> a -> Buffer -> a
+foldl' f z = go z
+  where go a _ | a `seq` False = undefined
+        go a Empty        = a
+        go a (Chunk c cs) = go (S.foldl f a c) cs
+{-# INLINE foldl' #-}
+
+-- | 'foldr', applied to a binary operator, a starting value
+-- (typically the right-identity of the operator), and a Buffer,
+-- reduces the Buffer using the binary operator, from right to left.
+foldr :: (Word8 -> a -> a) -> a -> Buffer -> a
+foldr k z cs = foldrChunks (flip (S.foldr k)) z cs
+{-# INLINE foldr #-}
+
+-- | 'foldl1' is a variant of 'foldl' that has no starting value
+-- argument, and thus must be applied to non-empty 'Buffers'.
+-- This function is subject to array fusion.
+foldl1 :: (Word8 -> Word8 -> Word8) -> Buffer -> Word8
+foldl1 _ Empty        = errorEmptyList "foldl1"
+foldl1 f (Chunk c cs) = foldl f (S.unsafeHead c) (Chunk (S.unsafeTail c) cs)
+
+-- | 'foldl1\'' is like 'foldl1', but strict in the accumulator.
+foldl1' :: (Word8 -> Word8 -> Word8) -> Buffer -> Word8
+foldl1' _ Empty        = errorEmptyList "foldl1'"
+foldl1' f (Chunk c cs) = foldl' f (S.unsafeHead c) (Chunk (S.unsafeTail c) cs)
+
+-- | 'foldr1' is a variant of 'foldr' that has no starting value argument,
+-- and thus must be applied to non-empty 'Buffer's
+foldr1 :: (Word8 -> Word8 -> Word8) -> Buffer -> Word8
+foldr1 _ Empty          = errorEmptyList "foldr1"
+foldr1 f (Chunk c0 cs0) = go c0 cs0
+  where go c Empty         = S.foldr1 f c
+        go c (Chunk c' cs) = S.foldr  f (go c' cs) c
+
+-- ---------------------------------------------------------------------
+-- Special folds
+
+-- | /O(n)/ Concatenate a list of Buffers.
+concat :: [Buffer] -> Buffer
+concat css0 = to css0
+  where
+    go Empty        css = to css
+    go (Chunk c cs) css = Chunk c (go cs css)
+    to []               = Empty
+    to (cs:css)         = go cs css
+
+-- | Map a function over a 'Buffer' and concatenate the results
+concatMap :: (Word8 -> Buffer) -> Buffer -> Buffer
+concatMap _ Empty        = Empty
+concatMap f (Chunk c0 cs0) = to c0 cs0
+  where
+    go :: Buffer -> P.Buffer -> Buffer -> Buffer
+    go Empty        c' cs' = to c' cs'
+    go (Chunk c cs) c' cs' = Chunk c (go cs c' cs')
+
+    to :: P.Buffer -> Buffer -> Buffer
+    to c cs | S.null c  = case cs of
+        Empty          -> Empty
+        (Chunk c' cs') -> to c' cs'
+            | otherwise = go (f (S.unsafeHead c)) (S.unsafeTail c) cs
+
+-- | /O(n)/ Applied to a predicate and a Buffer, 'any' determines if
+-- any element of the 'Buffer' satisfies the predicate.
+any :: (Word8 -> Bool) -> Buffer -> Bool
+any f cs = foldrChunks (\c rest -> S.any f c || rest) False cs
+{-# INLINE any #-}
+-- todo fuse
+
+-- | /O(n)/ Applied to a predicate and a 'Buffer', 'all' determines
+-- if all elements of the 'Buffer' satisfy the predicate.
+all :: (Word8 -> Bool) -> Buffer -> Bool
+all f cs = foldrChunks (\c rest -> S.all f c && rest) True cs
+{-# INLINE all #-}
+-- todo fuse
+
+-- | /O(n)/ 'maximum' returns the maximum value from a 'Buffer'
+maximum :: Buffer -> Word8
+maximum Empty        = errorEmptyList "maximum"
+maximum (Chunk c cs) = foldlChunks (\n c' -> n `max` S.maximum c')
+                                   (S.maximum c) cs
+{-# INLINE maximum #-}
+
+-- | /O(n)/ 'minimum' returns the minimum value from a 'Buffer'
+minimum :: Buffer -> Word8
+minimum Empty        = errorEmptyList "minimum"
+minimum (Chunk c cs) = foldlChunks (\n c' -> n `min` S.minimum c')
+                                     (S.minimum c) cs
+{-# INLINE minimum #-}
+
+-- | The 'mapAccumL' function behaves like a combination of 'map' and
+-- 'foldl'; it applies a function to each element of a Buffer,
+-- passing an accumulating parameter from left to right, and returning a
+-- final value of this accumulator together with the new Buffer.
+mapAccumL :: (acc -> Word8 -> (acc, Word8)) -> acc -> Buffer -> (acc, Buffer)
+mapAccumL f s0 cs0 = go s0 cs0
+  where
+    go s Empty        = (s, Empty)
+    go s (Chunk c cs) = (s'', Chunk c' cs')
+        where (s',  c')  = S.mapAccumL f s c
+              (s'', cs') = go s' cs
+
+-- | The 'mapAccumR' function behaves like a combination of 'map' and
+-- 'foldr'; it applies a function to each element of a Buffer,
+-- passing an accumulating parameter from right to left, and returning a
+-- final value of this accumulator together with the new Buffer.
+mapAccumR :: (acc -> Word8 -> (acc, Word8)) -> acc -> Buffer -> (acc, Buffer)
+mapAccumR f s0 cs0 = go s0 cs0
+  where
+    go s Empty        = (s, Empty)
+    go s (Chunk c cs) = (s'', Chunk c' cs')
+        where (s'', c') = S.mapAccumR f s' c
+              (s', cs') = go s cs
+
+-- ---------------------------------------------------------------------
+-- Building Buffers
+
+-- | 'scanl' is similar to 'foldl', but returns a list of successive
+-- reduced values from the left. This function will fuse.
+--
+-- > scanl f z [x1, x2, ...] == [z, z `f` x1, (z `f` x1) `f` x2, ...]
+--
+-- Note that
+--
+-- > last (scanl f z xs) == foldl f z xs.
+scanl :: (Word8 -> Word8 -> Word8) -> Word8 -> Buffer -> Buffer
+scanl f z = snd . foldl k (z,singleton z)
+ where
+    k (c,acc) a = let n = f c a in (n, acc `snoc` n)
+{-# INLINE scanl #-}
+
+-- ---------------------------------------------------------------------
+-- Unfolds and replicates
+
+-- | @'iterate' f x@ returns an infinite Buffer of repeated applications
+-- of @f@ to @x@:
+--
+-- > iterate f x == [x, f x, f (f x), ...]
+--
+iterate :: (Word8 -> Word8) -> Word8 -> Buffer
+iterate f = unfoldr (\x -> case f x of x' -> x' `seq` Just (x', x'))
+
+-- | @'repeat' x@ is an infinite Buffer, with @x@ the value of every
+-- element.
+--
+repeat :: Word8 -> Buffer
+repeat w = cs where cs = Chunk (S.replicate smallChunkSize w) cs
+
+-- | /O(n)/ @'replicate' n x@ is a Buffer of length @n@ with @x@
+-- the value of every element.
+--
+replicate :: Int64 -> Word8 -> Buffer
+replicate n w
+    | n <= 0             = Empty
+    | n < fromIntegral smallChunkSize = Chunk (S.replicate (fromIntegral n) w) Empty
+    | r == 0             = cs -- preserve invariant
+    | otherwise          = Chunk (S.unsafeTake (fromIntegral r) c) cs
+ where
+    c      = S.replicate smallChunkSize w
+    cs     = nChunks q
+    (q, r) = quotRem n (fromIntegral smallChunkSize)
+    nChunks 0 = Empty
+    nChunks m = Chunk c (nChunks (m-1))
+
+-- | 'cycle' ties a finite Buffer into a circular one, or equivalently,
+-- the infinite repetition of the original Buffer.
+--
+cycle :: Buffer -> Buffer
+cycle Empty = errorEmptyList "cycle"
+cycle cs    = cs' where cs' = foldrChunks Chunk cs' cs
+
+-- | /O(n)/ The 'unfoldr' function is analogous to the List \'unfoldr\'.
+-- 'unfoldr' builds a Buffer from a seed value.  The function takes
+-- the element and returns 'Nothing' if it is done producing the
+-- Buffer or returns 'Just' @(a,b)@, in which case, @a@ is a
+-- prepending to the Buffer and @b@ is used as the next element in a
+-- recursive call.
+unfoldr :: (a -> Maybe (Word8, a)) -> a -> Buffer
+unfoldr f s0 = unfoldChunk 32 s0
+  where unfoldChunk n s =
+          case S.unfoldrN n f s of
+            (c, Nothing)
+              | S.null c  -> Empty
+              | otherwise -> Chunk c Empty
+            (c, Just s')  -> Chunk c (unfoldChunk (n*2) s')
+
+-- ---------------------------------------------------------------------
+-- Substrings
+
+-- | /O(n\/c)/ 'take' @n@, applied to a Buffer @xs@, returns the prefix
+-- of @xs@ of length @n@, or @xs@ itself if @n > 'length' xs@.
+take :: Int64 -> Buffer -> Buffer
+take i _ | i <= 0 = Empty
+take i cs0         = take' i cs0
+  where take' 0 _            = Empty
+        take' _ Empty        = Empty
+        take' n (Chunk c cs) =
+          if n < fromIntegral (S.length c)
+            then Chunk (S.take (fromIntegral n) c) Empty
+            else Chunk c (take' (n - fromIntegral (S.length c)) cs)
+
+-- | /O(n\/c)/ 'drop' @n xs@ returns the suffix of @xs@ after the first @n@
+-- elements, or @[]@ if @n > 'length' xs@.
+drop  :: Int64 -> Buffer -> Buffer
+drop i p | i <= 0 = p
+drop i cs0 = drop' i cs0
+  where drop' 0 cs           = cs
+        drop' _ Empty        = Empty
+        drop' n (Chunk c cs) =
+          if n < fromIntegral (S.length c)
+            then Chunk (S.drop (fromIntegral n) c) cs
+            else drop' (n - fromIntegral (S.length c)) cs
+
+-- | /O(n\/c)/ 'splitAt' @n xs@ is equivalent to @('take' n xs, 'drop' n xs)@.
+splitAt :: Int64 -> Buffer -> (Buffer, Buffer)
+splitAt i cs0 | i <= 0 = (Empty, cs0)
+splitAt i cs0 = splitAt' i cs0
+  where splitAt' 0 cs           = (Empty, cs)
+        splitAt' _ Empty        = (Empty, Empty)
+        splitAt' n (Chunk c cs) =
+          if n < fromIntegral (S.length c)
+            then (Chunk (S.take (fromIntegral n) c) Empty 
+                 ,Chunk (S.drop (fromIntegral n) c) cs)
+            else let (cs', cs'') = splitAt' (n - fromIntegral (S.length c)) cs
+                   in (Chunk c cs', cs'')
+
+
+-- | 'takeWhile', applied to a predicate @p@ and a Buffer @xs@,
+-- returns the longest prefix (possibly empty) of @xs@ of elements that
+-- satisfy @p@.
+takeWhile :: (Word8 -> Bool) -> Buffer -> Buffer
+takeWhile f cs0 = takeWhile' cs0
+  where takeWhile' Empty        = Empty
+        takeWhile' (Chunk c cs) =
+          case findIndexOrEnd (not . f) c of
+            0                  -> Empty
+            n | n < S.length c -> Chunk (S.take n c) Empty
+              | otherwise      -> Chunk c (takeWhile' cs)
+
+-- | 'dropWhile' @p xs@ returns the suffix remaining after 'takeWhile' @p xs@.
+dropWhile :: (Word8 -> Bool) -> Buffer -> Buffer
+dropWhile f cs0 = dropWhile' cs0
+  where dropWhile' Empty        = Empty
+        dropWhile' (Chunk c cs) =
+          case findIndexOrEnd (not . f) c of
+            n | n < S.length c -> Chunk (S.drop n c) cs
+              | otherwise      -> dropWhile' cs
+
+-- | 'break' @p@ is equivalent to @'span' ('not' . p)@.
+break :: (Word8 -> Bool) -> Buffer -> (Buffer, Buffer)
+break f cs0 = break' cs0
+  where break' Empty        = (Empty, Empty)
+        break' (Chunk c cs) =
+          case findIndexOrEnd f c of
+            0                  -> (Empty, Chunk c cs)
+            n | n < S.length c -> (Chunk (S.take n c) Empty
+                                  ,Chunk (S.drop n c) cs)
+              | otherwise      -> let (cs', cs'') = break' cs
+                                   in (Chunk c cs', cs'')
+
+--
+-- TODO
+--
+-- Add rules
+--
+
+{-
+-- | 'breakByte' breaks its Buffer argument at the first occurence
+-- of the specified byte. It is more efficient than 'break' as it is
+-- implemented with @memchr(3)@. I.e.
+-- 
+-- > break (=='c') "abcd" == breakByte 'c' "abcd"
+--
+breakByte :: Word8 -> Buffer -> (Buffer, Buffer)
+breakByte c (LPS ps) = case (breakByte' ps) of (a,b) -> (LPS a, LPS b)
+  where breakByte' []     = ([], [])
+        breakByte' (x:xs) =
+          case P.elemIndex c x of
+            Just 0  -> ([], x : xs)
+            Just n  -> (P.take n x : [], P.drop n x : xs)
+            Nothing -> let (xs', xs'') = breakByte' xs
+                        in (x : xs', xs'')
+
+-- | 'spanByte' breaks its Buffer argument at the first
+-- occurence of a byte other than its argument. It is more efficient
+-- than 'span (==)'
+--
+-- > span  (=='c') "abcd" == spanByte 'c' "abcd"
+--
+spanByte :: Word8 -> Buffer -> (Buffer, Buffer)
+spanByte c (LPS ps) = case (spanByte' ps) of (a,b) -> (LPS a, LPS b)
+  where spanByte' []     = ([], [])
+        spanByte' (x:xs) =
+          case P.spanByte c x of
+            (x', x'') | P.null x'  -> ([], x : xs)
+                      | P.null x'' -> let (xs', xs'') = spanByte' xs
+                                       in (x : xs', xs'')
+                      | otherwise  -> (x' : [], x'' : xs)
+-}
+
+-- | 'span' @p xs@ breaks the Buffer into two segments. It is
+-- equivalent to @('takeWhile' p xs, 'dropWhile' p xs)@
+span :: (Word8 -> Bool) -> Buffer -> (Buffer, Buffer)
+span p = break (not . p)
+
+-- | /O(n)/ Splits a 'Buffer' into components delimited by
+-- separators, where the predicate returns True for a separator element.
+-- The resulting components do not contain the separators.  Two adjacent
+-- separators result in an empty component in the output.  eg.
+--
+-- > splitWith (=='a') "aabbaca" == ["","","bb","c",""]
+-- > splitWith (=='a') []        == []
+--
+splitWith :: (Word8 -> Bool) -> Buffer -> [Buffer]
+splitWith _ Empty          = []
+splitWith p (Chunk c0 cs0) = comb [] (S.splitWith p c0) cs0
+
+  where comb :: [P.Buffer] -> [P.Buffer] -> Buffer -> [Buffer]
+        comb acc (s:[]) Empty        = revChunks (s:acc) : []
+        comb acc (s:[]) (Chunk c cs) = comb (s:acc) (S.splitWith p c) cs
+        comb acc (s:ss) cs           = revChunks (s:acc) : comb [] ss cs
+
+{-# INLINE splitWith #-}
+
+-- | /O(n)/ Break a 'Buffer' into pieces separated by the byte
+-- argument, consuming the delimiter. I.e.
+--
+-- > split '\n' "a\nb\nd\ne" == ["a","b","d","e"]
+-- > split 'a'  "aXaXaXa"    == ["","X","X","X",""]
+-- > split 'x'  "x"          == ["",""]
+-- 
+-- and
+--
+-- > intercalate [c] . split c == id
+-- > split == splitWith . (==)
+-- 
+-- As for all splitting functions in this library, this function does
+-- not copy the substrings, it just constructs new 'Buffers' that
+-- are slices of the original.
+--
+split :: Word8 -> Buffer -> [Buffer]
+split _ Empty     = []
+split w (Chunk c0 cs0) = comb [] (S.split w c0) cs0
+
+  where comb :: [P.Buffer] -> [P.Buffer] -> Buffer -> [Buffer]
+        comb acc (s:[]) Empty        = revChunks (s:acc) : []
+        comb acc (s:[]) (Chunk c cs) = comb (s:acc) (S.split w c) cs
+        comb acc (s:ss) cs           = revChunks (s:acc) : comb [] ss cs
+{-# INLINE split #-}
+
+{-
+-- | Like 'splitWith', except that sequences of adjacent separators are
+-- treated as a single separator. eg.
+-- 
+-- > tokens (=='a') "aabbaca" == ["bb","c"]
+--
+tokens :: (Word8 -> Bool) -> Buffer -> [Buffer]
+tokens f = L.filter (not.null) . splitWith f
+-}
+
+-- | The 'group' function takes a Buffer and returns a list of
+-- Buffers such that the concatenation of the result is equal to the
+-- argument.  Moreover, each sublist in the result contains only equal
+-- elements.  For example,
+--
+-- > group "Mississippi" = ["M","i","ss","i","ss","i","pp","i"]
+--
+-- It is a special case of 'groupBy', which allows the programmer to
+-- supply their own equality test.
+group :: Buffer -> [Buffer]
+group Empty          = []
+group (Chunk c0 cs0) = group' [] (S.group c0) cs0
+  where 
+    group' :: [P.Buffer] -> [P.Buffer] -> Buffer -> [Buffer]
+    group' acc@(s':_) ss@(s:_) cs
+      | S.unsafeHead s'
+     /= S.unsafeHead s             = revNonEmptyChunks    acc  : group' [] ss cs
+    group' acc (s:[]) Empty        = revNonEmptyChunks (s:acc) : []
+    group' acc (s:[]) (Chunk c cs) = group' (s:acc) (S.group c) cs
+    group' acc (s:ss) cs           = revNonEmptyChunks (s:acc) : group' [] ss cs
+
+{-
+TODO: check if something like this might be faster
+
+group :: Buffer -> [Buffer]
+group xs
+    | null xs   = []
+    | otherwise = ys : group zs
+    where
+        (ys, zs) = spanByte (unsafeHead xs) xs
+-}
+
+-- | The 'groupBy' function is the non-overloaded version of 'group'.
+--
+groupBy :: (Word8 -> Word8 -> Bool) -> Buffer -> [Buffer]
+groupBy _ Empty          = []
+groupBy k (Chunk c0 cs0) = groupBy' [] 0 (S.groupBy k c0) cs0
+  where
+    groupBy' :: [P.Buffer] -> Word8 -> [P.Buffer] -> Buffer -> [Buffer]
+    groupBy' acc@(_:_) c ss@(s:_) cs
+      | not (c `k` S.unsafeHead s)     = revNonEmptyChunks acc : groupBy' [] 0 ss cs
+    groupBy' acc _ (s:[]) Empty        = revNonEmptyChunks (s : acc) : []
+    groupBy' acc w (s:[]) (Chunk c cs) = groupBy' (s:acc) w' (S.groupBy k c) cs
+                                           where w' | L.null acc = S.unsafeHead s
+                                                    | otherwise  = w
+    groupBy' acc _ (s:ss) cs           = revNonEmptyChunks (s : acc) : groupBy' [] 0 ss cs
+
+{-
+TODO: check if something like this might be faster
+
+groupBy :: (Word8 -> Word8 -> Bool) -> Buffer -> [Buffer]
+groupBy k xs
+    | null xs   = []
+    | otherwise = take n xs : groupBy k (drop n xs)
+    where
+        n = 1 + findIndexOrEnd (not . k (head xs)) (tail xs)
+-}
+
+-- | /O(n)/ The 'intercalate' function takes a 'Buffer' and a list of
+-- 'Buffer's and concatenates the list after interspersing the first
+-- argument between each element of the list.
+intercalate :: Buffer -> [Buffer] -> Buffer
+intercalate s = concat . (L.intersperse s)
+
+-- ---------------------------------------------------------------------
+-- Indexing Buffers
+
+-- | /O(c)/ 'Buffer' index (subscript) operator, starting from 0.
+index :: Buffer -> Int64 -> Word8
+index _  i | i < 0  = moduleError "index" ("negative index: " ++ show i)
+index cs0 i         = index' cs0 i
+  where index' Empty     n = moduleError "index" ("index too large: " ++ show n)
+        index' (Chunk c cs) n
+          | n >= fromIntegral (S.length c) = 
+              index' cs (n - fromIntegral (S.length c))
+          | otherwise       = S.unsafeIndex c (fromIntegral n)
+
+-- | /O(n)/ The 'elemIndex' function returns the index of the first
+-- element in the given 'Buffer' which is equal to the query
+-- element, or 'Nothing' if there is no such element. 
+-- This implementation uses memchr(3).
+elemIndex :: Word8 -> Buffer -> Maybe Int64
+elemIndex w cs0 = elemIndex' 0 cs0
+  where elemIndex' _ Empty        = Nothing
+        elemIndex' n (Chunk c cs) =
+          case S.elemIndex w c of
+            Nothing -> elemIndex' (n + fromIntegral (S.length c)) cs
+            Just i  -> Just (n + fromIntegral i)
+
+{-
+-- | /O(n)/ The 'elemIndexEnd' function returns the last index of the
+-- element in the given 'Buffer' which is equal to the query
+-- element, or 'Nothing' if there is no such element. The following
+-- holds:
+--
+-- > elemIndexEnd c xs == 
+-- > (-) (length xs - 1) `fmap` elemIndex c (reverse xs)
+--
+elemIndexEnd :: Word8 -> Buffer -> Maybe Int
+elemIndexEnd ch (PS x s l) = inlinePerformIO $ withForeignPtr x $ \p ->
+    go (p `plusPtr` s) (l-1)
+  where
+    STRICT2(go)
+    go p i | i < 0     = return Nothing
+           | otherwise = do ch' <- peekByteOff p i
+                            if ch == ch'
+                                then return $ Just i
+                                else go p (i-1)
+-}
+-- | /O(n)/ The 'elemIndices' function extends 'elemIndex', by returning
+-- the indices of all elements equal to the query element, in ascending order.
+-- This implementation uses memchr(3).
+elemIndices :: Word8 -> Buffer -> [Int64]
+elemIndices w cs0 = elemIndices' 0 cs0
+  where elemIndices' _ Empty        = []
+        elemIndices' n (Chunk c cs) = L.map ((+n).fromIntegral) (S.elemIndices w c)
+                             ++ elemIndices' (n + fromIntegral (S.length c)) cs
+
+-- | count returns the number of times its argument appears in the Buffer
+--
+-- > count = length . elemIndices
+--
+-- But more efficiently than using length on the intermediate list.
+count :: Word8 -> Buffer -> Int64
+count w cs = foldlChunks (\n c -> n + fromIntegral (S.count w c)) 0 cs
+
+-- | The 'findIndex' function takes a predicate and a 'Buffer' and
+-- returns the index of the first element in the Buffer
+-- satisfying the predicate.
+findIndex :: (Word8 -> Bool) -> Buffer -> Maybe Int64
+findIndex k cs0 = findIndex' 0 cs0
+  where findIndex' _ Empty        = Nothing
+        findIndex' n (Chunk c cs) =
+          case S.findIndex k c of
+            Nothing -> findIndex' (n + fromIntegral (S.length c)) cs
+            Just i  -> Just (n + fromIntegral i)
+{-# INLINE findIndex #-}
+
+-- | /O(n)/ The 'find' function takes a predicate and a Buffer,
+-- and returns the first element in matching the predicate, or 'Nothing'
+-- if there is no such element.
+--
+-- > find f p = case findIndex f p of Just n -> Just (p ! n) ; _ -> Nothing
+--
+find :: (Word8 -> Bool) -> Buffer -> Maybe Word8
+find f cs0 = find' cs0
+  where find' Empty        = Nothing
+        find' (Chunk c cs) = case S.find f c of
+            Nothing -> find' cs
+            Just w  -> Just w
+{-# INLINE find #-}
+
+-- | The 'findIndices' function extends 'findIndex', by returning the
+-- indices of all elements satisfying the predicate, in ascending order.
+findIndices :: (Word8 -> Bool) -> Buffer -> [Int64]
+findIndices k cs0 = findIndices' 0 cs0
+  where findIndices' _ Empty        = []
+        findIndices' n (Chunk c cs) = L.map ((+n).fromIntegral) (S.findIndices k c)
+                             ++ findIndices' (n + fromIntegral (S.length c)) cs
+
+-- ---------------------------------------------------------------------
+-- Searching Buffers
+
+-- | /O(n)/ 'elem' is the 'Buffer' membership predicate.
+elem :: Word8 -> Buffer -> Bool
+elem w cs = case elemIndex w cs of Nothing -> False ; _ -> True
+
+-- | /O(n)/ 'notElem' is the inverse of 'elem'
+notElem :: Word8 -> Buffer -> Bool
+notElem w cs = not (elem w cs)
+
+-- | /O(n)/ 'filter', applied to a predicate and a Buffer,
+-- returns a Buffer containing those characters that satisfy the
+-- predicate.
+filter :: (Word8 -> Bool) -> Buffer -> Buffer
+filter p s = go s
+    where
+        go Empty        = Empty
+        go (Chunk x xs) = chunk (S.filter p x) (go xs)
+{-# INLINE filter #-}
+
+{-
+-- | /O(n)/ and /O(n\/c) space/ A first order equivalent of /filter .
+-- (==)/, for the common case of filtering a single byte. It is more
+-- efficient to use /filterByte/ in this case.
+--
+-- > filterByte == filter . (==)
+--
+-- filterByte is around 10x faster, and uses much less space, than its
+-- filter equivalent
+filterByte :: Word8 -> Buffer -> Buffer
+filterByte w ps = replicate (count w ps) w
+{-# INLINE filterByte #-}
+
+{-# RULES
+"Buffer specialise filter (== x)" forall x.
+  filter ((==) x) = filterByte x
+
+"Buffer specialise filter (== x)" forall x.
+ filter (== x) = filterByte x
+  #-}
+-}
+
+{-
+-- | /O(n)/ A first order equivalent of /filter . (\/=)/, for the common
+-- case of filtering a single byte out of a list. It is more efficient
+-- to use /filterNotByte/ in this case.
+--
+-- > filterNotByte == filter . (/=)
+--
+-- filterNotByte is around 2x faster than its filter equivalent.
+filterNotByte :: Word8 -> Buffer -> Buffer
+filterNotByte w (LPS xs) = LPS (filterMap (P.filterNotByte w) xs)
+-}
+
+-- | /O(n)/ The 'partition' function takes a predicate a Buffer and returns
+-- the pair of Buffers with elements which do and do not satisfy the
+-- predicate, respectively; i.e.,
+--
+-- > partition p bs == (filter p xs, filter (not . p) xs)
+--
+partition :: (Word8 -> Bool) -> Buffer -> (Buffer, Buffer)
+partition f p = (filter f p, filter (not . f) p)
+--TODO: use a better implementation
+
+-- ---------------------------------------------------------------------
+-- Searching for substrings
+
+-- | /O(n)/ The 'isPrefixOf' function takes two Buffers and returns 'True'
+-- iff the first is a prefix of the second.
+isPrefixOf :: Buffer -> Buffer -> Bool
+isPrefixOf Empty _  = True
+isPrefixOf _ Empty  = False
+isPrefixOf (Chunk x xs) (Chunk y ys)
+    | S.length x == S.length y = x == y  && isPrefixOf xs ys
+    | S.length x <  S.length y = x == yh && isPrefixOf xs (Chunk yt ys)
+    | otherwise                = xh == y && isPrefixOf (Chunk xt xs) ys
+  where (xh,xt) = S.splitAt (S.length y) x
+        (yh,yt) = S.splitAt (S.length x) y
+
+-- | /O(n)/ The 'isSuffixOf' function takes two Buffers and returns 'True'
+-- iff the first is a suffix of the second.
+-- 
+-- The following holds:
+--
+-- > isSuffixOf x y == reverse x `isPrefixOf` reverse y
+--
+isSuffixOf :: Buffer -> Buffer -> Bool
+isSuffixOf x y = reverse x `isPrefixOf` reverse y
+--TODO: a better implementation
+
+-- ---------------------------------------------------------------------
+-- Zipping
+
+-- | /O(n)/ 'zip' takes two Buffers and returns a list of
+-- corresponding pairs of bytes. If one input Buffer is short,
+-- excess elements of the longer Buffer are discarded. This is
+-- equivalent to a pair of 'unpack' operations.
+zip :: Buffer -> Buffer -> [(Word8,Word8)]
+zip = zipWith (,)
+
+-- | 'zipWith' generalises 'zip' by zipping with the function given as
+-- the first argument, instead of a tupling function.  For example,
+-- @'zipWith' (+)@ is applied to two Buffers to produce the list of
+-- corresponding sums.
+zipWith :: (Word8 -> Word8 -> a) -> Buffer -> Buffer -> [a]
+zipWith _ Empty     _  = []
+zipWith _ _      Empty = []
+zipWith f (Chunk a as) (Chunk b bs) = go a as b bs
+  where
+    go x xs y ys = f (S.unsafeHead x) (S.unsafeHead y)
+                 : to (S.unsafeTail x) xs (S.unsafeTail y) ys
+
+    to x Empty         _ _             | S.null x       = []
+    to _ _             y Empty         | S.null y       = []
+    to x xs            y ys            | not (S.null x)
+                                      && not (S.null y) = go x  xs y  ys
+    to x xs            _ (Chunk y' ys) | not (S.null x) = go x  xs y' ys
+    to _ (Chunk x' xs) y ys            | not (S.null y) = go x' xs y  ys
+    to _ (Chunk x' xs) _ (Chunk y' ys)                  = go x' xs y' ys
+
+-- | /O(n)/ 'unzip' transforms a list of pairs of bytes into a pair of
+-- Buffers. Note that this performs two 'pack' operations.
+unzip :: [(Word8,Word8)] -> (Buffer,Buffer)
+unzip ls = (pack (L.map fst ls), pack (L.map snd ls))
+{-# INLINE unzip #-}
+
+-- ---------------------------------------------------------------------
+-- Special lists
+
+-- | /O(n)/ Return all initial segments of the given 'Buffer', shortest first.
+inits :: Buffer -> [Buffer]
+inits = (Empty :) . inits'
+  where inits' Empty        = []
+        inits' (Chunk c cs) = L.map (\c' -> Chunk c' Empty) (L.tail (S.inits c))
+                           ++ L.map (Chunk c) (inits' cs)
+
+-- | /O(n)/ Return all final segments of the given 'Buffer', longest first.
+tails :: Buffer -> [Buffer]
+tails Empty         = Empty : []
+tails cs@(Chunk c cs')
+  | S.length c == 1 = cs : tails cs'
+  | otherwise       = cs : tails (Chunk (S.unsafeTail c) cs')
+
+-- ---------------------------------------------------------------------
+-- Low level constructors
+
+-- | /O(n)/ Make a copy of the 'Buffer' with its own storage.
+--   This is mainly useful to allow the rest of the data pointed
+--   to by the 'Buffer' to be garbage collected, for example
+--   if a large string has been read in, and only a small part of it
+--   is needed in the rest of the program.
+copy :: Buffer -> Buffer
+copy cs = foldrChunks (Chunk . S.copy) Empty cs
+--TODO, we could coalese small blocks here
+--FIXME: probably not strict enough, if we're doing this to avoid retaining
+-- the parent blocks then we'd better copy strictly.
+
+-- ---------------------------------------------------------------------
+
+-- TODO defrag func that concatenates block together that are below a threshold
+-- defrag :: Buffer -> Buffer
+
+-- ---------------------------------------------------------------------
+-- Lazy Buffer IO
+--
+-- Rule for when to close: is it expected to read the whole file?
+-- If so, close when done. 
+--
+
+-- | Read entire handle contents /lazily/ into a 'Buffer'. Chunks
+-- are read on demand, in at most @k@-sized chunks. It does not block
+-- waiting for a whole @k@-sized chunk, so if less than @k@ bytes are
+-- available then they will be returned immediately as a smaller chunk.
+--
+-- The handle is closed on EOF.
+--
+hGetContentsN :: Int -> Handle -> IO Buffer
+hGetContentsN k h = lazyRead -- TODO close on exceptions
+  where
+    lazyRead = unsafeInterleaveIO loop
+
+    loop = do
+        c <- S.hGetNonBlocking h k
+        --TODO: I think this should distinguish EOF from no data available
+        -- the underlying POSIX call makes this distincion, returning either
+        -- 0 or EAGAIN
+        if S.null c
+          then do eof <- hIsEOF h
+                  if eof then hClose h >> return Empty
+                         else hWaitForInput h (-1)
+                           >> loop
+          else do cs <- lazyRead
+                  return (Chunk c cs)
+
+-- | Read @n@ bytes into a 'Buffer', directly from the
+-- specified 'Handle', in chunks of size @k@.
+--
+hGetN :: Int -> Handle -> Int -> IO Buffer
+hGetN k h n | n > 0 = readChunks n
+  where
+    STRICT1(readChunks)
+    readChunks i = do
+        c <- S.hGet h (min k i)
+        case S.length c of
+            0 -> return Empty
+            m -> do cs <- readChunks (i - m)
+                    return (Chunk c cs)
+
+hGetN _ _ 0 = return Empty
+hGetN _ h n = illegalBufferSize h "hGet" n
+
+-- | hGetNonBlockingN is similar to 'hGetContentsN', except that it will never block
+-- waiting for data to become available, instead it returns only whatever data
+-- is available. Chunks are read on demand, in @k@-sized chunks.
+--
+hGetNonBlockingN :: Int -> Handle -> Int -> IO Buffer
+#if defined(__GLASGOW_HASKELL__)
+hGetNonBlockingN k h n | n > 0= readChunks n
+  where
+    STRICT1(readChunks)
+    readChunks i = do
+        c <- S.hGetNonBlocking h (min k i)
+        case S.length c of
+            0 -> return Empty
+            m -> do cs <- readChunks (i - m)
+                    return (Chunk c cs)
+
+hGetNonBlockingN _ _ 0 = return Empty
+hGetNonBlockingN _ h n = illegalBufferSize h "hGetNonBlocking" n
+#else
+hGetNonBlockingN = hGetN
+#endif
+
+illegalBufferSize :: Handle -> String -> Int -> IO a
+illegalBufferSize handle fn sz =
+    ioError (mkIOError illegalOperationErrorType msg (Just handle) Nothing)
+    --TODO: System.IO uses InvalidArgument here, but it's not exported :-(
+    where
+      msg = fn ++ ": illegal Buffer size " ++ showsPrec 9 sz []
+
+-- | Read entire handle contents /lazily/ into a 'Buffer'. Chunks
+-- are read on demand, using the default chunk size.
+--
+-- Once EOF is encountered, the Handle is closed.
+--
+hGetContents :: Handle -> IO Buffer
+hGetContents = hGetContentsN defaultChunkSize
+
+-- | Read @n@ bytes into a 'Buffer', directly from the specified 'Handle'.
+--
+hGet :: Handle -> Int -> IO Buffer
+hGet = hGetN defaultChunkSize
+
+-- | hGetNonBlocking is similar to 'hGet', except that it will never block
+-- waiting for data to become available, instead it returns only whatever data
+-- is available.
+#if defined(__GLASGOW_HASKELL__)
+hGetNonBlocking :: Handle -> Int -> IO Buffer
+hGetNonBlocking = hGetNonBlockingN defaultChunkSize
+#else
+hGetNonBlocking = hGet
+#endif
+
+-- | Read an entire file /lazily/ into a 'Buffer'.
+-- The Handle will be held open until EOF is encountered.
+--
+readFile :: FilePath -> IO Buffer
+readFile f = openBinaryFile f ReadMode >>= hGetContents
+
+-- | Write a 'Buffer' to a file.
+--
+writeFile :: FilePath -> Buffer -> IO ()
+writeFile f txt = bracket (openBinaryFile f WriteMode) hClose
+    (\hdl -> hPut hdl txt)
+
+-- | Append a 'Buffer' to a file.
+--
+appendFile :: FilePath -> Buffer -> IO ()
+appendFile f txt = bracket (openBinaryFile f AppendMode) hClose
+    (\hdl -> hPut hdl txt)
+
+-- | getContents. Equivalent to hGetContents stdin. Will read /lazily/
+--
+getContents :: IO Buffer
+getContents = hGetContents stdin
+
+-- | Outputs a 'Buffer' to the specified 'Handle'.
+--
+hPut :: Handle -> Buffer -> IO ()
+hPut h cs = foldrChunks (\c rest -> S.hPut h c >> rest) (return ()) cs
+
+-- | A synonym for @hPut@, for compatibility
+--
+hPutStr :: Handle -> Buffer -> IO ()
+hPutStr = hPut
+
+-- | Write a Buffer to stdout
+putStr :: Buffer -> IO ()
+putStr = hPut stdout
+
+-- | Write a Buffer to stdout, appending a newline byte
+--
+putStrLn :: Buffer -> IO ()
+putStrLn ps = hPut stdout ps >> hPut stdout (singleton 0x0a)
+
+-- | The interact function takes a function of type @Buffer -> Buffer@
+-- as its argument. The entire input from the standard input device is passed
+-- to this function as its argument, and the resulting string is output on the
+-- standard output device.
+--
+interact :: (Buffer -> Buffer) -> IO ()
+interact transformer = putStr . transformer =<< getContents
+
+-- ---------------------------------------------------------------------
+-- Internal utilities
+
+-- Common up near identical calls to `error' to reduce the number
+-- constant strings created when compiled:
+errorEmptyList :: String -> a
+errorEmptyList fun = moduleError fun "empty Buffer"
+
+moduleError :: String -> String -> a
+moduleError fun msg = error ("Data.Buffer.Lazy." ++ fun ++ ':':' ':msg)
+
+
+-- reverse a list of non-empty chunks into a lazy Buffer
+revNonEmptyChunks :: [P.Buffer] -> Buffer
+revNonEmptyChunks cs = L.foldl' (flip Chunk) Empty cs
+
+-- reverse a list of possibly-empty chunks into a lazy Buffer
+revChunks :: [P.Buffer] -> Buffer
+revChunks cs = L.foldl' (flip chunk) Empty cs
+
+-- | 'findIndexOrEnd' is a variant of findIndex, that returns the length
+-- of the string if no element is found, rather than Nothing.
+findIndexOrEnd :: (Word8 -> Bool) -> P.Buffer -> Int
+findIndexOrEnd k (S.PS x s l _) = S.inlinePerformIO $ withForeignPtr x $ \f -> go (f `plusPtr` s) 0
+  where
+    STRICT2(go)
+    go ptr n | n >= l    = return l
+             | otherwise = do w <- peek ptr
+                              if k w
+                                then return n
+                                else go (ptr `plusPtr` 1) (n+1)
+{-# INLINE findIndexOrEnd #-}
hunk ./Data/Buffer/Unsafe.hs 20
-        __ * Construction
-		ps                      -- :: !!(ForeignPtr Word8) -> Int -> Int -> Buffer
-
hunk ./Data/Buffer/Unsafe.hs 23
+        unsafeLast,             -- :: Buffer -> Word8
+        unsafeInit,             -- :: Buffer -> Buffer
hunk ./Data/Buffer/Unsafe.hs 36
-        unsafePackCString,      -- :: CString -> IO Buffer
-        unsafePackAsciiString   -- :: CString -> IO Buffer
-        unsafePackCStringLen,   -- :: CStringLen -> IO Buffer
-        unsafePackAsciiCStringLen, -- :: CStringLen -> IO Buffer
-        unsafePackMallocCString,-- :: CString -> IO Buffer
-        unsafePackMallocAsciiCString -- CString -> IO Buffer
+        unsafePackCString,           -- :: CString -> IO Buffer
+        unsafePackAsciiCString,      -- :: CString -> IO Buffer
+        unsafePackCStringLen,        -- :: CStringLen -> IO Buffer
+        unsafePackAsciiCStringLen,   -- :: CStringLen -> IO Buffer
+        unsafePackMallocCString,     -- :: CString -> IO Buffer
+        unsafePackMallocAsciiCString,-- :: CString -> IO Buffer
hunk ./Data/Buffer/Unsafe.hs 44
-        unsafePackAddress,          -- :: Addr# -> IO Buffer
-        unsafePackAsciiAddress,     -- :: Addr# -> IO Buffer
-        unsafePackAddressLen,       -- :: Int -> Addr# -> IO Buffer
-        unsafePackAsciiAddressLen   -- :: Int -> Addr# -> IO Buffer
-        unsafePackCStringFinalizer, -- :: Ptr Word8 -> Int -> IO () -> IO Buffer
-        unsafePackAsciiCStringFinalizer -- :: Ptr Word8 -> Int -> IO () -> IO Buffer
-        unsafeFinalize,             -- :: Buffer -> IO ()
+        unsafePackAddress,               -- :: Addr# -> IO Buffer
+        unsafePackAsciiAddress,          -- :: Addr# -> IO Buffer
+        unsafePackAddressLen,            -- :: Int -> Addr# -> IO Buffer
+        unsafePackAsciiAddressLen,       -- :: Int -> Addr# -> IO Buffer
+        unsafePackCStringFinalizer,      -- :: Ptr Word8 -> Int -> IO () -> IO Buffer
+        unsafePackAsciiCStringFinalizer, -- :: Ptr Word8 -> Int -> IO () -> IO Buffer
+        unsafeFinalize,                  -- :: Buffer -> IO ()
hunk ./Data/Buffer/Unsafe.hs 77
+
hunk ./Data/Buffer/Unsafe.hs 104
+-- | This counts the number of multibyte tail bytes in the first n bytes of a buffer
+-- It may do so by counting the number of tail bytes in all of the other bytes of a buffer
+-- if that will require traversing fewer elements.
+-- TODO: replace internal 'go' method with external 'c_count_extras'
hunk ./Data/Buffer/Unsafe.hs 110
-     let lmn = l - i in 
-     -- inlinePerformIO ?
-     unsafePerformIO $ withForeignPtr x $ \p -> 
+     let lmi = l - i in 
+     inlinePerformIO $ withForeignPtr x $ \p -> 
hunk ./Data/Buffer/Unsafe.hs 113
-     then e - go (p `plusPtr` (s + i)) lmi 0
+     then (e -) `fmap` go (p `plusPtr` (s + i)) lmi 0
hunk ./Data/Buffer/Unsafe.hs 117
-        go p 0 acc = acc
+        go _ 0 acc = return acc
hunk ./Data/Buffer/Unsafe.hs 123
-ps :: ForeignPtr Word8 -> Int -> Int -> Buffer
-ps x s l = PS x s l $ 
-    inlinePerformIO $ withForeignPtr x $ \p -> 
-        go (p `plusPtr` s) l 0
-    where 
-    	STRICT3(go)
-    	go p 0 acc = acc
-    	go p n acc = do
-    		w <- peekByteOff p n
-    		go p (n-1) $! acc `plusExtra` w
-{-# INLINE ps #-}
-
hunk ./Data/Buffer/Unsafe.hs 131
+-- | A variety of 'head' for non-empty Buffers. 'unsafeHead' omits the
+-- check for the empty case, so there is an obligation on the programmer
+-- to provide a proof that the Buffer is non-empty.
+unsafeLast :: Buffer -> Word8
+unsafeLast (PS x s l _) = assert (l > 0) $
+    inlinePerformIO $ withForeignPtr x $ \p -> peekByteOff p (s+l-1)
+{-# INLINE unsafeLast #-}
+
hunk ./Data/Buffer/Unsafe.hs 143
-unsafeTail (PS ps s l e) = assert (l > 0) $ 
-        PS ps (s+1) (1-1) $!   
-        e `minusExtra` (inlinePerformIO $ withForeignPtr ps $ \p -> peekByteOff p s)
+unsafeTail (PS x s l e) = assert (l > 0) $ 
+        PS x (s+1) (1-1) $!   
+        e `minusExtra` (inlinePerformIO $ withForeignPtr x $ \p -> peekByteOff p s)
hunk ./Data/Buffer/Unsafe.hs 148
+-- | A variety of 'tail' for non-empty Buffers. 'unsafeTail' omits the
+-- check for the empty case. As with 'unsafeHead', the programmer must
+-- provide a separate proof that the Buffer is non-empty.
+unsafeInit :: Buffer -> Buffer
+unsafeInit (PS x s l e) = assert (l > 0) $ 
+        PS x s (1-1) $!   
+        e `minusExtra` (inlinePerformIO $ withForeignPtr x $ \p -> peekByteOff p (s+l-1))
+{-# INLINE unsafeInit #-}
+
hunk ./Data/Buffer/Unsafe.hs 169
-unsafeTake n ps@(PS x s l e) = assert (0 <= n && n <= l) $ 
-    PS x s n $ unsafeExtras ps n
+unsafeTake n xs@(PS x s l _) = assert (0 <= n && n <= l) $ 
+    PS x s n $ unsafeExtras xs n
hunk ./Data/Buffer/Unsafe.hs 176
-unsafeDrop n ps@(PS x s l e) = assert (0 <= n && n <= l) $ 
-    PS x (s+n) (l-n) $ e - unsafeExtras ps n
+unsafeDrop n xs@(PS x s l e) = assert (0 <= n && n <= l) $ 
+    PS x (s+n) (l-n) $ e - unsafeExtras xs n
hunk ./Data/Buffer/Unsafe.hs 180
-unsafeSplitAt :: Int -> Buffer -> Buffer
-unsafeSplitAt n ps@(PS x s l e) = assert (0 <= n && n <= l) $
-    let e' = unsafeExtras ps n
+unsafeSplitAt :: Int -> Buffer -> (Buffer, Buffer)
+unsafeSplitAt n xs@(PS x s l e) = assert (0 <= n && n <= l) $
+    let e' = unsafeExtras xs n
hunk ./Data/Buffer/Unsafe.hs 298
-{-# INLINE unsafePackAddressLen #-}
+{-# INLINE unsafePackAsciiAddressLen #-}
hunk ./Data/Buffer/Unsafe.hs 364
+-- | /O(n)/ Build a @Buffer@ from a @CString@. This value will have /no/
+-- finalizer associated to it, and will not be garbage collected by
+-- Haskell. The Buffer length is calculated using /strlen(3)/,
+-- and thus the complexity is a /O(n)/.
+--
+-- This function is /unsafe/. If the @CString@ is later modified, this
+-- change will be reflected in the resulting @Buffer@, breaking
+-- referential transparency. In addition the CString must not contain
+-- any bytes greater than 0x7f.
+
+unsafePackAsciiCString :: CString -> IO Buffer
+unsafePackAsciiCString cstr = do
+    fp <- newForeignPtr_ (castPtr cstr)
+    l <- c_strlen cstr
+    return $! PS fp 0 (fromIntegral l) 0
+
hunk ./Data/Buffer/Unsafe.hs 429
+-- | /O(n)/ Build a @Buffer@ from a malloced @CString@. This value will
+-- have a @free(3)@ finalizer associated to it.
+--
+-- This funtion is /unsafe/. If the original @CString@ is later
+-- modified, this change will be reflected in the resulting @Buffer@,
+-- breaking referential transparency. In addition, the original 
+-- CString may not contain any bytes greter than 0x7f.
+--
+-- This function is also unsafe if you call its finalizer twice,
+-- which will result in a /double free/ error, or if you pass it
+-- a CString not allocated with 'malloc'.
+--
+unsafePackMallocAsciiCString :: CString -> IO Buffer
+unsafePackMallocAsciiCString cstr = do
+    fp <- newForeignPtr c_free_finalizer (castPtr cstr)
+    len <- c_strlen cstr
+    return $! PS fp 0 (fromIntegral len) 0
+
hunk ./Data/Buffer/Unsafe.hs 471
-unsafeUseAsCString (PS ps s _ _) ac = withForeignPtr ps $ \p -> ac (castPtr p `plusPtr` s)
+unsafeUseAsCString (PS x s _ _) ac = withForeignPtr x $ \p -> ac (castPtr p `plusPtr` s)
hunk ./Data/Buffer/Unsafe.hs 489
-unsafeUseAsCStringLen (PS ps s l _) f = withForeignPtr ps $ \p -> f (castPtr p `plusPtr` s,l)
+unsafeUseAsCStringLen (PS x s l _) f = withForeignPtr x $ \p -> f (castPtr p `plusPtr` s,l)
addfile ./Data/Buffer/View.hs
hunk ./Data/Buffer/View.hs 1
+{-# LANGUAGE CPP #-}
+module Data.Buffer.View (
+    ViewL(..)
+    ViewR(..)
+    ) where
+
+data ViewL as a = 
+    EmptyL |
+    a :< as
+
+instance Functor (ViewL c) where
+    fmap f EmptyL = EmptyL
+    fmap f (a :< c) = f a :< c
+
+data ViewR as a = 
+    EmptyR |
+    a :> container
+
+#ifndef __HADDOCK__
+# if __GLASGOW_HASKELL__
+    deriving (Eq,Ord,Show,Read,Data)
+# else
+    deriving (Eq,Ord,Show,Read)
+# endif
+#else
+instance (Eq c, Eq a) => Eq (ViewL c a)
+instance (Ord c, Ord a) => Ord (ViewL c a)
+instance (Show c, Show a) => Show (ViewL c a)
+instance (Read c, Read a) => Read (ViewL c a)
+instance (Data c, Data a) => Data (ViewL c a)
+#endif
+
+INSTANCE_TYPEABLE2(ViewL,viewLTc,"ViewL")
+
+instance Functor (ViewR as) where
+    fmap f EmptyL = EmptyL
+    fmap f (as :> a) = as :> f a
+
+#ifndef __HADDOCK__
+# if __GLASGOW_HASKELL__
+    deriving (Eq,Ord,Show,Read,Data)
+# else
+    deriving (Eq,Ord,Show,Read)
+# endif
+#else
+instance (Eq c, Eq a) => Eq (ViewL c a)
+instance (Ord c, Ord a) => Ord (ViewL c a)
+instance (Show c, Show a) => Show (ViewL c a)
+instance (Read c, Read a) => Read (ViewL c a)
+instance (Data c, Data a) => Data (ViewL c a)
+#endif
+
+INSTANCE_TYPEABLE2(ViewR,viewRTc,"ViewR")
hunk ./Data/Buffer/Word8.hs 1
-{-# LANGUAGE CPP #-}
--- We cannot actually specify all the language pragmas, see ghc ticket #
--- If we could, these are what they would be:
-{- LANGUAGE MagicHash, UnboxedTuples,
-            NamedFieldPuns, BangPatterns, RecordWildCards -}
-{-# OPTIONS_HADDOCK prune #-}
-
--- |
--- Module      : Data.Buffer
--- Copyright   : (c) The University of Glasgow 2001,
---               (c) David Roundy 2003-2005,
---               (c) Simon Marlow 2005
---               (c) Bjorn Bringert 2006
---               (c) Don Stewart 2005-2008
---               (c) Edward Kmett 2009-2010
---
---               Array fusion code:
---               (c) 2001,2002 Manuel M T Chakravarty & Gabriele Keller
---               (c) 2006      Manuel M T Chakravarty & Roman Leshchinskiy
---
--- License     : BSD-style
---
--- Maintainer  : ekmett@gmail.com
--- Stability   : experimental
--- Portability : portable
--- 
--- A time and space-efficient implementation of byte vectors using
--- packed Word8 arrays, suitable for high performance use, both in terms
--- of large data quantities, or high speed requirements. Byte vectors
--- are encoded as strict 'Word8' arrays of bytes, held in a 'ForeignPtr',
--- and can be passed between C and Haskell with little effort.
---
--- This module is intended to be imported @qualified@, to avoid name
--- clashes with "Prelude" functions.  eg.
---
--- > import qualified Data.Buffer as B
---
--- Original GHC implementation by Bryan O\'Sullivan.
--- Rewritten to use 'Data.Array.Unboxed.UArray' by Simon Marlow.
--- Rewritten to support slices and use 'ForeignPtr' by David Roundy.
--- Polished and extended by Don Stewart.
---
-
-module Data.Buffer.Word8 (
-
-        -- * The @Buffer@ type
-        Buffer,             -- abstract, instances: Eq, Ord, Show, Read, Data, Typeable, Monoid
-
-        -- * Introducing and eliminating 'Buffer's
-        empty,                  -- :: Buffer
-        singleton,              -- :: Word8   -> Buffer
-        pack,                   -- :: [Word8] -> Buffer
-        unpack,                 -- :: Buffer -> [Word8]
-
-        -- * Basic interface
-        cons,                   -- :: Word8 -> Buffer -> Buffer
-        snoc,                   -- :: Buffer -> Word8 -> Buffer
-        append,                 -- :: Buffer -> Buffer -> Buffer
-        head,                   -- :: Buffer -> Word8
-        uncons,                 -- :: Buffer -> Maybe (Word8, Buffer)
-        last,                   -- :: Buffer -> Word8
-        tail,                   -- :: Buffer -> Buffer
-        init,                   -- :: Buffer -> Buffer
-        null,                   -- :: Buffer -> Bool
-        length,                 -- :: Buffer -> Int
-
-        -- * Transforming Buffers
-        map,                    -- :: (Word8 -> Word8) -> Buffer -> Buffer
-        reverse,                -- :: Buffer -> Buffer
-        intersperse,            -- :: Word8 -> Buffer -> Buffer
-        intercalate,            -- :: Buffer -> [Buffer] -> Buffer
-        transpose,              -- :: [Buffer] -> [Buffer]
-
-        -- * Reducing 'Buffer's (folds)
-        foldl,                  -- :: (a -> Word8 -> a) -> a -> Buffer -> a
-        foldl',                 -- :: (a -> Word8 -> a) -> a -> Buffer -> a
-        foldl1,                 -- :: (Word8 -> Word8 -> Word8) -> Buffer -> Word8
-        foldl1',                -- :: (Word8 -> Word8 -> Word8) -> Buffer -> Word8
-
-        foldr,                  -- :: (Word8 -> a -> a) -> a -> Buffer -> a
-        foldr',                 -- :: (Word8 -> a -> a) -> a -> Buffer -> a
-        foldr1,                 -- :: (Word8 -> Word8 -> Word8) -> Buffer -> Word8
-        foldr1',                -- :: (Word8 -> Word8 -> Word8) -> Buffer -> Word8
-
-        -- ** Special folds
-        concat,                 -- :: [Buffer] -> Buffer
-        concatMap,              -- :: (Word8 -> Buffer) -> Buffer -> Buffer
-        any,                    -- :: (Word8 -> Bool) -> Buffer -> Bool
-        all,                    -- :: (Word8 -> Bool) -> Buffer -> Bool
-        maximum,                -- :: Buffer -> Word8
-        minimum,                -- :: Buffer -> Word8
-
-        -- * Building Buffers
-        -- ** Scans
-        scanl,                  -- :: (Word8 -> Word8 -> Word8) -> Word8 -> Buffer -> Buffer
-        scanl1,                 -- :: (Word8 -> Word8 -> Word8) -> Buffer -> Buffer
-        scanr,                  -- :: (Word8 -> Word8 -> Word8) -> Word8 -> Buffer -> Buffer
-        scanr1,                 -- :: (Word8 -> Word8 -> Word8) -> Buffer -> Buffer
-
-        -- ** Accumulating maps
-        mapAccumL,              -- :: (acc -> Word8 -> (acc, Word8)) -> acc -> Buffer -> (acc, Buffer)
-        mapAccumR,              -- :: (acc -> Word8 -> (acc, Word8)) -> acc -> Buffer -> (acc, Buffer)
-
-        -- ** Generating and unfolding Buffers
-        replicate,              -- :: Int -> Word8 -> Buffer
-        unfoldr,                -- :: (a -> Maybe (Word8, a)) -> a -> Buffer
-        unfoldrN,               -- :: Int -> (a -> Maybe (Word8, a)) -> a -> (Buffer, Maybe a)
-
-        -- * Substrings
-
-        -- ** Breaking strings
-        take,                   -- :: Int -> Buffer -> Buffer
-        drop,                   -- :: Int -> Buffer -> Buffer
-        splitAt,                -- :: Int -> Buffer -> (Buffer, Buffer)
-        takeWhile,              -- :: (Word8 -> Bool) -> Buffer -> Buffer
-        dropWhile,              -- :: (Word8 -> Bool) -> Buffer -> Buffer
-        span,                   -- :: (Word8 -> Bool) -> Buffer -> (Buffer, Buffer)
-        spanEnd,                -- :: (Word8 -> Bool) -> Buffer -> (Buffer, Buffer)
-        break,                  -- :: (Word8 -> Bool) -> Buffer -> (Buffer, Buffer)
-        breakEnd,               -- :: (Word8 -> Bool) -> Buffer -> (Buffer, Buffer)
-        group,                  -- :: Buffer -> [Buffer]
-        groupBy,                -- :: (Word8 -> Word8 -> Bool) -> Buffer -> [Buffer]
-        inits,                  -- :: Buffer -> [Buffer]
-        tails,                  -- :: Buffer -> [Buffer]
-
-        -- ** Breaking into many substrings
-        split,                  -- :: Word8 -> Buffer -> [Buffer]
-        splitWith,              -- :: (Word8 -> Bool) -> Buffer -> [Buffer]
-
-        -- * Predicates
-        isPrefixOf,             -- :: Buffer -> Buffer -> Bool
-        isSuffixOf,             -- :: Buffer -> Buffer -> Bool
-        isInfixOf,              -- :: Buffer -> Buffer -> Bool
-
-        -- ** Search for arbitrary substrings
-        breakSubstring,         -- :: Buffer -> Buffer -> (Buffer,Buffer)
-        findSubstring,          -- :: Buffer -> Buffer -> Maybe Int
-        findSubstrings,         -- :: Buffer -> Buffer -> [Int]
-
-        -- * Searching Buffers
-
-        -- ** Searching by equality
-        elem,                   -- :: Word8 -> Buffer -> Bool
-        notElem,                -- :: Word8 -> Buffer -> Bool
-
-        -- ** Searching with a predicate
-        find,                   -- :: (Word8 -> Bool) -> Buffer -> Maybe Word8
-        filter,                 -- :: (Word8 -> Bool) -> Buffer -> Buffer
-        partition,              -- :: (Word8 -> Bool) -> Buffer -> (Buffer, Buffer)
-
-        -- * Indexing Buffers
-        index,                  -- :: Buffer -> Int -> Word8
-        elemIndex,              -- :: Word8 -> Buffer -> Maybe Int
-        elemIndices,            -- :: Word8 -> Buffer -> [Int]
-        elemIndexEnd,           -- :: Word8 -> Buffer -> Maybe Int
-        findIndex,              -- :: (Word8 -> Bool) -> Buffer -> Maybe Int
-        findIndices,            -- :: (Word8 -> Bool) -> Buffer -> [Int]
-        count,                  -- :: Word8 -> Buffer -> Int
-
-        -- * Zipping and unzipping Buffers
-        zip,                    -- :: Buffer -> Buffer -> [(Word8,Word8)]
-        zipWith,                -- :: (Word8 -> Word8 -> c) -> Buffer -> Buffer -> [c]
-        unzip,                  -- :: [(Word8,Word8)] -> (Buffer,Buffer)
-
-        -- * Ordered Buffers
-        sort,                   -- :: Buffer -> Buffer
-
-        -- * Low level conversions
-        -- ** Copying Buffers
-        copy,                   -- :: Buffer -> Buffer
-
-        -- ** Packing 'CString's and pointers
-        packCString,            -- :: CString -> IO Buffer
-        packCStringLen,         -- :: CStringLen -> IO Buffer
-
-        -- ** Using Buffers as 'CString's
-        useAsCString,           -- :: Buffer -> (CString    -> IO a) -> IO a
-        useAsCStringLen,        -- :: Buffer -> (CStringLen -> IO a) -> IO a
-
-        -- * I\/O with 'Buffer's
-
-        -- ** Standard input and output
-        getLine,                -- :: IO Buffer
-        getContents,            -- :: IO Buffer
-        putStr,                 -- :: Buffer -> IO ()
-        putStrLn,               -- :: Buffer -> IO ()
-        interact,               -- :: (Buffer -> Buffer) -> IO ()
-
-        -- ** Files
-        readFile,               -- :: FilePath -> IO Buffer
-        writeFile,              -- :: FilePath -> Buffer -> IO ()
-        appendFile,             -- :: FilePath -> Buffer -> IO ()
-
-        -- ** I\/O with Handles
-        hGetLine,               -- :: Handle -> IO Buffer
-        hGetContents,           -- :: Handle -> IO Buffer
-        hGet,                   -- :: Handle -> Int -> IO Buffer
-        hGetNonBlocking,        -- :: Handle -> Int -> IO Buffer
-        hPut,                   -- :: Handle -> Buffer -> IO ()
-        hPutStr,                -- :: Handle -> Buffer -> IO ()
-        hPutStrLn,              -- :: Handle -> Buffer -> IO ()
-
-        breakByte
-  ) where
-
-import qualified Prelude as P
-import Prelude hiding           (reverse,head,tail,last,init,null
-                                ,length,map,lines,foldl,foldr,unlines
-                                ,concat,any,take,drop,splitAt,takeWhile
-                                ,dropWhile,span,break,elem,filter,maximum
-                                ,minimum,all,concatMap,foldl1,foldr1
-                                ,scanl,scanl1,scanr,scanr1
-                                ,readFile,writeFile,appendFile,replicate
-                                ,getContents,getLine,putStr,putStrLn,interact
-                                ,zip,zipWith,unzip,notElem)
-
-import Data.Buffer.Internal
-import Data.Buffer.Unsafe
-
-import qualified Data.List as List
-
-import Data.Word                (Word8)
-import Data.Maybe               (isJust, listToMaybe)
-
--- Control.Exception.assert not available in yhc or nhc
-#ifndef __NHC__
-import Control.Exception        (finally, bracket, assert)
-#else
-import Control.Exception	(bracket, finally)
-#endif
-import Control.Monad            (when)
-
-import Foreign.C.String         (CString, CStringLen)
-import Foreign.C.Types          (CSize)
-import Foreign.ForeignPtr
-import Foreign.Marshal.Alloc    (allocaBytes, mallocBytes, reallocBytes, finalizerFree)
-import Foreign.Marshal.Array    (allocaArray)
-import Foreign.Ptr
-import Foreign.Storable         (Storable(..))
-
--- hGetBuf and hPutBuf not available in yhc or nhc
-import System.IO                (stdin,stdout,hClose,hFileSize
-                                ,hGetBuf,hPutBuf,openBinaryFile
-                                ,IOMode(..))
-import System.IO.Error          (mkIOError, illegalOperationErrorType)
-
-import Data.Monoid              (Monoid, mempty, mappend, mconcat)
-
-#if !defined(__GLASGOW_HASKELL__)
-import System.IO.Unsafe
-import qualified System.Environment
-import qualified System.IO      (hGetLine)
-#endif
-
-#if defined(__GLASGOW_HASKELL__)
-
-import System.IO                (hGetBufNonBlocking)
-
-#if __GLASGOW_HASKELL__ >= 611
-import Data.IORef
-import GHC.IO.Handle.Internals
-import GHC.IO.Handle.Types
-import GHC.IO.Buffer
-import GHC.IO.BufferedIO as Buffered
-import GHC.IO hiding (finally)
-import Data.Char                (ord)
-import Foreign.Marshal.Utils    (copyBytes)
-#else
-import System.IO.Error          (isEOFError)
-import GHC.IOBase
-import GHC.Handle
-#endif
-
-import GHC.Prim                 (Word#, (+#), writeWord8OffAddr#)
-import GHC.Base                 (build)
-import GHC.Word hiding (Word8)
-import GHC.Ptr                  (Ptr(..))
-import GHC.ST                   (ST(..))
-
-#endif
-
--- An alternative to Control.Exception (assert) for nhc98
-#ifdef __NHC__
-#define assert  assertS "__FILE__ : __LINE__"
-assertS :: String -> Bool -> a -> a
-assertS _ True  = id
-assertS s False = error ("assertion failed at "++s)
-#endif
-
--- -----------------------------------------------------------------------------
---
--- Useful macros, until we have bang patterns
---
-
-#define STRICT1(f) f a | a `seq` False = undefined
-#define STRICT2(f) f a b | a `seq` b `seq` False = undefined
-#define STRICT3(f) f a b c | a `seq` b `seq` c `seq` False = undefined
-#define STRICT4(f) f a b c d | a `seq` b `seq` c `seq` d `seq` False = undefined
-#define STRICT5(f) f a b c d e | a `seq` b `seq` c `seq` d `seq` e `seq` False = undefined
-
--- -----------------------------------------------------------------------------
-
-instance Eq  Buffer where
-    (==)    = eq
-
-instance Ord Buffer where
-    compare = compareBytes
-
-instance Monoid Buffer where
-    mempty  = empty
-    mappend = append
-    mconcat = concat
-
--- | /O(n)/ Equality on the 'Buffer' type.
-eq :: Buffer -> Buffer -> Bool
-eq a@(PS p s l x) b@(PS p' s' l' x')
-    | l /= l' || x /= x' = False    -- short cut on length and number of extra bytes
-    | p == p' && s == s' = True     -- short cut for the same string
-    | otherwise          = compareBytes a b == EQ
-{-# INLINE eq #-}
--- ^ still needed
-
--- | /O(n)/ 'compareBytes' provides an 'Ordering' for 'Buffers' supporting slices. 
-compareBytes :: Buffer -> Buffer -> Ordering
-compareBytes (PS x1 s1 l1 _) (PS x2 s2 l2 _)
-    | l1 == 0  && l2 == 0               = EQ  -- short cut for empty strings
-    | otherwise                         = inlinePerformIO $
-        withForeignPtr x1 $ \p1 ->
-        withForeignPtr x2 $ \p2 -> do
-            i <- memcmp (p1 `plusPtr` s1) (p2 `plusPtr` s2) (fromIntegral $ min l1 l2)
-            return $! case i `compare` 0 of
-                        EQ  -> l1 `compare` l2
-                        x   -> x
-
-{-
-
--- Pure Haskell version
-
-compareBytes (PS fp1 off1 len1 _) (PS fp2 off2 len2 _)
---    | len1 == 0  && len2 == 0                     = EQ  -- short cut for empty strings
---    | fp1 == fp2 && off1 == off2 && len1 == len2  = EQ  -- short cut for the same string
-    | otherwise                                   = inlinePerformIO $
-    withForeignPtr fp1 $ \p1 ->
-        withForeignPtr fp2 $ \p2 ->
-            cmp (p1 `plusPtr` off1)
-                (p2 `plusPtr` off2) 0 len1 len2
-
--- XXX todo.
-cmp :: Ptr Word8 -> Ptr Word8 -> Int -> Int -> Int-> IO Ordering
-cmp p1 p2 n len1 len2
-      | n == len1 = if n == len2 then return EQ else return LT
-      | n == len2 = return GT
-      | otherwise = do
-          a <- peekByteOff p1 n :: IO Word8
-          b <- peekByteOff p2 n
-          case a `compare` b of
-                EQ -> cmp p1 p2 (n+1) len1 len2
-                LT -> return LT
-                GT -> return GT
--}
-
--- -----------------------------------------------------------------------------
--- Introducing and eliminating 'Buffer's
-
--- | /O(1)/ The empty 'Buffer'
-empty :: Buffer
-empty = PS nullForeignPtr 0 0 0
-
--- | /O(1)/ Convert a 'Word8' into a 'Buffer'
-singleton :: Word8 -> Buffer
-singleton c = unsafeCreate 1 $ \p -> poke p c
-{-# INLINE [1] singleton #-}
-
--- Inline [1] for intercalate rule
-
---
--- XXX The use of unsafePerformIO in allocating functions (unsafeCreate) is critical!
---
--- Otherwise:
---
---  singleton 255 `compare` singleton 127
---
--- is compiled to:
---
---  case mallocBuffer 2 of 
---      ForeignPtr f internals -> 
---           case writeWord8OffAddr# f 0 255 of _ -> 
---           case writeWord8OffAddr# f 0 127 of _ ->
---           case eqAddr# f f of 
---                  False -> case compare (GHC.Prim.plusAddr# f 0) 
---                                        (GHC.Prim.plusAddr# f 0)
---
---
-
--- | /O(n)/ Convert a '[Word8]' into a 'Buffer'. 
---
--- For applications with large numbers of string literals, pack can be a
--- bottleneck. In such cases, consider using packAddress (GHC only).
-pack :: [Word8] -> Buffer
-
-#if !defined(__GLASGOW_HASKELL__)
-
-pack str = unsafeCreate' (P.length str) $ \p -> go p str 0
-    where
-        STRICT3(go)
-        go _ [] acc    = return acc
-        go p (x:xs) acc = poke p x >> go (p `plusPtr` 1) xs (acc `plusExtra` x) -- less space than pokeElemOff
-
-#else /* hack away */
-
-pack str = unsafeCreate' (P.length str) $ \(Ptr p) -> stToIO (go p 0# str 0#)
-    where
-        go _ _ [] acc       = return (I# acc)
-        go p i (W8# c:cs) acc = writeByte p i c >> go p (i +# 1#) cs (if x >=# 0x80# && x <# 0xC0 then acc +# 1 else acc)
-
-        writeByte p i c = ST $ \s# ->
-            case writeWord8OffAddr# p i c s# of s2# -> (# s2#, () #)
-
-#endif
-
--- | /O(n)/ Converts a 'Buffer' to a '[Word8]'.
-unpack :: Buffer -> [Word8]
-
-#if !defined(__GLASGOW_HASKELL__)
-
-unpack (PS _  _ 0 _) = []
-unpack (PS ps s l _) = inlinePerformIO $ withForeignPtr ps $ \p ->
-        go (p `plusPtr` s) (l - 1) []
-    where
-        STRICT3(go)
-        go p 0 acc = peek p          >>= \e -> return (e : acc)
-        go p n acc = peekByteOff p n >>= \e -> go p (n-1) (e : acc)
-{-# INLINE unpack #-}
-
-#else
-
-unpack ps = build (unpackFoldr ps)
-{-# INLINE unpack #-}
-
---
--- Have unpack fuse with good list consumers
---
--- critical this isn't strict in the acc
--- as it will break in the presence of list fusion. this is a known
--- issue with seq and build/foldr rewrite rules, which rely on lazy
--- demanding to avoid bottoms in the list.
---
-unpackFoldr :: Buffer -> (Word8 -> a -> a) -> a -> a
-unpackFoldr (PS fp off len _) f ch = withPtr fp $ \p -> do
-    let loop q n    _   | q `seq` n `seq` False = undefined -- n.b.
-        loop _ (-1) acc = return acc
-        loop q n    acc = do
-           a <- peekByteOff q n
-           loop q (n-1) (a `f` acc)
-    loop (p `plusPtr` off) (len-1) ch
-{-# INLINE [0] unpackFoldr #-}
-
-unpackList :: Buffer -> [Word8]
-unpackList (PS fp off len _) = withPtr fp $ \p -> do
-    let STRICT3(loop)
-        loop _ (-1) acc = return acc
-        loop q n acc = do
-           a <- peekByteOff q n
-           loop q (n-1) (a : acc)
-    loop (p `plusPtr` off) (len-1) []
-
-{-# RULES
-"Buffer unpack-list" [1]  forall p  .
-    unpackFoldr p (:) [] = unpackList p
- #-}
-
-#endif
-
--- ---------------------------------------------------------------------
--- Basic interface
-
--- | /O(1)/ Test whether a Buffer is empty.
-null :: Buffer -> Bool
-null (PS _ _ l _) = assert (l >= 0) $ l <= 0
-{-# INLINE null #-}
-
--- ---------------------------------------------------------------------
--- | /O(1)/ 'length' returns the length of a Buffer as an 'Int'.
-length :: Buffer -> Int
-length (PS _ _ l _) = assert (l >= 0) $ l
-{-# INLINE length #-}
-
-------------------------------------------------------------------------
-
--- | /O(n)/ 'cons' is analogous to (:) for lists, but of different
--- complexity, as it requires a memcpy.
-cons :: Word8 -> Buffer -> Buffer
-cons c (PS x s l e) = unsafeCreate' (l+1) $ \p -> withForeignPtr x $ \f -> do
-        poke p c
-        memcpy (p `plusPtr` 1) (f `plusPtr` s) (fromIntegral l)
-        return $! if c >= 0x80 && c < 0xC0 then e + 1 else e
-{-# INLINE cons #-}
-
--- | /O(n)/ Append a byte to the end of a 'Buffer'
-snoc :: Buffer -> Word8 -> Buffer
-snoc (PS x s l e) c = unsafeCreate' (l+1) $ \p -> withForeignPtr x $ \f -> do
-        memcpy p (f `plusPtr` s) (fromIntegral l)
-        poke (p `plusPtr` l) c
-        return $! if c >= 0x80 then e + 1 else e
-{-# INLINE snoc #-}
-
--- todo fuse
-
--- | /O(1)/ Extract the first element of a Buffer, which must be non-empty.
--- An exception will be thrown in the case of an empty Buffer.
-head :: Buffer -> Word8
-head (PS x s l _)
-    | l <= 0    = errorEmptyList "head"
-    | otherwise = inlinePerformIO $ withForeignPtr x $ \p -> peekByteOff p s
-{-# INLINE head #-}
-
--- | /O(1)/ Extract the elements after the head of a Buffer, which must be non-empty.
--- An exception will be thrown in the case of an empty Buffer.
-tail :: Buffer -> Buffer
-tail (PS p s l e)
-    | l <= 0    = errorEmptyList "tail"
-    | otherwise = PS p (s+1) (l-1) $!
-        if e == 0 || (inlinePerformIO $ withForeignPtr ps $ \p -> peekByteOff p s) < 0x80
-        then e
-        else e - 1       
-{-# INLINE tail #-}
-
--- | /O(1)/ Extract the head and tail of a Buffer, returning Nothing
--- if it is empty.
-uncons :: Buffer -> Maybe (Word8, Buffer)
-uncons (PS x s l e)
-    | l <= 0    = Nothing   
-    | otherwise = let h = inlinePerformIO $ withForeignPtr x
-                                        $ \p -> peekByteOff p s in
-                  Just (h, PS x (s+1) (l-1) $! if h < 0x80 then e else e - 1)
-{-# INLINE uncons #-}
-
--- | /O(1)/ Extract the last element of a Buffer, which must be finite and non-empty.
--- An exception will be thrown in the case of an empty Buffer.
-last :: Buffer -> Word8
-last (PS x s l _)
-    | l <= 0   = errorEmptyList "last"
-    | otherwise = inlinePerformIO $ withForeignPtr x $ \p -> peekByteOff p (s+l-1)
-{-# INLINE last #-}
-
--- | /O(1)/ Return all the elements of a 'Buffer' except the last one.
--- An exception will be thrown in the case of an empty Buffer.
-init :: Buffer -> Buffer
-init ps@(PS p s l e)
-    | null ps   = errorEmptyList "init"
-    | otherwise = PS p s (l-1) $!
-        if e == 0 || (inlinePerformIO $ withForeignPtr ps $ \p -> peekByteOff p (s+l-1)) < 0x80
-        then e
-        else e - 1   
-{-# INLINE init #-}
-
--- | /O(n)/ Append two Buffers
-append :: Buffer -> Buffer -> Buffer
-append xs ys | null xs   = ys
-             | null ys   = xs
-             | otherwise = concat [xs,ys]
-{-# INLINE append #-}
-
--- ---------------------------------------------------------------------
--- Transformations
-
--- EAK: is inlinePerformIO correct here? create' _does_ perform allocation
-
--- | /O(n)/ 'map' @f xs@ is the Buffer obtained by applying @f@ to each
--- element of @xs@. This function is subject to array fusion.
-map :: (Word8 -> Word8) -> Buffer -> Buffer
-map f (PS fp s len) = inlinePerformIO $ withForeignPtr fp $ \a ->
-    create' len $ map_ 0 (a `plusPtr` s) 0
-  where
-    map_ :: Int -> Ptr Word8 -> Ptr Word8 -> Int -> IO Int
-    STRICT4(map_)
-    map_ n p1 p2 acc
-       | n >= len = return acc
-       | otherwise = do
-            x <- peekByteOff p1 n
-            let x' = f x
-            pokeByteOff p2 n x'
-            map_ (n+1) p1 p2 $!
-                if x' < 0x80 
-                then acc 
-                else acc + 1
-            
-{-# INLINE map #-}
-
--- | /O(n)/ 'reverse' @xs@ efficiently returns the elements of @xs@ in reverse order.
-reverse :: Buffer -> Buffer
-reverse (PS x s l e) = unsafeCreate' l $ \p -> withForeignPtr x $ \f -> do
-        c_reverse p (f `plusPtr` s) (fromIntegral l)
-        return e
-
--- | /O(n)/ The 'intersperse' function takes a 'Word8' and a
--- 'Buffer' and \`intersperses\' that byte between the elements of
--- the 'Buffer'.  It is analogous to the intersperse function on
--- Lists.
-intersperse :: Word8 -> Buffer -> Buffer
-intersperse c ps@(PS x s l e)
-    | length ps < 2  = ps
-    | otherwise      = unsafeCreate' (2*l-1) $ \p -> withForeignPtr x $ \f -> do
-        c_intersperse p (f `plusPtr` s) (fromIntegral l) c
-        return $!
-            if c >= 0x80
-            then e + l - 1
-            else e
-
--- | The 'transpose' function transposes the rows and columns of its
--- 'Buffer' argument.
-transpose :: [Buffer] -> [Buffer]
-transpose ps = P.map pack (List.transpose (P.map unpack ps))
-
--- ---------------------------------------------------------------------
--- Reducing 'Buffer's
-
--- | 'foldl', applied to a binary operator, a starting value (typically
--- the left-identity of the operator), and a Buffer, reduces the
--- Buffer using the binary operator, from left to right.
---
--- This function is subject to array fusion.
---
-foldl :: (a -> Word8 -> a) -> a -> Buffer -> a
-foldl f v (PS x s l _) = inlinePerformIO $ withForeignPtr x $ \ptr ->
-        lgo v (ptr `plusPtr` s) (ptr `plusPtr` (s+l))
-    where
-        STRICT3(lgo)
-        lgo z p q | p == q    = return z
-                  | otherwise = do c <- peek p
-                                   lgo (f z c) (p `plusPtr` 1) q
-{-# INLINE foldl #-}
-
--- | 'foldl\'' is like 'foldl', but strict in the accumulator.
--- However, for Buffers, all left folds are strict in the accumulator.
---
-foldl' :: (a -> Word8 -> a) -> a -> Buffer -> a
-foldl' = foldl
-{-# INLINE foldl' #-}
-
--- | 'foldr', applied to a binary operator, a starting value
--- (typically the right-identity of the operator), and a Buffer,
--- reduces the Buffer using the binary operator, from right to left.
-foldr :: (Word8 -> a -> a) -> a -> Buffer -> a
-foldr k v (PS x s l _) = inlinePerformIO $ withForeignPtr x $ \ptr ->
-        go v (ptr `plusPtr` (s+l-1)) (ptr `plusPtr` (s-1))
-    where
-        STRICT3(go)
-        go z p q | p == q    = return z
-                 | otherwise = do c  <- peek p
-                                  go (c `k` z) (p `plusPtr` (-1)) q -- tail recursive
-{-# INLINE foldr #-}
-
--- | 'foldr\'' is like 'foldr', but strict in the accumulator.
-foldr' :: (Word8 -> a -> a) -> a -> Buffer -> a
-foldr' k v (PS x s l _) = inlinePerformIO $ withForeignPtr x $ \ptr ->
-        go v (ptr `plusPtr` (s+l-1)) (ptr `plusPtr` (s-1))
-    where
-        STRICT3(go)
-        go z p q | p == q    = return z
-                 | otherwise = do c  <- peek p
-                                  go (c `k` z) (p `plusPtr` (-1)) q -- tail recursive
-{-# INLINE foldr' #-}
-
--- | 'foldl1' is a variant of 'foldl' that has no starting value
--- argument, and thus must be applied to non-empty 'Buffers'.
--- This function is subject to array fusion. 
--- An exception will be thrown in the case of an empty Buffer.
-foldl1 :: (Word8 -> Word8 -> Word8) -> Buffer -> Word8
-foldl1 f ps
-    | null ps   = errorEmptyList "foldl1"
-    | otherwise = foldl f (unsafeHead ps) (unsafeTail ps)
-{-# INLINE foldl1 #-}
-
--- | 'foldl1\'' is like 'foldl1', but strict in the accumulator.
--- An exception will be thrown in the case of an empty Buffer.
-foldl1' :: (Word8 -> Word8 -> Word8) -> Buffer -> Word8
-foldl1' f ps
-    | null ps   = errorEmptyList "foldl1'"
-    | otherwise = foldl' f (unsafeHead ps) (unsafeTail ps)
-{-# INLINE foldl1' #-}
-
--- | 'foldr1' is a variant of 'foldr' that has no starting value argument,
--- and thus must be applied to non-empty 'Buffer's
--- An exception will be thrown in the case of an empty Buffer.
-foldr1 :: (Word8 -> Word8 -> Word8) -> Buffer -> Word8
-foldr1 f ps
-    | null ps        = errorEmptyList "foldr1"
-    | otherwise      = foldr f (last ps) (init ps)
-{-# INLINE foldr1 #-}
-
--- | 'foldr1\'' is a variant of 'foldr1', but is strict in the
--- accumulator.
-foldr1' :: (Word8 -> Word8 -> Word8) -> Buffer -> Word8
-foldr1' f ps
-    | null ps        = errorEmptyList "foldr1"
-    | otherwise      = foldr' f (last ps) (init ps)
-{-# INLINE foldr1' #-}
-
--- ---------------------------------------------------------------------
--- Special folds
-
--- EAK: TODO: pick up here and keep hacking
-
--- | /O(n)/ Concatenate a list of Buffers.
-concat :: [Buffer] -> Buffer
-concat []     = empty
-concat [ps]   = ps
-concat xs     = unsafeCreate len $ \ptr -> go xs ptr
-  where len = P.sum . P.map length $ xs
-        STRICT2(go)
-        go []            _   = return ()
-        go (PS p s l:ps) ptr = do
-                withForeignPtr p $ \fp -> memcpy ptr (fp `plusPtr` s) (fromIntegral l)
-                go ps (ptr `plusPtr` l)
-
--- | Map a function over a 'Buffer' and concatenate the results
-concatMap :: (Word8 -> Buffer) -> Buffer -> Buffer
-concatMap f = concat . foldr ((:) . f) []
-
--- foldr (append . f) empty
-
--- | /O(n)/ Applied to a predicate and a Buffer, 'any' determines if
--- any element of the 'Buffer' satisfies the predicate.
-any :: (Word8 -> Bool) -> Buffer -> Bool
-any _ (PS _ _ 0) = False
-any f (PS x s l) = inlinePerformIO $ withForeignPtr x $ \ptr ->
-        go (ptr `plusPtr` s) (ptr `plusPtr` (s+l))
-    where
-        STRICT2(go)
-        go p q | p == q    = return False
-               | otherwise = do c <- peek p
-                                if f c then return True
-                                       else go (p `plusPtr` 1) q
-{-# INLINE any #-}
-
--- todo fuse
-
--- | /O(n)/ Applied to a predicate and a 'Buffer', 'all' determines
--- if all elements of the 'Buffer' satisfy the predicate.
-all :: (Word8 -> Bool) -> Buffer -> Bool
-all _ (PS _ _ 0) = True
-all f (PS x s l) = inlinePerformIO $ withForeignPtr x $ \ptr ->
-        go (ptr `plusPtr` s) (ptr `plusPtr` (s+l))
-    where
-        STRICT2(go)
-        go p q | p == q     = return True  -- end of list
-               | otherwise  = do c <- peek p
-                                 if f c
-                                    then go (p `plusPtr` 1) q
-                                    else return False
-{-# INLINE all #-}
-
-------------------------------------------------------------------------
-
--- | /O(n)/ 'maximum' returns the maximum value from a 'Buffer'
--- This function will fuse.
--- An exception will be thrown in the case of an empty Buffer.
-maximum :: Buffer -> Word8
-maximum xs@(PS x s l)
-    | null xs   = errorEmptyList "maximum"
-    | otherwise = inlinePerformIO $ withForeignPtr x $ \p ->
-                      c_maximum (p `plusPtr` s) (fromIntegral l)
-{-# INLINE maximum #-}
-
--- | /O(n)/ 'minimum' returns the minimum value from a 'Buffer'
--- This function will fuse.
--- An exception will be thrown in the case of an empty Buffer.
-minimum :: Buffer -> Word8
-minimum xs@(PS x s l)
-    | null xs   = errorEmptyList "minimum"
-    | otherwise = inlinePerformIO $ withForeignPtr x $ \p ->
-                      c_minimum (p `plusPtr` s) (fromIntegral l)
-{-# INLINE minimum #-}
-
-------------------------------------------------------------------------
-
--- | The 'mapAccumL' function behaves like a combination of 'map' and
--- 'foldl'; it applies a function to each element of a Buffer,
--- passing an accumulating parameter from left to right, and returning a
--- final value of this accumulator together with the new list.
-mapAccumL :: (acc -> Word8 -> (acc, Word8)) -> acc -> Buffer -> (acc, Buffer)
-mapAccumL f acc (PS fp o len) = inlinePerformIO $ withForeignPtr fp $ \a -> do
-    gp   <- mallocBuffer len
-    acc' <- withForeignPtr gp $ \p -> mapAccumL_ acc 0 (a `plusPtr` o) p
-    return $! (acc', PS gp 0 len)
-  where
-    STRICT4(mapAccumL_)
-    mapAccumL_ s n p1 p2
-       | n >= len = return s
-       | otherwise = do
-            x <- peekByteOff p1 n
-            let (s', y) = f s x
-            pokeByteOff p2 n y
-            mapAccumL_ s' (n+1) p1 p2
-{-# INLINE mapAccumL #-}
-
--- | The 'mapAccumR' function behaves like a combination of 'map' and
--- 'foldr'; it applies a function to each element of a Buffer,
--- passing an accumulating parameter from right to left, and returning a
--- final value of this accumulator together with the new Buffer.
-mapAccumR :: (acc -> Word8 -> (acc, Word8)) -> acc -> Buffer -> (acc, Buffer)
-mapAccumR f acc (PS fp o len) = inlinePerformIO $ withForeignPtr fp $ \a -> do
-    gp   <- mallocBuffer len
-    acc' <- withForeignPtr gp $ \p -> mapAccumR_ acc (len-1) (a `plusPtr` o) p
-    return $! (acc', PS gp 0 len)
-  where
-    STRICT4(mapAccumR_)
-    mapAccumR_ s n p q
-       | n <  0    = return s
-       | otherwise = do
-            x  <- peekByteOff p n
-            let (s', y) = f s x
-            pokeByteOff q n y
-            mapAccumR_ s' (n-1) p q
-{-# INLINE mapAccumR #-}
-
--- ---------------------------------------------------------------------
--- Building Buffers
-
--- | 'scanl' is similar to 'foldl', but returns a list of successive
--- reduced values from the left. This function will fuse.
---
--- > scanl f z [x1, x2, ...] == [z, z `f` x1, (z `f` x1) `f` x2, ...]
---
--- Note that
---
--- > last (scanl f z xs) == foldl f z xs.
---
-scanl :: (Word8 -> Word8 -> Word8) -> Word8 -> Buffer -> Buffer
-
-scanl f v (PS fp s len) = inlinePerformIO $ withForeignPtr fp $ \a ->
-    create (len+1) $ \q -> do
-        poke q v
-        scanl_ v 0 (a `plusPtr` s) (q `plusPtr` 1)
-  where
-    STRICT4(scanl_)
-    scanl_ z n p q
-        | n >= len  = return ()
-        | otherwise = do
-            x <- peekByteOff p n
-            let z' = f z x
-            pokeByteOff q n z'
-            scanl_ z' (n+1) p q
-{-# INLINE scanl #-}
-
-    -- n.b. haskell's List scan returns a list one bigger than the
-    -- input, so we need to snoc here to get some extra space, however,
-    -- it breaks map/up fusion (i.e. scanl . map no longer fuses)
-
--- | 'scanl1' is a variant of 'scanl' that has no starting value argument.
--- This function will fuse.
---
--- > scanl1 f [x1, x2, ...] == [x1, x1 `f` x2, ...]
-scanl1 :: (Word8 -> Word8 -> Word8) -> Buffer -> Buffer
-scanl1 f ps
-    | null ps   = empty
-    | otherwise = scanl f (unsafeHead ps) (unsafeTail ps)
-{-# INLINE scanl1 #-}
-
--- | scanr is the right-to-left dual of scanl.
-scanr :: (Word8 -> Word8 -> Word8) -> Word8 -> Buffer -> Buffer
-scanr f v (PS fp s len) = inlinePerformIO $ withForeignPtr fp $ \a ->
-    create (len+1) $ \q -> do
-        poke (q `plusPtr` len) v
-        scanr_ v (len-1) (a `plusPtr` s) q
-  where
-    STRICT4(scanr_)
-    scanr_ z n p q
-        | n <  0    = return ()
-        | otherwise = do
-            x <- peekByteOff p n
-            let z' = f x z
-            pokeByteOff q n z'
-            scanr_ z' (n-1) p q
-{-# INLINE scanr #-}
-
--- | 'scanr1' is a variant of 'scanr' that has no starting value argument.
-scanr1 :: (Word8 -> Word8 -> Word8) -> Buffer -> Buffer
-scanr1 f ps
-    | null ps   = empty
-    | otherwise = scanr f (last ps) (init ps) -- todo, unsafe versions
-{-# INLINE scanr1 #-}
-
--- ---------------------------------------------------------------------
--- Unfolds and replicates
-
--- | /O(n)/ 'replicate' @n x@ is a Buffer of length @n@ with @x@
--- the value of every element. The following holds:
---
--- > replicate w c = unfoldr w (\u -> Just (u,u)) c
---
--- This implemenation uses @memset(3)@
-replicate :: Int -> Word8 -> Buffer
-replicate w c
-    | w <= 0    = empty
-    | otherwise = unsafeCreate w $ \ptr ->
-                      memset ptr c (fromIntegral w) >> return ()
-
--- | /O(n)/, where /n/ is the length of the result.  The 'unfoldr' 
--- function is analogous to the List \'unfoldr\'.  'unfoldr' builds a 
--- Buffer from a seed value.  The function takes the element and 
--- returns 'Nothing' if it is done producing the Buffer or returns 
--- 'Just' @(a,b)@, in which case, @a@ is the next byte in the string, 
--- and @b@ is the seed value for further production.
---
--- Examples:
---
--- >    unfoldr (\x -> if x <= 5 then Just (x, x + 1) else Nothing) 0
--- > == pack [0, 1, 2, 3, 4, 5]
---
-unfoldr :: (a -> Maybe (Word8, a)) -> a -> Buffer
-unfoldr f = concat . unfoldChunk 32 64
-  where unfoldChunk n n' x =
-          case unfoldrN n f x of
-            (s, Nothing) -> s : []
-            (s, Just x') -> s : unfoldChunk n' (n+n') x'
-{-# INLINE unfoldr #-}
-
--- | /O(n)/ Like 'unfoldr', 'unfoldrN' builds a Buffer from a seed
--- value.  However, the length of the result is limited by the first
--- argument to 'unfoldrN'.  This function is more efficient than 'unfoldr'
--- when the maximum length of the result is known.
---
--- The following equation relates 'unfoldrN' and 'unfoldr':
---
--- > snd (unfoldrN n f s) == take n (unfoldr f s)
---
-unfoldrN :: Int -> (a -> Maybe (Word8, a)) -> a -> (Buffer, Maybe a)
-unfoldrN i f x0
-    | i < 0     = (empty, Just x0)
-    | otherwise = unsafePerformIO $ createAndTrim' i $ \p -> go p x0 0
-  where STRICT3(go)
-        go p x n =
-          case f x of
-            Nothing      -> return (0, n, Nothing)
-            Just (w,x')
-             | n == i    -> return (0, n, Just x)
-             | otherwise -> do poke p w
-                               go (p `plusPtr` 1) x' (n+1)
-{-# INLINE unfoldrN #-}
-
--- ---------------------------------------------------------------------
--- Substrings
-
--- | /O(1)/ 'take' @n@, applied to a Buffer @xs@, returns the prefix
--- of @xs@ of length @n@, or @xs@ itself if @n > 'length' xs@.
-take :: Int -> Buffer -> Buffer
-take n ps@(PS x s l)
-    | n <= 0    = empty
-    | n >= l    = ps
-    | otherwise = PS x s n
-{-# INLINE take #-}
-
--- | /O(1)/ 'drop' @n xs@ returns the suffix of @xs@ after the first @n@
--- elements, or @[]@ if @n > 'length' xs@.
-drop  :: Int -> Buffer -> Buffer
-drop n ps@(PS x s l)
-    | n <= 0    = ps
-    | n >= l    = empty
-    | otherwise = PS x (s+n) (l-n)
-{-# INLINE drop #-}
-
--- | /O(1)/ 'splitAt' @n xs@ is equivalent to @('take' n xs, 'drop' n xs)@.
-splitAt :: Int -> Buffer -> (Buffer, Buffer)
-splitAt n ps@(PS x s l)
-    | n <= 0    = (empty, ps)
-    | n >= l    = (ps, empty)
-    | otherwise = (PS x s n, PS x (s+n) (l-n))
-{-# INLINE splitAt #-}
-
--- | 'takeWhile', applied to a predicate @p@ and a Buffer @xs@,
--- returns the longest prefix (possibly empty) of @xs@ of elements that
--- satisfy @p@.
-takeWhile :: (Word8 -> Bool) -> Buffer -> Buffer
-takeWhile f ps = unsafeTake (findIndexOrEnd (not . f) ps) ps
-{-# INLINE takeWhile #-}
-
--- | 'dropWhile' @p xs@ returns the suffix remaining after 'takeWhile' @p xs@.
-dropWhile :: (Word8 -> Bool) -> Buffer -> Buffer
-dropWhile f ps = unsafeDrop (findIndexOrEnd (not . f) ps) ps
-{-# INLINE dropWhile #-}
-
--- instead of findIndexOrEnd, we could use memchr here.
-
--- | 'break' @p@ is equivalent to @'span' ('not' . p)@.
---
--- Under GHC, a rewrite rule will transform break (==) into a
--- call to the specialised breakByte:
---
--- > break ((==) x) = breakByte x
--- > break (==x) = breakByte x
---
-break :: (Word8 -> Bool) -> Buffer -> (Buffer, Buffer)
-break p ps = case findIndexOrEnd p ps of n -> (unsafeTake n ps, unsafeDrop n ps)
-#if __GLASGOW_HASKELL__ 
-{-# INLINE [1] break #-}
-#endif
-
-#if __GLASGOW_HASKELL__ >= 606
--- This RULE LHS is not allowed by ghc-6.4
-{-# RULES
-"Buffer specialise break (x==)" forall x.
-    break ((==) x) = breakByte x
-"Buffer specialise break (==x)" forall x.
-    break (==x) = breakByte x
-  #-}
-#endif
-
--- INTERNAL:
-
--- | 'breakByte' breaks its Buffer argument at the first occurence
--- of the specified byte. It is more efficient than 'break' as it is
--- implemented with @memchr(3)@. I.e.
--- 
--- > break (=='c') "abcd" == breakByte 'c' "abcd"
---
-breakByte :: Word8 -> Buffer -> (Buffer, Buffer)
-breakByte c p = case elemIndex c p of
-    Nothing -> (p,empty)
-    Just n  -> (unsafeTake n p, unsafeDrop n p)
-{-# INLINE breakByte #-}
-
--- | 'breakEnd' behaves like 'break' but from the end of the 'Buffer'
--- 
--- breakEnd p == spanEnd (not.p)
-breakEnd :: (Word8 -> Bool) -> Buffer -> (Buffer, Buffer)
-breakEnd  p ps = splitAt (findFromEndUntil p ps) ps
-
--- | 'span' @p xs@ breaks the Buffer into two segments. It is
--- equivalent to @('takeWhile' p xs, 'dropWhile' p xs)@
-span :: (Word8 -> Bool) -> Buffer -> (Buffer, Buffer)
-span p ps = break (not . p) ps
-#if __GLASGOW_HASKELL__
-{-# INLINE [1] span #-}
-#endif
-
--- | 'spanByte' breaks its Buffer argument at the first
--- occurence of a byte other than its argument. It is more efficient
--- than 'span (==)'
---
--- > span  (=='c') "abcd" == spanByte 'c' "abcd"
---
-spanByte :: Word8 -> Buffer -> (Buffer, Buffer)
-spanByte c ps@(PS x s l) = inlinePerformIO $ withForeignPtr x $ \p ->
-    go (p `plusPtr` s) 0
-  where
-    STRICT2(go)
-    go p i | i >= l    = return (ps, empty)
-           | otherwise = do c' <- peekByteOff p i
-                            if c /= c'
-                                then return (unsafeTake i ps, unsafeDrop i ps)
-                                else go p (i+1)
-{-# INLINE spanByte #-}
-
-#if __GLASGOW_HASKELL__ >= 606
--- This RULE LHS is not allowed by ghc-6.4
-{-# RULES
-"Buffer specialise span (x==)" forall x.
-    span ((==) x) = spanByte x
-"Buffer specialise span (==x)" forall x.
-    span (==x) = spanByte x
-  #-}
-#endif
-
--- | 'spanEnd' behaves like 'span' but from the end of the 'Buffer'.
--- We have
---
--- > spanEnd (not.isSpace) "x y z" == ("x y ","z")
---
--- and
---
--- > spanEnd (not . isSpace) ps
--- >    == 
--- > let (x,y) = span (not.isSpace) (reverse ps) in (reverse y, reverse x) 
---
-spanEnd :: (Word8 -> Bool) -> Buffer -> (Buffer, Buffer)
-spanEnd  p ps = splitAt (findFromEndUntil (not.p) ps) ps
-
--- | /O(n)/ Splits a 'Buffer' into components delimited by
--- separators, where the predicate returns True for a separator element.
--- The resulting components do not contain the separators.  Two adjacent
--- separators result in an empty component in the output.  eg.
---
--- > splitWith (=='a') "aabbaca" == ["","","bb","c",""]
--- > splitWith (=='a') []        == []
---
-splitWith :: (Word8 -> Bool) -> Buffer -> [Buffer]
-
-#if defined(__GLASGOW_HASKELL__)
-splitWith _pred (PS _  _   0) = []
-splitWith pred_ (PS fp off len) = splitWith0 pred# off len fp
-  where pred# c# = pred_ (W8# c#)
-
-        STRICT4(splitWith0)
-        splitWith0 pred' off' len' fp' = withPtr fp $ \p ->
-            splitLoop pred' p 0 off' len' fp'
-
-        splitLoop :: (Word# -> Bool)
-                  -> Ptr Word8
-                  -> Int -> Int -> Int
-                  -> ForeignPtr Word8
-                  -> IO [Buffer]
-
-        splitLoop pred' p idx' off' len' fp'
-            | idx' >= len'  = return [PS fp' off' idx']
-            | otherwise = do
-                w <- peekElemOff p (off'+idx')
-                if pred' (case w of W8# w# -> w#)
-                   then return (PS fp' off' idx' :
-                              splitWith0 pred' (off'+idx'+1) (len'-idx'-1) fp')
-                   else splitLoop pred' p (idx'+1) off' len' fp'
-{-# INLINE splitWith #-}
-
-#else
-splitWith _ (PS _ _ 0) = []
-splitWith p ps = loop p ps
-    where
-        STRICT2(loop)
-        loop q qs = if null rest then [chunk]
-                                 else chunk : loop q (unsafeTail rest)
-            where (chunk,rest) = break q qs
-#endif
-
--- | /O(n)/ Break a 'Buffer' into pieces separated by the byte
--- argument, consuming the delimiter. I.e.
---
--- > split '\n' "a\nb\nd\ne" == ["a","b","d","e"]
--- > split 'a'  "aXaXaXa"    == ["","X","X","X",""]
--- > split 'x'  "x"          == ["",""]
--- 
--- and
---
--- > intercalate [c] . split c == id
--- > split == splitWith . (==)
--- 
--- As for all splitting functions in this library, this function does
--- not copy the substrings, it just constructs new 'Buffers' that
--- are slices of the original.
---
-split :: Word8 -> Buffer -> [Buffer]
-split _ (PS _ _ 0) = []
-split w (PS x s l) = loop 0
-    where
-        STRICT1(loop)
-        loop n =
-            let q = inlinePerformIO $ withForeignPtr x $ \p ->
-                      memchr (p `plusPtr` (s+n))
-                             w (fromIntegral (l-n))
-            in if q == nullPtr
-                then [PS x (s+n) (l-n)]
-                else let i = inlinePerformIO $ withForeignPtr x $ \p ->
-                               return (q `minusPtr` (p `plusPtr` s))
-                      in PS x (s+n) (i-n) : loop (i+1)
-
-{-# INLINE split #-}
-
-{-
--- slower. but stays inside Haskell.
-split _ (PS _  _   0) = []
-split (W8# w#) (PS fp off len) = splitWith' off len fp
-    where
-        splitWith' off' len' fp' = withPtr fp $ \p ->
-            splitLoop p 0 off' len' fp'
-
-        splitLoop :: Ptr Word8
-                  -> Int -> Int -> Int
-                  -> ForeignPtr Word8
-                  -> IO [Buffer]
-
-        STRICT5(splitLoop)
-        splitLoop p idx' off' len' fp'
-            | idx' >= len'  = return [PS fp' off' idx']
-            | otherwise = do
-                (W8# x#) <- peekElemOff p (off'+idx')
-                if word2Int# w# ==# word2Int# x#
-                   then return (PS fp' off' idx' :
-                              splitWith' (off'+idx'+1) (len'-idx'-1) fp')
-                   else splitLoop p (idx'+1) off' len' fp'
--}
-
-{-
--- | Like 'splitWith', except that sequences of adjacent separators are
--- treated as a single separator. eg.
--- 
--- > tokens (=='a') "aabbaca" == ["bb","c"]
---
-tokens :: (Word8 -> Bool) -> Buffer -> [Buffer]
-tokens f = P.filter (not.null) . splitWith f
-{-# INLINE tokens #-}
--}
-
--- | The 'group' function takes a Buffer and returns a list of
--- Buffers such that the concatenation of the result is equal to the
--- argument.  Moreover, each sublist in the result contains only equal
--- elements.  For example,
---
--- > group "Mississippi" = ["M","i","ss","i","ss","i","pp","i"]
---
--- It is a special case of 'groupBy', which allows the programmer to
--- supply their own equality test. It is about 40% faster than 
--- /groupBy (==)/
-group :: Buffer -> [Buffer]
-group xs
-    | null xs   = []
-    | otherwise = ys : group zs
-    where
-        (ys, zs) = spanByte (unsafeHead xs) xs
-
--- | The 'groupBy' function is the non-overloaded version of 'group'.
-groupBy :: (Word8 -> Word8 -> Bool) -> Buffer -> [Buffer]
-groupBy k xs
-    | null xs   = []
-    | otherwise = unsafeTake n xs : groupBy k (unsafeDrop n xs)
-    where
-        n = 1 + findIndexOrEnd (not . k (unsafeHead xs)) (unsafeTail xs)
-
--- | /O(n)/ The 'intercalate' function takes a 'Buffer' and a list of
--- 'Buffer's and concatenates the list after interspersing the first
--- argument between each element of the list.
-intercalate :: Buffer -> [Buffer] -> Buffer
-intercalate s = concat . (List.intersperse s)
-{-# INLINE [1] intercalate #-}
-
-{-# RULES
-"Buffer specialise intercalate c -> intercalateByte" forall c s1 s2 .
-    intercalate (singleton c) (s1 : s2 : []) = intercalateWithByte c s1 s2
-  #-}
-
--- | /O(n)/ intercalateWithByte. An efficient way to join to two Buffers
--- with a char. Around 4 times faster than the generalised join.
---
-intercalateWithByte :: Word8 -> Buffer -> Buffer -> Buffer
-intercalateWithByte c f@(PS ffp s l) g@(PS fgp t m) = unsafeCreate len $ \ptr ->
-    withForeignPtr ffp $ \fp ->
-    withForeignPtr fgp $ \gp -> do
-        memcpy ptr (fp `plusPtr` s) (fromIntegral l)
-        poke (ptr `plusPtr` l) c
-        memcpy (ptr `plusPtr` (l + 1)) (gp `plusPtr` t) (fromIntegral m)
-    where
-      len = length f + length g + 1
-{-# INLINE intercalateWithByte #-}
-
--- ---------------------------------------------------------------------
--- Indexing Buffers
-
--- | /O(1)/ 'Buffer' index (subscript) operator, starting from 0.
-index :: Buffer -> Int -> Word8
-index ps n
-    | n < 0          = moduleError "index" ("negative index: " ++ show n)
-    | n >= length ps = moduleError "index" ("index too large: " ++ show n
-                                         ++ ", length = " ++ show (length ps))
-    | otherwise      = ps `unsafeIndex` n
-{-# INLINE index #-}
-
--- | /O(n)/ The 'elemIndex' function returns the index of the first
--- element in the given 'Buffer' which is equal to the query
--- element, or 'Nothing' if there is no such element. 
--- This implementation uses memchr(3).
-elemIndex :: Word8 -> Buffer -> Maybe Int
-elemIndex c (PS x s l) = inlinePerformIO $ withForeignPtr x $ \p -> do
-    let p' = p `plusPtr` s
-    q <- memchr p' c (fromIntegral l)
-    return $! if q == nullPtr then Nothing else Just $! q `minusPtr` p'
-{-# INLINE elemIndex #-}
-
--- | /O(n)/ The 'elemIndexEnd' function returns the last index of the
--- element in the given 'Buffer' which is equal to the query
--- element, or 'Nothing' if there is no such element. The following
--- holds:
---
--- > elemIndexEnd c xs == 
--- > (-) (length xs - 1) `fmap` elemIndex c (reverse xs)
---
-elemIndexEnd :: Word8 -> Buffer -> Maybe Int
-elemIndexEnd ch (PS x s l) = inlinePerformIO $ withForeignPtr x $ \p ->
-    go (p `plusPtr` s) (l-1)
-  where
-    STRICT2(go)
-    go p i | i < 0     = return Nothing
-           | otherwise = do ch' <- peekByteOff p i
-                            if ch == ch'
-                                then return $ Just i
-                                else go p (i-1)
-{-# INLINE elemIndexEnd #-}
-
--- | /O(n)/ The 'elemIndices' function extends 'elemIndex', by returning
--- the indices of all elements equal to the query element, in ascending order.
--- This implementation uses memchr(3).
-elemIndices :: Word8 -> Buffer -> [Int]
-elemIndices w (PS x s l) = loop 0
-    where
-        STRICT1(loop)
-        loop n = let q = inlinePerformIO $ withForeignPtr x $ \p ->
-                           memchr (p `plusPtr` (n+s))
-                                                w (fromIntegral (l - n))
-                 in if q == nullPtr
-                        then []
-                        else let i = inlinePerformIO $ withForeignPtr x $ \p ->
-                                       return (q `minusPtr` (p `plusPtr` s))
-                             in i : loop (i+1)
-{-# INLINE elemIndices #-}
-
-{-
--- much slower
-elemIndices :: Word8 -> Buffer -> [Int]
-elemIndices c ps = loop 0 ps
-   where STRICT2(loop)
-         loop _ ps' | null ps'            = []
-         loop n ps' | c == unsafeHead ps' = n : loop (n+1) (unsafeTail ps')
-                    | otherwise           = loop (n+1) (unsafeTail ps')
--}
-
--- | count returns the number of times its argument appears in the Buffer
---
--- > count = length . elemIndices
---
--- But more efficiently than using length on the intermediate list.
-count :: Word8 -> Buffer -> Int
-count w (PS x s m) = inlinePerformIO $ withForeignPtr x $ \p ->
-    fmap fromIntegral $ c_count (p `plusPtr` s) (fromIntegral m) w
-{-# INLINE count #-}
-
-{-
---
--- around 30% slower
---
-count w (PS x s m) = inlinePerformIO $ withForeignPtr x $ \p ->
-     go (p `plusPtr` s) (fromIntegral m) 0
-    where
-        go :: Ptr Word8 -> CSize -> Int -> IO Int
-        STRICT3(go)
-        go p l i = do
-            q <- memchr p w l
-            if q == nullPtr
-                then return i
-                else do let k = fromIntegral $ q `minusPtr` p
-                        go (q `plusPtr` 1) (l-k-1) (i+1)
--}
-
--- | The 'findIndex' function takes a predicate and a 'Buffer' and
--- returns the index of the first element in the Buffer
--- satisfying the predicate.
-findIndex :: (Word8 -> Bool) -> Buffer -> Maybe Int
-findIndex k (PS x s l) = inlinePerformIO $ withForeignPtr x $ \f -> go (f `plusPtr` s) 0
-  where
-    STRICT2(go)
-    go ptr n | n >= l    = return Nothing
-             | otherwise = do w <- peek ptr
-                              if k w
-                                then return (Just n)
-                                else go (ptr `plusPtr` 1) (n+1)
-{-# INLINE findIndex #-}
-
--- | The 'findIndices' function extends 'findIndex', by returning the
--- indices of all elements satisfying the predicate, in ascending order.
-findIndices :: (Word8 -> Bool) -> Buffer -> [Int]
-findIndices p ps = loop 0 ps
-   where
-     STRICT2(loop)
-     loop n qs | null qs           = []
-               | p (unsafeHead qs) = n : loop (n+1) (unsafeTail qs)
-               | otherwise         =     loop (n+1) (unsafeTail qs)
-
--- ---------------------------------------------------------------------
--- Searching Buffers
-
--- | /O(n)/ 'elem' is the 'Buffer' membership predicate.
-elem :: Word8 -> Buffer -> Bool
-elem c ps = case elemIndex c ps of Nothing -> False ; _ -> True
-{-# INLINE elem #-}
-
--- | /O(n)/ 'notElem' is the inverse of 'elem'
-notElem :: Word8 -> Buffer -> Bool
-notElem c ps = not (elem c ps)
-{-# INLINE notElem #-}
-
--- | /O(n)/ 'filter', applied to a predicate and a Buffer,
--- returns a Buffer containing those characters that satisfy the
--- predicate. This function is subject to array fusion.
-filter :: (Word8 -> Bool) -> Buffer -> Buffer
-filter k ps@(PS x s l)
-    | null ps   = ps
-    | otherwise = unsafePerformIO $ createAndTrim l $ \p -> withForeignPtr x $ \f -> do
-        t <- go (f `plusPtr` s) p (f `plusPtr` (s + l))
-        return $! t `minusPtr` p -- actual length
-    where
-        STRICT3(go)
-        go f t end | f == end  = return t
-                   | otherwise = do
-                        w <- peek f
-                        if k w
-                            then poke t w >> go (f `plusPtr` 1) (t `plusPtr` 1) end
-                            else             go (f `plusPtr` 1) t               end
-{-# INLINE filter #-}
-
-{-
---
--- | /O(n)/ A first order equivalent of /filter . (==)/, for the common
--- case of filtering a single byte. It is more efficient to use
--- /filterByte/ in this case.
---
--- > filterByte == filter . (==)
---
--- filterByte is around 10x faster, and uses much less space, than its
--- filter equivalent
---
-filterByte :: Word8 -> Buffer -> Buffer
-filterByte w ps = replicate (count w ps) w
-{-# INLINE filterByte #-}
-
-{-# RULES
-"Buffer specialise filter (== x)" forall x.
-    filter ((==) x) = filterByte x
-"Buffer specialise filter (== x)" forall x.
-    filter (== x) = filterByte x
-  #-}
--}
-
--- | /O(n)/ The 'find' function takes a predicate and a Buffer,
--- and returns the first element in matching the predicate, or 'Nothing'
--- if there is no such element.
---
--- > find f p = case findIndex f p of Just n -> Just (p ! n) ; _ -> Nothing
---
-find :: (Word8 -> Bool) -> Buffer -> Maybe Word8
-find f p = case findIndex f p of
-                    Just n -> Just (p `unsafeIndex` n)
-                    _      -> Nothing
-{-# INLINE find #-}
-
-{-
---
--- fuseable, but we don't want to walk the whole array.
--- 
-find k = foldl findEFL Nothing
-    where findEFL a@(Just _) _ = a
-          findEFL _          c | k c       = Just c
-                               | otherwise = Nothing
--}
-
--- | /O(n)/ The 'partition' function takes a predicate a Buffer and returns
--- the pair of Buffers with elements which do and do not satisfy the
--- predicate, respectively; i.e.,
---
--- > partition p bs == (filter p xs, filter (not . p) xs)
---
-partition :: (Word8 -> Bool) -> Buffer -> (Buffer, Buffer)
-partition p bs = (filter p bs, filter (not . p) bs)
---TODO: use a better implementation
-
--- ---------------------------------------------------------------------
--- Searching for substrings
-
--- | /O(n)/ The 'isPrefixOf' function takes two Buffers and returns 'True'
--- iff the first is a prefix of the second.
-isPrefixOf :: Buffer -> Buffer -> Bool
-isPrefixOf (PS x1 s1 l1) (PS x2 s2 l2)
-    | l1 == 0   = True
-    | l2 < l1   = False
-    | otherwise = inlinePerformIO $ withForeignPtr x1 $ \p1 ->
-        withForeignPtr x2 $ \p2 -> do
-            i <- memcmp (p1 `plusPtr` s1) (p2 `plusPtr` s2) (fromIntegral l1)
-            return $! i == 0
-
--- | /O(n)/ The 'isSuffixOf' function takes two Buffers and returns 'True'
--- iff the first is a suffix of the second.
--- 
--- The following holds:
---
--- > isSuffixOf x y == reverse x `isPrefixOf` reverse y
---
--- However, the real implemenation uses memcmp to compare the end of the
--- string only, with no reverse required..
-isSuffixOf :: Buffer -> Buffer -> Bool
-isSuffixOf (PS x1 s1 l1) (PS x2 s2 l2)
-    | l1 == 0   = True
-    | l2 < l1   = False
-    | otherwise = inlinePerformIO $ withForeignPtr x1 $ \p1 ->
-        withForeignPtr x2 $ \p2 -> do
-            i <- memcmp (p1 `plusPtr` s1) (p2 `plusPtr` s2 `plusPtr` (l2 - l1)) (fromIntegral l1)
-            return $! i == 0
-
--- | Check whether one string is a substring of another. @isInfixOf
--- p s@ is equivalent to @not (null (findSubstrings p s))@.
-isInfixOf :: Buffer -> Buffer -> Bool
-isInfixOf p s = isJust (findSubstring p s)
-
--- | Break a string on a substring, returning a pair of the part of the
--- string prior to the match, and the rest of the string.
---
--- The following relationships hold:
---
--- > break (== c) l == breakSubstring (singleton c) l
---
--- and:
---
--- > findSubstring s l ==
--- >    if null s then Just 0
--- >              else case breakSubstring s l of
--- >                       (x,y) | null y    -> Nothing
--- >                             | otherwise -> Just (length x)
---
--- For example, to tokenise a string, dropping delimiters:
---
--- > tokenise x y = h : if null t then [] else tokenise x (drop (length x) t)
--- >     where (h,t) = breakSubstring x y
---
--- To skip to the first occurence of a string:
--- 
--- > snd (breakSubstring x y) 
---
--- To take the parts of a string before a delimiter:
---
--- > fst (breakSubstring x y) 
---
-breakSubstring :: Buffer -- ^ String to search for
-               -> Buffer -- ^ String to search in
-               -> (Buffer,Buffer) -- ^ Head and tail of string broken at substring
-
-breakSubstring pat src = search 0 src
-  where
-    STRICT2(search)
-    search n s
-        | null s             = (src,empty)      -- not found
-        | pat `isPrefixOf` s = (take n src,s)
-        | otherwise          = search (n+1) (unsafeTail s)
-
--- | Get the first index of a substring in another string,
---   or 'Nothing' if the string is not found.
---   @findSubstring p s@ is equivalent to @listToMaybe (findSubstrings p s)@.
-findSubstring :: Buffer -- ^ String to search for.
-              -> Buffer -- ^ String to seach in.
-              -> Maybe Int
-findSubstring f i = listToMaybe (findSubstrings f i)
-
-{-# DEPRECATED findSubstring "findSubstring is deprecated in favour of breakSubstring." #-}
-
-{-
-findSubstring pat str = search 0 str
-    where
-        STRICT2(search)
-        search n s
-            = let x = pat `isPrefixOf` s
-              in
-                if null s
-                    then if x then Just n else Nothing
-                    else if x then Just n
-                              else     search (n+1) (unsafeTail s)
--}
-
--- | Find the indexes of all (possibly overlapping) occurances of a
--- substring in a string.
---
-findSubstrings :: Buffer -- ^ String to search for.
-               -> Buffer -- ^ String to seach in.
-               -> [Int]
-findSubstrings pat str
-    | null pat         = [0 .. length str]
-    | otherwise        = search 0 str
-  where
-    STRICT2(search)
-    search n s
-        | null s             = []
-        | pat `isPrefixOf` s = n : search (n+1) (unsafeTail s)
-        | otherwise          =     search (n+1) (unsafeTail s)
-
-{-# DEPRECATED findSubstrings "findSubstrings is deprecated in favour of breakSubstring." #-}
-
-{-
-{- This function uses the Knuth-Morris-Pratt string matching algorithm.  -}
-
-findSubstrings pat@(PS _ _ m) str@(PS _ _ n) = search 0 0
-  where
-      patc x = pat `unsafeIndex` x
-      strc x = str `unsafeIndex` x
-
-      -- maybe we should make kmpNext a UArray before using it in search?
-      kmpNext = listArray (0,m) (-1:kmpNextL pat (-1))
-      kmpNextL p _ | null p = []
-      kmpNextL p j = let j' = next (unsafeHead p) j + 1
-                         ps = unsafeTail p
-                         x = if not (null ps) && unsafeHead ps == patc j'
-                                then kmpNext Array.! j' else j'
-                        in x:kmpNextL ps j'
-      search i j = match ++ rest -- i: position in string, j: position in pattern
-        where match = if j == m then [(i - j)] else []
-              rest = if i == n then [] else search (i+1) (next (strc i) j + 1)
-      next c j | j >= 0 && (j == m || c /= patc j) = next c (kmpNext Array.! j)
-               | otherwise = j
--}
-
--- ---------------------------------------------------------------------
--- Zipping
-
--- | /O(n)/ 'zip' takes two Buffers and returns a list of
--- corresponding pairs of bytes. If one input Buffer is short,
--- excess elements of the longer Buffer are discarded. This is
--- equivalent to a pair of 'unpack' operations.
-zip :: Buffer -> Buffer -> [(Word8,Word8)]
-zip ps qs
-    | null ps || null qs = []
-    | otherwise = (unsafeHead ps, unsafeHead qs) : zip (unsafeTail ps) (unsafeTail qs)
-
--- | 'zipWith' generalises 'zip' by zipping with the function given as
--- the first argument, instead of a tupling function.  For example,
--- @'zipWith' (+)@ is applied to two Buffers to produce the list of
--- corresponding sums. 
-zipWith :: (Word8 -> Word8 -> a) -> Buffer -> Buffer -> [a]
-zipWith f ps qs
-    | null ps || null qs = []
-    | otherwise = f (unsafeHead ps) (unsafeHead qs) : zipWith f (unsafeTail ps) (unsafeTail qs)
-
---
--- | A specialised version of zipWith for the common case of a
--- simultaneous map over two Buffers, to build a 3rd. Rewrite rules
--- are used to automatically covert zipWith into zipWith' when a pack is
--- performed on the result of zipWith.
---
-zipWith' :: (Word8 -> Word8 -> Word8) -> Buffer -> Buffer -> Buffer
-zipWith' f (PS fp s l) (PS fq t m) = inlinePerformIO $
-    withForeignPtr fp $ \a ->
-    withForeignPtr fq $ \b ->
-    create len $ zipWith_ 0 (a `plusPtr` s) (b `plusPtr` t)
-  where
-    zipWith_ :: Int -> Ptr Word8 -> Ptr Word8 -> Ptr Word8 -> IO ()
-    STRICT4(zipWith_)
-    zipWith_ n p1 p2 r
-       | n >= len = return ()
-       | otherwise = do
-            x <- peekByteOff p1 n
-            y <- peekByteOff p2 n
-            pokeByteOff r n (f x y)
-            zipWith_ (n+1) p1 p2 r
-
-    len = min l m
-{-# INLINE zipWith' #-}
-
-{-# RULES
-"Buffer specialise zipWith" forall (f :: Word8 -> Word8 -> Word8) p q .
-    zipWith f p q = unpack (zipWith' f p q)
-  #-}
-
--- | /O(n)/ 'unzip' transforms a list of pairs of bytes into a pair of
--- Buffers. Note that this performs two 'pack' operations.
-unzip :: [(Word8,Word8)] -> (Buffer,Buffer)
-unzip ls = (pack (P.map fst ls), pack (P.map snd ls))
-{-# INLINE unzip #-}
-
--- ---------------------------------------------------------------------
--- Special lists
-
--- | /O(n)/ Return all initial segments of the given 'Buffer', shortest first.
-inits :: Buffer -> [Buffer]
-inits (PS x s l) = [PS x s n | n <- [0..l]]
-
--- | /O(n)/ Return all final segments of the given 'Buffer', longest first.
-tails :: Buffer -> [Buffer]
-tails p | null p    = [empty]
-        | otherwise = p : tails (unsafeTail p)
-
--- less efficent spacewise: tails (PS x s l) = [PS x (s+n) (l-n) | n <- [0..l]]
-
--- ---------------------------------------------------------------------
--- ** Ordered 'Buffer's
-
--- | /O(n)/ Sort a Buffer efficiently, using counting sort.
-sort :: Buffer -> Buffer
-sort (PS input s l) = unsafeCreate l $ \p -> allocaArray 256 $ \arr -> do
-
-    _ <- memset (castPtr arr) 0 (256 * fromIntegral (sizeOf (undefined :: CSize)))
-    withForeignPtr input (\x -> countOccurrences arr (x `plusPtr` s) l)
-
-    let STRICT2(go)
-        go 256 _   = return ()
-        go i   ptr = do n <- peekElemOff arr i
-                        when (n /= 0) $ memset ptr (fromIntegral i) n >> return ()
-                        go (i + 1) (ptr `plusPtr` (fromIntegral n))
-    go 0 p
-  where
-    -- | Count the number of occurrences of each byte.
-    -- Used by 'sort'
-    --
-    countOccurrences :: Ptr CSize -> Ptr Word8 -> Int -> IO ()
-    STRICT3(countOccurrences)
-    countOccurrences counts str len = go 0
-     where
-        STRICT1(go)
-        go i | i == len    = return ()
-             | otherwise = do k <- fromIntegral `fmap` peekElemOff str i
-                              x <- peekElemOff counts k
-                              pokeElemOff counts k (x + 1)
-                              go (i + 1)
-
-{-
-sort :: Buffer -> Buffer
-sort (PS x s l) = unsafeCreate l $ \p -> withForeignPtr x $ \f -> do
-        memcpy p (f `plusPtr` s) l
-        c_qsort p l -- inplace
--}
-
--- The 'sortBy' function is the non-overloaded version of 'sort'.
---
--- Try some linear sorts: radix, counting
--- Or mergesort.
---
--- sortBy :: (Word8 -> Word8 -> Ordering) -> Buffer -> Buffer
--- sortBy f ps = undefined
-
--- ---------------------------------------------------------------------
--- Low level constructors
-
--- | /O(n) construction/ Use a @Buffer@ with a function requiring a
--- null-terminated @CString@.  The @CString@ will be freed
--- automatically. This is a memcpy(3).
-useAsCString :: Buffer -> (CString -> IO a) -> IO a
-useAsCString (PS fp o l) action = do
- allocaBytes (l+1) $ \buf ->
-   withForeignPtr fp $ \p -> do
-     memcpy buf (p `plusPtr` o) (fromIntegral l)
-     pokeByteOff buf l (0::Word8)
-     action (castPtr buf)
-
--- | /O(n) construction/ Use a @Buffer@ with a function requiring a @CStringLen@.
--- As for @useAsCString@ this function makes a copy of the original @Buffer@.
-useAsCStringLen :: Buffer -> (CStringLen -> IO a) -> IO a
-useAsCStringLen p@(PS _ _ l) f = useAsCString p $ \cstr -> f (cstr,l)
-
-------------------------------------------------------------------------
-
--- | /O(n)./ Construct a new @Buffer@ from a @CString@. The
--- resulting @Buffer@ is an immutable copy of the original
--- @CString@, and is managed on the Haskell heap. The original
--- @CString@ must be null terminated.
-packCString :: CString -> IO Buffer
-packCString cstr = do
-    len <- c_strlen cstr
-    packCStringLen (cstr, fromIntegral len)
-
--- | /O(n)./ Construct a new @Buffer@ from a @CStringLen@. The
--- resulting @Buffer@ is an immutable copy of the original @CStringLen@.
--- The @Buffer@ is a normal Haskell value and will be managed on the
--- Haskell heap.
-packCStringLen :: CStringLen -> IO Buffer
-packCStringLen (cstr, len) | len >= 0 = create len $ \p ->
-    memcpy p (castPtr cstr) (fromIntegral len)
-packCStringLen (_, len) =
-    moduleError "packCStringLen" ("negative length: " ++ show len)
-
-------------------------------------------------------------------------
-
--- | /O(n)/ Make a copy of the 'Buffer' with its own storage. 
--- This is mainly useful to allow the rest of the data pointed
--- to by the 'Buffer' to be garbage collected, for example
--- if a large string has been read in, and only a small part of it 
--- is needed in the rest of the program.
--- 
-copy :: Buffer -> Buffer
-copy (PS x s l) = unsafeCreate l $ \p -> withForeignPtr x $ \f ->
-    memcpy p (f `plusPtr` s) (fromIntegral l)
-
--- ---------------------------------------------------------------------
--- Line IO
-
--- | Read a line from stdin.
-getLine :: IO Buffer
-getLine = hGetLine stdin
-
--- | Read a line from a handle
-
-hGetLine :: Handle -> IO Buffer
-
-#if !defined(__GLASGOW_HASKELL__)
-
-hGetLine h = System.IO.hGetLine h >>= return . pack . P.map c2w
-
-#elif __GLASGOW_HASKELL__ >= 611
-
-hGetLine h =
-  wantReadableHandle_ "Data.Buffer.hGetLine" h $
-    \ h_@Handle__{haByteBuffer} -> do
-      flushCharReadBuffer h_
-      buf <- readIORef haByteBuffer
-      if isEmptyBuffer buf
-         then fill h_ buf 0 []
-         else haveBuf h_ buf 0 []
- where
-
-  fill h_@Handle__{haByteBuffer,haDevice} buf len xss =
-    len `seq` do
-    (r,buf') <- Buffered.fillReadBuffer haDevice buf
-    if r == 0
-       then do writeIORef haByteBuffer buf{ bufR=0, bufL=0 }
-               if len > 0
-                  then mkBigPS len xss
-                  else ioe_EOF
-       else haveBuf h_ buf' len xss
-
-  haveBuf h_@Handle__{haByteBuffer}
-          buf@Buffer{ bufRaw=raw, bufR=w, bufL=r }
-          len xss =
-    do
-        off <- findEOL r w raw
-        let new_len = len + off - r
-        xs <- mkPS raw r off
-
-      -- if eol == True, then off is the offset of the '\n'
-      -- otherwise off == w and the buffer is now empty.
-        if off /= w
-            then do if (w == off + 1)
-                            then writeIORef haByteBuffer buf{ bufL=0, bufR=0 }
-                            else writeIORef haByteBuffer buf{ bufL = off + 1 }
-                    mkBigPS new_len (xs:xss)
-            else do
-                 fill h_ buf{ bufL=0, bufR=0 } new_len (xs:xss)
-
-  -- find the end-of-line character, if there is one
-  findEOL r w raw
-        | r == w = return w
-        | otherwise =  do
-            c <- readWord8Buf raw r
-            if c == fromIntegral (ord '\n')
-                then return r -- NB. not r+1: don't include the '\n'
-                else findEOL (r+1) w raw
-
-mkPS :: RawBuffer Word8 -> Int -> Int -> IO Buffer
-mkPS buf start end =
- create len $ \p ->
-   withRawBuffer buf $ \pbuf -> do
-   copyBytes p (pbuf `plusPtr` start) len
- where
-   len = end - start
-
-#else
--- GHC 6.10 and older, pre-Unicode IO library
-
-hGetLine h = wantReadableHandle "Data.Buffer.hGetLine" h $ \ handle_ -> do
-    case haBufferMode handle_ of
-       NoBuffering -> error "no buffering"
-       _other      -> hGetLineBuffered handle_
-
- where
-    hGetLineBuffered handle_ = do
-        let ref = haBuffer handle_
-        buf <- readIORef ref
-        hGetLineBufferedLoop handle_ ref buf 0 []
-
-    hGetLineBufferedLoop handle_ ref
-            buf@Buffer{ bufRPtr=r, bufWPtr=w, bufBuf=raw } len xss =
-        len `seq` do
-        off <- findEOL r w raw
-        let new_len = len + off - r
-        xs <- mkPS raw r off
-
-      -- if eol == True, then off is the offset of the '\n'
-      -- otherwise off == w and the buffer is now empty.
-        if off /= w
-            then do if (w == off + 1)
-                            then writeIORef ref buf{ bufRPtr=0, bufWPtr=0 }
-                            else writeIORef ref buf{ bufRPtr = off + 1 }
-                    mkBigPS new_len (xs:xss)
-            else do
-                 maybe_buf <- maybeFillReadBuffer (haFD handle_) True (haIsStream handle_)
-                                    buf{ bufWPtr=0, bufRPtr=0 }
-                 case maybe_buf of
-                    -- Nothing indicates we caught an EOF, and we may have a
-                    -- partial line to return.
-                    Nothing -> do
-                         writeIORef ref buf{ bufRPtr=0, bufWPtr=0 }
-                         if new_len > 0
-                            then mkBigPS new_len (xs:xss)
-                            else ioe_EOF
-                    Just new_buf ->
-                         hGetLineBufferedLoop handle_ ref new_buf new_len (xs:xss)
-
-    -- find the end-of-line character, if there is one
-    findEOL r w raw
-        | r == w = return w
-        | otherwise =  do
-            (c,r') <- readCharFromBuffer raw r
-            if c == '\n'
-                then return r -- NB. not r': don't include the '\n'
-                else findEOL r' w raw
-
-    maybeFillReadBuffer fd is_line is_stream buf = catch
-        (do buf' <- fillReadBuffer fd is_line is_stream buf
-            return (Just buf'))
-        (\e -> if isEOFError e then return Nothing else ioError e)
-
--- TODO, rewrite to use normal memcpy
-mkPS :: RawBuffer -> Int -> Int -> IO Buffer
-mkPS buf start end =
-    let len = end - start
-    in create len $ \p -> do
-        memcpy_ptr_baoff p buf (fromIntegral start) (fromIntegral len)
-        return ()
-
-#endif
-
-mkBigPS :: Int -> [Buffer] -> IO Buffer
-mkBigPS _ [ps] = return ps
-mkBigPS _ pss = return $! concat (P.reverse pss)
-
--- ---------------------------------------------------------------------
--- Block IO
-
--- | Outputs a 'Buffer' to the specified 'Handle'.
-hPut :: Handle -> Buffer -> IO ()
-hPut _ (PS _  _ 0) = return ()
-hPut h (PS ps s l) = withForeignPtr ps $ \p-> hPutBuf h (p `plusPtr` s) l
-
--- | A synonym for @hPut@, for compatibility 
-hPutStr :: Handle -> Buffer -> IO ()
-hPutStr = hPut
-
--- | Write a Buffer to a handle, appending a newline byte
-hPutStrLn :: Handle -> Buffer -> IO ()
-hPutStrLn h ps
-    | length ps < 1024 = hPut h (ps `snoc` 0x0a)
-    | otherwise        = hPut h ps >> hPut h (singleton (0x0a)) -- don't copy
-
--- | Write a Buffer to stdout
-putStr :: Buffer -> IO ()
-putStr = hPut stdout
-
--- | Write a Buffer to stdout, appending a newline byte
-putStrLn :: Buffer -> IO ()
-putStrLn = hPutStrLn stdout
-
-------------------------------------------------------------------------
--- Low level IO
-
--- | Read a 'Buffer' directly from the specified 'Handle'.  This
--- is far more efficient than reading the characters into a 'String'
--- and then using 'pack'. First argument is the Handle to read from, 
--- and the second is the number of bytes to read. It returns the bytes
--- read, up to n, or EOF.
---
--- 'hGet' is implemented in terms of 'hGetBuf'.
---
--- If the handle is a pipe or socket, and the writing end
--- is closed, 'hGet' will behave as if EOF was reached.
---
-hGet :: Handle -> Int -> IO Buffer
-hGet h i
-    | i >  0    = createAndTrim i $ \p -> hGetBuf h p i
-    | i == 0    = return empty
-    | otherwise = illegalBufferSize h "hGet" i
-
--- | hGetNonBlocking is identical to 'hGet', except that it will never block
--- waiting for data to become available, instead it returns only whatever data
--- is available.
---
-hGetNonBlocking :: Handle -> Int -> IO Buffer
-#if defined(__GLASGOW_HASKELL__)
-hGetNonBlocking h i
-    | i >  0    = createAndTrim i $ \p -> hGetBufNonBlocking h p i
-    | i == 0    = return empty
-    | otherwise = illegalBufferSize h "hGetNonBlocking" i
-#else
-hGetNonBlocking = hGet
-#endif
-
-illegalBufferSize :: Handle -> String -> Int -> IO a
-illegalBufferSize handle fn sz =
-    ioError (mkIOError illegalOperationErrorType msg (Just handle) Nothing)
-    --TODO: System.IO uses InvalidArgument here, but it's not exported :-(
-    where
-      msg = fn ++ ": illegal Buffer size " ++ showsPrec 9 sz []
-
-
--- | Read entire handle contents strictly into a 'Buffer'.
---
--- This function reads chunks at a time, doubling the chunksize on each
--- read. The final buffer is then realloced to the appropriate size. For
--- files > half of available memory, this may lead to memory exhaustion.
--- Consider using 'readFile' in this case.
---
--- As with 'hGet', the string representation in the file is assumed to
--- be ISO-8859-1.
---
--- The Handle is closed once the contents have been read,
--- or if an exception is thrown.
---
-hGetContents :: Handle -> IO Buffer
-hGetContents h = always (hClose h) $ do -- strict, so hClose
-    let start_size = 1024
-    p <- mallocBytes start_size
-    i <- hGetBuf h p start_size
-    if i < start_size
-        then do p' <- reallocBytes p i
-                fp <- newForeignPtr finalizerFree p'
-                return $! PS fp 0 i
-        else f p start_size
-    where
-        always = flip finally
-        f p s = do
-            let s' = 2 * s
-            p' <- reallocBytes p s'
-            i  <- hGetBuf h (p' `plusPtr` s) s
-            if i < s
-                then do let i' = s + i
-                        p'' <- reallocBytes p' i'
-                        fp  <- newForeignPtr finalizerFree p''
-                        return $! PS fp 0 i'
-                else f p' s'
-
--- | getContents. Read stdin strictly. Equivalent to hGetContents stdin
--- The 'Handle' is closed after the contents have been read.
---
-getContents :: IO Buffer
-getContents = hGetContents stdin
-
--- | The interact function takes a function of type @Buffer -> Buffer@
--- as its argument. The entire input from the standard input device is passed
--- to this function as its argument, and the resulting string is output on the
--- standard output device.
---
-interact :: (Buffer -> Buffer) -> IO ()
-interact transformer = putStr . transformer =<< getContents
-
--- | Read an entire file strictly into a 'Buffer'.  This is far more
--- efficient than reading the characters into a 'String' and then using
--- 'pack'.  It also may be more efficient than opening the file and
--- reading it using hGet. Files are read using 'binary mode' on Windows,
--- for 'text mode' use the Char8 version of this function.
---
-readFile :: FilePath -> IO Buffer
-readFile f = bracket (openBinaryFile f ReadMode) hClose
-    (\h -> hFileSize h >>= hGet h . fromIntegral)
-
--- | Write a 'Buffer' to a file.
-writeFile :: FilePath -> Buffer -> IO ()
-writeFile f txt = bracket (openBinaryFile f WriteMode) hClose
-    (\h -> hPut h txt)
-
--- | Append a 'Buffer' to a file.
-appendFile :: FilePath -> Buffer -> IO ()
-appendFile f txt = bracket (openBinaryFile f AppendMode) hClose
-    (\h -> hPut h txt)
-
--- ---------------------------------------------------------------------
--- Internal utilities
-
--- | 'findIndexOrEnd' is a variant of findIndex, that returns the length
--- of the string if no element is found, rather than Nothing.
-findIndexOrEnd :: (Word8 -> Bool) -> Buffer -> Int
-findIndexOrEnd k (PS x s l) = inlinePerformIO $ withForeignPtr x $ \f -> go (f `plusPtr` s) 0
-  where
-    STRICT2(go)
-    go ptr n | n >= l    = return l
-             | otherwise = do w <- peek ptr
-                              if k w
-                                then return n
-                                else go (ptr `plusPtr` 1) (n+1)
-{-# INLINE findIndexOrEnd #-}
-
--- | Perform an operation with a temporary Buffer
-withPtr :: ForeignPtr a -> (Ptr a -> IO b) -> b
-withPtr fp io = inlinePerformIO (withForeignPtr fp io)
-{-# INLINE withPtr #-}
-
--- Common up near identical calls to `error' to reduce the number
--- constant strings created when compiled:
-errorEmptyList :: String -> a
-errorEmptyList fun = moduleError fun "empty Buffer"
-{-# NOINLINE errorEmptyList #-}
-
-moduleError :: String -> String -> a
-moduleError fun msg = error ("Data.Buffer." ++ fun ++ ':':' ':msg)
-{-# NOINLINE moduleError #-}
-
--- Find from the end of the string using predicate
-findFromEndUntil :: (Word8 -> Bool) -> Buffer -> Int
-STRICT2(findFromEndUntil)
-findFromEndUntil f ps@(PS x s l) =
-    if null ps then 0
-    else if f (last ps) then l
-         else findFromEndUntil f (PS x s (l-1))
+{-# LANGUAGE CPP #-}
+-- We cannot actually specify all the language pragmas, see ghc ticket #
+-- If we could, these are what they would be:
+{- LANGUAGE MagicHash, UnboxedTuples,
+            NamedFieldPuns, BangPatterns, RecordWildCards -}
+{-# OPTIONS_HADDOCK prune #-}
+
+-- |
+-- Module      : Data.Buffer
+-- Copyright   : (c) The University of Glasgow 2001,
+--               (c) David Roundy 2003-2005,
+--               (c) Simon Marlow 2005
+--               (c) Bjorn Bringert 2006
+--               (c) Don Stewart 2005-2008
+--               (c) Edward Kmett 2009-2010
+--
+--               Array fusion code:
+--               (c) 2001,2002 Manuel M T Chakravarty & Gabriele Keller
+--               (c) 2006      Manuel M T Chakravarty & Roman Leshchinskiy
+--
+-- License     : BSD-style
+--
+-- Maintainer  : ekmett@gmail.com
+-- Stability   : experimental
+-- Portability : portable
+-- 
+-- A time and space-efficient implementation of byte vectors using
+-- packed Word8 arrays, suitable for high performance use, both in terms
+-- of large data quantities, or high speed requirements. Byte vectors
+-- are encoded as strict 'Word8' arrays of bytes, held in a 'ForeignPtr',
+-- and can be passed between C and Haskell with little effort.
+--
+-- This module is intended to be imported @qualified@, to avoid name
+-- clashes with "Prelude" functions.  eg.
+--
+-- > import qualified Data.Buffer as B
+--
+-- Original GHC implementation by Bryan O\'Sullivan.
+-- Rewritten to use 'Data.Array.Unboxed.UArray' by Simon Marlow.
+-- Rewritten to support slices and use 'ForeignPtr' by David Roundy.
+-- Polished and extended by Don Stewart.
+--
+
+module Data.Buffer.Word8 (
+
+        -- * The @Buffer@ type
+        Buffer,             -- abstract, instances: Eq, Ord, Show, Read, Data, Typeable, Monoid
+
+        -- * Introducing and eliminating 'Buffer's
+        empty,                  -- :: Buffer
+        singleton,              -- :: Word8   -> Buffer
+        pack,                   -- :: [Word8] -> Buffer
+        unpack,                 -- :: Buffer -> [Word8]
+
+        -- * Basic interface
+        cons,                   -- :: Word8 -> Buffer -> Buffer
+        snoc,                   -- :: Buffer -> Word8 -> Buffer
+        append,                 -- :: Buffer -> Buffer -> Buffer
+        head,                   -- :: Buffer -> Word8
+        uncons,                 -- :: Buffer -> Maybe (Word8, Buffer)
+        unsnoc,                 -- :: Buffer -> Maybe (Buffer, Word8)
+        last,                   -- :: Buffer -> Word8
+        tail,                   -- :: Buffer -> Buffer
+        init,                   -- :: Buffer -> Buffer
+        null,                   -- :: Buffer -> Bool
+        length,                 -- :: Buffer -> Int
+
+        -- * Transforming Buffers
+        map,                    -- :: (Word8 -> Word8) -> Buffer -> Buffer
+        reverse,                -- :: Buffer -> Buffer
+        intersperse,            -- :: Word8 -> Buffer -> Buffer
+        intercalate,            -- :: Buffer -> [Buffer] -> Buffer
+        transpose,              -- :: [Buffer] -> [Buffer]
+
+        -- * Reducing 'Buffer's (folds)
+        foldl,                  -- :: (a -> Word8 -> a) -> a -> Buffer -> a
+        foldl',                 -- :: (a -> Word8 -> a) -> a -> Buffer -> a
+        foldl1,                 -- :: (Word8 -> Word8 -> Word8) -> Buffer -> Word8
+        foldl1',                -- :: (Word8 -> Word8 -> Word8) -> Buffer -> Word8
+
+        foldr,                  -- :: (Word8 -> a -> a) -> a -> Buffer -> a
+        foldr',                 -- :: (Word8 -> a -> a) -> a -> Buffer -> a
+        foldr1,                 -- :: (Word8 -> Word8 -> Word8) -> Buffer -> Word8
+        foldr1',                -- :: (Word8 -> Word8 -> Word8) -> Buffer -> Word8
+
+        -- ** Special folds
+        concat,                 -- :: [Buffer] -> Buffer
+        concatMap,              -- :: (Word8 -> Buffer) -> Buffer -> Buffer
+        any,                    -- :: (Word8 -> Bool) -> Buffer -> Bool
+        all,                    -- :: (Word8 -> Bool) -> Buffer -> Bool
+        maximum,                -- :: Buffer -> Word8
+        minimum,                -- :: Buffer -> Word8
+
+        -- * Building Buffers
+        -- ** Scans
+        scanl,                  -- :: (Word8 -> Word8 -> Word8) -> Word8 -> Buffer -> Buffer
+        scanl1,                 -- :: (Word8 -> Word8 -> Word8) -> Buffer -> Buffer
+        scanr,                  -- :: (Word8 -> Word8 -> Word8) -> Word8 -> Buffer -> Buffer
+        scanr1,                 -- :: (Word8 -> Word8 -> Word8) -> Buffer -> Buffer
+
+        -- ** Accumulating maps
+        mapAccumL,              -- :: (acc -> Word8 -> (acc, Word8)) -> acc -> Buffer -> (acc, Buffer)
+        mapAccumR,              -- :: (acc -> Word8 -> (acc, Word8)) -> acc -> Buffer -> (acc, Buffer)
+
+        -- ** Generating and unfolding Buffers
+        replicate,              -- :: Int -> Word8 -> Buffer
+        unfoldr,                -- :: (a -> Maybe (Word8, a)) -> a -> Buffer
+        unfoldrN,               -- :: Int -> (a -> Maybe (Word8, a)) -> a -> (Buffer, Maybe a)
+
+        -- * Substrings
+
+        -- ** Breaking strings
+        take,                   -- :: Int -> Buffer -> Buffer
+        drop,                   -- :: Int -> Buffer -> Buffer
+        splitAt,                -- :: Int -> Buffer -> (Buffer, Buffer)
+        takeWhile,              -- :: (Word8 -> Bool) -> Buffer -> Buffer
+        dropWhile,              -- :: (Word8 -> Bool) -> Buffer -> Buffer
+        span,                   -- :: (Word8 -> Bool) -> Buffer -> (Buffer, Buffer)
+        spanEnd,                -- :: (Word8 -> Bool) -> Buffer -> (Buffer, Buffer)
+        break,                  -- :: (Word8 -> Bool) -> Buffer -> (Buffer, Buffer)
+        breakEnd,               -- :: (Word8 -> Bool) -> Buffer -> (Buffer, Buffer)
+        group,                  -- :: Buffer -> [Buffer]
+        groupBy,                -- :: (Word8 -> Word8 -> Bool) -> Buffer -> [Buffer]
+        inits,                  -- :: Buffer -> [Buffer]
+        tails,                  -- :: Buffer -> [Buffer]
+
+        -- ** Breaking into many substrings
+        split,                  -- :: Word8 -> Buffer -> [Buffer]
+        splitWith,              -- :: (Word8 -> Bool) -> Buffer -> [Buffer]
+
+        -- * Predicates
+        isPrefixOf,             -- :: Buffer -> Buffer -> Bool
+        isSuffixOf,             -- :: Buffer -> Buffer -> Bool
+        isInfixOf,              -- :: Buffer -> Buffer -> Bool
+
+        -- ** Search for arbitrary substrings
+        breakSubstring,         -- :: Buffer -> Buffer -> (Buffer,Buffer)
+
+        -- * Searching Buffers
+
+        -- ** Searching by equality
+        elem,                   -- :: Word8 -> Buffer -> Bool
+        notElem,                -- :: Word8 -> Buffer -> Bool
+
+        -- ** Searching with a predicate
+        find,                   -- :: (Word8 -> Bool) -> Buffer -> Maybe Word8
+        filter,                 -- :: (Word8 -> Bool) -> Buffer -> Buffer
+        partition,              -- :: (Word8 -> Bool) -> Buffer -> (Buffer, Buffer)
+
+        -- * Indexing Buffers
+        index,                  -- :: Buffer -> Int -> Word8
+        elemIndex,              -- :: Word8 -> Buffer -> Maybe Int
+        elemIndices,            -- :: Word8 -> Buffer -> [Int]
+        elemIndexEnd,           -- :: Word8 -> Buffer -> Maybe Int
+        findIndex,              -- :: (Word8 -> Bool) -> Buffer -> Maybe Int
+        findIndices,            -- :: (Word8 -> Bool) -> Buffer -> [Int]
+        count,                  -- :: Word8 -> Buffer -> Int
+
+        -- * Zipping and unzipping Buffers
+        zip,                    -- :: Buffer -> Buffer -> [(Word8,Word8)]
+        zipWith,                -- :: (Word8 -> Word8 -> c) -> Buffer -> Buffer -> [c]
+        unzip,                  -- :: [(Word8,Word8)] -> (Buffer,Buffer)
+
+        -- * Ordered Buffers
+        sort,                   -- :: Buffer -> Buffer
+
+        -- * Low level conversions
+        -- ** Copying Buffers
+        copy,                   -- :: Buffer -> Buffer
+        copyCString,            -- :: CString -> Buffer
+        copyCStringLen,         -- :: CStringLen -> Buffer
+
+        -- ** Packing 'CString's and pointers
+        packCString,            -- :: CString -> IO Buffer
+        packCStringLen,         -- :: CStringLen -> IO Buffer
+        packMallocCString       -- :: CString -> ByteString
+
+        -- ** Using Buffers as 'CString's
+        useAsCString,           -- :: Buffer -> (CString    -> IO a) -> IO a
+        useAsCStringLen,        -- :: Buffer -> (CStringLen -> IO a) -> IO a
+
+        -- * I\/O with 'Buffer's
+
+        -- ** Standard input and output
+        getLine,                -- :: IO Buffer
+        getContents,            -- :: IO Buffer
+        putStr,                 -- :: Buffer -> IO ()
+        putStrLn,               -- :: Buffer -> IO ()
+        interact,               -- :: (Buffer -> Buffer) -> IO ()
+
+        -- ** Files
+        readFile,               -- :: FilePath -> IO Buffer
+        writeFile,              -- :: FilePath -> Buffer -> IO ()
+        appendFile,             -- :: FilePath -> Buffer -> IO ()
+
+        -- ** I\/O with Handles
+        hGetLine,               -- :: Handle -> IO Buffer
+        hGetContents,           -- :: Handle -> IO Buffer
+        hGet,                   -- :: Handle -> Int -> IO Buffer
+        hGetNonBlocking,        -- :: Handle -> Int -> IO Buffer
+        hPut,                   -- :: Handle -> Buffer -> IO ()
+        hPutStr,                -- :: Handle -> Buffer -> IO ()
+        hPutStrLn,              -- :: Handle -> Buffer -> IO ()
+
+        breakByte
+  ) where
+
+import qualified Prelude as P
+import Prelude hiding           (reverse,head,tail,last,init,null
+                                ,length,map,lines,foldl,foldr,unlines
+                                ,concat,any,take,drop,splitAt,takeWhile
+                                ,dropWhile,span,break,elem,filter,maximum
+                                ,minimum,all,concatMap,foldl1,foldr1
+                                ,scanl,scanl1,scanr,scanr1
+                                ,readFile,writeFile,appendFile,replicate
+                                ,getContents,getLine,putStr,putStrLn,interact
+                                ,zip,zipWith,unzip,notElem)
+
+import Data.Buffer.Internal
+import Data.Buffer.Unsafe
+
+import qualified Data.List as List
+
+import Data.Word                (Word8)
+
+-- Control.Exception.assert not available in yhc or nhc
+#ifndef __NHC__
+import Control.Exception        (finally, bracket, assert)
+#else
+import Control.Exception    (bracket, finally)
+#endif
+import Control.Monad            (when)
+
+import Foreign.C.String         (CString, CStringLen)
+import Foreign.C.Types          (CSize)
+import Foreign.ForeignPtr
+import Foreign.Marshal.Alloc    (allocaBytes, mallocBytes, reallocBytes, finalizerFree)
+import Foreign.Marshal.Array    (allocaArray)
+import Foreign.Ptr
+import Foreign.Storable         (Storable(..))
+
+-- hGetBuf and hPutBuf not available in yhc or nhc
+import System.IO                (stdin,stdout,hClose,hFileSize
+                                ,hGetBuf,hPutBuf,openBinaryFile
+                                ,IOMode(..))
+import System.IO.Error          (mkIOError, illegalOperationErrorType)
+
+import Data.Monoid              (Monoid, mempty, mappend, mconcat)
+
+#if !defined(__GLASGOW_HASKELL__)
+import System.IO.Unsafe
+import qualified System.Environment
+import qualified System.IO      (hGetLine)
+#endif
+
+#if defined(__GLASGOW_HASKELL__)
+
+import System.IO                (hGetBufNonBlocking)
+
+#if __GLASGOW_HASKELL__ >= 611
+import Data.IORef
+import GHC.IO.Handle.Internals
+import GHC.IO.Handle.Types
+import GHC.IO.Buffer
+import GHC.IO.BufferedIO as Buffered
+import GHC.IO hiding (finally)
+import Data.Char                (ord)
+import Foreign.Marshal.Utils    (copyBytes)
+#else
+import System.IO.Error          (isEOFError)
+import qualified GHC.IOBase as IOBase
+import GHC.IOBase hiding (Buffer)
+import GHC.Handle
+#endif
+
+import GHC.Prim                 (int2Word#, Word#, (+#), geWord#, ltWord#, writeWord8OffAddr#)
+import GHC.Base                 (build, Int(..))
+import GHC.Word hiding (Word8)
+import GHC.Ptr                  (Ptr(..))
+import GHC.ST                   (ST(..))
+
+#endif
+
+-- An alternative to Control.Exception (assert) for nhc98
+#ifdef __NHC__
+#define assert  assertS "__FILE__ : __LINE__"
+assertS :: String -> Bool -> a -> a
+assertS _ True  = id
+assertS s False = error ("assertion failed at "++s)
+#endif
+
+-- -----------------------------------------------------------------------------
+--
+-- Useful macros, until we have bang patterns
+--
+
+#define STRICT1(f) f a | a `seq` False = undefined
+#define STRICT2(f) f a b | a `seq` b `seq` False = undefined
+#define STRICT3(f) f a b c | a `seq` b `seq` c `seq` False = undefined
+#define STRICT4(f) f a b c d | a `seq` b `seq` c `seq` d `seq` False = undefined
+#define STRICT5(f) f a b c d e | a `seq` b `seq` c `seq` d `seq` e `seq` False = undefined
+
+-- -----------------------------------------------------------------------------
+
+instance Eq  Buffer where
+    (==)    = eq
+
+instance Ord Buffer where
+    compare = compareBytes
+
+instance Monoid Buffer where
+    mempty  = empty
+    mappend = append
+    mconcat = concat
+
+-- | /O(n)/ Equality on the 'Buffer' type.
+eq :: Buffer -> Buffer -> Bool
+eq a@(PS p s l x) b@(PS p' s' l' x')
+    | l /= l' || x /= x' = False    -- short cut on length and number of extra bytes
+    | p == p' && s == s' = True     -- short cut for the same string
+    | otherwise          = compareBytes a b == EQ
+{-# INLINE eq #-}
+-- ^ still needed
+
+-- | /O(n)/ 'compareBytes' provides an 'Ordering' for 'Buffers' supporting slices. 
+compareBytes :: Buffer -> Buffer -> Ordering
+compareBytes (PS x1 s1 l1 _) (PS x2 s2 l2 _)
+    | l1 == 0  && l2 == 0               = EQ  -- short cut for empty strings
+    | otherwise                         = inlinePerformIO $
+        withForeignPtr x1 $ \p1 ->
+        withForeignPtr x2 $ \p2 -> do
+            i <- memcmp (p1 `plusPtr` s1) (p2 `plusPtr` s2) (fromIntegral $ min l1 l2)
+            return $! case i `compare` 0 of
+                        EQ  -> l1 `compare` l2
+                        x   -> x
+
+{-
+
+-- Pure Haskell version
+
+compareBytes (PS fp1 off1 len1 _) (PS fp2 off2 len2 _)
+--    | len1 == 0  && len2 == 0                     = EQ  -- short cut for empty strings
+--    | fp1 == fp2 && off1 == off2 && len1 == len2  = EQ  -- short cut for the same string
+    | otherwise                                   = inlinePerformIO $
+    withForeignPtr fp1 $ \p1 ->
+        withForeignPtr fp2 $ \p2 ->
+            cmp (p1 `plusPtr` off1)
+                (p2 `plusPtr` off2) 0 len1 len2
+
+-- XXX todo.
+cmp :: Ptr Word8 -> Ptr Word8 -> Int -> Int -> Int-> IO Ordering
+cmp p1 p2 n len1 len2
+      | n == len1 = if n == len2 then return EQ else return LT
+      | n == len2 = return GT
+      | otherwise = do
+          a <- peekByteOff p1 n :: IO Word8
+          b <- peekByteOff p2 n
+          case a `compare` b of
+                EQ -> cmp p1 p2 (n+1) len1 len2
+                LT -> return LT
+                GT -> return GT
+-}
+
+-- -----------------------------------------------------------------------------
+-- Introducing and eliminating 'Buffer's
+
+-- | /O(1)/ The empty 'Buffer'
+empty :: Buffer
+empty = PS nullForeignPtr 0 0 0
+
+-- | /O(1)/ Convert a 'Word8' into a 'Buffer'
+singleton :: Word8 -> Buffer
+singleton c = unsafeCreate 1 $ \p -> poke p c
+{-# INLINE [1] singleton #-}
+
+-- Inline [1] for intercalate rule
+
+--
+-- XXX The use of unsafePerformIO in allocating functions (unsafeCreate) is critical!
+--
+-- Otherwise:
+--
+--  singleton 255 `compare` singleton 127
+--
+-- is compiled to:
+--
+--  case mallocBuffer 2 of 
+--      ForeignPtr f internals -> 
+--           case writeWord8OffAddr# f 0 255 of _ -> 
+--           case writeWord8OffAddr# f 0 127 of _ ->
+--           case eqAddr# f f of 
+--                  False -> case compare (GHC.Prim.plusAddr# f 0) 
+--                                        (GHC.Prim.plusAddr# f 0)
+--
+--
+
+-- | /O(n)/ Convert a '[Word8]' into a 'Buffer'. 
+--
+-- For applications with large numbers of string literals, pack can be a
+-- bottleneck. In such cases, consider using packAddress (GHC only).
+pack :: [Word8] -> Buffer
+
+#if !defined(__GLASGOW_HASKELL__)
+pack str = unsafeCreate' (P.length str) $ \p -> go p str 0
+    where
+        STRICT3(go)
+        go _ [] acc    = return acc
+        go p (x:xs) acc = poke p x >> go (p `plusPtr` 1) xs (acc `plusExtra` x) -- less space than pokeElemOff
+
+#else /* hack away */
+
+pack str = unsafeCreate' (P.length str) $ \(Ptr p) -> stToIO (go p 0# str 0#)
+    where
+        go _ _ [] acc       = return (I# acc)
+        go p i (W8# c:cs) acc = do
+            writeByte p i c
+            go p (i +# 1#) cs (acc +# (if geWord# c (int2Word# 0x80#) && ltWord# c (int2Word# 0xC0#) then 1# else 0#))
+
+        writeByte p i c = ST $ \s# ->
+            case writeWord8OffAddr# p i c s# of s2# -> (# s2#, () #)
+
+#endif
+
+-- | /O(n)/ Converts a 'Buffer' to a '[Word8]'.
+unpack :: Buffer -> [Word8]
+
+#if !defined(__GLASGOW_HASKELL__)
+
+unpack (PS _  _ 0 _) = []
+unpack (PS ps s l _) = inlinePerformIO $ withForeignPtr ps $ \p ->
+        go (p `plusPtr` s) (l - 1) []
+    where
+        STRICT3(go)
+        go p 0 acc = peek p          >>= \e -> return (e : acc)
+        go p n acc = peekByteOff p n >>= \e -> go p (n-1) (e : acc)
+{-# INLINE unpack #-}
+
+#else
+
+unpack xs = build (unpackFoldr xs)
+{-# INLINE unpack #-}
+
+--
+-- Have unpack fuse with good list consumers
+--
+-- critical this isn't strict in the acc
+-- as it will break in the presence of list fusion. this is a known
+-- issue with seq and build/foldr rewrite rules, which rely on lazy
+-- demanding to avoid bottoms in the list.
+--
+unpackFoldr :: Buffer -> (Word8 -> a -> a) -> a -> a
+unpackFoldr (PS fp off len _) f ch = withPtr fp $ \p -> do
+    let loop q n    _   | q `seq` n `seq` False = undefined -- n.b.
+        loop _ (-1) acc = return acc
+        loop q n    acc = do
+           a <- peekByteOff q n
+           loop q (n-1) (a `f` acc)
+    loop (p `plusPtr` off) (len-1) ch
+{-# INLINE [0] unpackFoldr #-}
+
+unpackList :: Buffer -> [Word8]
+unpackList (PS fp off len _) = withPtr fp $ \p -> do
+    let STRICT3(loop)
+        loop _ (-1) acc = return acc
+        loop q n acc = do
+           a <- peekByteOff q n
+           loop q (n-1) (a : acc)
+    loop (p `plusPtr` off) (len-1) []
+
+{-# RULES
+"Buffer unpack-list" [1]  forall p  .
+    unpackFoldr p (:) [] = unpackList p
+ #-}
+
+#endif
+
+-- ---------------------------------------------------------------------
+-- Basic interface
+
+-- | /O(1)/ Test whether a Buffer is empty.
+null :: Buffer -> Bool
+null (PS _ _ l _) = assert (l >= 0) $ l <= 0
+{-# INLINE null #-}
+
+-- ---------------------------------------------------------------------
+-- | /O(1)/ 'length' returns the length of a Buffer as an 'Int'.
+length :: Buffer -> Int
+length (PS _ _ l _) = assert (l >= 0) $ l
+{-# INLINE length #-}
+
+------------------------------------------------------------------------
+
+-- | /O(n)/ 'cons' is analogous to (:) for lists, but of different
+-- complexity, as it requires a memcpy.
+cons :: Word8 -> Buffer -> Buffer
+cons c (PS x s l e) = unsafeCreate' (l+1) $ \p -> withForeignPtr x $ \f -> do
+        poke p c
+        memcpy (p `plusPtr` 1) (f `plusPtr` s) (fromIntegral l)
+        return $! if c >= 0x80 && c < 0xC0 then e + 1 else e
+{-# INLINE cons #-}
+
+-- | /O(n)/ Append a byte to the end of a 'Buffer'
+snoc :: Buffer -> Word8 -> Buffer
+snoc (PS x s l e) c = unsafeCreate' (l+1) $ \p -> withForeignPtr x $ \f -> do
+        memcpy p (f `plusPtr` s) (fromIntegral l)
+        poke (p `plusPtr` l) c
+        return $! if c >= 0x80 && c < 0xC0 then e + 1 else e
+{-# INLINE snoc #-}
+
+-- todo fuse
+
+-- | /O(1)/ Extract the first element of a Buffer, which must be non-empty.
+-- An exception will be thrown in the case of an empty Buffer.
+head :: Buffer -> Word8
+head (PS x s l _)
+    | l <= 0    = errorEmptyList "head"
+    | otherwise = inlinePerformIO $ withForeignPtr x $ \p -> peekByteOff p s
+{-# INLINE head #-}
+
+-- | /O(1)/ Extract the elements after the head of a Buffer, which must be non-empty.
+-- An exception will be thrown in the case of an empty Buffer.
+tail :: Buffer -> Buffer
+tail (PS x s l e)
+    | l <= 0    = errorEmptyList "tail"
+    | otherwise = PS x (s+1) (l-1) $! minusExtra e $ inlinePerformIO $ withForeignPtr x $ \p -> peekByteOff p s
+{-# INLINE tail #-}
+
+-- | /O(1)/ Extract the head and tail of a Buffer, returning Nothing
+-- if it is empty.
+uncons :: Buffer -> Maybe (Word8, Buffer)
+uncons (PS x s l e)
+    | l <= 0    = Nothing   
+    | otherwise = let h = inlinePerformIO $ withForeignPtr x $ \p -> peekByteOff p s
+                  in Just (h, PS x (s+1) (l-1) $! e `minusExtra` h)
+{-# INLINE uncons #-}
+
+-- | /O(1)/ Extract the head and tail of a Buffer, returning Nothing
+-- if it is empty.
+unsnoc :: Buffer -> Maybe (Buffer, Word8)
+unsnoc (PS x s l e)
+    | l <= 0    = Nothing   
+    | otherwise = let z = inlinePerformIO $ withForeignPtr x $ \p -> peekByteOff p (s+l-1)
+                  in Just (PS x s (l-1) $! e `minusExtra` z, z)
+{-# INLINE unsnoc #-}
+
+
+-- | /O(1)/ Extract the last element of a Buffer, which must be finite and non-empty.
+-- An exception will be thrown in the case of an empty Buffer.
+last :: Buffer -> Word8
+last (PS x s l _)
+    | l <= 0   = errorEmptyList "last"
+    | otherwise = inlinePerformIO $ withForeignPtr x $ \p -> peekByteOff p (s+l-1)
+{-# INLINE last #-}
+
+-- | /O(1)/ Return all the elements of a 'Buffer' except the last one.
+-- An exception will be thrown in the case of an empty Buffer.
+init :: Buffer -> Buffer
+init (PS x s l e)
+    | l <= 0 = errorEmptyList "init"
+    | otherwise = PS x s (l-1) $! minusExtra e $ inlinePerformIO $ withForeignPtr x $ \p -> peekByteOff p (s+l-1)
+{-# INLINE init #-}
+
+-- | /O(n)/ Append two Buffers
+append :: Buffer -> Buffer -> Buffer
+append xs ys | null xs   = ys
+             | null ys   = xs
+             | otherwise = concat [xs,ys]
+{-# INLINE append #-}
+
+-- ---------------------------------------------------------------------
+-- Transformations
+
+-- EAK: is inlinePerformIO correct here? create' _does_ perform allocation
+
+-- | /O(n)/ 'map' @f xs@ is the Buffer obtained by applying @f@ to each
+-- element of @xs@. This function is subject to array fusion.
+map :: (Word8 -> Word8) -> Buffer -> Buffer
+map f (PS fp s len _) = inlinePerformIO $ withForeignPtr fp $ \a ->
+    create' len $ map_ 0 (a `plusPtr` s) 0
+  where
+    map_ :: Int -> Ptr Word8 -> Int -> Ptr Word8 -> IO Int
+    STRICT4(map_)
+    map_ n p1 acc p2 
+       | n >= len = return acc
+       | otherwise = do
+            x <- peekByteOff p1 n
+            let x' = f x
+            pokeByteOff p2 n x'
+            map_ (n+1) p1 (acc `plusExtra` x') p2 
+            
+{-# INLINE map #-}
+
+-- | /O(n)/ 'reverse' @xs@ efficiently returns the elements of @xs@ in reverse order.
+reverse :: Buffer -> Buffer
+reverse (PS x s l e) = unsafeCreate' l $ \p -> withForeignPtr x $ \f -> do
+        c_reverse p (f `plusPtr` s) (fromIntegral l)
+        return e
+
+-- | /O(n)/ The 'intersperse' function takes a 'Word8' and a
+-- 'Buffer' and \`intersperses\' that byte between the elements of
+-- the 'Buffer'.  It is analogous to the intersperse function on
+-- Lists.
+intersperse :: Word8 -> Buffer -> Buffer
+intersperse c xs@(PS x s l e)
+    | length xs < 2  = xs
+    | otherwise      = unsafeCreate' (2*l-1) $ \p -> withForeignPtr x $ \f -> do
+        c_intersperse p (f `plusPtr` s) (fromIntegral l) c
+        return $! e + extra c * (l-1)
+
+-- | The 'transpose' function transposes the rows and columns of its
+-- 'Buffer' argument.
+transpose :: [Buffer] -> [Buffer]
+transpose xs = P.map pack (List.transpose (P.map unpack xs))
+
+-- ---------------------------------------------------------------------
+-- Reducing 'Buffer's
+
+-- | 'foldl', applied to a binary operator, a starting value (typically
+-- the left-identity of the operator), and a Buffer, reduces the
+-- Buffer using the binary operator, from left to right.
+--
+-- This function is subject to array fusion.
+--
+foldl :: (a -> Word8 -> a) -> a -> Buffer -> a
+foldl f v (PS x s l _) = inlinePerformIO $ withForeignPtr x $ \ptr ->
+        lgo v (ptr `plusPtr` s) (ptr `plusPtr` (s+l))
+    where
+        STRICT3(lgo)
+        lgo z p q | p == q    = return z
+                  | otherwise = do c <- peek p
+                                   lgo (f z c) (p `plusPtr` 1) q
+{-# INLINE foldl #-}
+
+-- | 'foldl\'' is like 'foldl', but strict in the accumulator.
+-- However, for Buffers, all left folds are strict in the accumulator.
+--
+foldl' :: (a -> Word8 -> a) -> a -> Buffer -> a
+foldl' = foldl
+{-# INLINE foldl' #-}
+
+-- | 'foldr', applied to a binary operator, a starting value
+-- (typically the right-identity of the operator), and a Buffer,
+-- reduces the Buffer using the binary operator, from right to left.
+foldr :: (Word8 -> a -> a) -> a -> Buffer -> a
+foldr k v (PS x s l _) = inlinePerformIO $ withForeignPtr x $ \ptr ->
+        go v (ptr `plusPtr` (s+l-1)) (ptr `plusPtr` (s-1))
+    where
+        STRICT3(go)
+        go z p q | p == q    = return z
+                 | otherwise = do c  <- peek p
+                                  go (c `k` z) (p `plusPtr` (-1)) q -- tail recursive
+{-# INLINE foldr #-}
+
+-- | 'foldr\'' is like 'foldr', but strict in the accumulator.
+foldr' :: (Word8 -> a -> a) -> a -> Buffer -> a
+foldr' k v (PS x s l _) = inlinePerformIO $ withForeignPtr x $ \ptr ->
+        go v (ptr `plusPtr` (s+l-1)) (ptr `plusPtr` (s-1))
+    where
+        STRICT3(go)
+        go z p q | p == q    = return z
+                 | otherwise = do c  <- peek p
+                                  go (c `k` z) (p `plusPtr` (-1)) q -- tail recursive
+{-# INLINE foldr' #-}
+
+-- | 'foldl1' is a variant of 'foldl' that has no starting value
+-- argument, and thus must be applied to non-empty 'Buffers'.
+-- This function is subject to array fusion. 
+-- An exception will be thrown in the case of an empty Buffer.
+foldl1 :: (Word8 -> Word8 -> Word8) -> Buffer -> Word8
+foldl1 f xs
+    | null xs   = errorEmptyList "foldl1"
+    | otherwise = foldl f (unsafeHead xs) (unsafeTail xs)
+{-# INLINE foldl1 #-}
+
+-- | 'foldl1\'' is like 'foldl1', but strict in the accumulator.
+-- An exception will be thrown in the case of an empty Buffer.
+foldl1' :: (Word8 -> Word8 -> Word8) -> Buffer -> Word8
+foldl1' f xs
+    | null xs   = errorEmptyList "foldl1'"
+    | otherwise = foldl' f (unsafeHead xs) (unsafeTail xs)
+{-# INLINE foldl1' #-}
+
+-- | 'foldr1' is a variant of 'foldr' that has no starting value argument,
+-- and thus must be applied to non-empty 'Buffer's
+-- An exception will be thrown in the case of an empty Buffer.
+foldr1 :: (Word8 -> Word8 -> Word8) -> Buffer -> Word8
+foldr1 f xs
+    | null xs        = errorEmptyList "foldr1"
+    | otherwise      = foldr f (unsafeLast xs) (unsafeInit xs)
+{-# INLINE foldr1 #-}
+
+-- | 'foldr1\'' is a variant of 'foldr1', but is strict in the
+-- accumulator.
+foldr1' :: (Word8 -> Word8 -> Word8) -> Buffer -> Word8
+foldr1' f xs
+    | null xs        = errorEmptyList "foldr1"
+    | otherwise      = foldr' f (unsafeLast xs) (unsafeInit xs)
+{-# INLINE foldr1' #-}
+
+-- ---------------------------------------------------------------------
+-- Special folds
+
+-- | /O(n)/ Concatenate a list of Buffers.
+concat :: [Buffer] -> Buffer
+concat []     = empty
+concat [xs]   = xs
+concat xs     = unsafeCreate' len $ \ptr -> go xs ptr 0
+  where len = P.sum . P.map length $ xs
+        STRICT3(go)
+        go []               _   acc  = return acc
+        go (PS p s l e: xs') ptr acc = do
+                withForeignPtr p $ \fp -> memcpy ptr (fp `plusPtr` s) (fromIntegral l)
+                go xs' (ptr `plusPtr` l) (acc + e)
+
+-- | Map a function over a 'Buffer' and concatenate the results
+concatMap :: (Word8 -> Buffer) -> Buffer -> Buffer
+concatMap f = concat . foldr ((:) . f) []
+
+-- foldr (append . f) empty
+
+-- | /O(n)/ Applied to a predicate and a Buffer, 'any' determines if
+-- any element of the 'Buffer' satisfies the predicate.
+any :: (Word8 -> Bool) -> Buffer -> Bool
+any _ (PS _ _ 0 _) = False
+any f (PS x s l _) = inlinePerformIO $ withForeignPtr x $ \ptr ->
+        go (ptr `plusPtr` s) (ptr `plusPtr` (s+l))
+    where
+        STRICT2(go)
+        go p q | p == q    = return False
+               | otherwise = do c <- peek p
+                                if f c then return True
+                                       else go (p `plusPtr` 1) q
+{-# INLINE any #-}
+
+-- todo fuse
+
+-- | /O(n)/ Applied to a predicate and a 'Buffer', 'all' determines
+-- if all elements of the 'Buffer' satisfy the predicate.
+all :: (Word8 -> Bool) -> Buffer -> Bool
+all _ (PS _ _ 0 _) = True
+all f (PS x s l _) = inlinePerformIO $ withForeignPtr x $ \ptr ->
+        go (ptr `plusPtr` s) (ptr `plusPtr` (s+l))
+    where
+        STRICT2(go)
+        go p q | p == q     = return True  -- end of list
+               | otherwise  = do c <- peek p
+                                 if f c
+                                    then go (p `plusPtr` 1) q
+                                    else return False
+{-# INLINE all #-}
+
+------------------------------------------------------------------------
+
+-- | /O(n)/ 'maximum' returns the maximum value from a 'Buffer'
+-- This function will fuse.
+-- An exception will be thrown in the case of an empty Buffer.
+maximum :: Buffer -> Word8
+maximum xs@(PS x s l _)
+    | null xs   = errorEmptyList "maximum"
+    | otherwise = inlinePerformIO $ withForeignPtr x $ \p ->
+                      c_maximum (p `plusPtr` s) (fromIntegral l)
+{-# INLINE maximum #-}
+
+-- | /O(n)/ 'minimum' returns the minimum value from a 'Buffer'
+-- This function will fuse.
+-- An exception will be thrown in the case of an empty Buffer.
+minimum :: Buffer -> Word8
+minimum xs@(PS x s l _)
+    | null xs   = errorEmptyList "minimum"
+    | otherwise = inlinePerformIO $ withForeignPtr x $ \p ->
+                      c_minimum (p `plusPtr` s) (fromIntegral l)
+{-# INLINE minimum #-}
+
+------------------------------------------------------------------------
+
+-- | The 'mapAccumL' function behaves like a combination of 'map' and
+-- 'foldl'; it applies a function to each element of a Buffer,
+-- passing an accumulating parameter from left to right, and returning a
+-- final value of this accumulator together with the new list.
+mapAccumL :: (acc -> Word8 -> (acc, Word8)) -> acc -> Buffer -> (acc, Buffer)
+mapAccumL f acc (PS fp o len _) = inlinePerformIO $ withForeignPtr fp $ \a -> do
+    gp   <- mallocBuffer len
+    (acc', e) <- withForeignPtr gp $ \p -> mapAccumL_ acc 0 (a `plusPtr` o) p 0
+    return $! (acc', PS gp 0 len e)
+  where
+    STRICT5(mapAccumL_)
+    mapAccumL_ s n p1 p2 e
+       | n >= len = return (s, e)
+       | otherwise = do
+            x <- peekByteOff p1 n
+            let (s', y) = f s x
+            pokeByteOff p2 n y
+            mapAccumL_ s' (n+1) p1 p2 (e `plusExtra` y)
+{-# INLINE mapAccumL #-}
+
+-- | The 'mapAccumR' function behaves like a combination of 'map' and
+-- 'foldr'; it applies a function to each element of a Buffer,
+-- passing an accumulating parameter from right to left, and returning a
+-- final value of this accumulator together with the new Buffer.
+mapAccumR :: (acc -> Word8 -> (acc, Word8)) -> acc -> Buffer -> (acc, Buffer)
+mapAccumR f acc (PS fp o len _) = inlinePerformIO $ withForeignPtr fp $ \a -> do
+    gp   <- mallocBuffer len
+    (acc', e) <- withForeignPtr gp $ \p -> mapAccumR_ acc (len-1) (a `plusPtr` o) p 0
+    return $! (acc', PS gp 0 len e)
+  where
+    STRICT5(mapAccumR_)
+    mapAccumR_ s n p q e
+       | n <  0    = return (s, e)
+       | otherwise = do
+            x  <- peekByteOff p n
+            let (s', y) = f s x
+            pokeByteOff q n y
+            mapAccumR_ s' (n-1) p q (e `plusExtra` y)
+{-# INLINE mapAccumR #-}
+
+-- ---------------------------------------------------------------------
+-- Building Buffers
+
+-- | 'scanl' is similar to 'foldl', but returns a list of successive
+-- reduced values from the left. This function will fuse.
+--
+-- > scanl f z [x1, x2, ...] == [z, z `f` x1, (z `f` x1) `f` x2, ...]
+--
+-- Note that
+--
+-- > last (scanl f z xs) == foldl f z xs.
+--
+scanl :: (Word8 -> Word8 -> Word8) -> Word8 -> Buffer -> Buffer
+scanl f v (PS fp s len _) = inlinePerformIO $ withForeignPtr fp $ \a ->
+    create' (len+1) $ \q -> do
+        poke q v
+        scanl_ v 0 (a `plusPtr` s) (q `plusPtr` 1) (extra v)
+  where
+    STRICT5(scanl_)
+    scanl_ z n p q e
+        | n >= len  = return e
+        | otherwise = do
+            x <- peekByteOff p n
+            let z' = f z x
+            pokeByteOff q n z'
+            scanl_ z' (n+1) p q (e `plusExtra` z')
+{-# INLINE scanl #-}
+
+    -- n.b. haskell's List scan returns a list one bigger than the
+    -- input, so we need to snoc here to get some extra space, however,
+    -- it breaks map/up fusion (i.e. scanl . map no longer fuses)
+
+-- | 'scanl1' is a variant of 'scanl' that has no starting value argument.
+-- This function will fuse.
+--
+-- > scanl1 f [x1, x2, ...] == [x1, x1 `f` x2, ...]
+scanl1 :: (Word8 -> Word8 -> Word8) -> Buffer -> Buffer
+scanl1 f xs
+    | null xs   = empty
+    | otherwise = scanl f (unsafeHead xs) (unsafeTail xs)
+{-# INLINE scanl1 #-}
+
+-- | scanr is the right-to-left dual of scanl.
+scanr :: (Word8 -> Word8 -> Word8) -> Word8 -> Buffer -> Buffer
+scanr f v (PS fp s len _) = inlinePerformIO $ withForeignPtr fp $ \a ->
+    create' (len+1) $ \q -> do
+        poke (q `plusPtr` len) v
+        scanr_ v (len-1) (a `plusPtr` s) q (extra v)
+  where
+    STRICT5(scanr_)
+    scanr_ z n p q e
+        | n <  0    = return e
+        | otherwise = do
+            x <- peekByteOff p n
+            let z' = f x z
+            pokeByteOff q n z'
+            scanr_ z' (n-1) p q (e `plusExtra` z')
+{-# INLINE scanr #-}
+
+-- | 'scanr1' is a variant of 'scanr' that has no starting value argument.
+scanr1 :: (Word8 -> Word8 -> Word8) -> Buffer -> Buffer
+scanr1 f xs
+    | null xs   = empty
+    | otherwise = scanr f (unsafeLast xs) (unsafeInit xs) 
+{-# INLINE scanr1 #-}
+
+-- ---------------------------------------------------------------------
+-- Unfolds and replicates
+
+-- | /O(n)/ 'replicate' @n x@ is a Buffer of length @n@ with @x@
+-- the value of every element. The following holds:
+--
+-- > replicate w c = unfoldr w (\u -> Just (u,u)) c
+--
+-- This implemenation uses @memset(3)@
+replicate :: Int -> Word8 -> Buffer
+replicate w c
+    | w <= 0    = empty
+    | otherwise = unsafeCreate w $ \ptr ->
+                      memset ptr c (fromIntegral w) >> return ()
+
+-- | /O(n)/, where /n/ is the length of the result.  The 'unfoldr' 
+-- function is analogous to the List \'unfoldr\'.  'unfoldr' builds a 
+-- Buffer from a seed value.  The function takes the element and 
+-- returns 'Nothing' if it is done producing the Buffer or returns 
+-- 'Just' @(a,b)@, in which case, @a@ is the next byte in the string, 
+-- and @b@ is the seed value for further production.
+--
+-- Examples:
+--
+-- >    unfoldr (\x -> if x <= 5 then Just (x, x + 1) else Nothing) 0
+-- > == pack [0, 1, 2, 3, 4, 5]
+--
+unfoldr :: (a -> Maybe (Word8, a)) -> a -> Buffer
+unfoldr f = concat . unfoldChunk 32 64
+  where unfoldChunk n n' x =
+          case unfoldrN n f x of
+            (s, Nothing) -> s : []
+            (s, Just x') -> s : unfoldChunk n' (n+n') x'
+{-# INLINE unfoldr #-}
+
+-- | /O(n)/ Like 'unfoldr', 'unfoldrN' builds a Buffer from a seed
+-- value.  However, the length of the result is limited by the first
+-- argument to 'unfoldrN'.  This function is more efficient than 'unfoldr'
+-- when the maximum length of the result is known.
+--
+-- The following equation relates 'unfoldrN' and 'unfoldr':
+--
+-- > snd (unfoldrN n f s) == take n (unfoldr f s)
+--
+unfoldrN :: Int -> (a -> Maybe (Word8, a)) -> a -> (Buffer, Maybe a)
+unfoldrN i f x0
+    | i < 0     = (empty, Just x0)
+    | otherwise = unsafePerformIO $ createAndTrim' i $ \p -> go p x0 0
+  where STRICT3(go)
+        go p x n =
+          case f x of
+            Nothing      -> return (0, n, Nothing)
+            Just (w,x')
+             | n == i    -> return (0, n, Just x)
+             | otherwise -> do poke p w
+                               go (p `plusPtr` 1) x' (n+1)
+{-# INLINE unfoldrN #-}
+
+-- ---------------------------------------------------------------------
+-- Substrings
+
+-- | /O(1)/ 'take' @n@, applied to a Buffer @xs@, returns the prefix
+-- of @xs@ of length @n@, or @xs@ itself if @n > 'length' xs@.
+take :: Int -> Buffer -> Buffer
+take n xs@(PS _ _ l _)
+    | n <= 0    = empty
+    | n >= l    = xs
+    | otherwise = unsafeTake n xs
+{-# INLINE take #-}
+
+-- | /O(1)/ 'drop' @n xs@ returns the suffix of @xs@ after the first @n@
+-- elements, or @[]@ if @n > 'length' xs@.
+drop  :: Int -> Buffer -> Buffer
+drop n xs@(PS _ _ l _)
+    | n <= 0    = xs
+    | n >= l    = empty
+    | otherwise = unsafeDrop n xs
+{-# INLINE drop #-}
+
+-- | /O(1)/ 'splitAt' @n xs@ is equivalent to @('take' n xs, 'drop' n xs)@.
+splitAt :: Int -> Buffer -> (Buffer, Buffer)
+splitAt n xs@(PS _ _ l _)
+    | n <= 0    = (empty, xs)
+    | n >= l    = (xs, empty)
+    | otherwise = unsafeSplitAt n xs
+{-# INLINE splitAt #-}
+
+-- | 'takeWhile', applied to a predicate @p@ and a Buffer @xs@,
+-- returns the longest prefix (possibly empty) of @xs@ of elements that
+-- satisfy @p@.
+takeWhile :: (Word8 -> Bool) -> Buffer -> Buffer
+takeWhile f xs = unsafeTake (findIndexOrEnd (not . f) xs) xs
+{-# INLINE takeWhile #-}
+
+-- | 'dropWhile' @p xs@ returns the suffix remaining after 'takeWhile' @p xs@.
+dropWhile :: (Word8 -> Bool) -> Buffer -> Buffer
+dropWhile f xs = unsafeDrop (findIndexOrEnd (not . f) xs) xs
+{-# INLINE dropWhile #-}
+
+-- instead of findIndexOrEnd, we could use memchr here.
+
+-- | 'break' @p@ is equivalent to @'span' ('not' . p)@.
+--
+-- Under GHC, a rewrite rule will transform break (==) into a
+-- call to the specialised breakByte:
+--
+-- > break ((==) x) = breakByte x
+-- > break (==x) = breakByte x
+--
+break :: (Word8 -> Bool) -> Buffer -> (Buffer, Buffer)
+break p xs = unsafeSplitAt (findIndexOrEnd p xs) xs
+#if __GLASGOW_HASKELL__ 
+{-# INLINE [1] break #-}
+#endif
+
+#if __GLASGOW_HASKELL__ >= 606
+-- This RULE LHS is not allowed by ghc-6.4
+{-# RULES
+"Buffer specialise break (x==)" forall x.
+    break ((==) x) = breakByte x
+"Buffer specialise break (==x)" forall x.
+    break (==x) = breakByte x
+  #-}
+#endif
+
+-- INTERNAL:
+
+-- | 'breakByte' breaks its Buffer argument at the first occurence
+-- of the specified byte. It is more efficient than 'break' as it is
+-- implemented with @memchr(3)@. I.e.
+-- 
+-- > break (=='c') "abcd" == breakByte 'c' "abcd"
+--
+breakByte :: Word8 -> Buffer -> (Buffer, Buffer)
+breakByte c p = case elemIndex c p of
+    Nothing -> (p, empty)
+    Just n  -> unsafeSplitAt n p
+{-# INLINE breakByte #-}
+
+-- | 'breakEnd' behaves like 'break' but from the end of the 'Buffer'
+-- 
+-- breakEnd p == spanEnd (not.p)
+breakEnd :: (Word8 -> Bool) -> Buffer -> (Buffer, Buffer)
+breakEnd  p xs = splitAt (findFromEndUntil p xs) xs
+
+-- | 'span' @p xs@ breaks the Buffer into two segments. It is
+-- equivalent to @('takeWhile' p xs, 'dropWhile' p xs)@
+span :: (Word8 -> Bool) -> Buffer -> (Buffer, Buffer)
+span p xs = break (not . p) xs
+#if __GLASGOW_HASKELL__
+{-# INLINE [1] span #-}
+#endif
+
+-- | 'spanByte' breaks its Buffer argument at the first
+-- occurence of a byte other than its argument. It is more efficient
+-- than 'span (==)'
+--
+-- > span  (=='c') "abcd" == spanByte 'c' "abcd"
+--
+--
+-- TODO: replace use of unsafeSplitAt, to avoid traversing the span twice, we know the count of tailbytes
+spanByte :: Word8 -> Buffer -> (Buffer, Buffer)
+spanByte c xs@(PS x s l e)
+    | ix == 0   = (xs, empty)
+    | ix == l   = (empty, xs)
+    | otherwise = (PS x s ix e', PS x (s + ix) (l - ix) (e - e'))
+  where
+    ix = inlinePerformIO $ withForeignPtr x $ \p -> go (p `plusPtr` s) 0
+    e' = extra c * ix
+    STRICT2(go)
+    go p i | i >= l    = return l
+           | otherwise = do c' <- peekByteOff p i
+                            if c /= c'
+                                then return i
+                                else go p (i+1)
+{-# INLINE spanByte #-}
+
+#if __GLASGOW_HASKELL__ >= 606
+-- This RULE LHS is not allowed by ghc-6.4
+{-# RULES
+"Buffer specialise span (x==)" forall x.
+    span ((==) x) = spanByte x
+"Buffer specialise span (==x)" forall x.
+    span (==x) = spanByte x
+  #-}
+#endif
+
+-- | 'spanEnd' behaves like 'span' but from the end of the 'Buffer'.
+-- We have
+--
+-- > spanEnd (not.isSpace) "x y z" == ("x y ","z")
+--
+-- and
+--
+-- > spanEnd (not . isSpace) ps
+-- >    == 
+-- > let (x,y) = span (not.isSpace) (reverse ps) in (reverse y, reverse x) 
+--
+spanEnd :: (Word8 -> Bool) -> Buffer -> (Buffer, Buffer)
+spanEnd p xs = splitAt (findFromEndUntil (not.p) xs) xs
+
+-- | /O(n)/ Splits a 'Buffer' into components delimited by
+-- separators, where the predicate returns True for a separator element.
+-- The resulting components do not contain the separators.  Two adjacent
+-- separators result in an empty component in the output.  eg.
+--
+-- > splitWith (=='a') "aabbaca" == ["","","bb","c",""]
+-- > splitWith (=='a') []        == []
+--
+splitWith :: (Word8 -> Bool) -> Buffer -> [Buffer]
+
+#if defined(__GLASGOW_HASKELL__)
+splitWith _pred (PS _  _   0 _) = []
+splitWith pred_ (PS fp off len 0) = splitWith0 pred# off len fp
+  where pred# c# = pred_ (W8# c#)
+
+        STRICT4(splitWith0)
+        splitWith0 pred' off' len' fp' = withPtr fp $ \p ->
+            splitLoop pred' p 0 off' len' fp'
+
+        splitLoop :: (Word# -> Bool)
+                  -> Ptr Word8
+                  -> Int -> Int -> Int
+                  -> ForeignPtr Word8
+                  -> IO [Buffer]
+
+        splitLoop pred' p idx' off' len' fp'
+            | idx' >= len'  = return [PS fp' off' idx' 0]
+            | otherwise = do
+                w <- peekElemOff p (off'+idx')
+                if pred' (case w of W8# w# -> w#)
+                   then return (PS fp' off' idx' 0 :
+                              splitWith0 pred' (off'+idx'+1) (len'-idx'-1) fp')
+                   else splitLoop pred' p (idx'+1) off' len' fp'
+splitWith pred_ (PS fp off len _) = splitWith0 pred# off len fp
+  where pred# c# = pred_ (W8# c#)
+
+        STRICT4(splitWith0)
+        splitWith0 pred' off' len' fp' = withPtr fp $ \p ->
+            splitLoop pred' p 0 off' len' fp'
+
+        splitLoop :: (Word# -> Bool)
+                  -> Ptr Word8
+                  -> Int -> Int -> Int
+                  -> ForeignPtr Word8
+                  -> IO [Buffer]
+
+        splitLoop pred' p idx' off' len' fp'
+            | idx' >= len'  = return [ps fp' off' idx']
+            | otherwise = do
+                w <- peekElemOff p (off'+idx')
+                if pred' (case w of W8# w# -> w#)
+                   then return (ps fp' off' idx' :
+                              splitWith0 pred' (off'+idx'+1) (len'-idx'-1) fp')
+                   else splitLoop pred' p (idx'+1) off' len' fp'
+{-# INLINE splitWith #-}
+
+#else
+splitWith _ (PS _ _ 0) = []
+splitWith p ps = loop p ps
+    where
+        STRICT2(loop)
+        loop q qs = if null rest then [chunk]
+                                 else chunk : loop q (unsafeTail rest)
+            where (chunk,rest) = break q qs
+#endif
+
+-- | /O(n)/ Break a 'Buffer' into pieces separated by the byte
+-- argument, consuming the delimiter. I.e.
+--
+-- > split '\n' "a\nb\nd\ne" == ["a","b","d","e"]
+-- > split 'a'  "aXaXaXa"    == ["","X","X","X",""]
+-- > split 'x'  "x"          == ["",""]
+-- 
+-- and
+--
+-- > intercalate [c] . split c == id
+-- > split == splitWith . (==)
+-- 
+-- As for all splitting functions in this library, this function does
+-- not copy the substrings, it just constructs new 'Buffers' that
+-- are slices of the original.
+--
+split :: Word8 -> Buffer -> [Buffer]
+split _ (PS _ _ 0 _) = []
+split w (PS x s l 0) 
+    | w >= 0x80 && w < 0xc0 = [] 
+    | otherwise = loop 0
+    where
+        STRICT1(loop)
+        loop n =
+            let q = inlinePerformIO $ withForeignPtr x $ \p ->
+                      memchr (p `plusPtr` (s+n))
+                             w (fromIntegral (l-n))
+            in if q == nullPtr
+                then [PS x (s+n) (l-n) 0]
+                else let i = inlinePerformIO $ withForeignPtr x $ \p ->
+                               return (q `minusPtr` (p `plusPtr` s))
+                      in PS x (s+n) (i-n) 0 : loop (i+1)
+split w (PS x s l _) = loop 0
+    where
+        STRICT1(loop)
+        loop n =
+            let q = inlinePerformIO $ withForeignPtr x $ \p ->
+                      memchr (p `plusPtr` (s+n))
+                             w (fromIntegral (l-n))
+            in if q == nullPtr
+                then [ps x (s+n) (l-n)]
+                else let i = inlinePerformIO $ withForeignPtr x $ \p ->
+                               return (q `minusPtr` (p `plusPtr` s))
+                      in ps x (s+n) (i-n) : loop (i+1)
+
+{-# INLINE split #-}
+
+{-
+-- slower. but stays inside Haskell.
+split _ (PS _  _   0) = []
+split (W8# w#) (PS fp off len) = splitWith' off len fp
+    where
+        splitWith' off' len' fp' = withPtr fp $ \p ->
+            splitLoop p 0 off' len' fp'
+
+        splitLoop :: Ptr Word8
+                  -> Int -> Int -> Int
+                  -> ForeignPtr Word8
+                  -> IO [Buffer]
+
+        STRICT5(splitLoop)
+        splitLoop p idx' off' len' fp'
+            | idx' >= len'  = return [PS fp' off' idx']
+            | otherwise = do
+                (W8# x#) <- peekElemOff p (off'+idx')
+                if word2Int# w# ==# word2Int# x#
+                   then return (PS fp' off' idx' :
+                              splitWith' (off'+idx'+1) (len'-idx'-1) fp')
+                   else splitLoop p (idx'+1) off' len' fp'
+-}
+
+{-
+-- | Like 'splitWith', except that sequences of adjacent separators are
+-- treated as a single separator. eg.
+-- 
+-- > tokens (=='a') "aabbaca" == ["bb","c"]
+--
+tokens :: (Word8 -> Bool) -> Buffer -> [Buffer]
+tokens f = P.filter (not.null) . splitWith f
+{-# INLINE tokens #-}
+-}
+
+-- | The 'group' function takes a Buffer and returns a list of
+-- Buffers such that the concatenation of the result is equal to the
+-- argument.  Moreover, each sublist in the result contains only equal
+-- elements.  For example,
+--
+-- > group "Mississippi" = ["M","i","ss","i","ss","i","pp","i"]
+--
+-- It is a special case of 'groupBy', which allows the programmer to
+-- supply their own equality test. It is about 40% faster than 
+-- /groupBy (==)/
+group :: Buffer -> [Buffer]
+group xs
+    | null xs   = []
+    | otherwise = ys : group zs
+    where
+        (ys, zs) = spanByte (unsafeHead xs) xs
+
+-- | The 'groupBy' function is the non-overloaded version of 'group'.
+groupBy :: (Word8 -> Word8 -> Bool) -> Buffer -> [Buffer]
+groupBy k xs
+    | null xs   = []
+    | otherwise = unsafeTake n xs : groupBy k (unsafeDrop n xs)
+    where
+        n = 1 + findIndexOrEnd (not . k (unsafeHead xs)) (unsafeTail xs)
+
+-- | /O(n)/ The 'intercalate' function takes a 'Buffer' and a list of
+-- 'Buffer's and concatenates the list after interspersing the first
+-- argument between each element of the list.
+intercalate :: Buffer -> [Buffer] -> Buffer
+intercalate s = concat . (List.intersperse s)
+{-# INLINE [1] intercalate #-}
+
+{-# RULES
+"Buffer specialise intercalate c -> intercalateByte" forall c s1 s2 .
+    intercalate (singleton c) (s1 : s2 : []) = intercalateWithByte c s1 s2
+  #-}
+
+-- | /O(n)/ intercalateWithByte. An efficient way to join to two Buffers
+-- with a char. Around 4 times faster than the generalised join.
+--
+intercalateWithByte :: Word8 -> Buffer -> Buffer -> Buffer
+intercalateWithByte c f@(PS ffp s l n) g@(PS fgp t m o) = unsafeCreate' len $ \ptr ->
+    withForeignPtr ffp $ \fp ->
+    withForeignPtr fgp $ \gp -> do
+        memcpy ptr (fp `plusPtr` s) (fromIntegral l)
+        poke (ptr `plusPtr` l) c
+        memcpy (ptr `plusPtr` (l + 1)) (gp `plusPtr` t) (fromIntegral m)
+        return $! (n + o) `plusExtra` c
+    where
+      len = length f + length g + 1
+{-# INLINE intercalateWithByte #-}
+
+-- ---------------------------------------------------------------------
+-- Indexing Buffers
+
+-- | /O(1)/ 'Buffer' index (subscript) operator, starting from 0.
+index :: Buffer -> Int -> Word8
+index xs n
+    | n < 0          = moduleError "index" ("negative index: " ++ show n)
+    | n >= length xs = moduleError "index" ("index too large: " ++ show n
+                                         ++ ", length = " ++ show (length xs))
+    | otherwise      = xs `unsafeIndex` n
+{-# INLINE index #-}
+
+-- | /O(n)/ The 'elemIndex' function returns the index of the first
+-- element in the given 'Buffer' which is equal to the query
+-- element, or 'Nothing' if there is no such element. 
+-- This implementation uses memchr(3).
+elemIndex :: Word8 -> Buffer -> Maybe Int
+elemIndex c (PS x s l e) 
+   | e == 0 && c >= 0x80 && c < 0xC0 = Nothing
+   | otherwise = inlinePerformIO $ withForeignPtr x $ \p -> do
+    let p' = p `plusPtr` s
+    q <- memchr p' c (fromIntegral l)
+    return $! if q == nullPtr then Nothing else Just $! q `minusPtr` p'
+{-# INLINE elemIndex #-}
+
+-- | /O(n)/ The 'elemIndexEnd' function returns the last index of the
+-- element in the given 'Buffer' which is equal to the query
+-- element, or 'Nothing' if there is no such element. The following
+-- holds:
+--
+-- > elemIndexEnd c xs == 
+-- > (-) (length xs - 1) `fmap` elemIndex c (reverse xs)
+--
+elemIndexEnd :: Word8 -> Buffer -> Maybe Int
+elemIndexEnd ch (PS x s l e) 
+   | e == 0 && ch >= 0x80 && ch < 0xC0 = Nothing
+   | otherwise = inlinePerformIO $ withForeignPtr x $ \p -> go (p `plusPtr` s) (l-1)
+  where
+    STRICT2(go)
+    go p i | i < 0     = return Nothing
+           | otherwise = do ch' <- peekByteOff p i
+                            if ch == ch'
+                                then return $ Just i
+                                else go p (i-1)
+{-# INLINE elemIndexEnd #-}
+
+-- | /O(n)/ The 'elemIndices' function extends 'elemIndex', by returning
+-- the indices of all elements equal to the query element, in ascending order.
+-- This implementation uses memchr(3).
+elemIndices :: Word8 -> Buffer -> [Int]
+elemIndices w (PS x s l e) 
+   | e == 0 && w >= 0x80 && w < 0xC0 = []
+   | otherwise = loop 0
+    where
+        STRICT1(loop)
+        loop n = let q = inlinePerformIO $ withForeignPtr x $ \p ->
+                           memchr (p `plusPtr` (n+s))
+                                                w (fromIntegral (l - n))
+                 in if q == nullPtr
+                        then []
+                        else let i = inlinePerformIO $ withForeignPtr x $ \p ->
+                                       return (q `minusPtr` (p `plusPtr` s))
+                             in i : loop (i+1)
+{-# INLINE elemIndices #-}
+
+{-
+-- much slower
+elemIndices :: Word8 -> Buffer -> [Int]
+elemIndices c ps = loop 0 ps
+   where STRICT2(loop)
+         loop _ ps' | null ps'            = []
+         loop n ps' | c == unsafeHead ps' = n : loop (n+1) (unsafeTail ps')
+                    | otherwise           = loop (n+1) (unsafeTail ps')
+-}
+
+-- | count returns the number of times its argument appears in the Buffer
+--
+-- > count = length . elemIndices
+--
+-- But more efficiently than using length on the intermediate list.
+count :: Word8 -> Buffer -> Int
+count w (PS x s m e) 
+    | e == 0 && w >= 0x80 && w < 0xC0 = 0 
+    | otherwise = inlinePerformIO $ withForeignPtr x $ \p ->
+        fmap fromIntegral $ c_count (p `plusPtr` s) (fromIntegral m) w
+{-# INLINE count #-}
+
+{-
+--
+-- around 30% slower
+--
+count w (PS x s m) = inlinePerformIO $ withForeignPtr x $ \p ->
+     go (p `plusPtr` s) (fromIntegral m) 0
+    where
+        go :: Ptr Word8 -> CSize -> Int -> IO Int
+        STRICT3(go)
+        go p l i = do
+            q <- memchr p w l
+            if q == nullPtr
+                then return i
+                else do let k = fromIntegral $ q `minusPtr` p
+                        go (q `plusPtr` 1) (l-k-1) (i+1)
+-}
+
+-- | The 'findIndex' function takes a predicate and a 'Buffer' and
+-- returns the index of the first element in the Buffer
+-- satisfying the predicate.
+findIndex :: (Word8 -> Bool) -> Buffer -> Maybe Int
+findIndex k (PS x s l _) = inlinePerformIO $ withForeignPtr x $ \f -> go (f `plusPtr` s) 0
+  where
+    STRICT2(go)
+    go ptr n | n >= l    = return Nothing
+             | otherwise = do w <- peek ptr
+                              if k w
+                                then return (Just n)
+                                else go (ptr `plusPtr` 1) (n+1)
+{-# INLINE findIndex #-}
+
+-- | The 'findIndices' function extends 'findIndex', by returning the
+-- indices of all elements satisfying the predicate, in ascending order.
+findIndices :: (Word8 -> Bool) -> Buffer -> [Int]
+findIndices p xs = loop 0 xs
+   where
+     STRICT2(loop)
+     loop n qs | null qs           = []
+               | p (unsafeHead qs) = n : loop (n+1) (unsafeTail qs)
+               | otherwise         =     loop (n+1) (unsafeTail qs)
+
+-- ---------------------------------------------------------------------
+-- Searching Buffers
+
+-- | /O(n)/ 'elem' is the 'Buffer' membership predicate.
+elem :: Word8 -> Buffer -> Bool
+elem c xs = case elemIndex c xs of Nothing -> False ; _ -> True
+{-# INLINE elem #-}
+
+-- | /O(n)/ 'notElem' is the inverse of 'elem'
+notElem :: Word8 -> Buffer -> Bool
+notElem c xs = not (elem c xs)
+{-# INLINE notElem #-}
+
+-- | /O(n)/ 'filter', applied to a predicate and a Buffer,
+-- returns a Buffer containing those characters that satisfy the
+-- predicate. This function is subject to array fusion.
+
+-- TODO: this could check to see if the input has 0 tail bytes, then perforce
+-- the output will as well, avoiding an extra traversal of the trimmed output
+-- and in the case when it wasn't 0 it could fuse the extra counting step into the loop
+filter :: (Word8 -> Bool) -> Buffer -> Buffer
+filter k xs@(PS x s l _)
+    | l <= 0 = xs
+    | otherwise = unsafePerformIO $ createAndTrim l $ \p -> withForeignPtr x $ \f -> do
+        t <- go (f `plusPtr` s) p (f `plusPtr` (s + l))
+        return $! t `minusPtr` p -- actual length
+    where
+        STRICT3(go)
+        go f t end | f == end  = return t
+                   | otherwise = do
+                        w <- peek f
+                        if k w
+                            then poke t w >> go (f `plusPtr` 1) (t `plusPtr` 1) end
+                            else             go (f `plusPtr` 1) t               end
+{-# INLINE filter #-}
+
+{-
+--
+-- | /O(n)/ A first order equivalent of /filter . (==)/, for the common
+-- case of filtering a single byte. It is more efficient to use
+-- /filterByte/ in this case.
+--
+-- > filterByte == filter . (==)
+--
+-- filterByte is around 10x faster, and uses much less space, than its
+-- filter equivalent
+--
+filterByte :: Word8 -> Buffer -> Buffer
+filterByte w ps = replicate (count w ps) w
+{-# INLINE filterByte #-}
+
+{-# RULES
+"Buffer specialise filter (== x)" forall x.
+    filter ((==) x) = filterByte x
+"Buffer specialise filter (== x)" forall x.
+    filter (== x) = filterByte x
+  #-}
+-}
+
+-- | /O(n)/ The 'find' function takes a predicate and a Buffer,
+-- and returns the first element in matching the predicate, or 'Nothing'
+-- if there is no such element.
+--
+-- > find f p = case findIndex f p of Just n -> Just (p ! n) ; _ -> Nothing
+--
+find :: (Word8 -> Bool) -> Buffer -> Maybe Word8
+find f p = case findIndex f p of
+                    Just n -> Just (p `unsafeIndex` n)
+                    _      -> Nothing
+{-# INLINE find #-}
+
+{-
+--
+-- fuseable, but we don't want to walk the whole array.
+-- 
+find k = foldl findEFL Nothing
+    where findEFL a@(Just _) _ = a
+          findEFL _          c | k c       = Just c
+                               | otherwise = Nothing
+-}
+
+-- | /O(n)/ The 'partition' function takes a predicate a Buffer and returns
+-- the pair of Buffers with elements which do and do not satisfy the
+-- predicate, respectively; i.e.,
+--
+-- > partition p bs == (filter p xs, filter (not . p) xs)
+--
+partition :: (Word8 -> Bool) -> Buffer -> (Buffer, Buffer)
+partition p bs = (filter p bs, filter (not . p) bs)
+--TODO: use a better implementation
+
+-- ---------------------------------------------------------------------
+-- Searching for substrings
+
+-- | /O(n)/ The 'isPrefixOf' function takes two Buffers and returns 'True'
+-- iff the first is a prefix of the second.
+isPrefixOf :: Buffer -> Buffer -> Bool
+isPrefixOf (PS x1 s1 l1 _) (PS x2 s2 l2 _)
+    | l1 == 0   = True
+    | l2 < l1   = False
+    | otherwise = inlinePerformIO $ withForeignPtr x1 $ \p1 ->
+        withForeignPtr x2 $ \p2 -> do
+            i <- memcmp (p1 `plusPtr` s1) (p2 `plusPtr` s2) (fromIntegral l1)
+            return $! i == 0
+
+-- | /O(n)/ The 'isSuffixOf' function takes two Buffers and returns 'True'
+-- iff the first is a suffix of the second.
+-- 
+-- The following holds:
+--
+-- > isSuffixOf x y == reverse x `isPrefixOf` reverse y
+--
+-- However, the real implemenation uses memcmp to compare the end of the
+-- string only, with no reverse required..
+isSuffixOf :: Buffer -> Buffer -> Bool
+isSuffixOf (PS x1 s1 l1 _) (PS x2 s2 l2 _)
+    | l1 == 0   = True
+    | l2 < l1   = False
+    | otherwise = inlinePerformIO $ withForeignPtr x1 $ \p1 ->
+        withForeignPtr x2 $ \p2 -> do
+            i <- memcmp (p1 `plusPtr` s1) (p2 `plusPtr` s2 `plusPtr` (l2 - l1)) (fromIntegral l1)
+            return $! i == 0
+
+-- | Check whether one string is a substring of another. @isInfixOf
+-- p s@ is equivalent to @not (null (findSubstrings p s))@.
+isInfixOf :: Buffer -> Buffer -> Bool
+isInfixOf p s = null p || not (null (snd (breakSubstring p s)))
+
+-- | Break a string on a substring, returning a pair of the part of the
+-- string prior to the match, and the rest of the string.
+--
+-- The following relationships hold:
+--
+-- > break (== c) l == breakSubstring (singleton c) l
+--
+-- and:
+--
+-- > findSubstring s l ==
+-- >    if null s then Just 0
+-- >              else case breakSubstring s l of
+-- >                       (x,y) | null y    -> Nothing
+-- >                             | otherwise -> Just (length x)
+--
+-- For example, to tokenise a string, dropping delimiters:
+--
+-- > tokenise x y = h : if null t then [] else tokenise x (drop (length x) t)
+-- >     where (h,t) = breakSubstring x y
+--
+-- To skip to the first occurence of a string:
+-- 
+-- > snd (breakSubstring x y) 
+--
+-- To take the parts of a string before a delimiter:
+--
+-- > fst (breakSubstring x y) 
+--
+breakSubstring :: Buffer -- ^ String to search for
+               -> Buffer -- ^ String to search in
+               -> (Buffer,Buffer) -- ^ Head and tail of string broken at substring
+
+breakSubstring pat src = search 0 src
+  where
+    STRICT2(search)
+    search n s
+        | null s             = (src,empty)      -- not found
+        | pat `isPrefixOf` s = (take n src,s)
+        | otherwise          = search (n+1) (unsafeTail s)
+
+{-
+{- This function uses the Knuth-Morris-Pratt string matching algorithm.  -}
+
+findSubstrings pat@(PS _ _ m) str@(PS _ _ n) = search 0 0
+  where
+      patc x = pat `unsafeIndex` x
+      strc x = str `unsafeIndex` x
+
+      -- maybe we should make kmpNext a UArray before using it in search?
+      kmpNext = listArray (0,m) (-1:kmpNextL pat (-1))
+      kmpNextL p _ | null p = []
+      kmpNextL p j = let j' = next (unsafeHead p) j + 1
+                         ps = unsafeTail p
+                         x = if not (null ps) && unsafeHead ps == patc j'
+                                then kmpNext Array.! j' else j'
+                        in x:kmpNextL ps j'
+      search i j = match ++ rest -- i: position in string, j: position in pattern
+        where match = if j == m then [(i - j)] else []
+              rest = if i == n then [] else search (i+1) (next (strc i) j + 1)
+      next c j | j >= 0 && (j == m || c /= patc j) = next c (kmpNext Array.! j)
+               | otherwise = j
+-}
+
+-- ---------------------------------------------------------------------
+-- Zipping
+
+-- | /O(n)/ 'zip' takes two Buffers and returns a list of
+-- corresponding pairs of bytes. If one input Buffer is short,
+-- excess elements of the longer Buffer are discarded. This is
+-- equivalent to a pair of 'unpack' operations.
+zip :: Buffer -> Buffer -> [(Word8,Word8)]
+zip xs ys
+    | null xs || null ys = []
+    | otherwise = (unsafeHead xs, unsafeHead ys) : zip (unsafeTail xs) (unsafeTail ys)
+
+-- | 'zipWith' generalises 'zip' by zipping with the function given as
+-- the first argument, instead of a tupling function.  For example,
+-- @'zipWith' (+)@ is applied to two Buffers to produce the list of
+-- corresponding sums. 
+zipWith :: (Word8 -> Word8 -> a) -> Buffer -> Buffer -> [a]
+zipWith f xs ys
+    | null xs || null ys = []
+    | otherwise = f (unsafeHead xs) (unsafeHead ys) : zipWith f (unsafeTail xs) (unsafeTail ys)
+
+--
+-- | A specialised version of zipWith for the common case of a
+-- simultaneous map over two Buffers, to build a 3rd. Rewrite rules
+-- are used to automatically covert zipWith into zipWith' when a pack is
+-- performed on the result of zipWith.
+--
+zipWith' :: (Word8 -> Word8 -> Word8) -> Buffer -> Buffer -> Buffer
+zipWith' f (PS fp s l _) (PS fq t m _) = inlinePerformIO $
+    withForeignPtr fp $ \a ->
+    withForeignPtr fq $ \b ->
+    create len $ zipWith_ 0 (a `plusPtr` s) (b `plusPtr` t)
+  where
+    zipWith_ :: Int -> Ptr Word8 -> Ptr Word8 -> Ptr Word8 -> IO ()
+    STRICT4(zipWith_)
+    zipWith_ n p1 p2 r
+       | n >= len = return ()
+       | otherwise = do
+            x <- peekByteOff p1 n
+            y <- peekByteOff p2 n
+            pokeByteOff r n (f x y)
+            zipWith_ (n+1) p1 p2 r
+
+    len = min l m
+{-# INLINE zipWith' #-}
+
+{-# RULES
+"Buffer specialise zipWith" forall (f :: Word8 -> Word8 -> Word8) p q .
+    zipWith f p q = unpack (zipWith' f p q)
+  #-}
+
+-- | /O(n)/ 'unzip' transforms a list of pairs of bytes into a pair of
+-- Buffers. Note that this performs two 'pack' operations.
+unzip :: [(Word8,Word8)] -> (Buffer,Buffer)
+unzip ls = (pack (P.map fst ls), pack (P.map snd ls))
+{-# INLINE unzip #-}
+
+-- ---------------------------------------------------------------------
+-- Special lists
+
+-- | /O(n)/ Return all initial segments of the given 'Buffer', shortest first.
+inits :: Buffer -> [Buffer]
+inits (PS x s l _) = go 0 0 where
+    STRICT2(go)
+    go i e' = PS x s i e' 
+            : if i == l 
+              then []
+              else go i $! 
+                   plusExtra e' $! 
+                   inlinePerformIO $ withForeignPtr x $ \p -> peekByteOff p (s + i)
+
+-- | /O(n)/ Return all final segments of the given 'Buffer', longest first.
+tails :: Buffer -> [Buffer]
+tails p | null p    = [empty]
+        | otherwise = p : tails (unsafeTail p)
+
+-- less efficent spacewise: tails (PS x s l) = [PS x (s+n) (l-n) | n <- [0..l]]
+
+-- ---------------------------------------------------------------------
+-- ** Ordered 'Buffer's
+
+-- | /O(n)/ Sort a Buffer efficiently, using counting sort.
+sort :: Buffer -> Buffer
+sort (PS input s l e) = unsafeCreate' l $ \p -> 
+                        allocaArray 256 $ \arr -> do
+    _ <- memset (castPtr arr) 0 $! 256 * fromIntegral (sizeOf (undefined :: CSize))
+    withForeignPtr input $ \x -> countOccurrences arr (x `plusPtr` s) l
+    let STRICT2(go)
+        go 256 _   = return ()
+        go i   ptr = do n <- peekElemOff arr i
+                        when (n /= 0) $ memset ptr (fromIntegral i) n >> return ()
+                        go (i + 1) (ptr `plusPtr` (fromIntegral n))
+    go 0 p
+    return e
+  where
+    -- | Count the number of occurrences of each byte.
+    -- Used by 'sort'
+    --
+    countOccurrences :: Ptr CSize -> Ptr Word8 -> Int -> IO ()
+    STRICT3(countOccurrences)
+    countOccurrences counts str len = go 0
+     where
+        STRICT1(go)
+        go i | i == len    = return ()
+             | otherwise = do k <- fromIntegral `fmap` peekElemOff str i
+                              x <- peekElemOff counts k
+                              pokeElemOff counts k (x + 1)
+                              go (i + 1)
+
+{-
+sort :: Buffer -> Buffer
+sort (PS x s l) = unsafeCreate l $ \p -> withForeignPtr x $ \f -> do
+        memcpy p (f `plusPtr` s) l
+        c_qsort p l -- inplace
+-}
+
+-- The 'sortBy' function is the non-overloaded version of 'sort'.
+--
+-- Try some linear sorts: radix, counting
+-- Or mergesort.
+--
+-- sortBy :: (Word8 -> Word8 -> Ordering) -> Buffer -> Buffer
+-- sortBy f ps = undefined
+
+-- ---------------------------------------------------------------------
+-- Low level constructors
+
+-- | /O(n) construction/ Use a @Buffer@ with a function requiring a
+-- null-terminated @CString@.  The @CString@ will be freed
+-- automatically. This is a memcpy(3).
+useAsCString :: Buffer -> (CString -> IO a) -> IO a
+useAsCString (PS fp o l _) action = do
+ allocaBytes (l+1) $ \buf ->
+   withForeignPtr fp $ \p -> do
+     memcpy buf (p `plusPtr` o) (fromIntegral l)
+     pokeByteOff buf l (0::Word8)
+     action (castPtr buf)
+
+-- | /O(n) construction/ Use a @Buffer@ with a function requiring a @CStringLen@.
+-- As for @useAsCString@ this function makes a copy of the original @Buffer@.
+useAsCStringLen :: Buffer -> (CStringLen -> IO a) -> IO a
+useAsCStringLen p@(PS _ _ l _) f = useAsCString p $ \cstr -> f (cstr,l)
+
+------------------------------------------------------------------------
+
+-- | /O(n)./ Construct a new @Buffer@ from a @CString@. The
+-- resulting @Buffer@ is an immutable copy of the original
+-- @CString@, and is managed on the Haskell heap. The original
+-- @CString@ must be null terminated.
+packCString :: CString -> IO Buffer
+packCString cstr = do
+    len <- c_strlen cstr
+    packCStringLen (cstr, fromIntegral len)
+
+-- | /O(n)./ Construct a new @Buffer@ from a @CStringLen@. The
+-- resulting @Buffer@ is an immutable copy of the original @CStringLen@.
+-- The @Buffer@ is a normal Haskell value and will be managed on the
+-- Haskell heap.
+packCStringLen :: CStringLen -> IO Buffer
+packCStringLen (cstr, len) | len >= 0 = create len $ \p ->
+    memcpy p (castPtr cstr) (fromIntegral len)
+packCStringLen (_, len) =
+    moduleError "packCStringLen" ("negative length: " ++ show len)
+
+------------------------------------------------------------------------
+
+-- | /O(n)/ Make a copy of the 'Buffer' with its own storage. 
+-- This is mainly useful to allow the rest of the data pointed
+-- to by the 'Buffer' to be garbage collected, for example
+-- if a large string has been read in, and only a small part of it 
+-- is needed in the rest of the program.
+-- 
+copy :: Buffer -> Buffer
+copy (PS x s l e) = unsafeCreate' l $ \p -> withForeignPtr x $ \f -> do
+    memcpy p (f `plusPtr` s) (fromIntegral l)
+    return e
+
+-- ---------------------------------------------------------------------
+-- Line IO
+
+-- | Read a line from stdin.
+getLine :: IO Buffer
+getLine = hGetLine stdin
+
+-- | Read a line from a handle
+
+hGetLine :: Handle -> IO Buffer
+
+#if !defined(__GLASGOW_HASKELL__)
+
+hGetLine h = System.IO.hGetLine h >>= return . pack . P.map c2w
+
+#elif __GLASGOW_HASKELL__ >= 611
+
+hGetLine h =
+  wantReadableHandle_ "Data.Buffer.hGetLine" h $
+    \ h_@Handle__{haByteBuffer} -> do
+      flushCharReadBuffer h_
+      buf <- readIORef haByteBuffer
+      if isEmptyBuffer buf
+         then fill h_ buf 0 []
+         else haveBuf h_ buf 0 []
+ where
+
+  fill h_@Handle__{haByteBuffer,haDevice} buf len xss =
+    len `seq` do
+    (r,buf') <- Buffered.fillReadBuffer haDevice buf
+    if r == 0
+       then do writeIORef haByteBuffer buf{ bufR=0, bufL=0 }
+               if len > 0
+                  then mkBigPS len xss
+                  else ioe_EOF
+       else haveBuf h_ buf' len xss
+
+  haveBuf h_@Handle__{haByteBuffer}
+          buf@IOBase.Buffer{ bufRaw=raw, bufR=w, bufL=r }
+          len xss =
+    do
+        off <- findEOL r w raw
+        let new_len = len + off - r
+        xs <- mkPS raw r off
+
+      -- if eol == True, then off is the offset of the '\n'
+      -- otherwise off == w and the buffer is now empty.
+        if off /= w
+            then do if (w == off + 1)
+                            then writeIORef haByteBuffer buf{ bufL=0, bufR=0 }
+                            else writeIORef haByteBuffer buf{ bufL = off + 1 }
+                    mkBigPS new_len (xs:xss)
+            else do
+                 fill h_ buf{ bufL=0, bufR=0 } new_len (xs:xss)
+
+  -- find the end-of-line character, if there is one
+  findEOL r w raw
+        | r == w = return w
+        | otherwise =  do
+            c <- readWord8Buf raw r
+            if c == fromIntegral (ord '\n')
+                then return r -- NB. not r+1: don't include the '\n'
+                else findEOL (r+1) w raw
+
+mkPS :: RawBuffer Word8 -> Int -> Int -> IO Buffer
+mkPS buf start end =
+ create len $ \p ->
+   withRawBuffer buf $ \pbuf -> do
+   copyBytes p (pbuf `plusPtr` start) len
+ where
+   len = end - start
+
+#else
+-- GHC 6.10 and older, pre-Unicode IO library
+
+hGetLine h = wantReadableHandle "Data.Buffer.hGetLine" h $ \ handle_ -> do
+    case haBufferMode handle_ of
+       NoBuffering -> error "no buffering"
+       _other      -> hGetLineBuffered handle_
+
+ where
+    hGetLineBuffered handle_ = do
+        let ref = haBuffer handle_
+        buf <- readIORef ref
+        hGetLineBufferedLoop handle_ ref buf 0 []
+
+    hGetLineBufferedLoop handle_ ref
+            buf@IOBase.Buffer{ bufRPtr=r, bufWPtr=w, bufBuf=raw } len xss =
+        len `seq` do
+        off <- findEOL r w raw
+        let new_len = len + off - r
+        xs <- mkPS raw r off
+
+      -- if eol == True, then off is the offset of the '\n'
+      -- otherwise off == w and the buffer is now empty.
+        if off /= w
+            then do if (w == off + 1)
+                            then writeIORef ref buf{ bufRPtr=0, bufWPtr=0 }
+                            else writeIORef ref buf{ bufRPtr = off + 1 }
+                    mkBigPS new_len (xs:xss)
+            else do
+                 maybe_buf <- maybeFillReadBuffer (haFD handle_) True (haIsStream handle_)
+                                    buf{ bufWPtr=0, bufRPtr=0 }
+                 case maybe_buf of
+                    -- Nothing indicates we caught an EOF, and we may have a
+                    -- partial line to return.
+                    Nothing -> do
+                         writeIORef ref buf{ bufRPtr=0, bufWPtr=0 }
+                         if new_len > 0
+                            then mkBigPS new_len (xs:xss)
+                            else ioe_EOF
+                    Just new_buf ->
+                         hGetLineBufferedLoop handle_ ref new_buf new_len (xs:xss)
+
+    -- find the end-of-line character, if there is one
+    findEOL r w raw
+        | r == w = return w
+        | otherwise =  do
+            (c,r') <- readCharFromBuffer raw r
+            if c == '\n'
+                then return r -- NB. not r': don't include the '\n'
+                else findEOL r' w raw
+
+    maybeFillReadBuffer fd is_line is_stream buf = catch
+        (do buf' <- fillReadBuffer fd is_line is_stream buf
+            return (Just buf'))
+        (\e -> if isEOFError e then return Nothing else ioError e)
+
+-- TODO, rewrite to use normal memcpy
+mkPS :: RawBuffer -> Int -> Int -> IO Buffer
+mkPS buf start end =
+    let len = end - start
+    in create len $ \p -> do
+        memcpy_ptr_baoff p buf (fromIntegral start) (fromIntegral len)
+        return ()
+
+#endif
+
+mkBigPS :: Int -> [Buffer] -> IO Buffer
+mkBigPS _ [xs] = return xs
+mkBigPS _ xss = return $! concat (P.reverse xss)
+
+-- ---------------------------------------------------------------------
+-- Block IO
+
+-- | Outputs a 'Buffer' to the specified 'Handle'.
+hPut :: Handle -> Buffer -> IO ()
+hPut _ (PS _ _ 0 _) = return ()
+hPut h (PS x s l _) = withForeignPtr x $ \p-> hPutBuf h (p `plusPtr` s) l
+
+-- | A synonym for @hPut@, for compatibility 
+hPutStr :: Handle -> Buffer -> IO ()
+hPutStr = hPut
+
+-- | Write a Buffer to a handle, appending a newline byte
+hPutStrLn :: Handle -> Buffer -> IO ()
+hPutStrLn h xs
+    | length xs < 1024 = hPut h (xs `snoc` 0x0a)
+    | otherwise        = hPut h xs >> hPut h (singleton (0x0a)) -- don't copy
+
+-- | Write a Buffer to stdout
+putStr :: Buffer -> IO ()
+putStr = hPut stdout
+
+-- | Write a Buffer to stdout, appending a newline byte
+putStrLn :: Buffer -> IO ()
+putStrLn = hPutStrLn stdout
+
+------------------------------------------------------------------------
+-- Low level IO
+
+-- | Read a 'Buffer' directly from the specified 'Handle'.  This
+-- is far more efficient than reading the characters into a 'String'
+-- and then using 'pack'. First argument is the Handle to read from, 
+-- and the second is the number of bytes to read. It returns the bytes
+-- read, up to n, or EOF.
+--
+-- 'hGet' is implemented in terms of 'hGetBuf'.
+--
+-- If the handle is a pipe or socket, and the writing end
+-- is closed, 'hGet' will behave as if EOF was reached.
+--
+hGet :: Handle -> Int -> IO Buffer
+hGet h i
+    | i >  0    = createAndTrim i $ \p -> hGetBuf h p i
+    | i == 0    = return empty
+    | otherwise = illegalBufferSize h "hGet" i
+
+-- | hGetNonBlocking is identical to 'hGet', except that it will never block
+-- waiting for data to become available, instead it returns only whatever data
+-- is available.
+--
+hGetNonBlocking :: Handle -> Int -> IO Buffer
+#if defined(__GLASGOW_HASKELL__)
+hGetNonBlocking h i
+    | i >  0    = createAndTrim i $ \p -> hGetBufNonBlocking h p i
+    | i == 0    = return empty
+    | otherwise = illegalBufferSize h "hGetNonBlocking" i
+#else
+hGetNonBlocking = hGet
+#endif
+
+illegalBufferSize :: Handle -> String -> Int -> IO a
+illegalBufferSize handle fn sz =
+    ioError (mkIOError illegalOperationErrorType msg (Just handle) Nothing)
+    --TODO: System.IO uses InvalidArgument here, but it's not exported :-(
+    where
+      msg = fn ++ ": illegal Buffer size " ++ showsPrec 9 sz []
+
+
+-- | Read entire handle contents strictly into a 'Buffer'.
+--
+-- This function reads chunks at a time, doubling the chunksize on each
+-- read. The final buffer is then realloced to the appropriate size. For
+-- files > half of available memory, this may lead to memory exhaustion.
+-- Consider using 'readFile' in this case.
+--
+-- The Handle is closed once the contents have been read,
+-- or if an exception is thrown.
+--
+hGetContents :: Handle -> IO Buffer
+hGetContents h = always (hClose h) $ do -- strict, so hClose
+    let start_size = 1024
+    p <- mallocBytes start_size
+    i <- hGetBuf h p start_size
+    if i < start_size
+        then do p' <- reallocBytes p i
+                fp <- newForeignPtr finalizerFree p'
+                return $! ps fp 0 i
+        else f p start_size
+    where
+        always = flip finally
+        f p s = do
+            let s' = 2 * s
+            p' <- reallocBytes p s'
+            i  <- hGetBuf h (p' `plusPtr` s) s
+            if i < s
+                then do let i' = s + i
+                        p'' <- reallocBytes p' i'
+                        fp  <- newForeignPtr finalizerFree p''
+                        return $! ps fp 0 i'
+                else f p' s'
+
+-- | getContents. Read stdin strictly. Equivalent to hGetContents stdin
+-- The 'Handle' is closed after the contents have been read.
+--
+getContents :: IO Buffer
+getContents = hGetContents stdin
+
+-- | The interact function takes a function of type @Buffer -> Buffer@
+-- as its argument. The entire input from the standard input device is passed
+-- to this function as its argument, and the resulting string is output on the
+-- standard output device.
+--
+interact :: (Buffer -> Buffer) -> IO ()
+interact transformer = putStr . transformer =<< getContents
+
+-- | Read an entire file strictly into a 'Buffer'.  This is far more
+-- efficient than reading the characters into a 'String' and then using
+-- 'pack'.  It also may be more efficient than opening the file and
+-- reading it using hGet. Files are read using 'binary mode' on Windows,
+-- for 'text mode' use the Char8 version of this function.
+--
+readFile :: FilePath -> IO Buffer
+readFile f = bracket (openBinaryFile f ReadMode) hClose
+    (\h -> hFileSize h >>= hGet h . fromIntegral)
+
+-- | Write a 'Buffer' to a file.
+writeFile :: FilePath -> Buffer -> IO ()
+writeFile f txt = bracket (openBinaryFile f WriteMode) hClose
+    (\h -> hPut h txt)
+
+-- | Append a 'Buffer' to a file.
+appendFile :: FilePath -> Buffer -> IO ()
+appendFile f txt = bracket (openBinaryFile f AppendMode) hClose
+    (\h -> hPut h txt)
+
+-- ---------------------------------------------------------------------
+-- Internal utilities
+
+-- | 'findIndexOrEnd' is a variant of findIndex, that returns the length
+-- of the string if no element is found, rather than Nothing.
+findIndexOrEnd :: (Word8 -> Bool) -> Buffer -> Int
+findIndexOrEnd k (PS x s l _) = inlinePerformIO $ withForeignPtr x $ \f -> go (f `plusPtr` s) 0
+  where
+    STRICT2(go)
+    go ptr n | n >= l    = return l
+             | otherwise = do w <- peek ptr
+                              if k w
+                                then return n
+                                else go (ptr `plusPtr` 1) (n+1)
+{-# INLINE findIndexOrEnd #-}
+
+-- | Perform an operation with a temporary Buffer
+withPtr :: ForeignPtr a -> (Ptr a -> IO b) -> b
+withPtr fp io = inlinePerformIO (withForeignPtr fp io)
+{-# INLINE withPtr #-}
+
+-- Common up near identical calls to `error' to reduce the number
+-- constant strings created when compiled:
+errorEmptyList :: String -> a
+errorEmptyList fun = moduleError fun "empty Buffer"
+{-# NOINLINE errorEmptyList #-}
+
+moduleError :: String -> String -> a
+moduleError fun msg = error ("Data.Buffer." ++ fun ++ ':':' ':msg)
+{-# NOINLINE moduleError #-}
+
+-- Find from the end of the string using predicate
+findFromEndUntil :: (Word8 -> Bool) -> Buffer -> Int
+STRICT2(findFromEndUntil)
+findFromEndUntil f xs@(PS x s l _) =
+    if l <= 0 then 0
+    else if f (last xs) then l
+         else findFromEndUntil f (PS x s (l-1) 0) -- HACK: invariant broken temporarily, but not saved
+
hunk ./buffer.cabal 3
-Synopsis:            Fast, packed, strict and lazy byte array fingertrees with fast character indexing
+Synopsis:            Fast, packed, UTF-8 finger trees
hunk ./buffer.cabal 7
-    of large data quantities, or high speed requirements. Byte vectors
-    are encoded as strict 'Word8' arrays of bytes, and lazy lists of
-    strict chunks, held in a 'ForeignPtr', and can be passed between C
-    and Haskell with little effort. Based on Data.ByteString with minor 
-    additions to track the number of (potential) UTF8 multibyte tail bytes 
-    present in a given buffer.
-    .
-    Test coverage data for this library is available at:
-        <http://code.haskell.org/~dons/tests/bytestring/hpc_index.html>
+    of large data quantities, or high speed requirements. Based on 
+    Data.ByteString and Data.FingerTree with minor additions to track 
+    the number of (potential) UTF8 multibyte tail bytes present in each 
+    given fragment and to break up fragments that include too many tail 
+    bytes to improve the asymptotics of splitting.
hunk ./buffer.cabal 35
+                     Data.Buffer.Word8
hunk ./buffer.cabal 38
+                     Data.Buffer.Internal.Classes
+                     Data.Buffer.Internal.FingerTree
hunk ./buffer.cabal 41
+                     Data.Buffer.Lazy.Word8
hunk ./buffer.cabal 43
+                     Data.Buffer.Rope
+                     Data.Buffer.Rope.Internal
+                     Data.Buffer.Rope.Word8
hunk ./cbits/fpstring.c 1
-s/*
+/*
hunk ./cbits/fpstring.c 32
-#include "bfpstring.h"
+#include "fpstring.h"
hunk ./cbits/fpstring.c 84
-unsigned long bfps_count_extras(unsigned char *p, unsigned long len, unsigned char w) { 
+unsigned long bfps_count_extras(unsigned char *p, unsigned long len) {
hunk ./cbits/fpstring.c 87
-        if (*p >= 0x80)
+        if (*p >= 0x80 && *p < 0xC0)
addfile ./include/measure.h
hunk ./include/measure.h 1
+#ifdef __GLASGOW_HASKELL__
+#define BOX I#
+#define HASH #
+#define ID(x) x
+#define INT Int#
+#define PACK(a,b) (let { BOX packed_a = a; BOX packed_b = b } in (ID(HASH) packed_a, packed_b ID(HASH)))
+#define PLUS +ID(HASH)
+#define UNBOX(a) = let I# unboxedResult = a in unboxedResult
+#define UNPACK(a,b) (ID(HASH) BOX -> a, BOX -> b ID(HASH))
+#define TUPLE(a,b) (ID(HASH) a, b ID(HASH))
+#else
+#define BOX
+#define INT Int
+#define PACK(a,b) (a,b)
+#define UNPACK(a,b) (a,b)
+#define TUPLE(a,b) (a,b)
+#define PLUS +
+#define UNBOX(a) a
+#endif
+
+#define MEASURED(a) UNPACK(s##a,s##a) = measureU a
+#define MEASURED(a,b) MEASURED(a); MEASURED(b)
+#define MEASURED(a,b,c) MEASURED(a,b); MEASURED(c)
+#define MEASURED(a,b,c,d) MEASURED(a,b); MEASURED(c,d)