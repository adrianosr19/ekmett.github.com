[it builds again!
ekmett@gmail.com**20080429072054] {
hunk ./src/Control/Bifunctor/Composition.hs 82
-	bimap = liftSwapB . flip bimap 
+	bimap f g = liftSwapB (bimap g f)
hunk ./src/Control/Bifunctor/Composition.hs 84
+{-
hunk ./src/Control/Bifunctor/Composition.hs 90
+-}
hunk ./src/Control/Bifunctor/Composition.hs 97
+{-
hunk ./src/Control/Bifunctor/Composition.hs 107
+-}
hunk ./src/Control/Bifunctor/Composition.hs 127
+{-
hunk ./src/Control/Bifunctor/Composition.hs 129
-	associate = liftFunctorB associate
+	associate = FunctorB . fmap associate . runFunctorB 
hunk ./src/Control/Bifunctor/Composition.hs 132
-	coassociate = liftFunctorB coassociate
+	coassociate = FunctorB . fmap f . runFunctorB
hunk ./src/Control/Bifunctor/Composition.hs 136
+
hunk ./src/Control/Bifunctor/Composition.hs 138
-	idr = idr . extract . runFunctorB
-	idl = idl . extract . runFunctorB
+	idr = idr . copoint . runFunctorB
+	idl = idl . copoint . runFunctorB
hunk ./src/Control/Bifunctor/Composition.hs 142
-	coidr = FunctorB . return . coidr
-	coidl = FunctorB . return . coidl
+	coidr = FunctorB . point . coidr
+	coidl = FunctorB . point . coidl
+-}
hunk ./src/Control/Bifunctor/Fix.hs 20
-        fmap f = InB . bimap f (map f) . outB
+        fmap f = InB . bimap f (fmap f) . outB
hunk ./src/Control/Comonad/Composition.hs 34
-	extract = extract . copoint . decompose
+	extract = extract . copoint .  decompose
hunk ./src/Control/Functor/Adjunction.hs 49
-instance Adjunction f g => Pointed (CompF g f) where
+instance Adjunction f g => Pointed (ACompF g f) where
hunk ./src/Control/Functor/Adjunction.hs 52
-instance Adjunction f g => Copointed (CompF f g) where
+instance Adjunction f g => Copointed (ACompF f g) where
hunk ./src/Control/Functor/Adjunction.hs 55
-instance Adjunction f g => Monad (CompF g f) where
+instance Adjunction f g => Monad (ACompF g f) where
hunk ./src/Control/Functor/Adjunction.hs 59
-instance Adjunction f g => Comonad (CompF f g) where
+instance Adjunction f g => Comonad (ACompF f g) where
hunk ./src/Control/Functor/Bifunctor.hs 19
+import Control.Bifunctor.Instances
hunk ./src/Control/Functor/Bifunctor.hs 24
+import Control.Arrow ((***),(&&&),(|||),(+++))
hunk ./src/Control/Functor/Bifunctor.hs 34
-        contrafmap f = BifunctorF . bimap (contrafmap f) (contrafmap f) . runBifunctorF
+        contramap f = BifunctorF . bimap (contramap f) (contramap f) . runBifunctorF
hunk ./src/Control/Functor/Bifunctor.hs 66
-instance (Pointed f, Pointed g) => Pointed (BifunctorF (,) f g) where
-        point = BifunctorF . (point &&& point)
-
-instance (Copointed f, Copointed g) => Copointed (BifunctorF Either f g) where
-        copoint = (copoint ||| copoint) . runBifunctorF
-
hunk ./src/Control/Morphism/Cata.hs 16
+import Control.Bifunctor.Fix
hunk ./src/Control/Morphism/Cata.hs 35
-cataB :: Bifunctor f => Alg (f b) a -> MuB b f -> a
-cataB f = f . bimap id (cataB f) . outF
+cataB :: Bifunctor f => Alg (f b) a -> MuB f b -> a
+cataB f = f . bimap id (cataB f) . outB
hunk ./src/Control/Morphism/Cata.hs 38
-g_cataB :: (Bifunctor f, Comonad w) => Dist (f b) w -> AlgW (f b) w a -> MuB b f -> a
-g_cataB k g = extract . c where c = liftW g . k . bimap id (duplicate . c) . outF
+g_cataB :: (Bifunctor f, Comonad w) => Dist (f b) w -> AlgW (f b) w a -> MuB f b -> a
+g_cataB k g = extract . c where c = liftW g . k . bimap id (duplicate . c) . outB
}
