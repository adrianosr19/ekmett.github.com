[added bifunctor instances
ekmett@gmail.com**20080428211419] {
adddir ./src/Control/Comonad/Cofree
adddir ./src/Data
hunk ./ctl.cabal 39
+	Control.Comonad.Cofree.Alt,
hunk ./ctl.cabal 66
-	Control.Morphism.Histo
+	Control.Morphism.Histo,
+	Data.Void
hunk ./src/Control/Bifunctor/Instances.hs 16
+import Control.Bifunctor.Associative
+import Control.Bifunctor.Monoidal
+import Control.Bifunctor.Braided
+import Data.Void
hunk ./src/Control/Bifunctor/Instances.hs 25
+instance Associative (,) where
+	associate ((a,b),c) = (a,(b,c))
+
+instance Coassociative (,) where
+	coassociate (a,(b,c)) = ((a,b),c)
+
+instance HasIdentity (,) Void
+
+instance Monoidal (,) Void where
+	idl = snd
+	idr = fst
+
+instance Braided (,) where
+	braid ~(a,b) = (b,a)
+
+instance Symmetric (,)
+
hunk ./src/Control/Bifunctor/Instances.hs 45
+instance Associative Either where
+	associate (Left (Left a)) = Left a
+	associate (Left (Right b)) = Right (Left b)
+	associate (Right c) = Right (Right c)
+
+instance Coassociative Either where
+	coassociate (Left a) = Left (Left a)
+	coassociate (Right (Left b)) = Left (Right b)
+	coassociate (Right (Right c)) = Right c
+
+instance Braided Either where
+	braid (Left a) = Right a
+	braid (Right b) = Left b
+
+instance Symmetric Either
+
+-- Either is NOT Comonoidal! bottom inhabits every type
+
hunk ./src/Control/Comonad/Cofree.hs 10
--- Portability :  portable
+-- Portability :  rank-2 types 
hunk ./src/Control/Comonad/Cofree.hs 18
--- | The cofree comonad of a functor (aka the branching stream comonad)
hunk ./src/Control/Comonad/Cofree.hs 33
+
addfile ./src/Control/Comonad/Cofree/Alt.hs
hunk ./src/Control/Comonad/Cofree/Alt.hs 1
+{-# OPTIONS -fglasgow-exts #-}
+-----------------------------------------------------------------------------
+-- |
+-- Module      :  Control.Comonad.Cofree.Alt
+-- Copyright   :  (C) 2008 Edward Kmett
+-- License     :  BSD-style (see the file LICENSE)
+--
+-- Maintainer  :  Edward Kmett <ekmett@gmail.com>
+-- Stability   :  experimental
+-- Portability :  rank-2 types 
+--
+----------------------------------------------------------------------------
+module Control.Comonad.Cofree.Alt where
+
+import Control.Comonad
+import Control.Arrow ((|||), (&&&), (+++), (***))
+
+data Cofree' f c = forall a. Cofree' (a -> c) (a -> f a) a
+
+runCofree' :: Functor f => Cofree' f c -> (c, f (Cofree' f c))
+runCofree' = extract &&& outCofree'
+
+instance Functor (Cofree' f) where
+	fmap f (Cofree' h t s) = Cofree' (f . h) t s
+
+instance Comonad (Cofree' f) where	
+	extract (Cofree' h _ s ) = h s 
+	extend f (Cofree' h t s) = Cofree' (f . Cofree' h t) t s
+
+outCofree' :: Functor f => Cofree' f a -> f (Cofree' f a)
+outCofree' (Cofree' h t s) = fmap (anaCofree' h t) (t s)
+
+anaCofree' :: (a -> c) -> (a -> f a) -> a -> Cofree' f c
+anaCofree' = Cofree'
addfile ./src/Control/Comonad/Pointer.hs
hunk ./src/Control/Comonad/Pointer.hs 1
+{-# OPTIONS -fglasgow-exts #-}
+-----------------------------------------------------------------------------
+-- |
+-- Module      :  Control.Comonad.Pointer
+-- Copyright   :  (C) 2008 Edward Kmett
+-- License     :  BSD-style (see the file LICENSE)
+--
+-- Maintainer  :  Edward Kmett <ekmett@gmail.com>
+-- Stability   :  experimental
+-- Portability :  non-portable (MPTCs)
+--
+-- SIGFPE (Dan Piponi)'s Pointer Comonad
+----------------------------------------------------------------------------
+module Control.Comonad.Pointer where
+
+import Control.Arrow ((&&&), first)
+import Data.Array
+import Data.Foldable
+import Control.Monad
+import Control.Comonad
+
+data Pointer i a = Pointer { index :: i, array :: Array i e } deriving (Show,Read)
+
+instance Ix i => Functor (Pointer i) where
+	fmap f (Pointer i a) = Pointer i (fmap f a)
+
+instance Ix i => Comonad (Pointer i) where
+	extract (Pointer i a) = a ! i
+	extend f (Pointer i a) = Pointer i $ listArray bds (fmap (f . flip Pointer a) (range bds) where
+		bds = bounds a
+
+distPointer :: (Monad m, Ix i) => Dist m (Pointer i)
+distPointer (Pointer i ma) = do
+	let bds = bounds ma
+	a <- sequence (elems ma)
+	return $ Pointer i (listArray bds a)
hunk ./src/Control/Functor/Composition.hs 65
-runProductF :: (f * g) a -> (f a, g a)
+runProductF :: (f :*: g) a -> (f a, g a)
addfile ./src/Data/Void.hs
hunk ./src/Data/Void.hs 1
+{-# OPTIONS -fglasgow-exts #-}
+-----------------------------------------------------------------------------
+-- |
+-- Module      :  Data.Void
+-- Copyright   :  (C) 2008 Edward Kmett
+-- License     :  BSD-style (see the file LICENSE)
+--
+-- Maintainer  :  Edward Kmett <ekmett@gmail.com>
+-- Stability   :  experimental
+-- Portability :  non-portable (empty data declaration)
+--
+----------------------------------------------------------------------------
+module Data.Void where
+
+data Void
}
