[added new files
ekmett@gmail.com**20080429070238] {
adddir ./src/Control/Comonad/Context
adddir ./src/Control/Functor/Composition
adddir ./src/Control/Functor/Pointed
addfile ./src/Control/Bifunctor/Fix.hs
hunk ./src/Control/Bifunctor/Fix.hs 1
+-------------------------------------------------------------------------------------------
+-- |
+-- Module	: Control.Bifunctor.Fix
+-- Copyright 	: 2008 Edward Kmett
+-- License	: BSD
+--
+-- Maintainer	: Edward Kmett <ekmett@gmail.com>
+-- Stability	: experimental
+-- Portability	: portable
+--
+-------------------------------------------------------------------------------------------
+module Control.Bifunctor.Fix where
+
+import Control.Bifunctor
+
+newtype MuB s a = InB { outB :: s a (MuB s a) }
+type NuB s a = MuB s a 
+
+instance Bifunctor s => Functor (MuB s) where
+        fmap f = InB . bimap f (map f) . outB
+
addfile ./src/Control/Comonad/Composition.hs
hunk ./src/Control/Comonad/Composition.hs 1
+-------------------------------------------------------------------------------------------
+-- |
+-- Module	: Control.Comonad.Composition
+-- Copyright 	: 2008 Edward Kmett
+-- License	: BSD
+--
+-- Maintainer	: Edward Kmett <ekmett@gmail.com>
+-- Stability	: experimental
+-- Portability	: non-portable (functional-dependencies)
+--
+-- composing a comonad with a copointed endofunctor yields a comonad given a distributive law
+-------------------------------------------------------------------------------------------
+
+module Control.Comonad.Composition where
+
+import Control.Comonad
+import Control.Functor.Composition
+import Control.Functor.Composition.Class
+import Control.Functor.Extras
+import Control.Functor.Pointed
+import Control.Functor.Pointed.Composition
+
+-- postDuplicate :: (Comonad w, PostUnfold w f) => w (f a) -> w (f (w (f a)))
+-- postDuplicate = fmap postUnfold . duplicate
+
+instance (Comonad w, Copointed f, PostUnfold w f) => Comonad (PostCompF w f) where
+	extract = copoint . extract . decompose
+	duplicate = compose . liftW (fmap compose . postUnfold) . duplicate . decompose
+
+-- preDuplicate :: (Comonad w, Functor f, PreUnfold f w) => f (w a) -> f (w (f (w a)))
+-- preDuplicate = preUnfold . fmap duplicate
+
+instance (Copointed f, Comonad w, PreUnfold f w) => Comonad (PreCompF f w) where
+	extract = extract . copoint . decompose
+	duplicate = compose . fmap (liftW compose) . preUnfold . fmap (duplicate) . decompose
+
+instance (Comonad f, Comonad g, Distributes f g) => Comonad (DistCompF f g) where
+	extract = extract . extract . decompose
+	duplicate = compose . fmap (fmap compose . dist) . duplicate . fmap duplicate . decompose
+--	join = compose . fmap join . join . fmap dist . fmap (fmap decompose) . decompose
addfile ./src/Control/Comonad/Context.hs
hunk ./src/Control/Comonad/Context.hs 1
+{-# OPTIONS -fglasgow-exts #-}
+-----------------------------------------------------------------------------
+-- |
+-- Module      :  Control.Comonad.Context
+-- Copyright   :  (C) 2008 Edward Kmett
+-- License     :  BSD-style (see the file LICENSE)
+--
+-- Maintainer  :  Edward Kmett <ekmett@gmail.com>
+-- Stability   :  experimental
+-- Portability :  non-portable (MPTCs)
+--
+-- The 'state-in-context' comonad and comonad transformer
+----------------------------------------------------------------------------
+module Control.Comonad.Context where
+
+import Control.Arrow ((&&&), first)
+import Control.Comonad
+import Control.Comonad.Context.Class
+
+
+data Context s a = Context (s -> a) s
+
+runContext f s = (a b, b) where
+	Context a b = f (Context id s)
+
+instance ComonadContext s (Context s) where
+	getC (Context f s) = s
+	modifyC m (Context f c) = f (m c)
+	
+instance Functor (Context s) where
+	fmap f (Context f' s) = Context (f . f') s
+
+instance Comonad (Context s) where
+	extract   (Context f a) = f a
+	duplicate (Context f a) = Context (Context f) a
+
+
+
+
+newtype ContextT s w a = ContextT { runContextT :: w (s -> a, s) }
+
+instance Comonad w => ComonadContext s (ContextT s w) where
+	getC = snd . extract . runContextT 
+	modifyC = undefined
+
+instance Functor f => Functor (ContextT b f) where
+        fmap f = ContextT . fmap (first (f .)) . runContextT
+
+instance Comonad w => Comonad (ContextT b w) where
+        extract = uncurry id . extract . runContextT
+        duplicate = undefined -- ContextT . liftW (fst . extract &&& ContextT) . duplicate . runContextT
addfile ./src/Control/Comonad/Context/Class.hs
hunk ./src/Control/Comonad/Context/Class.hs 1
+{-# OPTIONS -fglasgow-exts #-}
+-----------------------------------------------------------------------------
+-- |
+-- Module      :  Control.Comonad.Context.Class
+-- Copyright   :  (C) 2008 Edward Kmett
+-- License     :  BSD-style (see the file LICENSE)
+--
+-- Maintainer  :  Edward Kmett <ekmett@gmail.com>
+-- Stability   :  experimental
+-- Portability :  portable
+--
+----------------------------------------------------------------------------
+module Control.Comonad.Context.Class where
+
+import Control.Comonad
+
+class Comonad w => ComonadContext s w | w -> s where
+	getC :: w a -> s
+	modifyC :: (s -> s) -> w a -> a 
+
+putC :: ComonadContext s w => s -> w a -> a
+putC = modifyC . const 
+
+experiment :: (ComonadContext s w, Functor f) => f (s -> s) -> w a -> f a
+experiment ms a = fmap (flip modifyC a) ms
addfile ./src/Control/Comonad/Zipper.hs
hunk ./src/Control/Comonad/Zipper.hs 1
+{-# OPTIONS -fglasgow-exts #-}
+-----------------------------------------------------------------------------
+-- |
+-- Module      :  Control.Comonad.Zipper
+-- Copyright   :  (C) 2008 Edward Kmett
+-- License     :  BSD-style (see the file LICENSE)
+--
+-- Maintainer  :  Edward Kmett <ekmett@gmail.com>
+-- Stability   :  experimental
+-- Portability :  non-portable (MPTCs)
+--
+----------------------------------------------------------------------------
+module Control.Comonad.Pointer where
+
+import Control.Arrow ((&&&), first)
+import Data.Array
+import Data.Foldable
+import Control.Monad
+import Control.Comonad
+
+{-
+
+data Pointer i a = Pointer { index :: i, array :: Array i e } deriving (Show,Read)
+
+instance Ix i => Functor (Pointer i) where
+	fmap f (Pointer i a) = Pointer i (fmap f a)
+
+instance Ix i => Comonad (Pointer i) where
+	extract (Pointer i a) = a ! i
+	extend f (Pointer i a) = Pointer i . listArray bds $ fmap (f . flip Pointer a) (range bds) where
+		bds = bounds a
+
+distPointer :: (Monad m, Ix i) => Dist m (Pointer i)
+distPointer (Pointer i ma) = do
+	let bds = bounds ma
+	a <- sequence (elems ma)
+	return $ Pointer i (listArray bds a)
+
+-}
addfile ./src/Control/Functor/Bifunctor.hs
hunk ./src/Control/Functor/Bifunctor.hs 1
+{-# OPTIONS -fglasgow-exts -fallow-undecidable-instances #-}
+-------------------------------------------------------------------------------------------
+-- |
+-- Module	: Control.Functor.Bifunctor
+-- Copyright 	: 2008 Edward Kmett
+-- License	: BSD
+--
+-- Maintainer	: Edward Kmett <ekmett@gmail.com>
+-- Stability	: experimental
+-- Portability	: non-portable (functional-dependencies)
+--
+-- transform a pair of functors with a bifunctor deriving a new functor.
+-- this subsumes functor product and functor coproduct
+-------------------------------------------------------------------------------------------
+
+module Control.Functor.Bifunctor where
+
+import Control.Bifunctor
+import Control.Functor.Contravariant
+import Control.Functor.Exponential
+import Control.Functor.Full
+import Control.Functor.Pointed
+
+-- * Bifunctor functor transformer
+
+newtype BifunctorF p f g a = BifunctorF { runBifunctorF :: p (f a) (g a) }
+
+instance (Bifunctor p, Functor f ,Functor g) => Functor (BifunctorF p f g) where
+        fmap f = BifunctorF . bimap (fmap f) (fmap f) . runBifunctorF
+
+instance (Bifunctor p, ContravariantFunctor f ,ContravariantFunctor g) => ContravariantFunctor (BifunctorF p f g) where
+        contrafmap f = BifunctorF . bimap (contrafmap f) (contrafmap f) . runBifunctorF
+
+instance (Bifunctor p, ExpFunctor f ,ExpFunctor g) => ExpFunctor (BifunctorF p f g) where
+        xmap f g = BifunctorF . bimap (xmap f g) (xmap f g) . runBifunctorF
+
+
+
+#ifndef __HADDOCK__
+type (f :*: g) a = BifunctorF (,) f g a
+#endif
+
+
+runProductF :: BifunctorF (,) f g a -> (f a, g a)
+runProductF = runBifunctorF
+
+instance (Pointed f, Pointed g) => Pointed (BifunctorF (,) f g) where
+        point = BifunctorF . (point &&& point)
+
+instance (Faithful f, Faithful g) => Faithful (BifunctorF (,) f g)
+
+#ifndef __HADDOCK__
+type (f :+: g) a = BifunctorF Either f g a
+#endif
+
+
+runCoproductF :: BifunctorF Either f g a -> Either (f a) (g a)
+runCoproductF = runBifunctorF
+
+instance (Copointed f, Copointed g) => Copointed (BifunctorF Either f g) where
+        copoint = (copoint ||| copoint) . runBifunctorF
+
+
+instance (Pointed f, Pointed g) => Pointed (BifunctorF (,) f g) where
+        point = BifunctorF . (point &&& point)
+
+instance (Copointed f, Copointed g) => Copointed (BifunctorF Either f g) where
+        copoint = (copoint ||| copoint) . runBifunctorF
addfile ./src/Control/Functor/Composition/Class.hs
hunk ./src/Control/Functor/Composition/Class.hs 1
+{-# OPTIONS -fglasgow-exts #-}
+-------------------------------------------------------------------------------------------
+-- |
+-- Module	: Control.Functor.Composition.Class
+-- Copyright 	: 2008 Edward Kmett
+-- License	: BSD
+--
+-- Maintainer	: Edward Kmett <ekmett@gmail.com>
+-- Stability	: experimental
+-- Portability	: non-portable (class-associated types)
+--
+-------------------------------------------------------------------------------------------
+
+module Control.Functor.Composition.Class where
+
+class Composition c where
+    decompose  :: c f g x -> f (g x)
+    compose    :: f (g x) -> c f g x
+
+
addfile ./src/Control/Functor/Constant.hs
hunk ./src/Control/Functor/Constant.hs 1
+{-# OPTIONS -fglasgow-exts -fallow-undecidable-instances #-}
+-------------------------------------------------------------------------------------------
+-- |
+-- Module	: Control.Functor.Constant
+-- Copyright 	: 2008 Edward Kmett
+-- License	: BSD
+--
+-- Maintainer	: Edward Kmett <ekmett@gmail.com>
+-- Stability	: experimental
+-- Portability	: non-portable (functional-dependencies)
+--
+-------------------------------------------------------------------------------------------
+
+module Control.Functor.Constant where
+
+import Control.Functor.Exponential
+import Control.Functor.Contravariant
+import Data.Void
+
+-- this is also the 'Fst' bifunctor
+
+newtype ConstantF a b = ConstantF a
+
+instance Functor (ConstantF a) where
+	fmap f (ConstantF a) = ConstantF a
+
+instance ContravariantFunctor (ConstantF a) where
+	contramap f (ConstantF a) = ConstantF a
+
+instance ExpFunctor (ConstantF a) where
+	xmap f g (ConstantF a) = ConstantF a
+
+type VoidF a = ConstantF Void a
addfile ./src/Control/Functor/Contravariant.hs
hunk ./src/Control/Functor/Contravariant.hs 1
+{-# OPTIONS -fglasgow-exts #-}
+-------------------------------------------------------------------------------------------
+-- |
+-- Module	: Control.Functor.Contravariant
+-- Copyright 	: 2008 Edward Kmett
+-- License	: BSD
+--
+-- Maintainer	: Edward Kmett <ekmett@gmail.com>
+-- Stability	: experimental
+-- Portability	: non-portable (class-associated types)
+--
+-------------------------------------------------------------------------------------------
+
+module Control.Functor.Contravariant where
+
+class ContravariantFunctor f where
+	contramap :: (a -> b)  -> f b -> f a
+
addfile ./src/Control/Functor/Derivative.hs
hunk ./src/Control/Functor/Derivative.hs 1
+-----------------------------------------------------------------------------
+-- |
+-- Module      :  Control.Functor.Derivative
+-- Copyright   :  (C) 2008 Edward Kmett
+-- License     :  BSD-style (see the file LICENSE)
+--
+-- Maintainer  :  Edward Kmett <ekmett@gmail.com>
+-- Stability   :  experimental
+-- Portability :  non-portable (rank-2 polymorphism)
+--
+----------------------------------------------------------------------------
+module Control.Functor.Derivative where
+
addfile ./src/Control/Functor/Exponential.hs
hunk ./src/Control/Functor/Exponential.hs 1
+{-# OPTIONS -fglasgow-exts #-}
+-------------------------------------------------------------------------------------------
+-- |
+-- Module	: Control.Functor.Exponential
+-- Copyright 	: 2008 Edward Kmett
+-- License	: BSD
+--
+-- Maintainer	: Edward Kmett <ekmett@gmail.com>
+-- Stability	: experimental
+-- Portability	: non-portable (class-associated types)
+--
+-- Exponential functors, see <http://comonad.com/reader/2008/rotten-bananas/>
+-------------------------------------------------------------------------------------------
+
+module Control.Functor.Exponential where
+
+class ExpFunctor f where
+	xmap :: (a -> b) -> (b -> a) -> f a -> f b
+
addfile ./src/Control/Functor/Instances.hs
hunk ./src/Control/Functor/Instances.hs 1
+{-# OPTIONS -fglasgow-exts #-}
+-------------------------------------------------------------------------------------------
+-- |
+-- Module	: Control.Functor.Instances
+-- Copyright 	: 2008 Edward Kmett
+-- License	: BSD
+--
+-- Maintainer	: Edward Kmett <ekmett@gmail.com>
+-- Stability	: experimental
+-- Portability	: non-portable (class-associated types)
+--
+-- Generalized functor composition.
+-------------------------------------------------------------------------------------------
+
+module Control.Functor.Composition where
+
+import Control.Bifunctor
+import Control.Bifunctor.Instances
+import Control.Functor.Adjunction
+import Control.Functor.Pointed
+import Control.Monad
+import Control.Comonad
+import Control.Functor.Full
+import Control.Arrow ((&&&),(|||))
+
+class Composer c where
+    open  :: c f g x -> f (g x)
+    close :: f (g x) -> c f g x
+
+newtype CompF f g a = CompF { deCompF :: f (g a) }
+
+#ifndef __HADDOCK__
+type (f :.: g) a = CompF f g a
+#endif
+
+instance Adjunction f g => Pointed (CompF g f) where
+        point = CompF . unit
+
+instance Adjunction f g => Copointed (CompF f g) where
+        copoint = counit . deCompF
+
+instance Adjunction f g => Monad (CompF g f) where
+	return = point
+        m >>= f = CompF . fmap (rightAdjunct (deCompF . f)) $ deCompF m
+
+instance Adjunction f g => Comonad (CompF f g) where
+	extract = copoint
+        extend f = CompF . fmap (leftAdjunct (f . CompF)) . deCompF
+
+instance (Functor f, Functor g) => Functor (CompF f g) where
+	fmap f = CompF . fmap (fmap f) . deCompF
+
+instance (Full f, Full g) => Full (CompF f g) where
+        prefmap f = prefmap . prefmap $ deCompF . f . CompF
+
+newtype BifunctorF p f g a = BifunctorF { runBifunctorF :: p (f a) (g a) }
+
+instance (Bifunctor p, Functor f ,Functor g) => Functor (BifunctorF p f g) where
+	fmap f = BifunctorF . bimap (fmap f) (fmap f) . runBifunctorF
+
+#ifndef __HADDOCK__
+type (f :*: g) a = BifunctorF (,) f g a
+#endif
+
+-- this would be a type but that causes the following line to freak out
+-- because (f :*: g) is a partialy applied type synonym even though it immediately gets filled out
+
+#ifndef __HADDOCK__
+runProductF :: (f :*: g) a -> (f a, g a)
+#else
+runProductF :: Bifunctor (,) f g a -> (f a, g a)
+#endif
+runProductF = runBifunctorF
+
+instance (Pointed f, Pointed g) => Pointed (BifunctorF (,) f g) where
+	point = BifunctorF . (point &&& point)
+
+instance (Faithful f, Faithful g) => Faithful (BifunctorF (,) f g)
+
+#ifndef __HADDOCK__
+type (f :+: g) a = BifunctorF Either f g a
+#endif
+
+#ifndef __HADDOCK__
+runCoproductF :: (f :+: g) a -> Either (f a) (g a)
+#else
+runCoproductF :: Bifunctor Either f g a -> Either (f a) (g a)
+#endif
+runCoproductF = runBifunctorF 
+
+instance (Copointed f, Copointed g) => Copointed (BifunctorF Either f g) where
+	copoint = (copoint ||| copoint) . runCoproductF
addfile ./src/Control/Functor/Pointed/Composition.hs
hunk ./src/Control/Functor/Pointed/Composition.hs 1
+{-# OPTIONS -fglasgow-exts #-}
+-------------------------------------------------------------------------------------------
+-- |
+-- Module	: Control.Functor.Pointed.Composition
+-- Copyright 	: 2008 Edward Kmett
+-- License	: BSD
+--
+-- Maintainer	: Edward Kmett <ekmett@gmail.com>
+-- Stability	: experimental
+-- Portability	: non-portable (functional-dependencies)
+--
+-------------------------------------------------------------------------------------------
+
+module Control.Functor.Pointed.Composition where
+
+import Control.Functor.Pointed
+import Control.Functor.Composition.Class
+import Control.Functor.Composition
+import Control.Functor.Exponential
+import Control.Functor.Full
+
+newtype PointedCompF f g a = PointedCompF (CompF f g a) deriving (Functor, ExpFunctor, Full, Composition)
+
+instance (Pointed f, Pointed g) => Pointed (PointedCompF f g) where
+        point = compose . point . point
+
+instance (Copointed f, Copointed g) => Copointed (PointedCompF f g) where
+        copoint = copoint . copoint . decompose
+
+newtype PostCompF mw f a = PostCompF (PointedCompF mw f a) deriving (Functor, ExpFunctor, Full, Composition, Pointed, Copointed)
+newtype PreCompF f mw a  = PreCompF (PointedCompF f mw a) deriving (Functor, ExpFunctor, Full, Composition, Pointed, Copointed)
+newtype DistCompF f g a  = DistCompF (PointedCompF f g a) deriving (Functor, ExpFunctor, Full, Composition, Pointed, Copointed)
+
addfile ./src/Control/Monad/Composition.hs
hunk ./src/Control/Monad/Composition.hs 1
+-------------------------------------------------------------------------------------------
+-- |
+-- Module	: Control.Monad.Composition
+-- Copyright 	: 2008 Edward Kmett
+-- License	: BSD
+--
+-- Maintainer	: Edward Kmett <ekmett@gmail.com>
+-- Stability	: experimental
+-- Portability	: non-portable (functional-dependencies)
+--
+-------------------------------------------------------------------------------------------
+
+module Control.Monad.Composition where
+
+import Control.Monad
+import Control.Functor.Composition
+import Control.Functor.Composition.Class
+import Control.Functor.Extras
+import Control.Functor.Pointed
+import Control.Functor.Pointed.Composition
+
+postJoin :: (Monad m, PostFold m f) => m (f (m (f a))) -> m (f a)
+postJoin = join . liftM postFold
+
+instance (Monad m, Pointed f, PostFold m f) => Monad (PostCompF m f) where
+        return = compose . return . point
+	m >>= k = undefined -- TODO: dualize the comonad version
+
+preJoin :: (Monad m, Functor f, PreFold f m) => f (m (f (m a))) -> f (m a)
+preJoin = fmap join . preFold
+
+instance (Pointed f, Monad m, PreFold f m) => Monad (PreCompF f m) where
+	return = compose . point . return
+	m >>= k = undefined
+
+
+instance (Monad m, Monad n, Distributes m n) => Monad (DistCompF m n) where
+	return = compose . return . return
+	m >>= k = undefined
+
+
+
}
