[it compiled again!
ekmett@gmail.com**20080502055849] {
move ./ctl.cabal ./category-extras.cabal
hunk ./category-extras.cabal 1
-name:			ctl
+name:			category-extras
hunk ./category-extras.cabal 3
-version:		0.2
+version:		0.3
hunk ./category-extras.cabal 7
-author:			Edward A. Kmett
+author:			Edward A. Kmett, Dave Menendez
hunk ./category-extras.cabal 10
-homepage:		http://comonad.com/
-synopsis:		Comonad Transformer Library
+homepage:		http://comonad.com/reader/
+synopsis:		Various modules and constructs inspired by category theory.
hunk ./category-extras.cabal 13
-description: 		Defines comonads, a few missing monads and a bunch of constructive algorithmic morphisms
+			Copyright (C) 2004--2008 Dave Menendez
+description: 		A collection of modules implementing various ideas from
+			category theory. Notable bits include: comonads, adjunctions,
+			functor fixedpoints and various recursion operaters ala
+			/Functional Programming with Bananas, Lenses, Envelopes
+			and Barbed Wire/. 
hunk ./category-extras.cabal 27
-	TypeFamilies, 
-	TypeSynonymInstances,
hunk ./category-extras.cabal 29
-	GADTs
+	ExistentialQuantification,
+	Rank2Types
hunk ./category-extras.cabal 47
+	Control.Comonad.HigherOrder,
hunk ./category-extras.cabal 65
+	Control.Functor.HigherOrder,
hunk ./category-extras.cabal 71
+	Control.Monad.HigherOrder,
hunk ./category-extras.cabal 86
-ghc-options:		-O2 -funbox-strict-fields
+ghc-options:		-O2 -funbox-strict-fields -Wall
hunk ./src/Control/Bifunctor/Associative.hs 22
-> second associate . associate . first associate = associate . associate
+> bimap id associate . associate . bimap associate id = associate . associate
hunk ./src/Control/Bifunctor/Associative.hs 29
-> first coassociate . coassociate . second coassociate = coassociate . coassociate
+> bimap coassociate id . coassociate . bimap id coassociate = coassociate . coassociate
hunk ./src/Control/Bifunctor/Associative.hs 35
-	"copentagonal coherence"
-		first coassociate . coassociate . second coassociate = coassociate . coassociate
-	"pentagonal coherence"
-		second associate . associate . first associate = associate . associate
+"copentagonal coherence" bimap coassociate id . coassociate . bimap id coassociate = coassociate . coassociate
+"pentagonal coherence" bimap id associate . associate . bimap associate id = associate . associate
hunk ./src/Control/Bifunctor/Associative.hs 39
+
+
hunk ./src/Control/Bifunctor/Braided.hs 15
+import Control.Bifunctor.Associative
hunk ./src/Control/Bifunctor/Braided.hs 31
-{-# RULES 
-	"idr/braid" 			idr . braid = idl
-	"idl/braid" 			idl . braid = idr
-	"braid/coidr" 			braid . coidr = coidl
-	"braid/coidl" 			braid . coidl = coidr
-	"braid/associate/braid" 	second braid . associate . first braid = associate . braid . associate
-	"braid/coassociate/braid" 	first braid . coassociate . second braid = coassociate . braid . coassociate
- #-}
-
hunk ./src/Control/Bifunctor/Braided.hs 42
-	"swap/swap" swap . swap = id
+"swap/swap" swap . swap = id
+"braid/associate/braid"         bimap id braid . associate . bimap braid id = associate . braid . associate
+"braid/coassociate/braid"       bimap braid id . coassociate . bimap id braid = coassociate . braid . coassociate
hunk ./src/Control/Bifunctor/Monoidal.hs 21
-import Prelude hiding ((.), id, fst, snd)
hunk ./src/Control/Bifunctor/Monoidal.hs 23
+import Control.Bifunctor.Braided
hunk ./src/Control/Bifunctor/Monoidal.hs 32
-> first idr = second idl . associate 
-> second idl = first idr . associate
+> bimap idr id = bimap id idl . associate 
+> bimap id idl = bimap idr id . associate
hunk ./src/Control/Bifunctor/Monoidal.hs 40
-{-# RULES
-	"second idl/associate" 	second idl . associate = first idr
-	"first idr/associate" 	first idr . associate = second idl
- #-}
-
hunk ./src/Control/Bifunctor/Monoidal.hs 42
-> first idr = coassociate . second idl
-> second idl = coassociate . first idr
+> bimap idr id = coassociate . bimap id idl
+> bimap id idl = coassociate . bimap idr id
hunk ./src/Control/Bifunctor/Monoidal.hs 59
-	"coassociate/second idl"  coassociate . second idl = first idr
-	"coassociate/first idr"   coassociate . first idr = second idl
+-- "bimap id idl/associate" 		bimap id idl . associate = bimap idr id
+-- "bimap idr id/associate" 		bimap idr id . associate = bimap id idl
+-- "coassociate/bimap id idl"  		coassociate . bimap id idl = bimap idr id
+-- "coassociate/bimap idr id"  		coassociate . bimap idr id = bimap id idl
+"idr/coidr" 			idr . coidr = id
+"idl/coidl"			idl . coidl = id
+"coidl/idl"			coidl . idl = id
+"coidr/idr"			coidr . idr = id
+"idr/braid"                     idr . braid = idl
+"idl/braid"                     idl . braid = idr
+"braid/coidr"                   braid . coidr = coidl
+"braid/coidl"                   braid . coidl = coidr
hunk ./src/Control/Bifunctor/Monoidal.hs 73
-{-# RULES
-	"idr/coidr" 		idr . coidr = id
-	"idl/coidl"		idl . coidl = id
-	"coidl/idl"		coidl . idl = id
-	"coidr/idr"		coidr . idr = id
- #-}
hunk ./src/Control/Comonad.hs 6
+--		  (C) 2004 Dave Menendez
hunk ./src/Control/Comonad.hs 13
+-- This module declares the 'Comonad' class
hunk ./src/Control/Comonad.hs 20
+infixl 1 =>>, .>>
+
+{-|
+There are two ways to define a comonad:
+
+I. Provide definitions for 'fmap', 'extract', and 'duplicate'
+satisfying these laws:
+
+> extract . duplicate      == id
+> fmap extract . duplicate == id
+> duplicate . duplicate    == fmap duplicate . duplicate
+
+II. Provide definitions for 'extract' and 'extend'
+satisfying these laws:
+
+> extend extract      == id
+> extract . extend f  == f
+> extend f . extend g == extend (f . extend g)
+
+('fmap' cannot be defaulted, but a comonad which defines
+'extend' may simply set 'fmap' equal to 'liftW'.)
+
+A comonad providing definitions for 'extend' /and/ 'duplicate',
+must also satisfy these laws:
+
+> extend f  == fmap f . duplicate
+> duplicate == extend id
+> fmap f    == extend (f . duplicate)
+
+(The first two are the defaults for 'extend' and 'duplicate',
+and the third is the definition of 'liftW'.)
+-}
+
hunk ./src/Control/Comonad.hs 63
+-- | 'extend' with the arguments swapped. Dual to '>>=' for monads.
+(=>>) :: Comonad w => w a -> (w a -> b) -> w b
+(=>>) = flip extend
+
+-- | Injects a value into the comonad.
+(.>>) :: Comonad w => w a -> b -> w b
+w .>> b = extend (\_ -> b) w
+
+-- | Transform a function into a comonadic action
hunk ./src/Control/Comonad.hs 75
+mapW :: Comonad w => (w a -> b) -> w [a] -> [b]
+mapW f w | null (extract w) = []
+         | otherwise        = f (fmap head w) : mapW f (fmap tail w)
+
+parallelW :: Comonad w => w [a] -> [w a]
+parallelW w | null (extract w) = []
+            | otherwise        = fmap head w : parallelW (fmap tail w)
+
+unfoldW :: Comonad w => (w b -> (a,b)) -> w b -> [a]
+unfoldW f w = fst (f w) : unfoldW f (w =>> snd . f)
+
+-- | Converts a list of comonadic functions into a single function
+-- returning a list of values
+sequenceW :: Comonad w => [w a -> b] -> w a -> [b]
+sequenceW []     _ = []
+sequenceW (f:fs) w = f w : sequenceW fs w
+
+
addfile ./src/Control/Comonad/HigherOrder.hs
hunk ./src/Control/Comonad/HigherOrder.hs 1
+-----------------------------------------------------------------------------
+-- |
+-- Module      :  Control.Comonad.HigherOrder
+-- Copyright   :  (C) 2008 Edward Kmett
+-- License     :  BSD-style (see the file LICENSE)
+--
+-- Maintainer  :  Edward Kmett <ekmett@gmail.com>
+-- Stability   :  experimental
+-- Portability :  non-portable (rank-2 polymorphism)
+--
+-- extending Neil Ghani and Patrician Johann's HFunctor to higher order comonads
+----------------------------------------------------------------------------
+module Control.Comonad.HigherOrder where
+
+import Control.Functor.Extras
+import Control.Functor.HigherOrder
+
+class HFunctor w => HComonad w where
+	hextract :: Functor f => Natural (w f) f
+	hextend  :: (Functor f, Functor g) => Natural (w f) g -> Natural (w f) (w g)
hunk ./src/Control/Functor/Composition.hs 41
+associateComp :: (Functor f, Composition c) => (c (c f g) h) a -> (c f (c g h)) a
+associateComp = compose . fmap compose . decompose . decompose
hunk ./src/Control/Functor/Composition.hs 44
+coassociateComp :: (Functor f, Composition c) => (c f (c g h)) a -> (c (c f g) h) a
+coassociateComp = compose . compose . fmap decompose . decompose
hunk ./src/Control/Functor/Full.hs 28
-	"fmap/premap" 	map . prefmap = id
+	"fmap/premap" 	map . premap = id
addfile ./src/Control/Functor/HigherOrder.hs
hunk ./src/Control/Functor/HigherOrder.hs 1
+-----------------------------------------------------------------------------
+-- |
+-- Module      :  Control.Functor.HigherOrder
+-- Copyright   :  (C) 2008 Edward Kmett
+-- License     :  BSD-style (see the file LICENSE)
+--
+-- Maintainer  :  Edward Kmett <ekmett@gmail.com>
+-- Stability   :  experimental
+-- Portability :  non-portable (rank-2 polymorphism)
+--
+-- Neil Ghani and Particia Johann' HFunctor <http://crab.rutgers.edu/~pjohann/tlca07-rev.pdf>
+----------------------------------------------------------------------------
+module Control.Functor.HigherOrder where
+
+import Control.Functor.Extras
+
+type AlgH f g = Natural (f g) g
+type CoAlgH f g = Natural g (f g)
+
+class HFunctor f where
+	ffmap :: Functor g => (a -> b) -> f g a -> f g b
+	hfmap :: Natural g h -> Natural (f g) (f h)
+
+newtype MuH f a = InH { outH :: f (MuH f) a }
+type NuH f a = MuH f a
hunk ./src/Control/Functor/Pointed.hs 24
-        "copoint/point" copoint . point = id
-        "point/copoint" point . copoint = id
+"copoint/point" copoint . point = id
+"point/copoint" point . copoint = id
hunk ./src/Control/Functor/Representable.hs 1
+{-# OPTIONS -fglasgow-exts #-}
hunk ./src/Control/Functor/Representable.hs 21
-  "rep/unrep"       	rep . unrep = id
-  "unrep/rep"   	unrep . rep = id
+"rep/unrep" rep . unrep = id
+"unrep/rep" unrep . rep = id
hunk ./src/Control/Functor/Representable.hs 25
+
hunk ./src/Control/Monad/Composition.hs 16
-import Control.Functor.Composition
+-- import Control.Functor.Composition
hunk ./src/Control/Monad/Either.hs 13
--- that prevents a natural encoding of Apomorphisms
+-- that prevents a natural encoding of Apomorphisms. This module is 
+-- therefore incompatible with Control.Monad.Error
hunk ./src/Control/Monad/Either.hs 18
+import Data.Either
hunk ./src/Control/Monad/Either.hs 20
-import Control.Arrow ((|||), (&&&), (+++), (***))
hunk ./src/Control/Monad/Either.hs 23
+instance Functor (Either e) where
+	fmap _ (Left a) = Left a
+	fmap f (Right a) = Right (f a)
+
hunk ./src/Control/Monad/Either.hs 30
-        Left e  >>= k = Left e
+        Left e  >>= _ = Left e
hunk ./src/Control/Monad/Free.hs 17
-import Control.Functor.Contravariant
+-- import Control.Functor.Contravariant
addfile ./src/Control/Monad/HigherOrder.hs
hunk ./src/Control/Monad/HigherOrder.hs 1
+-----------------------------------------------------------------------------
+-- |
+-- Module      :  Control.Monad.HigherOrder
+-- Copyright   :  (C) 2008 Edward Kmett
+-- License     :  BSD-style (see the file LICENSE)
+--
+-- Maintainer  :  Edward Kmett <ekmett@gmail.com>
+-- Stability   :  experimental
+-- Portability :  non-portable (rank-2 polymorphism)
+--
+----------------------------------------------------------------------------
+module Control.Monad.HigherOrder where
+
+import Control.Functor.Extras
+import Control.Functor.HigherOrder
+
+class HFunctor m => HMonad m where
+	hreturn :: Functor f => Natural f (m f)
+	hbind   :: (Functor f, Functor g) => Natural f (m g) -> Natural (m f) (m g)
hunk ./src/Control/Morphism/Ana.hs 12
--- Traditional operators, shown here to show how to roll your own
hunk ./src/Control/Morphism/Ana.hs 18
-import Control.Comonad
+import Control.Functor.HigherOrder
+import Control.Comonad ()
hunk ./src/Control/Morphism/Ana.hs 21
-import Control.Comonad.Identity
+import Control.Comonad.Identity ()
hunk ./src/Control/Morphism/Ana.hs 25
+-- | Anamorphisms are a generalized form of 'unfoldr'
hunk ./src/Control/Morphism/Ana.hs 27
--- ana g = g_ana distAna (liftCoAlg g)
hunk ./src/Control/Morphism/Ana.hs 28
+-- ana g = g_ana distAna (liftCoAlg g)
hunk ./src/Control/Morphism/Ana.hs 30
+-- | Generalized anamorphisms allow you to work with a monad given a distributive law
hunk ./src/Control/Morphism/Ana.hs 35
+-- | The distributive law for the identity monad
hunk ./src/Control/Morphism/Ana.hs 39
+-- | A higher-order anamorphism for constructing higher order functors.
+anaH :: HFunctor f => CoAlgH f a -> Natural a (NuH f)
+anaH g = InH . hfmap (anaH g) . g
hunk ./src/Control/Morphism/Cata.hs 20
+import Control.Functor.HigherOrder
hunk ./src/Control/Morphism/Cata.hs 42
+cataH :: HFunctor f => AlgH f a -> Natural (MuH f) a
+cataH f = f . hfmap (cataH f) . outH
+
hunk ./src/Control/Morphism/Futu.hs 19
-import Control.Comonad
+import Control.Comonad ()
hunk ./src/Control/Morphism/Hylo.hs 22
+import Control.Functor.HigherOrder
hunk ./src/Control/Morphism/Hylo.hs 41
+-- | higher order hylomorphisms for use in building up and tearing down higher order functors
+hyloH :: HFunctor f => AlgH f b -> CoAlgH f a -> Natural a b
+hyloH f g = f . hfmap (hyloH f g) . g
+
}
