[0.44.1
ekmett@gmail.com**20080505003610
 
 Initial package for hackage
 Better documentation forthcoming
 
] {
adddir ./src/Control/Arrow
adddir ./src/Control/Comonad/Indexed
adddir ./src/Control/Monad/Indexed
hunk ./Makefile 15
+sdist:
+	@runhaskell Setup.lhs sdist
+
hunk ./Makefile 21
-run:
-	$(GHCI) Control.Comonad.State
-
hunk ./Setup.lhs 3
-> main = defaultMainWithHooks defaultUserHooks
+> main = defaultMainWithHooks simpleUserHooks
hunk ./category-extras.cabal 3
-version:		0.41
+version:		0.44.1
hunk ./category-extras.cabal 12
+build-type: 		Simple
hunk ./category-extras.cabal 36
---	Control.Arrow.CoKleisli,
+	Control.Arrow.BiKleisli,
+	Control.Arrow.CoKleisli,
hunk ./category-extras.cabal 39
-	Control.Bifunctor.Braided,
hunk ./category-extras.cabal 40
-	Control.Bifunctor.Instances,
+	Control.Bifunctor.Braided,
+	Control.Bifunctor.Composition,
+	Control.Bifunctor.Either,
hunk ./category-extras.cabal 46
-	Control.Bifunctor.Composition,
+	Control.Bifunctor.Pair,
hunk ./category-extras.cabal 49
-	Control.Comonad.Cofree.Alt,
hunk ./category-extras.cabal 50
-	Control.Comonad.Identity,
-	Control.Comonad.Instances,
-	Control.Comonad.HigherOrder,
hunk ./category-extras.cabal 52
+	Control.Comonad.Identity,
+	Control.Comonad.Indexed,
+	Control.Comonad.HigherOrder,
hunk ./category-extras.cabal 74
+	Control.Functor.Indexed,
hunk ./category-extras.cabal 76
+	Control.Functor.Strong,
hunk ./category-extras.cabal 80
+	Control.Functor.Zip,
+	Control.Functor.Zap,
hunk ./category-extras.cabal 85
+	Control.Monad.Indexed,
+	Control.Monad.Indexed.State,
+	Control.Monad.Indexed.Cont,
hunk ./category-extras.cabal 90
+	Control.Monad.Hyper,
addfile ./src/Control/Arrow/BiKleisli.hs
hunk ./src/Control/Arrow/BiKleisli.hs 1
+-------------------------------------------------------------------------------------------
+-- |
+-- Module	: Control.Arrow.BiKleisli
+-- Copyright 	: 2008 Edward Kmett
+-- License	: BSD3
+--
+-- Maintainer	: Edward Kmett <ekmett@gmail.com>
+-- Stability	: experimental
+-- Portability	: portable
+--
+-------------------------------------------------------------------------------------------
+
+module Control.Arrow.BiKleisli where
+
+#if __GLASGOW_HASKELL__ >= 609 
+import Prelude hiding (id,(.))
+import Control.Category
+#endif
+import Control.Monad (liftM)
+import Control.Comonad
+import Control.Arrow
+import Control.Functor.Extras
+
+newtype BiKleisli w m a b = BiKleisli { runBiKleisli :: w a -> m b } 
+
+instance Monad m => Functor (BiKleisli w m a) where
+	fmap f (BiKleisli g) = BiKleisli (liftM f . g)
+
+instance (Comonad w, Monad m, Distributes w m) => Arrow (BiKleisli w m) where
+	arr f = BiKleisli (return . f . extract)
+	first (BiKleisli f) = BiKleisli $ \x -> do
+		u <- f (fmap fst x)
+		return (u, extract (fmap snd x))
+#if __GLASGOW_HASKELL__ < 609
+	BiKleisli g >>> BiKleisli f = BiKleisli ((>>= f) . dist . extend g)
+#else 
+instance (Comonad w, Monad m, Distributes w m) => Category (BiKleisli w m) where
+	BiKleisli f . BiKleisli g = BiKleisli ((>>=f) . dist . extend g)
+	id = BiKleisli (return . extract)
+#endif
addfile ./src/Control/Arrow/CoKleisli.hs
hunk ./src/Control/Arrow/CoKleisli.hs 1
+-------------------------------------------------------------------------------------------
+-- |
+-- Module	: Control.Arrow.CoKleisli
+-- Copyright 	: 2008 Edward Kmett
+-- License	: BSD3
+--
+-- Maintainer	: Edward Kmett <ekmett@gmail.com>
+-- Stability	: experimental
+-- Portability	: portable
+--
+-------------------------------------------------------------------------------------------
+module Control.Arrow.CoKleisli where
+
+#if __GLASGOW_HASKELL__ >= 609 
+import Prelude hiding (id,(.))
+import Control.Category
+#endif
+import Control.Comonad
+import Control.Arrow
+
+newtype CoKleisli w a b = CoKleisli { runCoKleisli :: w a -> b } 
+
+instance Functor (CoKleisli w a) where
+	fmap f (CoKleisli g) = CoKleisli (f . g)
+
+instance Comonad w => Arrow (CoKleisli w) where
+	arr f = CoKleisli (f . extract)
+	CoKleisli a &&& CoKleisli b = CoKleisli (a &&& b)
+	CoKleisli a *** CoKleisli b = CoKleisli (a . fmap fst &&& b . fmap snd)
+	first a = a *** CoKleisli extract
+	second a = CoKleisli extract *** a
+#if __GLASGOW_HASKELL__ >= 609
+instance Comonad w => Category (CoKleisli w) where
+	id = CoKleisli extract
+	CoKleisli b . CoKleisli a = CoKleisli (b . fmap a . duplicate)
+#else
+	CoKleisli a >>> CoKleisli b = CoKleisli (b . fmap a . duplicate)
+#endif
+
hunk ./src/Control/Bifunctor.hs 14
-import Prelude hiding (id)
-
hunk ./src/Control/Bifunctor.hs 16
+	first :: (a -> c) -> f a b -> f c b
+	first f = bimap f id
+	second :: (b -> d) -> f a b -> f a d
+	second = bimap id
hunk ./src/Control/Bifunctor/Composition.hs 1
+-------------------------------------------------------------------------------------------
+-- |
+-- Module	: Control.Bifunctor.Composition
+-- Copyright 	: 2008 Edward Kmett
+-- License	: BSD3
+--
+-- Maintainer	: Edward Kmett <ekmett@gmail.com>
+-- Stability	: experimental
+-- Portability	: portable
+--
+-------------------------------------------------------------------------------------------
+
hunk ./src/Control/Bifunctor/Composition.hs 15
+
hunk ./src/Control/Bifunctor/Composition.hs 38
-
hunk ./src/Control/Bifunctor/Composition.hs 88
+
+
hunk ./src/Control/Bifunctor/Composition.hs 98
-{-
-instance Coassociative p => Associative (SwapB p) where
-	associate = liftSwapB coassociate
-
-instance Associative p => Coassociative (SwapB p) where
-	coassociate = liftSwapB associate
--}
-
hunk ./src/Control/Bifunctor/Composition.hs 103
-{-
-instance HasIdentity p i => HasIdentity (SwapB p) i
+instance Bifunctor p => Functor (SwapB p a) where
+	fmap = bimap id
hunk ./src/Control/Bifunctor/Composition.hs 106
-instance Monoidal p i => Monoidal (SwapB p) i where
-	idl = idr . runSwapB
-	idr = idl . runSwapB
hunk ./src/Control/Bifunctor/Composition.hs 107
-instance Comonoidal p i => Comonoidal (SwapB p) i where
-	coidl = SwapB . coidr
-	coidr = SwapB . coidl
--}
hunk ./src/Control/Bifunctor/Composition.hs 108
-instance Bifunctor p => Functor (SwapB p a) where
-	fmap = bimap id
hunk ./src/Control/Bifunctor/Composition.hs 124
-{-
-instance (Functor f, Associative p) => Associative (FunctorB f p) where
-	associate = FunctorB . fmap associate . runFunctorB 
+instance (Functor f, Bifunctor p) => Functor (FunctorB f p a) where
+	fmap = bimap id
hunk ./src/Control/Bifunctor/Composition.hs 127
-instance (Functor f, Coassociative p) => Coassociative (FunctorB f p) where
-	coassociate = FunctorB . fmap f . runFunctorB
hunk ./src/Control/Bifunctor/Composition.hs 128
-instance (Functor f, HasIdentity p i) => HasIdentity (FunctorB f p) i
+-- a bifunctor wrapping a pair of functors with different values
hunk ./src/Control/Bifunctor/Composition.hs 130
+newtype BiffB p f g a b = BiffB { runBiffB :: p (f a) (g b) } 
hunk ./src/Control/Bifunctor/Composition.hs 132
-instance (Copointed f, Monoidal p i) => Monoidal (FunctorB f p) i where
-	idr = idr . copoint . runFunctorB
-	idl = idl . copoint . runFunctorB
-	
-instance (Pointed f, Comonoidal p i) => Comonoidal (FunctorB f p) i where
-	coidr = FunctorB . point . coidr
-	coidl = FunctorB . point . coidl
--}
+instance (Functor f, Bifunctor p, Functor g) => Bifunctor (BiffB p f g) where
+	bimap f g = BiffB . bimap (fmap f) (fmap g) . runBiffB
hunk ./src/Control/Bifunctor/Composition.hs 135
-instance (Functor f, Bifunctor p) => Functor (FunctorB f p a) where
-	fmap = bimap id
+instance (Functor f, Braided p) => Braided (BiffB p f f) where
+	braid = BiffB . braid . runBiffB
+
+instance (Functor f, Symmetric p) => Symmetric (BiffB p f f) 
+
+instance (Functor f, Bifunctor p, Functor g) => Functor (BiffB p f g a) where
+	fmap f = bimap id f
addfile ./src/Control/Bifunctor/Either.hs
hunk ./src/Control/Bifunctor/Either.hs 1
+{-# OPTIONS -fglasgow-exts #-}
+-----------------------------------------------------------------------------
+-- |
+-- Module      :  Control.Bifunctor.Either
+-- Copyright   :  (C) 2008 Edward Kmett
+-- License     :  BSD-style (see the file LICENSE)
+--
+-- Maintainer  :  Edward Kmett <ekmett@gmail.com>
+-- Stability   :  experimental
+-- Portability :  portable
+--
+----------------------------------------------------------------------------
+module Control.Bifunctor.Either where
+
+import Control.Bifunctor
+import Control.Bifunctor.Associative
+import Control.Bifunctor.Monoidal
+import Control.Bifunctor.Braided
+import Data.Void
+import Control.Arrow ((***), (+++))
+
+instance Bifunctor Either where
+	bimap = (+++)
+
+instance Associative Either where
+	associate (Left (Left a)) = Left a
+	associate (Left (Right b)) = Right (Left b)
+	associate (Right c) = Right (Right c)
+
+instance Coassociative Either where
+	coassociate (Left a) = Left (Left a)
+	coassociate (Right (Left b)) = Left (Right b)
+	coassociate (Right (Right c)) = Right c
+
+instance Braided Either where
+	braid (Left a) = Right a
+	braid (Right b) = Left b
+
+instance Symmetric Either
hunk ./src/Control/Bifunctor/Instances.hs 1
-{-# OPTIONS -fglasgow-exts #-}
------------------------------------------------------------------------------
--- |
--- Module      :  Control.Bifunctor.Instances
--- Copyright   :  (C) 2008 Edward Kmett
--- License     :  BSD-style (see the file LICENSE)
---
--- Maintainer  :  Edward Kmett <ekmett@gmail.com>
--- Stability   :  experimental
--- Portability :  portable
---
-----------------------------------------------------------------------------
-module Control.Bifunctor.Instances where
-
-import Control.Bifunctor
-import Control.Bifunctor.Associative
-import Control.Bifunctor.Monoidal
-import Control.Bifunctor.Braided
-import Data.Void
-import Control.Arrow ((***), (+++))
-
-instance Bifunctor (,) where
-        bimap = (***)
-
-instance Associative (,) where
-	associate ((a,b),c) = (a,(b,c))
-
-instance Coassociative (,) where
-	coassociate (a,(b,c)) = ((a,b),c)
-
-instance HasIdentity (,) Void
-
-instance Monoidal (,) Void where
-	idl = snd
-	idr = fst
-
-instance Braided (,) where
-	braid ~(a,b) = (b,a)
-
-instance Symmetric (,)
-
-instance Bifunctor Either where
-	bimap = (+++)
-
-instance Associative Either where
-	associate (Left (Left a)) = Left a
-	associate (Left (Right b)) = Right (Left b)
-	associate (Right c) = Right (Right c)
-
-instance Coassociative Either where
-	coassociate (Left a) = Left (Left a)
-	coassociate (Right (Left b)) = Left (Right b)
-	coassociate (Right (Right c)) = Right c
-
-instance Braided Either where
-	braid (Left a) = Right a
-	braid (Right b) = Left b
-
-instance Symmetric Either
-
--- Either is NOT Comonoidal! bottom inhabits every type
rmfile ./src/Control/Bifunctor/Instances.hs
addfile ./src/Control/Bifunctor/Pair.hs
hunk ./src/Control/Bifunctor/Pair.hs 1
+{-# OPTIONS -fglasgow-exts #-}
+-----------------------------------------------------------------------------
+-- |
+-- Module      :  Control.Bifunctor.Pair
+-- Copyright   :  (C) 2008 Edward Kmett
+-- License     :  BSD-style (see the file LICENSE)
+--
+-- Maintainer  :  Edward Kmett <ekmett@gmail.com>
+-- Stability   :  experimental
+-- Portability :  portable
+--
+----------------------------------------------------------------------------
+module Control.Bifunctor.Pair where
+
+import Control.Bifunctor
+import Control.Bifunctor.Associative
+import Control.Bifunctor.Monoidal
+import Control.Bifunctor.Braided
+import Data.Void
+import Control.Arrow ((***), (+++))
+
+instance Bifunctor (,) where
+        bimap = (***)
+
+instance Associative (,) where
+	associate ((a,b),c) = (a,(b,c))
+
+instance Coassociative (,) where
+	coassociate (a,(b,c)) = ((a,b),c)
+
+instance HasIdentity (,) Void
+
+instance Monoidal (,) Void where
+	idl = snd
+	idr = fst
+
+instance Braided (,) where
+	braid ~(a,b) = (b,a)
+
+instance Symmetric (,)
+
hunk ./src/Control/Comonad/Cofree.hs 15
+import Control.Arrow ((&&&))
+import Control.Bifunctor
+import Control.Bifunctor.Fix
+import Control.Bifunctor.Composition
+import Control.Bifunctor.Pair
hunk ./src/Control/Comonad/Cofree.hs 21
-import Control.Functor.Pointed
-import Control.Functor.Contravariant
-import Control.Functor.Exponential
-import Control.Arrow ((|||), (&&&), (+++), (***))
+import Control.Comonad.Parameterized
+import Control.Comonad.Parameterized.Class
+import Control.Functor.Extras
+import Control.Monad.Identity
+import Control.Monad.Parameterized
+import Control.Monad.Parameterized.Class
hunk ./src/Control/Comonad/Cofree.hs 28
-data Cofree f a = Cofree { runCofree :: (a, f (Cofree f a)) }
+type CofreeB f a b = BiffB (,) Identity f a b
+type Cofree f a = FixB (BiffB (,) Identity f) a
hunk ./src/Control/Comonad/Cofree.hs 31
-instance Functor f => Functor (Cofree f) where
-        fmap f = Cofree . (f *** fmap (fmap f)) . runCofree
+instance Functor f => PComonad (BiffB (,) Identity f) where
+	pextract = runIdentity . fst . runBiffB
+	pextend f = BiffB . (Identity . f &&& snd . runBiffB)
hunk ./src/Control/Comonad/Cofree.hs 35
--- instance ContravariantFunctor f => ContravariantFunctor (Cofree f) where
---       contramap f = Cofree . (f *** contramap (fmap f)) . runCofree
-
-instance ExpFunctor f => ExpFunctor (Cofree f) where
-        xmap f g = Cofree . (f *** xmap (xmap f g) (xmap g f)) . runCofree
-
-instance Functor f => Comonad (Cofree f) where
-        extract = fst . runCofree
-        extend f = Cofree . (f &&& (fmap (extend f) . outCofree))
-
-instance Functor f => Copointed (Cofree f) where
-	copoint = extract
+instance FunctorPlus f => PMonad (BiffB (,) Identity f) where
+	preturn a = BiffB (Identity a,fzero)
+	pbind k (BiffB ~(Identity a,as)) = BiffB (ib, fplus as bs) where BiffB (ib,bs) = k a 
hunk ./src/Control/Comonad/Cofree.hs 40
-outCofree = snd . runCofree
+outCofree = snd . runBiffB . outB
+
+runCofree :: Cofree f a -> (a, f (Cofree f a))
+runCofree = first runIdentity . runBiffB . outB
hunk ./src/Control/Comonad/Cofree.hs 46
-anaCofree h t = Cofree . (h &&& fmap (anaCofree h t) . t)
+anaCofree h t = InB . BiffB . (Identity . h &&& fmap (anaCofree h t) . t)
+
+cofree :: a -> f (Cofree f a) -> Cofree f a 
+cofree a as = InB $ BiffB (Identity a,as)
hunk ./src/Control/Comonad/Context.hs 12
--- The 'state-in-context' comonad and comonad transformer
+-- The state-in-context comonad and comonad transformer
hunk ./src/Control/Comonad/Context.hs 40
-newtype ContextT s w a = ContextT { runContextT :: w (s -> a, s) }
+newtype ContextT s w a = ContextT { runContextT :: (w s -> a, w s) }
hunk ./src/Control/Comonad/Context.hs 43
-	getC = snd . extract . runContextT 
-	modifyC = undefined
+	getC = extract . snd . runContextT 
+	modifyC m (ContextT (f,c)) = f (fmap m c)
hunk ./src/Control/Comonad/Context.hs 46
-instance Functor f => Functor (ContextT b f) where
-        fmap f = ContextT . fmap (first (f .)) . runContextT
+instance Functor (ContextT b f) where
+        fmap f = ContextT . first (f .) . runContextT
hunk ./src/Control/Comonad/Context.hs 50
-        extract = uncurry id . extract . runContextT
-        duplicate = undefined -- ContextT . liftW (fst . extract &&& ContextT) . duplicate . runContextT
+        extract = uncurry id . runContextT
+        duplicate (ContextT (f,ws)) = ContextT (ContextT . (,) f, ws)
addfile ./src/Control/Comonad/Indexed.hs
hunk ./src/Control/Comonad/Indexed.hs 1
+-----------------------------------------------------------------------------
+-- |
+-- Module      :  Control.Comonad.Indexed
+-- Copyright   :  (C) 2008 Edward Kmett
+-- License     :  BSD-style (see the file LICENSE)
+--
+-- Maintainer  :  Edward Kmett <ekmett@gmail.com>
+-- Stability   :  experimental
+-- Portability :  portable 
+--
+----------------------------------------------------------------------------
+module Control.Comonad.Indexed where
+
+import Control.Comonad
+import Control.Arrow
+import Control.Functor.Extras
+import Control.Functor.HigherOrder
+import Control.Functor.Indexed
+import Control.Monad
+
+class IxFunctor w => IxComonad w where
+	iextract :: w i i a -> a
+	iextend :: (w j k a -> b) -> w i k a -> w i j b
+
+iduplicate :: IxComonad w => w i k a -> w i j (w j k a)
+iduplicate = iextend id
+
+instance Comonad w => IxComonad (LiftIx w) where
+	iextract = extract . lowerIx 
+	iextend f = LiftIx . extend (f . LiftIx) . lowerIx
hunk ./src/Control/Comonad/Instances.hs 1
-{-# OPTIONS -fglasgow-exts #-}
------------------------------------------------------------------------------
--- |
--- Module      :  Control.Comonad.Instances
--- Copyright   :  (C) 2008 Edward Kmett
--- License     :  BSD-style (see the file LICENSE)
---
--- Maintainer  :  Edward Kmett <ekmett@gmail.com>
--- Stability   :  experimental
--- Portability :  portable
---
-----------------------------------------------------------------------------
-module Control.Comonad.Instances where
-
-import Control.Comonad
-
-instance Comonad ((,)e) where
-        extract = snd
-        duplicate ~(e,a) = (e,(e,a))
rmfile ./src/Control/Comonad/Instances.hs
hunk ./src/Control/Comonad/Parameterized.hs 21
--- this does not seem to be nicely quantifiable
hunk ./src/Control/Comonad/Reader.hs 15
+import Control.Bifunctor
+import Control.Bifunctor.Pair
+import Control.Monad.Instances -- for Functor ((,)e)
hunk ./src/Control/Comonad/Reader.hs 20
-import Control.Arrow ((&&&), second)
+import Control.Arrow ((&&&))
hunk ./src/Control/Comonad/Reader.hs 35
+instance Bifunctor ReaderC where
+	bimap f g = uncurry ReaderC . bimap f g . runReaderC
hunk ./src/Control/Comonad/Reader.hs 39
-newtype ReaderCT r w a = ReaderCT { runReaderCT :: w (r, a) }
+newtype ReaderCT w r a = ReaderCT { runReaderCT :: w (r, a) }
hunk ./src/Control/Comonad/Reader.hs 41
-instance Comonad w => ComonadReader r (ReaderCT r w) where
+instance Comonad w => ComonadReader r (ReaderCT w r) where
hunk ./src/Control/Comonad/Reader.hs 44
-instance Functor f => Functor (ReaderCT b f) where
+instance Functor f => Functor (ReaderCT f b) where
hunk ./src/Control/Comonad/Reader.hs 47
-instance Comonad w => Comonad (ReaderCT b w) where
+instance Comonad w => Comonad (ReaderCT w b) where
hunk ./src/Control/Comonad/Reader.hs 51
+instance Functor f => Bifunctor (ReaderCT f) where
+	bimap f g = ReaderCT . fmap (bimap f g) . runReaderCT
+
+
+instance Comonad ((,)e) where
+        extract = snd
+        duplicate ~(e,a) = (e,(e,a))
+
+instance ComonadReader e ((,)e) where
+        askC = fst
+
+-- instance Functor ((,)e) where
+--        fmap f = second f 
+
+-- instance Bifunctor (,) where
+--        bimap f g = uncurry ReaderC . bimap f g . runReaderC
+
+
hunk ./src/Control/Functor/Bifunctor.hs 19
-import Control.Bifunctor.Instances
+import Control.Bifunctor.Pair
+import Control.Bifunctor.Either
hunk ./src/Control/Functor/Contravariant.hs 19
+newtype ContraF a b = ContraF { runContraF :: b -> a }
+
+instance ContravariantFunctor (ContraF a) where
+        contramap g (ContraF f) = ContraF (f . g)
hunk ./src/Control/Functor/Extras.hs 35
-class FunctorZero f where
+class Functor f => FunctorZero f where
hunk ./src/Control/Functor/Extras.hs 42
-class FunctorSplit f where
+class Functor f => FunctorSplit f where
hunk ./src/Control/Functor/Extras.hs 44
-	
addfile ./src/Control/Functor/Indexed.hs
hunk ./src/Control/Functor/Indexed.hs 1
+-----------------------------------------------------------------------------
+-- |
+-- Module      :  Control.Functor.Indexed
+-- Copyright   :  (C) 2008 Edward Kmett
+-- License     :  BSD-style (see the file LICENSE)
+--
+-- Maintainer  :  Edward Kmett <ekmett@gmail.com>
+-- Stability   :  experimental
+-- Portability :  portable
+--
+----------------------------------------------------------------------------
+module Control.Functor.Indexed where
+
+import Control.Comonad
+import Control.Arrow
+import Control.Functor.Extras
+import Control.Functor.HigherOrder
+import Control.Monad
+
+class IxFunctor f where
+	imap :: (a -> b) -> f j k a -> f j k b
+
+newtype LiftIx m i j a = LiftIx { lowerIx :: m a }
+
+instance Functor f => IxFunctor (LiftIx f) where
+        imap f = LiftIx . fmap f . lowerIx
+
+newtype LowerIx m i a = LowerIx { liftIx :: m i i a } 
+
+instance IxFunctor f => Functor (LowerIx f i) where
+	fmap f = LowerIx . imap f . liftIx
hunk ./src/Control/Functor/Representable.hs 24
+
+data EitherF a b c = EitherF (a -> c) (b -> c)
+
+instance Functor (EitherF a b) where
+        fmap f (EitherF l r) = EitherF (f . l) (f . r)
+
+instance Representable (EitherF a b) (Either a b) where
+        rep f = EitherF (f . Left) (f . Right)
+        unrep (EitherF l r) = either l r
addfile ./src/Control/Functor/Strong.hs
hunk ./src/Control/Functor/Strong.hs 1
+{-# OPTIONS -fglasgow-exts -fallow-undecidable-instances #-}
+-------------------------------------------------------------------------------------------
+-- |
+-- Module	: Control.Functor.Strong
+-- Copyright 	: 2008 Edward Kmett
+-- License	: BSD
+--
+-- Maintainer	: Edward Kmett <ekmett@gmail.com>
+-- Stability	: experimental
+-- Portability	: non-portable (functional-dependencies)
+--
+-------------------------------------------------------------------------------------------
+
+module Control.Functor.Strong where
+
+import Prelude hiding (sequence)
+import Data.Traversable
+import Control.Monad.Either
+
+strength :: Functor f => f a -> b -> f (a,b)
+strength fa b = fmap (\a -> (a,b)) fa
+
+costrength :: Traversable f => f (Either a b) -> Either a (f b)
+costrength = sequence
addfile ./src/Control/Functor/Zap.hs
hunk ./src/Control/Functor/Zap.hs 1
+{-# OPTIONS -fglasgow-exts -fallow-undecidable-instances #-}
+-------------------------------------------------------------------------------------------
+-- |
+-- Module	: Control.Functor.Zap
+-- Copyright 	: 2008 Edward Kmett
+-- License	: BSD
+--
+-- Maintainer	: Edward Kmett <ekmett@gmail.com>
+-- Stability	: experimental
+-- Portability	: non-portable (functional-dependencies)
+--
+-- Dual Functors
+-------------------------------------------------------------------------------------------
+
+module Control.Functor.Zap where
+
+import Control.Bifunctor
+import Control.Bifunctor.Composition
+import Control.Comonad.Cofree
+import Control.Monad.Either
+import Control.Monad.Free
+import Control.Monad.Identity
+import Data.Traversable
+
+{- | Minimum definition: zapWith -}
+
+class Zap f g | f -> g, g -> f where
+	zapWith :: (a -> b -> c) -> f a -> g b -> c
+	zap :: f (a -> b) -> g a -> b
+	zap = zapWith id
+
+(>$<) :: Zap f g => f (a -> b) -> g a -> b
+(>$<) = zap
+
+instance Zap Identity Identity where
+	zapWith f (Identity a) (Identity b) = f a b
+
+{- | Minimum definition: bizapWith -}
+
+class BiZap p q | p -> q, q -> p where
+	bizapWith :: (a -> c -> e) -> (b -> d -> e) -> p a b -> q c d -> e
+
+	bizap :: p (a -> c) (b -> c) -> q a b -> c
+	bizap = bizapWith id id
+
+(>>$<<) :: BiZap p q => p (a -> c) (b -> c) -> q a b -> c
+(>>$<<) = bizap
+
+instance BiZap (,) Either where
+	bizapWith l _ (f,_) (Left a) = l f a
+	bizapWith _ r (_,g) (Right b) = r g b 
+
+instance BiZap Either (,) where
+	bizapWith l _ (Left f) (a,_) = l f a
+	bizapWith _ r (Right g) (_,b) = r g b
+
+-- instance (Functor f, Functor g, Zap f g) => BiZap (CofreeB f) (FreeB g) where
+--	bizapWith l r (CofreeB fs) (FreeB as) = bizapWith l (zapWith r) fs as
+
+-- instance (Functor f, Functor g, Zap f g) => BiZap (FreeB f) (CofreeB g) where
+--	bizapWith l r (FreeB fs) (CofreeB as) = bizapWith l (zapWith r) fs as
+
+instance (BiZap p q, Zap f g, Zap i j) => BiZap (BiffB p f i) (BiffB q g j) where
+	bizapWith l r fs as = bizapWith (zapWith l) (zapWith r) (runBiffB fs) (runBiffB as)
addfile ./src/Control/Functor/Zip.hs
hunk ./src/Control/Functor/Zip.hs 1
+-------------------------------------------------------------------------------------------
+-- |
+-- Module	: Control.Functor.Zip
+-- Copyright 	: 2008 Edward Kmett
+-- License	: BSD
+--
+-- Maintainer	: Edward Kmett <ekmett@gmail.com>
+-- Stability	: experimental
+-- Portability	: portable
+--
+-------------------------------------------------------------------------------------------
+
+module Control.Functor.Zip where
+
+import Control.Arrow ((&&&))
+import Control.Bifunctor
+import Control.Bifunctor.Composition
+import Control.Bifunctor.Pair -- Bifunctor (,)
+import Control.Bifunctor.Fix
+import Control.Comonad.Cofree
+import Control.Monad.Free
+import Control.Monad.Identity
+import Data.Monoid
+
+unfzip :: Functor f => f (a, b) -> (f a, f b)
+unfzip = fmap fst &&& fmap snd
+
+unbizip :: Bifunctor p => p (a, c) (b, d) -> (p a b, p c d)
+unbizip = bimap fst fst &&& bimap snd snd
+
+{- | Minimum definition:
+
+1. fzipWith
+
+2. fzip
+
+-}
+
+class Functor f => Zip f where
+	fzip :: f a -> f b -> f (a, b)
+	fzip = fzipWith (,)
+	fzipWith :: (a -> b -> c) -> f a -> f b -> f c
+	fzipWith f as bs = fmap (uncurry f) (fzip as bs)
+
+{- | Minimum definition: 
+
+1. bizipWith
+
+2. bizip
+
+-}
+
+class Bifunctor p => Bizip p where
+	bizip :: p a c -> p b d -> p (a,b) (c,d)
+	bizip = bizipWith (,) (,)
+	bizipWith :: (a -> b -> e) -> (c -> d -> f) -> p a c -> p b d -> p e f 
+	bizipWith f g as bs = bimap (uncurry f) (uncurry g) (bizip as bs)
+
+instance Zip Identity where
+	fzipWith f (Identity a) (Identity b) = Identity (f a b)
+
+instance Zip [] where
+	fzip = zip
+	fzipWith = zipWith
+
+instance Zip Maybe where
+	fzipWith f (Just a) (Just b) = Just (f a b)
+	fzipWith f _ _ = Nothing
+
+instance Monoid a => Zip ((,)a) where
+	fzipWith f (a, c) (b, d) = (mappend a b, f c d)
+
+instance Bizip (,) where 
+	bizipWith f g (a,b) (c,d) = (f a c, g b d)
+
+-- comes for free with BiffB
+-- instance Zip f => Bizip (CofreeB f) where
+--	bizipWith f g (CofreeB as) (CofreeB bs) = CofreeB $ bizipWith f (fzipWith g) as bs
+
+instance (Bizip p, Zip f, Zip g) => Bizip (BiffB p f g) where
+	bizipWith f g as bs = BiffB $ bizipWith (fzipWith f) (fzipWith g) (runBiffB as) (runBiffB bs)
+
+instance (Zip f, Bizip p) => Bizip (FunctorB f p) where
+	bizipWith f g as bs = FunctorB $ fzipWith (bizipWith f g) (runFunctorB as) (runFunctorB bs)
+
+instance Bizip p => Zip (FixB p) where
+	fzipWith f as bs = InB $ bizipWith f (fzipWith f) (outB as) (outB bs)
+
+instance Monoid a => Zip (Either a) where
+	fzipWith f (Left a) (Left b) = Left (mappend a b)
+	fzipWith f (Right a) (Left b) = Left b
+	fzipWith f (Left a) (Right b) = Left a
+	fzipWith f (Right a) (Right b) = Right (f a b)
+
+
+{- -- fails because Either cannot be made an instance of Bizip!
+instance Zip f => Bizip (FreeB f) where
+	bizipWith f g (FreeB as) (FreeB bs) = FreeB $ bizipWith f (fzipWith g) as bs
+-}
hunk ./src/Control/Monad/Free.hs 16
+import Control.Bifunctor
+import Control.Bifunctor.Either
+import Control.Bifunctor.Fix
+import Control.Bifunctor.Composition
+import Control.Functor.Extras
hunk ./src/Control/Monad/Free.hs 22
--- import Control.Functor.Contravariant
+import Control.Functor.Contravariant
hunk ./src/Control/Monad/Free.hs 24
+import Control.Monad.Identity
+import Control.Monad.Parameterized
+import Control.Monad.Parameterized.Class
+import Control.Comonad.Parameterized
+import Control.Comonad.Parameterized.Class
hunk ./src/Control/Monad/Free.hs 30
--- | The free monad of a functor
-data Free f a = Free { runFree :: Either a (f (Free f a)) }
+instance Functor f => PMonad (BiffB Either Identity f) where
+        preturn = BiffB . Left . Identity
+        pbind k = (k . runIdentity ||| BiffB . Right) . runBiffB
hunk ./src/Control/Monad/Free.hs 34
-instance Functor f => Functor (Free f) where
-        fmap f = Free . (f +++ fmap (fmap f)) . runFree
-
---instance ContravariantFunctor f => ContravariantFunctor (Free f) where
---        contramap f = Free . (f +++ contramap (fmap f)) . runFree
-
-instance ExpFunctor f => ExpFunctor (Free f) where
-        xmap f g = Free . (f +++ xmap (xmap f g) (xmap g f)) . runFree
-
-instance Functor f => Monad (Free f) where
-        return = Free . Left
-        m >>= k = (k ||| (inFree . fmap (>>= k))) (runFree m)
+type FreeB f a b = BiffB Either Identity f a b
+type Free f a = FixB (BiffB Either Identity f) a
hunk ./src/Control/Monad/Free.hs 38
-inFree = Free . Right
+inFree = InB . BiffB . Right
+
+runFree :: Free f a -> Either a (f (Free f a))
+runFree = first runIdentity . runBiffB . outB
hunk ./src/Control/Monad/Free.hs 44
-cataFree l r = (l ||| r . fmap (cataFree l r)) . runFree
+cataFree l r = (l . runIdentity ||| r . fmap (cataFree l r)) . runBiffB . outB
hunk ./src/Control/Monad/Free.hs 46
+free :: Either a (f (Free f a)) -> Free f a
+free = InB . BiffB . first Identity
addfile ./src/Control/Monad/Hyper.hs
hunk ./src/Control/Monad/Hyper.hs 1
+-------------------------------------------------------------------------------------------
+-- |
+-- Module	: Control.Monad.Hyper
+-- Copyright 	: 2008 Edward Kmett
+-- License	: BSD
+--
+-- Maintainer	: Edward Kmett <ekmett@gmail.com>
+-- Stability	: experimental
+-- Portability	: non-portable (functional-dependencies)
+--
+-- Based on the construction of hyperfunctions as parameterized monads in 
+-- <http://crab.rutgers.edu/~pjohann/f14-ghani.pdf>
+-------------------------------------------------------------------------------------------
+
+module Control.Monad.Hyper where
+
+import Control.Bifunctor
+import Control.Bifunctor.Fix
+import Control.Monad.Parameterized.Class
+import Control.Functor.Contravariant
+import Control.Monad.Instances
+
+newtype HyperB h a b = HyperB { runHyperB :: h b -> a } 
+
+instance ContravariantFunctor h => Bifunctor (HyperB h) where
+	bimap f g h = HyperB (f . runHyperB h . contramap g)
+
+instance ContravariantFunctor h => PMonad (HyperB h) where
+	preturn = HyperB . const
+	pbind k (HyperB h) = HyperB (k . h >>= runHyperB) -- the bind is in the (->)e monad
+
+-- | A generic recursive hyperfunction-like combinator
+type Hyper h a = FixB (HyperB h)
+
+-- | Traditional Hyper functions
+type Hyp e a = Hyper (ContraF e) a
+
addfile ./src/Control/Monad/Indexed.hs
hunk ./src/Control/Monad/Indexed.hs 1
+-----------------------------------------------------------------------------
+-- |
+-- Module      :  Control.Monad.Indexed
+-- Copyright   :  (C) 2008 Edward Kmett
+-- License     :  BSD-style (see the file LICENSE)
+--
+-- Maintainer  :  Edward Kmett <ekmett@gmail.com>
+-- Stability   :  experimental
+-- Portability :  non-portable (rank-2 polymorphism)
+--
+----------------------------------------------------------------------------
+module Control.Monad.Indexed where
+
+import Control.Comonad
+import Control.Arrow
+import Control.Functor.Extras
+import Control.Functor.HigherOrder
+import Control.Functor.Indexed
+import Control.Monad
+
+class IxFunctor m => IxMonad m where
+	ireturn :: a -> m i i a
+	ibind :: (a -> m j k b) -> m i j a -> m i k b
+
+ijoin :: IxMonad m => m i j (m j k a) -> m i k a 
+ijoin = ibind id
+
+infixl 1 >>>=
+
+(>>>=) :: IxMonad m => m i j a -> (a -> m j k b) -> m i k b
+m >>>= k = ibind k m 
+
+instance (Functor m, Monad m) => IxMonad (LiftIx m) where
+	ireturn = LiftIx . return
+	ibind f m = LiftIx (lowerIx m >>= lowerIx . f)
+
+instance (IxMonad m) => Monad (LowerIx m i) where
+	return = LowerIx . ireturn
+	m >>= f = LowerIx (liftIx m >>>= liftIx . f)
addfile ./src/Control/Monad/Indexed/Cont.hs
hunk ./src/Control/Monad/Indexed/Cont.hs 1
+{-# OPTIONS -fglasgow-exts #-}
+-------------------------------------------------------------------------------------------
+-- |
+-- Module	: Control.Monad.Indexed.Cont
+-- Copyright 	: 2008 Edward Kmett
+--		  2008 Dan Doel
+-- License	: BSD
+--
+-- Maintainer	: Edward Kmett <ekmett@gmail.com>
+-- Stability	: experimental
+-- Portability	: portable
+--
+-------------------------------------------------------------------------------------------
+
+module Control.Monad.Indexed.Cont where
+
+import Control.Monad.Identity
+import Control.Functor.Indexed
+import Control.Monad.Indexed
+
+
+newtype IxContT m r o a = IxContT { runIxContT :: (a -> m o) -> m r }
+
+runIxContT_ :: Monad m => IxContT m r a a -> m r 
+runIxContT_ m = runIxContT m return
+
+-- runIxContT :: Monad m => IxContT m r a a -> m r
+-- runIxContT m = unIxContT m return
+
+instance IxFunctor (IxContT m) where
+	imap f m = IxContT $ \c -> runIxContT m (c . f)
+
+
+instance Monad m => IxMonad (IxContT m) where
+	ireturn a = IxContT ($a)
+	ibind f c = IxContT $ \k -> runIxContT c $ \a -> runIxContT (f a) k
+
+class IxMonad m => IxContMonad m where
+	reset :: m a o o -> m r r a
+	shift :: ((a -> m i i o) -> m r j j) -> m r o a
+
+
+instance Monad m => IxContMonad (IxContT m) where
+	reset e = IxContT $ \k -> runIxContT e return >>= k
+	shift e = IxContT $ \k -> e (\a -> IxContT (\k' -> k a >>= k')) `runIxContT` return
+
+newtype IxCont r o a = IxCont (IxContT Identity r o a) deriving (IxFunctor, IxMonad, IxContMonad)
+
+runIxCont :: IxCont r o a -> (a -> o) -> r 
+runIxCont (IxCont k) f = runIdentity $ runIxContT k (return . f)
+
+runIxCont_ :: IxCont r a a -> r
+runIxCont_ m = runIxCont m id
addfile ./src/Control/Monad/Indexed/State.hs
hunk ./src/Control/Monad/Indexed/State.hs 1
+-----------------------------------------------------------------------------
+-- |
+-- Module      :  Control.Monad.Indexed.State
+-- Copyright   :  (C) 2008 Edward Kmett
+-- License     :  BSD-style (see the file LICENSE)
+--
+-- Maintainer  :  Edward Kmett <ekmett@gmail.com>
+-- Stability   :  experimental
+-- Portability :  non-portable (rank-2 polymorphism)
+--
+----------------------------------------------------------------------------
+module Control.Monad.Indexed.State where
+
+import Control.Comonad
+import Control.Arrow
+import Control.Functor.Extras
+import Control.Functor.HigherOrder
+import Control.Functor.Indexed
+import Control.Monad
+import Control.Monad.Indexed
+
+newtype IxState i j a = IxState { runIxState :: i -> (a, j) }
+
+instance IxFunctor IxState where
+	imap f (IxState m) = IxState (first f . m)
+
+instance IxMonad IxState where
+	ireturn = IxState . (,)
+	ibind f (IxState m) = IxState $ \s1 -> let (a,s2) = m s1 in runIxState (f a) s2 
hunk ./src/Control/Morphism/Para.hs 17
-import Control.Comonad.Instances
hunk ./src/Control/Morphism/Para.hs 28
-g_para :: (Functor f, Comonad w) => Dist f w -> AlgW f (ParaT f w) a -> Fix f -> a
+g_para :: (Functor f, Comonad w) => Dist f w -> AlgW f (ParaT w f) a -> Fix f -> a
hunk ./src/Control/Morphism/Para.hs 32
-type ParaT f w a 	= ReaderCT (Fix f) w a
+type ParaT w f a 	= ReaderCT w (Fix f) a
hunk ./src/Control/Morphism/Para.hs 34
-distParaT :: (Functor f, Comonad w) => Dist f w -> Dist f (ParaT f w)
+distParaT :: (Functor f, Comonad w) => Dist f w -> Dist f (ParaT w f)
hunk ./src/Control/Morphism/Zygo.hs 15
-
+import Control.Arrow ((&&&))
+import Control.Bifunctor.Pair
+import Control.Comonad
+import Control.Comonad.Reader
hunk ./src/Control/Morphism/Zygo.hs 22
-import Control.Comonad
-import Control.Comonad.Reader
-import Control.Comonad.Instances
hunk ./src/Control/Morphism/Zygo.hs 23
-import Control.Arrow ((&&&))
hunk ./src/Control/Morphism/Zygo.hs 29
-g_zygo :: (Functor f, Comonad w) => AlgW f w b -> Dist f w -> AlgW f (ReaderCT b w) a -> Fix f -> a
+g_zygo :: (Functor f, Comonad w) => AlgW f w b -> Dist f w -> AlgW f (ReaderCT w b) a -> Fix f -> a
hunk ./src/Control/Morphism/Zygo.hs 37
-distZygoT :: (Functor f, Comonad w) => AlgW f w b -> Dist f w -> Dist f (ReaderCT b w)
+distZygoT :: (Functor f, Comonad w) => AlgW f w b -> Dist f w -> Dist f (ReaderCT w b)
}
