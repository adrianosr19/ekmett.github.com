[0.44.3
ekmett@gmail.com**20080507054023
 
 Fleshed out IxState
 
 Cleared up -Wall and all orphans except the unfixable ones in Control.Monad.Either
 
 Merged some of the near-empty files together
 
] {
move ./src/Control/Bifunctor/Pair.hs ./src/Control/Bifunctor/Tuple.hs
adddir ./src/Control/Applicative
rmdir ./src/Control/Comonad/Indexed
adddir ./src/Control/Functor/Indexed
hunk ./Makefile 5
-
hunk ./Makefile 8
+over: clean config all html
+
+clean:
+	@runhaskell Setup.lhs clean
+
hunk ./Makefile 17
-	@runhaskell Setup.lhs haddock
+	@runhaskell Setup.lhs haddock --hyperlink-source
hunk ./category-extras.cabal 3
-version:                0.44.1
+version:                0.44.3
hunk ./category-extras.cabal 35
-        Control.Arrow.BiKleisli,
-        Control.Arrow.CoKleisli,
-        Control.Bifunctor,
-        Control.Bifunctor.Associative,
-        Control.Bifunctor.Braided,
-        Control.Bifunctor.Composition,
-        Control.Bifunctor.Either,
-        Control.Bifunctor.Fix,
-        Control.Bifunctor.HigherOrder,
-        Control.Bifunctor.Monoidal,
-        Control.Bifunctor.Pair,
-        Control.Comonad,
-        Control.Comonad.Cofree,
-        Control.Comonad.Composition,
-        Control.Comonad.Context,
-        Control.Comonad.Context.Class,
-        Control.Comonad.Identity,
-        Control.Comonad.Indexed,
-        Control.Comonad.HigherOrder,
-        Control.Comonad.Parameterized,
-        Control.Comonad.Parameterized.Class,
-        Control.Comonad.Pointer,
-        Control.Comonad.Reader,
-        Control.Comonad.Reader.Class,
-        Control.Comonad.Supply
-        Control.Functor.Adjunction,
-        Control.Functor.Algebra,
-        Control.Functor.Bifunctor,
-        Control.Functor.Composition
-        Control.Functor.Composition.Class
-        Control.Functor.Contravariant,
-        Control.Functor.Constant,
-        Control.Functor.Derivative,
-        Control.Functor.Extras,
-        Control.Functor.Exponential,
-        Control.Functor.Fix,
-        Control.Functor.Full,
-        Control.Functor.HigherOrder,
-        Control.Functor.Indexed,
-        Control.Functor.KanExtension,
-        Control.Functor.Strong,
-        Control.Functor.Pointed,
-        Control.Functor.Pointed.Composition,
-        Control.Functor.Representable,
-        Control.Functor.Zip,
-        Control.Functor.Zap,
-        Control.Monad.Composition,
-        Control.Monad.Free,
-        Control.Monad.HigherOrder,
-        Control.Monad.Indexed,
-        Control.Monad.Indexed.State,
-        Control.Monad.Indexed.Cont,
-        Control.Monad.Parameterized,
-        Control.Monad.Parameterized.Class,
-        Control.Monad.Hyper,
-        Control.Monad.Either,
-        Control.Morphism.Hylo,
-        Control.Morphism.Cata,
-        Control.Morphism.Ana,
-        Control.Morphism.Meta,
-        Control.Morphism.Futu,
-        Control.Morphism.Chrono,
-        Control.Morphism.Para,
-        Control.Morphism.Dyna,
-        Control.Morphism.Apo,
-        Control.Morphism.Zygo,
-        Control.Morphism.Histo,
-        Data.Void
+	Control.Applicative.Parameterized,
+	Control.Arrow.BiKleisli,
+	Control.Arrow.CoKleisli,
+	Control.Bifunctor,
+	Control.Bifunctor.Associative,
+	Control.Bifunctor.Biff,
+	Control.Bifunctor.Braided,
+	Control.Bifunctor.Composition,
+	Control.Bifunctor.Constant,
+	Control.Bifunctor.Functor,
+	Control.Bifunctor.Fix,
+	Control.Bifunctor.Monoidal,
+	Control.Bifunctor.Pointed,
+	Control.Bifunctor.Swap,
+	Control.Comonad,
+	Control.Comonad.Cofree,
+	Control.Comonad.Context,
+	Control.Comonad.Fix,
+	Control.Comonad.Indexed,
+	Control.Comonad.HigherOrder,
+	Control.Comonad.Parameterized,
+	Control.Comonad.Pointer,
+	Control.Comonad.Reader,
+	Control.Comonad.Supply
+	Control.Functor.Adjunction,
+	Control.Functor.Algebra,
+	Control.Functor.Bifunctor,
+	Control.Functor.Composition
+	Control.Functor.Contravariant,
+	Control.Functor.Constant,
+	Control.Functor.Extras,
+	Control.Functor.Exponential,
+	Control.Functor.Fix,
+	Control.Functor.Full,
+	Control.Functor.HigherOrder,
+	Control.Functor.Indexed,
+	Control.Functor.KanExtension,
+	Control.Functor.Strong,
+	Control.Functor.Pointed,
+	Control.Functor.Pointed.Composition,
+	Control.Functor.Representable,
+	Control.Functor.Zip,
+	Control.Functor.Zap,
+	Control.Monad.Free,
+	Control.Monad.HigherOrder,
+	Control.Monad.Indexed,
+	Control.Monad.Indexed.State,
+	Control.Monad.Indexed.Cont,
+	Control.Monad.Parameterized,
+	Control.Monad.Hyper,
+	Control.Monad.Either,
+	Control.Morphism.Hylo,
+	Control.Morphism.Cata,
+	Control.Morphism.Ana,
+	Control.Morphism.Meta,
+	Control.Morphism.Futu,
+	Control.Morphism.Chrono,
+	Control.Morphism.Para,
+	Control.Morphism.Dyna,
+	Control.Morphism.Apo,
+	Control.Morphism.Zygo,
+	Control.Morphism.Histo,
+	Data.Void
hunk ./category-extras.cabal 99
-ghc-options:            -Wall -funbox-strict-fields
+ghc-options:            -Wall -funbox-strict-fields -O2
addfile ./src/Control/Applicative/Parameterized.hs
hunk ./src/Control/Applicative/Parameterized.hs 1
+{-# OPTIONS -fglasgow-exts #-}
+-----------------------------------------------------------------------------
+-- |
+-- Module      :  Control.Applicative.Paramterized
+-- Copyright   :  (C) 2008 Edward Kmett
+-- License     :  BSD-style (see the file LICENSE)
+--
+-- Maintainer  :  Edward Kmett <ekmett@gmail.com>
+-- Stability   :  experimental
+-- Portability :  portable
+--
+----------------------------------------------------------------------------
+module Control.Applicative.Parameterized 
+	( PApplicative(..)
+	, PPointed(..)
+	) where
+
+import Control.Bifunctor.Pointed
+
+class PPointed f => PApplicative f where
+	pap :: f (a -> b) c -> f a c -> f b c
hunk ./src/Control/Arrow/BiKleisli.hs 14
-module Control.Arrow.BiKleisli where
+module Control.Arrow.BiKleisli
+	( BiKleisli(..)
+	) where
hunk ./src/Control/Arrow/CoKleisli.hs 14
-module Control.Arrow.CoKleisli where
+module Control.Arrow.CoKleisli 
+	( CoKleisli(..)
+	) where
hunk ./src/Control/Bifunctor.hs 12
-module Control.Bifunctor where
+module Control.Bifunctor 
+	( Bifunctor(..) 
+	) where
+
+import Control.Arrow ((+++), (***))
hunk ./src/Control/Bifunctor.hs 25
+instance Bifunctor Either where
+        bimap = (+++)
+
+instance Bifunctor (,) where
+	bimap = (***)
+
hunk ./src/Control/Bifunctor/Associative.hs 16
-module Control.Bifunctor.Associative where
+module Control.Bifunctor.Associative 
+	( module Control.Bifunctor
+	, Associative(..)
+	, Coassociative(..)
+	) where
hunk ./src/Control/Bifunctor/Associative.hs 43
+instance Associative (,) where
+        associate ((a,b),c) = (a,(b,c))
hunk ./src/Control/Bifunctor/Associative.hs 46
+instance Coassociative (,) where
+        coassociate (a,(b,c)) = ((a,b),c)
+
+instance Associative Either where
+        associate (Left (Left a)) = Left a
+        associate (Left (Right b)) = Right (Left b)
+        associate (Right c) = Right (Right c)
+
+instance Coassociative Either where
+        coassociate (Left a) = Left (Left a)
+        coassociate (Right (Left b)) = Left (Right b)
+        coassociate (Right (Right c)) = Right c
addfile ./src/Control/Bifunctor/Biff.hs
hunk ./src/Control/Bifunctor/Biff.hs 1
+-------------------------------------------------------------------------------------------
+-- |
+-- Module	: Control.Bifunctor.Biff
+-- Copyright 	: 2008 Edward Kmett
+-- License	: BSD3
+--
+-- Maintainer	: Edward Kmett <ekmett@gmail.com>
+-- Stability	: experimental
+-- Portability	: portable
+--
+-------------------------------------------------------------------------------------------
+
+module Control.Bifunctor.Biff 
+	( BiffB(..)
+	) where
+
+import Control.Arrow ((|||),(&&&))
+import Control.Monad.Identity
+import Control.Bifunctor.Monoidal
+import Control.Functor.Extras
+import Control.Monad.Parameterized
+import Control.Comonad.Parameterized
+
+newtype BiffB p f g a b = BiffB { runBiffB :: p (f a) (g b) } 
+
+instance (Functor f, Bifunctor p, Functor g) => Bifunctor (BiffB p f g) where
+	bimap f g = BiffB . bimap (fmap f) (fmap g) . runBiffB
+
+instance (Functor f, Braided p) => Braided (BiffB p f f) where
+	braid = BiffB . braid . runBiffB
+
+instance (Functor f, Symmetric p) => Symmetric (BiffB p f f) 
+
+instance (Functor f, Bifunctor p, Functor g) => Functor (BiffB p f g a) where
+	fmap f = bimap id f
+
+instance FunctorPlus f => PPointed (BiffB (,) Identity f) where
+        preturn a = BiffB (Identity a,fzero)
+
+instance Functor f => PPointed (BiffB Either Identity f) where
+        preturn = BiffB . Left . Identity
+
+instance Functor f => PCopointed (BiffB (,) Identity f) where
+        pextract = runIdentity . fst . runBiffB
+
+instance Functor f => PApplicative (BiffB Either Identity f) where
+        pap = papPMonad
+
+instance Functor f => PMonad (BiffB Either Identity f) where
+        pbind k = (k . runIdentity ||| BiffB . Right) . runBiffB
+
+instance FunctorPlus f => PApplicative (BiffB (,) Identity f) where
+        pap = papPMonad
+
+instance FunctorPlus f => PMonad (BiffB (,) Identity f) where
+        pbind k (BiffB ~(Identity a,as)) = BiffB (ib, fplus as bs) where BiffB (ib,bs) = k a
+
+instance Functor f => PComonad (BiffB (,) Identity f) where
+        pextend f = BiffB . (Identity . f &&& snd . runBiffB)
hunk ./src/Control/Bifunctor/Braided.hs 12
-module Control.Bifunctor.Braided where
+module Control.Bifunctor.Braided 
+	( module Control.Bifunctor.Associative
+	, Braided(..)
+	, Symmetric
+	, swap
+	) where
hunk ./src/Control/Bifunctor/Braided.hs 19
-import Control.Bifunctor
hunk ./src/Control/Bifunctor/Braided.hs 51
+
+instance Braided Either where
+        braid (Left a) = Right a
+        braid (Right b) = Left b
+
+instance Symmetric Either
+
+
+instance Braided (,) where
+        braid ~(a,b) = (b,a)
+
+instance Symmetric (,)
+
+
hunk ./src/Control/Bifunctor/Composition.hs 13
-module Control.Bifunctor.Composition where
+module Control.Bifunctor.Composition 
+	( module Control.Bifunctor.Braided
+	, CompB(..)
+	, liftCompB
+	) where
hunk ./src/Control/Bifunctor/Composition.hs 19
-
-import Control.Comonad
-import Control.Bifunctor
-import Control.Bifunctor.Associative
hunk ./src/Control/Bifunctor/Composition.hs 20
-import Control.Bifunctor.Monoidal
-import Control.Functor.Pointed
-import Control.Functor.Exponential
-import Control.Functor.Contravariant
-
-newtype ArrowB f g a b = ArrowB { runArrowB :: f a b -> g a b }
-
-
-
-newtype ConstB t a b = ConstB { runConstB :: t } 
-
-instance Bifunctor (ConstB t) where
-	bimap f g = ConstB . runConstB
-instance Functor (ConstB t a) where
-	fmap f = ConstB . runConstB
-
-
-
-newtype FstB a b = FstB { runFstB :: a } 
-
-instance Bifunctor FstB where
-	bimap f g = FstB . f . runFstB 
-
-instance Associative FstB where
-	associate = FstB . runFstB . runFstB
-
-instance Functor (FstB a) where
-        fmap f (FstB a) = FstB a
-
-instance ContravariantFunctor (FstB a) where
-        contramap f (FstB a) = FstB a
-
-instance ExpFunctor (FstB a) where
-        xmap f g (FstB a) = FstB a
-
-
-newtype SndB a b = SndB { runSndB :: b } 
-
-instance Bifunctor SndB where
-	bimap f g = SndB . g . runSndB 
-
--- instance Coassociative SndB where
---	coassociate = SndB . SndB . runSndB
-
--- as a functor its a family of identity functors with a type-level parameter (a)
-instance Functor (SndB a) where
-	fmap = bimap id
-
--- bifunctor composition
hunk ./src/Control/Bifunctor/Composition.hs 39
-
-
-newtype SwapB p a b = SwapB { runSwapB :: p b a } 
-
-liftSwapB :: Bifunctor p => (p a b -> p c d) -> SwapB p b a -> SwapB p d c
-liftSwapB f = SwapB . f . runSwapB
-
-instance Bifunctor p => Bifunctor (SwapB p) where
-	bimap f g = liftSwapB (bimap g f)
-
-instance Braided p => Braided (SwapB p) where
-	braid = liftSwapB braid
-
-instance Symmetric p => Symmetric (SwapB p)
-
-instance Bifunctor p => Functor (SwapB p a) where
-	fmap = bimap id
-
-
-
-
--- a functor composed around a bifunctor
-
-newtype FunctorB f p a b = FunctorB { runFunctorB :: f (p a b) } 
-
-liftFunctorB :: Functor f => (p a b -> p c d) -> FunctorB f p a b -> FunctorB f p c d
-liftFunctorB f = FunctorB . fmap f . runFunctorB
-
-instance (Functor f, Bifunctor p) => Bifunctor (FunctorB f p) where
-	bimap f g = liftFunctorB (bimap f g)
-
-instance (Functor f, Braided p) => Braided (FunctorB f p) where
-	braid = liftFunctorB braid
-
-instance (Functor f, Symmetric p) => Symmetric (FunctorB f p) 
-
-instance (Functor f, Bifunctor p) => Functor (FunctorB f p a) where
-	fmap = bimap id
-
-
--- a bifunctor wrapping a pair of functors with different values
-
-newtype BiffB p f g a b = BiffB { runBiffB :: p (f a) (g b) } 
-
-instance (Functor f, Bifunctor p, Functor g) => Bifunctor (BiffB p f g) where
-	bimap f g = BiffB . bimap (fmap f) (fmap g) . runBiffB
-
-instance (Functor f, Braided p) => Braided (BiffB p f f) where
-	braid = BiffB . braid . runBiffB
-
-instance (Functor f, Symmetric p) => Symmetric (BiffB p f f) 
-
-instance (Functor f, Bifunctor p, Functor g) => Functor (BiffB p f g a) where
-	fmap f = bimap id f
-
addfile ./src/Control/Bifunctor/Constant.hs
hunk ./src/Control/Bifunctor/Constant.hs 1
+-------------------------------------------------------------------------------------------
+-- |
+-- Module	: Control.Bifunctor.Constant
+-- Copyright 	: 2008 Edward Kmett
+-- License	: BSD3
+--
+-- Maintainer	: Edward Kmett <ekmett@gmail.com>
+-- Stability	: experimental
+-- Portability	: portable
+--
+-------------------------------------------------------------------------------------------
+
+module Control.Bifunctor.Constant 
+	( module Control.Functor.Exponential
+	, module Control.Functor.Contravariant
+	, module Control.Bifunctor.Associative
+	, ConstB(..)
+	, FstB(..)
+	, SndB(..)
+	) where
+
+import Control.Bifunctor.Associative
+import Control.Functor.Exponential
+import Control.Functor.Contravariant
+
+newtype ConstB t a b = ConstB { runConstB :: t } 
+
+instance Bifunctor (ConstB t) where
+	bimap _ _ = ConstB . runConstB
+
+instance Functor (ConstB t a) where
+	fmap _ = ConstB . runConstB
+
+instance ContravariantFunctor (ConstB t a) where
+	contramap _ = ConstB . runConstB
+
+instance ExpFunctor (ConstB t a) where
+	xmap _ _ = ConstB . runConstB
+
+
+
+
+
+
+newtype FstB a b = FstB { runFstB :: a } 
+
+instance Bifunctor FstB where
+	bimap f _ = FstB . f . runFstB 
+
+instance Associative FstB where
+	associate = FstB . runFstB . runFstB
+
+instance Functor (FstB a) where
+        fmap _ (FstB a) = FstB a
+
+instance ContravariantFunctor (FstB a) where
+        contramap _ (FstB a) = FstB a
+
+instance ExpFunctor (FstB a) where
+        xmap _ _ (FstB a) = FstB a
+
+
+
+
+
+
+
+
+newtype SndB a b = SndB { runSndB :: b } 
+
+instance Bifunctor SndB where
+	bimap _ g = SndB . g . runSndB 
+
+instance Functor (SndB a) where
+	fmap = bimap id
hunk ./src/Control/Bifunctor/Fix.hs 12
-module Control.Bifunctor.Fix where
+module Control.Bifunctor.Fix 
+	( FixB(..)
+	, paugment
+	, pcoaugment
+	) where
hunk ./src/Control/Bifunctor/Fix.hs 18
-import Control.Bifunctor
+import Control.Monad.Parameterized
+import Control.Comonad.Parameterized
+import Control.Comonad
+import Control.Morphism.Hylo
hunk ./src/Control/Bifunctor/Fix.hs 28
+instance PCopointed f => Copointed (FixB f) where
+        extract = pextract . outB
+
+instance PPointed f => Pointed (FixB f) where
+        point = InB . preturn
+
+instance PComonad f => Comonad (FixB f) where
+        extend k w = pcoaugment (\g -> bihylo InB id g w) k
+
+instance PMonad f => Monad (FixB f) where
+        return = InB . preturn
+        m >>= k = paugment (\f -> bihylo f id outB m) k
+
+paugment :: PMonad f => (forall c. (f a c -> c) -> c) -> (a -> FixB f b) -> FixB f b
+paugment g k = g (InB . pbind (outB . k))
+
+pcoaugment :: PComonad f => ((FixB f a -> f b (FixB f a)) -> FixB f b) -> (FixB f a -> b) -> FixB f b
+pcoaugment g k = g (pextend (k . InB) . outB)
+
addfile ./src/Control/Bifunctor/Functor.hs
hunk ./src/Control/Bifunctor/Functor.hs 1
+-------------------------------------------------------------------------------------------
+-- |
+-- Module	: Control.Bifunctor.Functor
+-- Copyright 	: 2008 Edward Kmett
+-- License	: BSD3
+--
+-- Maintainer	: Edward Kmett <ekmett@gmail.com>
+-- Stability	: experimental
+-- Portability	: portable
+--
+-------------------------------------------------------------------------------------------
+
+module Control.Bifunctor.Functor 
+	( module Control.Bifunctor.Monoidal
+	, FunctorB(..)
+	, liftFunctorB
+	) where
+
+import Control.Bifunctor.Monoidal
+
+-- a functor composed around a bifunctor
+
+newtype FunctorB f p a b = FunctorB { runFunctorB :: f (p a b) } 
+
+liftFunctorB :: Functor f => (p a b -> p c d) -> FunctorB f p a b -> FunctorB f p c d
+liftFunctorB f = FunctorB . fmap f . runFunctorB
+
+instance (Functor f, Bifunctor p) => Bifunctor (FunctorB f p) where
+	bimap f g = liftFunctorB (bimap f g)
+
+instance (Functor f, Braided p) => Braided (FunctorB f p) where
+	braid = liftFunctorB braid
+
+instance (Functor f, Symmetric p) => Symmetric (FunctorB f p) 
+
+instance (Functor f, Bifunctor p) => Functor (FunctorB f p a) where
+	fmap = bimap id
+
hunk ./src/Control/Bifunctor/HigherOrder.hs 1
------------------------------------------------------------------------------
--- |
--- Module      :  Control.Bifunctor.HigherOrder
--- Copyright   :  (C) 2008 Edward Kmett
--- License     :  BSD-style (see the file LICENSE)
---
--- Maintainer  :  Edward Kmett <ekmett@gmail.com>
--- Stability   :  experimental
--- Portability :  non-portable (rank-2 polymorphism)
---
-----------------------------------------------------------------------------
-module Control.Bifunctor.HigherOrder where
-
-import Control.Bifunctor
-import Control.Functor.Extras
-
-{-
-type BiNatural p q = forall a b. p a b -> q a b
-
-class HBifunctor p where
-        fbimap :: Bifunctor q => (a -> b) -> (c -> d) -> p q a c -> p q b d
-	hbimap :: BiNatural g h -> BiNatural (p g) (p h)
-
-newtype MuHB p a b = InHB { outHB :: p (MuHB p) a b }
-type NuHB p a b = MuHB p a b
--}
rmfile ./src/Control/Bifunctor/HigherOrder.hs
hunk ./src/Control/Bifunctor/Monoidal.hs 19
-module Control.Bifunctor.Monoidal where
hunk ./src/Control/Bifunctor/Monoidal.hs 20
-import Control.Bifunctor
-import Control.Bifunctor.Associative
+module Control.Bifunctor.Monoidal 
+	( module Control.Bifunctor.Braided
+	, module Data.Void
+	, HasIdentity
+	, Monoidal(..)
+	, Comonoidal(..)
+	) where
+
hunk ./src/Control/Bifunctor/Monoidal.hs 29
+import Data.Void
hunk ./src/Control/Bifunctor/Monoidal.hs 79
+instance HasIdentity (,) Void
+
+instance Monoidal (,) Void where
+        idl = snd
+        idr = fst
+
addfile ./src/Control/Bifunctor/Pointed.hs
hunk ./src/Control/Bifunctor/Pointed.hs 1
+-------------------------------------------------------------------------------------------
+-- |
+-- Module	: Control.Bifunctor.Pointed
+-- Copyright 	: 2008 Edward Kmett
+-- License	: BSD
+--
+-- Maintainer	: Edward Kmett <ekmett@gmail.com>
+-- Stability	: experimental
+-- Portability	: non-portable (functional-dependencies)
+--
+-------------------------------------------------------------------------------------------
+
+module Control.Bifunctor.Pointed
+	( PPointed(..)
+	, PCopointed(..)
+	) where
+
+import Control.Bifunctor
+
+class Bifunctor f => PPointed f where
+        preturn :: a -> f a c 
+
+class Bifunctor f => PCopointed f where
+	pextract :: f a c -> a
+
+{-# RULES
+"bimap id g . preturn"     	forall g. bimap id g . preturn = preturn
+"pextract . bimap id g"    	forall g. pextract . bimap id g = pextract
+"preturn/pextract" 		preturn . pextract = id
+"pextract/preturn" 		pextract. preturn = id
+ #-}
+
addfile ./src/Control/Bifunctor/Swap.hs
hunk ./src/Control/Bifunctor/Swap.hs 1
+-------------------------------------------------------------------------------------------
+-- |
+-- Module	: Control.Bifunctor.Composition
+-- Copyright 	: 2008 Edward Kmett
+-- License	: BSD3
+--
+-- Maintainer	: Edward Kmett <ekmett@gmail.com>
+-- Stability	: experimental
+-- Portability	: portable
+--
+-------------------------------------------------------------------------------------------
+
+module Control.Bifunctor.Swap 
+	( module Control.Bifunctor.Monoidal
+	, SwapB(..)
+	, liftSwapB
+	) where
+
+import Control.Bifunctor.Monoidal
+
+newtype SwapB p a b = SwapB { runSwapB :: p b a } 
+
+liftSwapB :: Bifunctor p => (p a b -> p c d) -> SwapB p b a -> SwapB p d c
+liftSwapB f = SwapB . f . runSwapB
+
+instance Bifunctor p => Bifunctor (SwapB p) where
+	bimap f g = liftSwapB (bimap g f)
+
+instance Braided p => Braided (SwapB p) where
+	braid = liftSwapB braid
+
+instance Symmetric p => Symmetric (SwapB p)
+
+instance Bifunctor p => Functor (SwapB p a) where
+	fmap = bimap id
+
hunk ./src/Control/Comonad.hs 15
-module Control.Comonad where
+module Control.Comonad 
+	( module Control.Functor.Pointed
+	, Comonad(..)
+	, liftW
+	, (=>>)
+	, (.>>)
+	, liftCtx
+	, mapW
+	, parallelW
+	, unfoldW
+	, sequenceW
+	) where
hunk ./src/Control/Comonad.hs 28
-import Control.Monad
-import Control.Arrow ((|||), (&&&), (+++), (***))
+import Control.Monad.Identity
+import Control.Functor.Pointed
hunk ./src/Control/Comonad.hs 64
-class Functor w => Comonad w where
+class Copointed w => Comonad w where
hunk ./src/Control/Comonad.hs 67
-        extract :: w a -> a
hunk ./src/Control/Comonad.hs 102
+instance Comonad Identity where
+        extend f x = Identity (f x)
+        duplicate = Identity
+
+instance Comonad ((,)e) where
+        duplicate ~(e,a) = (e,(e,a))
+
hunk ./src/Control/Comonad/Cofree.hs 13
-module Control.Comonad.Cofree where
+module Control.Comonad.Cofree 
+	( BiffB(..)
+	, FixB(..)
+	, PCopointed(..)
+	, PComonad(..)
+	, Identity(..)
+	, CofreeB
+	, Cofree
+	, outCofree, runCofree, anaCofree, cofree
+	) where
hunk ./src/Control/Comonad/Cofree.hs 25
-import Control.Bifunctor
hunk ./src/Control/Comonad/Cofree.hs 26
-import Control.Bifunctor.Composition
-import Control.Bifunctor.Pair
-import Control.Comonad
+import Control.Bifunctor.Biff
hunk ./src/Control/Comonad/Cofree.hs 28
-import Control.Comonad.Parameterized.Class
-import Control.Functor.Extras
hunk ./src/Control/Comonad/Cofree.hs 30
-import Control.Monad.Parameterized.Class
hunk ./src/Control/Comonad/Cofree.hs 34
-instance Functor f => PComonad (BiffB (,) Identity f) where
-	pextract = runIdentity . fst . runBiffB
-	pextend f = BiffB . (Identity . f &&& snd . runBiffB)
-
-instance FunctorPlus f => PMonad (BiffB (,) Identity f) where
-	preturn a = BiffB (Identity a,fzero)
-	pbind k (BiffB ~(Identity a,as)) = BiffB (ib, fplus as bs) where BiffB (ib,bs) = k a 
-
hunk ./src/Control/Comonad/Composition.hs 1
--------------------------------------------------------------------------------------------
--- |
--- Module	: Control.Comonad.Composition
--- Copyright 	: 2008 Edward Kmett
--- License	: BSD
---
--- Maintainer	: Edward Kmett <ekmett@gmail.com>
--- Stability	: experimental
--- Portability	: non-portable (functional-dependencies)
---
--- composing a comonad with a copointed endofunctor yields a comonad given a distributive law
--------------------------------------------------------------------------------------------
-
-module Control.Comonad.Composition where
-
-import Control.Comonad
-import Control.Functor.Composition
-import Control.Functor.Composition.Class
-import Control.Functor.Extras
-import Control.Functor.Pointed
-import Control.Functor.Pointed.Composition
-
--- postDuplicate :: (Comonad w, PostUnfold w f) => w (f a) -> w (f (w (f a)))
--- postDuplicate = fmap postUnfold . duplicate
-
-instance (Comonad w, Copointed f, PostUnfold w f) => Comonad (PostCompF w f) where
-	extract = copoint . extract . decompose
-	duplicate = compose . liftW (fmap compose . postUnfold) . duplicate . decompose
-
--- preDuplicate :: (Comonad w, Functor f, PreUnfold f w) => f (w a) -> f (w (f (w a)))
--- preDuplicate = preUnfold . fmap duplicate
-
-instance (Copointed f, Comonad w, PreUnfold f w) => Comonad (PreCompF f w) where
-	extract = extract . copoint .  decompose
-	duplicate = compose . fmap (liftW compose) . preUnfold . fmap (duplicate) . decompose
-
-instance (Comonad f, Comonad g, Distributes f g) => Comonad (DistCompF f g) where
-	extract = extract . extract . decompose
-	duplicate = compose . fmap (fmap compose . dist) . duplicate . fmap duplicate . decompose
---	join = compose . fmap join . join . fmap dist . fmap (fmap decompose) . decompose
rmfile ./src/Control/Comonad/Composition.hs
hunk ./src/Control/Comonad/Context.hs 14
-module Control.Comonad.Context where
+module Control.Comonad.Context 
+	( module Control.Comonad
+	, ComonadContext(..)
+	, putC
+	, experiment
+	, Context(..)
+	, runContext
+	, ContextT(..)
+	) where
hunk ./src/Control/Comonad/Context.hs 24
-import Control.Arrow ((&&&), first)
+import Control.Bifunctor (first)
hunk ./src/Control/Comonad/Context.hs 26
-import Control.Comonad.Context.Class
hunk ./src/Control/Comonad/Context.hs 27
+class Comonad w => ComonadContext s w | w -> s where
+	getC :: w a -> s
+	modifyC :: (s -> s) -> w a -> a 
+
+putC :: ComonadContext s w => s -> w a -> a
+putC = modifyC . const 
+
+experiment :: (ComonadContext s w, Functor f) => f (s -> s) -> w a -> f a
+experiment ms a = fmap (flip modifyC a) ms
hunk ./src/Control/Comonad/Context.hs 39
+
+runContext :: (Context s s -> Context s b) -> s -> (b, s)
hunk ./src/Control/Comonad/Context.hs 45
-	getC (Context f s) = s
+	getC (Context _ s) = s
hunk ./src/Control/Comonad/Context.hs 51
-instance Comonad (Context s) where
+instance Copointed (Context s) where
hunk ./src/Control/Comonad/Context.hs 53
-	duplicate (Context f a) = Context (Context f) a
-
hunk ./src/Control/Comonad/Context.hs 54
+instance Comonad (Context s) where
+	duplicate (Context f a) = Context (Context f) a
hunk ./src/Control/Comonad/Context.hs 67
-instance Comonad w => Comonad (ContextT b w) where
+instance Copointed (ContextT b w) where
hunk ./src/Control/Comonad/Context.hs 69
+
+instance Comonad w => Comonad (ContextT b w) where
hunk ./src/Control/Comonad/Context/Class.hs 13
-module Control.Comonad.Context.Class where
+module Control.Comonad.Context.Class 
+	( module Control.Comonad
+	, ComonadContext(..)
+	, putC
+	, experiment
+	) where
addfile ./src/Control/Comonad/Fix.hs
hunk ./src/Control/Comonad/Fix.hs 1
+-------------------------------------------------------------------------------------------
+-- |
+-- Module	: Control.Comonad.Fix
+-- Copyright 	: 2008 Edward Kmett
+-- License	: BSD
+--
+-- Maintainer	: Edward Kmett <ekmett@gmail.com>
+-- Stability	: experimental
+-- Portability	: portable
+--
+-------------------------------------------------------------------------------------------
+module Control.Comonad.Fix 
+	( ComonadFix(..)
+	) where
+
+import Control.Comonad
+import Control.Monad.Identity
+
+class Comonad w => ComonadFix w where
+	cofix :: w (w a -> a) -> a
+
+instance ComonadFix Identity where
+	cofix (Identity f) = fix (f . Identity)
+
+instance ComonadFix ((,)e) where
+	cofix ~(e,f) = let x = f (e,x) in x
hunk ./src/Control/Comonad/HigherOrder.hs 13
-module Control.Comonad.HigherOrder where
+module Control.Comonad.HigherOrder 
+	( HFunctor(..)
+	, HCopointed(..)
+	, HComonad(..)
+	) where
hunk ./src/Control/Comonad/HigherOrder.hs 19
-import Control.Functor.Extras
+import Control.Functor.Extras (Natural)
hunk ./src/Control/Comonad/HigherOrder.hs 22
-class HFunctor w => HComonad w where
-	hextract :: Functor f => Natural (w f) f
+class HCopointed w => HComonad w where
hunk ./src/Control/Comonad/Identity.hs 1
-{-# OPTIONS_GHC -fglasgow-exts #-}
------------------------------------------------------------------------------
--- |
--- Module      :  Control.Comonad.Identity
--- Copyright   :  (C) 2008 Edward Kmett
--- License     :  BSD-style (see the file LICENSE)
---
--- Maintainer  :  Edward Kmett <ekmett@gmail.com>
--- Stability   :  experimental
--- Portability :  portable
---
-----------------------------------------------------------------------------
-module Control.Comonad.Identity where
-
-import Control.Monad.Identity
-import Control.Comonad
-
-instance Comonad Identity where
-        extract = runIdentity
-        extend f x = Identity (f x)
-        duplicate = Identity
rmfile ./src/Control/Comonad/Identity.hs
hunk ./src/Control/Comonad/Indexed.hs 12
-module Control.Comonad.Indexed where
+module Control.Comonad.Indexed 
+	( IxFunctor(..)
+	, IxCopointed(..)
+	, IxComonad(..)
+	, iduplicate
+	) where
hunk ./src/Control/Comonad/Indexed.hs 19
-import Control.Comonad
-import Control.Arrow
-import Control.Functor.Extras
-import Control.Functor.HigherOrder
hunk ./src/Control/Comonad/Indexed.hs 20
-import Control.Monad
hunk ./src/Control/Comonad/Indexed.hs 21
-class IxFunctor w => IxComonad w where
-	iextract :: w i i a -> a
+class IxCopointed w => IxComonad w where
hunk ./src/Control/Comonad/Indexed.hs 27
-instance Comonad w => IxComonad (LiftIx w) where
-	iextract = extract . lowerIx 
-	iextend f = LiftIx . extend (f . LiftIx) . lowerIx
hunk ./src/Control/Comonad/Parameterized.hs 13
-module Control.Comonad.Parameterized where
+module Control.Comonad.Parameterized 
+	( Bifunctor(..)
+	, PCopointed(..)
+	, PComonad(..)
+	) where
hunk ./src/Control/Comonad/Parameterized.hs 20
-import Control.Bifunctor.Fix
-import Control.Comonad
-import Control.Comonad.Parameterized.Class
-import Control.Morphism.Ana
+import Control.Bifunctor.Pointed
hunk ./src/Control/Comonad/Parameterized.hs 22
-copaugment :: PComonad f => ((FixB f a -> f b (FixB f a)) -> FixB f b) -> (FixB f a -> b) -> FixB f b
-copaugment g k = g (pextend (k . InB) . outB)
+class PCopointed f => PComonad f where
+	pextend :: (f b c -> a) -> f b c -> f a c
hunk ./src/Control/Comonad/Parameterized.hs 25
-instance PComonad f => Comonad (FixB f) where
-        extract = pextract . outB
-        extend k w = copaugment (flip biana w) k
+{- Parameterized comonad laws:
+
+> pextend pextract = id
+> pextract . pextend g = g
+> pextend (g . pextend j) = pextend g . pextend j
+> pextract . second g = pextract 
+> second g . pextend (j . second g) = pextend j . second g 
+
+-}
+
+{-# RULES
+"pextend pextract" 		pextend pextract = id
+"pextract . pextend g" 		forall g. pextract . pextend g = g
+"bimap _ _ . pextract" 		forall j g. bimap id g . pextend (j . bimap id g) = pextend j . bimap id g
+ #-}
+
+	
hunk ./src/Control/Comonad/Parameterized/Class.hs 1
-{-# OPTIONS_GHC -cpp -fglasgow-exts #-}
------------------------------------------------------------------------------
--- |
--- Module      :  Control.Comonad.Parameterized.Class
--- Copyright   :  (C) 2008 Edward Kmett
--- License     :  BSD-style (see the file LICENSE)
---
--- Maintainer  :  Edward Kmett <ekmett@gmail.com>
--- Stability   :  experimental
--- Portability :  portable
---
-----------------------------------------------------------------------------
-module Control.Comonad.Parameterized.Class where
-
-import Control.Arrow ((|||), (+++))
-import Control.Monad
-import Control.Bifunctor
-
-class Bifunctor f => PComonad f where
-	pextract :: f a c -> a
-	pextend :: (f b c -> a) -> f b c -> f a c
-
-{- Parameterized comonad laws:
-
-> pextend pextract = id
-> pextract . pextend g = g
-> pextend (g . pextend j) = pextend g . pextend j
-> pextract . second g = pextract
-> second g . pextend (j . second g) = pextend j . second g
-
--}
-
-#ifndef __HADDOCK__
-{-# RULES
-"pextend pextract" 		pextend pextract = id
-"pextract . pextend g" 		forall g. pextract . pextend g = g
-"pextract . bimap id g" 	forall g. pextract . bimap id g = pextract
-"bimap _ _ . pextract" 		forall j g. bimap id g . pextend (j . bimap id g) = pextend j . bimap id g
- #-}
-#endif
rmfile ./src/Control/Comonad/Parameterized/Class.hs
hunk ./src/Control/Comonad/Pointer.hs 10
--- Portability :  non-portable (MPTCs)
+-- Portability :  portable
hunk ./src/Control/Comonad/Pointer.hs 14
-module Control.Comonad.Pointer where
+module Control.Comonad.Pointer 
+	( module Control.Comonad
+	, Pointer(..)
+	, distPointer
+	) where
hunk ./src/Control/Comonad/Pointer.hs 21
-import Control.Arrow ((&&&), first)
hunk ./src/Control/Comonad/Pointer.hs 22
-import Data.Foldable
-import Control.Monad
hunk ./src/Control/Comonad/Pointer.hs 29
-instance Ix i => Comonad (Pointer i) where
+instance Ix i => Copointed (Pointer i) where
hunk ./src/Control/Comonad/Pointer.hs 31
+
+instance Ix i => Comonad (Pointer i) where
hunk ./src/Control/Comonad/Reader.hs 13
-module Control.Comonad.Reader where
+module Control.Comonad.Reader 
+	( module Control.Bifunctor
+	, module Control.Comonad
+	, ReaderC(..)
+	, runReaderC
+	, ReaderCT(..)
+	, ComonadReader(..)
+	) where
hunk ./src/Control/Comonad/Reader.hs 22
+import Control.Arrow ((&&&))
hunk ./src/Control/Comonad/Reader.hs 24
-import Control.Bifunctor.Pair
-import Control.Monad.Instances -- for Functor ((,)e)
-import Control.Comonad.Reader.Class
hunk ./src/Control/Comonad/Reader.hs 25
-import Control.Arrow ((&&&))
+import Control.Monad.Instances
+
+class Comonad w => ComonadReader r w | w -> r where
+        askC :: w a -> r
hunk ./src/Control/Comonad/Reader.hs 31
+
+runReaderC :: ReaderC r a -> (r, a)
hunk ./src/Control/Comonad/Reader.hs 41
-instance Comonad (ReaderC r) where
+instance Copointed (ReaderC r) where
hunk ./src/Control/Comonad/Reader.hs 43
+
+instance Comonad (ReaderC r) where
hunk ./src/Control/Comonad/Reader.hs 59
-instance Comonad w => Comonad (ReaderCT w b) where
+instance Copointed w => Copointed (ReaderCT w b) where
hunk ./src/Control/Comonad/Reader.hs 61
+
+instance Comonad w => Comonad (ReaderCT w b) where
hunk ./src/Control/Comonad/Reader.hs 69
-instance Comonad ((,)e) where
-        extract = snd
-        duplicate ~(e,a) = (e,(e,a))
-
hunk ./src/Control/Comonad/Reader.hs 72
--- instance Functor ((,)e) where
---        fmap f = second f 
-
--- instance Bifunctor (,) where
---        bimap f g = uncurry ReaderC . bimap f g . runReaderC
-
-
hunk ./src/Control/Comonad/Supply.hs 22
-  (
+  ( module Control.Comonad
+
hunk ./src/Control/Comonad/Supply.hs 26
-  Supply
+  , Supply
hunk ./src/Control/Comonad/Supply.hs 98
--- (Supply, supplyValue, modifySupply) form a comonad:
+-- (Supply, supplyValue, modifySupply) forms a comonad:
hunk ./src/Control/Comonad/Supply.hs 140
-instance Comonad Supply where
+instance Copointed Supply where
hunk ./src/Control/Comonad/Supply.hs 142
+
+instance Comonad Supply where
hunk ./src/Control/Functor/Adjunction.hs 18
-import Control.Functor.Composition.Class
hunk ./src/Control/Functor/Adjunction.hs 22
+import Control.Applicative
hunk ./src/Control/Functor/Adjunction.hs 44
-
-
hunk ./src/Control/Functor/Adjunction.hs 51
-        copoint = counit . decompose
+        extract = counit . decompose
+
+instance Adjunction f g => Applicative (ACompF g f) where
+	pure = point
+	(<*>) = ap
hunk ./src/Control/Functor/Adjunction.hs 62
-        extract = copoint
hunk ./src/Control/Functor/Bifunctor.hs 19
-import Control.Bifunctor.Pair
-import Control.Bifunctor.Either
hunk ./src/Control/Functor/Bifunctor.hs 23
-import Control.Arrow ((***),(&&&),(|||),(+++))
+import Control.Arrow ((&&&),(|||))
hunk ./src/Control/Functor/Bifunctor.hs 62
-        copoint = (copoint ||| copoint) . runBifunctorF
+        extract = (extract ||| extract) . runBifunctorF
hunk ./src/Control/Functor/Composition.hs 15
-module Control.Functor.Composition where
+module Control.Functor.Composition
+	( CompF(..)
+	, Composition(..)
+	, associateComp
+	, coassociateComp
+	, (:.:)
+	) where
hunk ./src/Control/Functor/Composition.hs 23
-import Control.Functor.Composition.Class
hunk ./src/Control/Functor/Composition.hs 26
+class Composition c where
+    decompose  :: c f g x -> f (g x)
+    compose    :: f (g x) -> c f g x
+
hunk ./src/Control/Functor/Composition.hs 36
-#ifndef __HADDOCK__
hunk ./src/Control/Functor/Composition.hs 37
-#endif
hunk ./src/Control/Functor/Composition/Class.hs 1
-{-# OPTIONS_GHC -fglasgow-exts #-}
--------------------------------------------------------------------------------------------
--- |
--- Module	: Control.Functor.Composition.Class
--- Copyright 	: 2008 Edward Kmett
--- License	: BSD
---
--- Maintainer	: Edward Kmett <ekmett@gmail.com>
--- Stability	: experimental
--- Portability	: non-portable (class-associated types)
---
--------------------------------------------------------------------------------------------
-
-module Control.Functor.Composition.Class where
-
-class Composition c where
-    decompose  :: c f g x -> f (g x)
-    compose    :: f (g x) -> c f g x
-
-
rmfile ./src/Control/Functor/Composition/Class.hs
hunk ./src/Control/Functor/Constant.hs 25
-	fmap f (ConstantF a) = ConstantF a
+	fmap _ (ConstantF a) = ConstantF a
hunk ./src/Control/Functor/Constant.hs 28
-	contramap f (ConstantF a) = ConstantF a
+	contramap _ (ConstantF a) = ConstantF a
hunk ./src/Control/Functor/Constant.hs 31
-	xmap f g (ConstantF a) = ConstantF a
+	xmap _ _ (ConstantF a) = ConstantF a
hunk ./src/Control/Functor/HigherOrder.hs 14
-module Control.Functor.HigherOrder where
+module Control.Functor.HigherOrder 
+	( HFunctor(..)
+	, HPointed(..)
+	, HCopointed(..)
+	, AlgH
+	, CoAlgH
+	, FixH(..)
+	) where
hunk ./src/Control/Functor/HigherOrder.hs 34
+class HFunctor m => HPointed m where
+	hreturn  :: Functor f => Natural f (m f)
+
+class HFunctor w => HCopointed w where
+	hextract :: Functor f => Natural (w f) f
+
+
hunk ./src/Control/Functor/Indexed.hs 12
-module Control.Functor.Indexed where
-
-import Control.Comonad
-import Control.Arrow
-import Control.Functor.Extras
-import Control.Functor.HigherOrder
-import Control.Monad
+module Control.Functor.Indexed 
+	( IxFunctor(..)
+	, IxCopointed(..)
+	, IxPointed(..)
+	, IxApplicative(..)
+	) where
hunk ./src/Control/Functor/Indexed.hs 22
-newtype LiftIx m i j a = LiftIx { lowerIx :: m a }
+class IxPointed m => IxApplicative m where
+	iap :: m i j (a -> b) -> m j k a -> m i k b
hunk ./src/Control/Functor/Indexed.hs 25
-instance Functor f => IxFunctor (LiftIx f) where
-        imap f = LiftIx . fmap f . lowerIx
+class IxFunctor m => IxPointed m where
+        ireturn :: a -> m i i a
hunk ./src/Control/Functor/Indexed.hs 28
-newtype LowerIx m i a = LowerIx { liftIx :: m i i a } 
+class IxFunctor w => IxCopointed w where
+	iextract :: w i i a -> a
hunk ./src/Control/Functor/Indexed.hs 31
-instance IxFunctor f => Functor (LowerIx f i) where
-	fmap f = LowerIx . imap f . liftIx
+{-# RULES
+"ireturn/iextract" ireturn . iextract = id
+"iextract/ireturn" iextract . ireturn = id
+ #-}
addfile ./src/Control/Functor/Indexed/Lift.hs
hunk ./src/Control/Functor/Indexed/Lift.hs 1
+-----------------------------------------------------------------------------
+-- |
+-- Module      :  Control.Functor.Indexed
+-- Copyright   :  (C) 2008 Edward Kmett
+-- License     :  BSD-style (see the file LICENSE)
+--
+-- Maintainer  :  Edward Kmett <ekmett@gmail.com>
+-- Stability   :  experimental
+-- Portability :  portable
+--
+----------------------------------------------------------------------------
+module Control.Functor.Indexed.Lift where
+
+import Control.Functor.Indexed
+import Control.Functor.Pointed.Indexed
+import Control.Applicative.Indexed
+import Control.Monad.Indexed
+import Control.Comonad.Indexed
+
+newtype LiftIx m i j a = LiftIx { lowerIx :: m a }
+
+instance Functor f => IxFunctor (LiftIx f) where
+        imap f = LiftIx . fmap f . lowerIx
+
+
+instance Pointed m => IxPointed (LiftIx m) where
+        ireturn = LiftIx . point
+
+instance Copointed m => IxCopointed (LiftIx m) where
+        iextract = extract . lowerIx
+
+instance (Pointed m, Applicative m) => IxApplicative (LiftIx m) where
+	iap f m = LiftIx (lowerIx f <*> lowerIx m)
+
+instance (Pointed m, Applicative m, Monad m) => IxMonad (LiftIx m) where
+	ibind f m = LiftIx (lowerIx m >>= lowerIx . f)
+
+instance Comonad w => IxComonad (LiftIx w) where
+	iextend f = LiftIx . extend (f . LiftIx) . lowerIx
+
+
+
+newtype LowerIx m i a = LowerIx { liftIx :: m i i a } 
+
+instance IxFunctor f => Functor (LowerIx f i) where
+	fmap f = LowerIx . imap f . liftIx
+
+instance IxPointed m => Pointed (LowerIx m i) where
+	point = LowerIx . ireturn
+
+instance IxCopointed m => Copointed (LowerIx m i) where
+	extract = iextract . liftIx
+
+instance IxApplicative m => Applicative (LowerIx m i) where
+	pure = LowerIx . ireturn
+	f <*> m = LowerIx (liftIx f `iap` liftIx m)
+
+instance IxMonad m => Monad (LowerIx m i) where
+	return = LowerIx . ireturn
+	m >>= f = LowerIx (liftIx m >>>= liftIx . f)
+
+instance IxComonad w => Comonad (LowerIx w i) where
+	extend f = LowerIx . iextend (f . LowerIx) . liftIx
hunk ./src/Control/Functor/KanExtension.hs 14
-import Control.Functor.Composition.Class
+import Control.Functor.Composition
hunk ./src/Control/Functor/Pointed.hs 9
--- Portability	: non-portable (functional-dependencies)
+-- Portability	: portable
hunk ./src/Control/Functor/Pointed.hs 13
-module Control.Functor.Pointed where
+module Control.Functor.Pointed 
+	( Pointed(..)
+	, Copointed(..)
+	) where
+
+import Control.Monad.Identity
hunk ./src/Control/Functor/Pointed.hs 24
--- extract
hunk ./src/Control/Functor/Pointed.hs 25
-        copoint :: f a -> a
+        extract :: f a -> a
hunk ./src/Control/Functor/Pointed.hs 28
-"copoint/point" copoint . point = id
-"point/copoint" point . copoint = id
+"extract/point" extract . point = id
+"point/extract" point . extract = id
hunk ./src/Control/Functor/Pointed.hs 32
+instance Pointed Identity where
+	point = Identity
+
+instance Pointed Maybe where
+	point = Just
+
+instance Pointed (Either a) where
+	point = Right
+
+instance Pointed [] where
+	point a = [a]
+
+instance Copointed Identity where
+        extract = runIdentity
+
+instance Copointed ((,)e) where
+	extract = snd
hunk ./src/Control/Functor/Pointed/Composition.hs 12
+-- TODO: finish the monad instances
hunk ./src/Control/Functor/Pointed/Composition.hs 15
-module Control.Functor.Pointed.Composition where
+module Control.Functor.Pointed.Composition 
+	( PointedCompF(..)
+	, PostCompF(..)
+	, PreCompF(..)
+	, DistCompF(..)
+	) where
hunk ./src/Control/Functor/Pointed/Composition.hs 22
-import Control.Functor.Pointed
-import Control.Functor.Composition.Class
+import Control.Functor.Extras
hunk ./src/Control/Functor/Pointed/Composition.hs 24
+import Control.Comonad
+import Control.Monad
hunk ./src/Control/Functor/Pointed/Composition.hs 35
-        copoint = copoint . copoint . decompose
+        extract = extract . extract . decompose
hunk ./src/Control/Functor/Pointed/Composition.hs 38
+
+instance (Comonad w, Copointed f, PostUnfold w f) => Comonad (PostCompF w f) where
+        duplicate = compose . liftW (fmap compose . postUnfold) . duplicate . decompose
+
+{-
+instance (Monad m, Pointed f, PostFold m f) => Monad (PostCompF m f) where
+        return = compose . return . point
+        m >>= k = undefined where
+		postJoin :: (Monad m, PostFold m f) => m (f (m (f a))) -> m (f a)
+		postJoin = join . liftM postFold
+-}
+
+
hunk ./src/Control/Functor/Pointed/Composition.hs 52
+
+instance (Copointed f, Comonad w, PreUnfold f w) => Comonad (PreCompF f w) where
+        duplicate = compose . fmap (liftW compose) . preUnfold . fmap (duplicate) . decompose
+
+{-
+instance (Pointed f, Monad m, PreFold f m) => Monad (PreCompF f m) where
+        return = compose . point . return
+        m >>= k = undefined where
+		preJoin :: (Monad m, Functor f, PreFold f m) => f (m (f (m a))) -> f (m a)
+		preJoin = fmap join . preFold
+-}
+
+
hunk ./src/Control/Functor/Pointed/Composition.hs 67
+instance (Comonad f, Comonad g, Distributes f g) => Comonad (DistCompF f g) where
+        duplicate = compose . fmap (fmap compose . dist) . duplicate . fmap duplicate . decompose
+
+{-
+instance (Monad m, Monad n, Distributes m n) => Monad (DistCompF m n) where
+        return = compose . return . return
+        m >>= k = undefined
+-}
hunk ./src/Control/Functor/Strong.hs 18
-import Control.Monad.Either
+import Control.Monad.Either ()
hunk ./src/Control/Functor/Zap.hs 17
-import Control.Bifunctor
-import Control.Bifunctor.Composition
hunk ./src/Control/Functor/Zap.hs 18
-import Control.Monad.Either
-import Control.Monad.Free
+import Control.Monad.Either ()
hunk ./src/Control/Functor/Zap.hs 20
-import Data.Traversable
hunk ./src/Control/Functor/Zip.hs 11
+-- Described in <http://comonad.com/reader/2008/zipping-and-unzipping-functors/> and
+-- <http://comonad.com/reader/2008/cozipping/>
hunk ./src/Control/Functor/Zip.hs 15
-module Control.Functor.Zip where
+module Control.Functor.Zip 
+	( unfzip, unbizip
+	, counzip, counbizip
+	, Zip(..)
+	, Bizip(..)
+	, Cozip(..)
+	) where
hunk ./src/Control/Functor/Zip.hs 23
-import Control.Arrow ((&&&))
-import Control.Bifunctor
-import Control.Bifunctor.Composition
-import Control.Bifunctor.Pair -- Bifunctor (,)
-import Control.Bifunctor.Fix
+import Control.Arrow ((&&&),(|||))
+import Control.Bifunctor.Functor
hunk ./src/Control/Functor/Zip.hs 73
-	fzipWith f _ _ = Nothing
+	fzipWith _ _ _ = Nothing
hunk ./src/Control/Functor/Zip.hs 95
-	fzipWith f (Left a) (Left b) = Left (mappend a b)
-	fzipWith f (Right a) (Left b) = Left b
-	fzipWith f (Left a) (Right b) = Left a
+	fzipWith _ (Left a) (Left b) = Left (mappend a b)
+	fzipWith _ (Right _) (Left b) = Left b
+	fzipWith _ (Left a) (Right _) = Left a
hunk ./src/Control/Functor/Zip.hs 106
+counzip :: Functor f => Either (f a) (f b) -> f (Either a b)
+counzip = fmap Left ||| fmap Right
+ 
+counbizip :: Bifunctor f => Either (f a c) (f b d) -> f (Either a b) (Either c d)
+counbizip = bimap Left Left ||| bimap Right Right
+
+class Functor f => Cozip f where
+   cozip :: f (Either a b) -> Either (f a) (f b)
+ 
+instance Cozip Identity where
+   cozip = bimap Identity Identity . runIdentity
+
+instance Cozip ((,)c) where
+   cozip (c,ab) = bimap ((,)c) ((,)c) ab
+ 
+-- ambiguous choice
+instance Cozip Maybe where
+   cozip = maybe (Left Nothing) (bimap Just Just)
+-- cozip = maybe (Right Nothing) (bimap Just Just)
+ 
+-- ambiguous choice
+instance Cozip (Either c) where
+   cozip = (Left . Left) ||| bimap Right Right
+-- cozip = (Right . Left) ||| bimap Right Right
+
hunk ./src/Control/Monad/Either.hs 16
-module Control.Monad.Either where
+module Control.Monad.Either 
+	( Either(..)
+	, EitherT(..)
+	) where
hunk ./src/Control/Monad/Either.hs 22
+import Control.Applicative
hunk ./src/Control/Monad/Either.hs 24
+import Control.Monad.Fix
+import Control.Functor.Pointed
hunk ./src/Control/Monad/Either.hs 29
+{-
hunk ./src/Control/Monad/Either.hs 34
+instance Pointed (Either e) where
+	point = Right
+-}
+
+instance Applicative (Either e) where
+	pure = Right
+	(<*>) = ap
+
hunk ./src/Control/Monad/Either.hs 47
-instance Functor f => Functor (EitherT b f) where
+instance MonadFix (Either e) where
+	mfix f = let 
+		a = f $ case a of
+			Right r -> r
+			_ -> error "empty mfix argument"
+		in a
+
+instance Functor f => Functor (EitherT a f) where
hunk ./src/Control/Monad/Either.hs 57
-instance Monad m => Monad (EitherT b m) where
+instance Pointed f => Pointed (EitherT a f) where
+	point = EitherT . point . Right
+
+instance Monad m => Monad (EitherT a m) where
hunk ./src/Control/Monad/Either.hs 65
-                    Left  l -> return (Left l)
-                    Right r -> runEitherT (k r)
+                	Left  l -> return (Left l)
+                	Right r -> runEitherT (k r)
+
+instance MonadFix m => MonadFix (EitherT a m) where
+	mfix f = EitherT $ mfix $ \a -> runEitherT $ f $ case a of
+        	Right r -> r
+        	_       -> error "empty mfix argument"	
hunk ./src/Control/Monad/Free.hs 13
-module Control.Monad.Free where
+module Control.Monad.Free 
+	( module Control.Monad.Parameterized
+	, module Control.Monad.Identity
+	, FreeB
+	, Free
+	, inFree
+	, runFree
+	, cataFree
+	, free
+	) where
hunk ./src/Control/Monad/Free.hs 24
-import Control.Arrow ((|||), (+++))
-import Control.Bifunctor
-import Control.Bifunctor.Either
+import Control.Arrow ((|||))
+import Control.Bifunctor.Biff
hunk ./src/Control/Monad/Free.hs 27
-import Control.Bifunctor.Composition
-import Control.Functor.Extras
-import Control.Functor.Exponential
-import Control.Functor.Contravariant
-import Control.Monad
-import Control.Monad.Identity
hunk ./src/Control/Monad/Free.hs 28
-import Control.Monad.Parameterized.Class
-import Control.Comonad.Parameterized
-import Control.Comonad.Parameterized.Class
-
-instance Functor f => PMonad (BiffB Either Identity f) where
-        preturn = BiffB . Left . Identity
-        pbind k = (k . runIdentity ||| BiffB . Right) . runBiffB
+import Control.Monad.Identity
hunk ./src/Control/Monad/HigherOrder.hs 12
-module Control.Monad.HigherOrder where
+module Control.Monad.HigherOrder 
+	( HFunctor(..)
+	, HPointed(..)
+	, HMonad(..)
+	, hjoin
+	, (>>**=), (=**<<)
+	) where
hunk ./src/Control/Monad/HigherOrder.hs 20
-import Control.Functor.Extras
+import Control.Functor.Extras (Natural)
hunk ./src/Control/Monad/HigherOrder.hs 23
-class HFunctor m => HMonad m where
-	hreturn :: Functor f => Natural f (m f)
+infixl 1 >>**=
+infixr 1 =**<<
+
+class HPointed m => HMonad m where
hunk ./src/Control/Monad/HigherOrder.hs 28
-	--hbind k = hjoin . hfmap k
hunk ./src/Control/Monad/HigherOrder.hs 35
+(=**<<) :: (HMonad m, Functor f, Functor g) => Natural f (m g) -> Natural (m f) (m g)
+(=**<<) = hbind
+
hunk ./src/Control/Monad/Hyper.hs 15
-module Control.Monad.Hyper where
+module Control.Monad.Hyper 
+	( ContravariantFunctor(..)
+	, Hyper
+	, Hyp
+	, HyperB(..)
+	) where
hunk ./src/Control/Monad/Hyper.hs 22
-import Control.Bifunctor
hunk ./src/Control/Monad/Hyper.hs 23
-import Control.Monad.Parameterized.Class
+import Control.Monad.Parameterized
hunk ./src/Control/Monad/Hyper.hs 32
-instance ContravariantFunctor h => PMonad (HyperB h) where
+instance ContravariantFunctor h => PPointed (HyperB h) where
hunk ./src/Control/Monad/Hyper.hs 34
-	pbind k (HyperB h) = HyperB (k . h >>= runHyperB) -- the bind is in the (->)e monad
+
+instance ContravariantFunctor h => PApplicative (HyperB h) where
+	pap = papPMonad
+
+instance ContravariantFunctor h => PMonad (HyperB h) where
+	pbind k (HyperB h) = HyperB (k . h >>= runHyperB)
hunk ./src/Control/Monad/Indexed.hs 12
-module Control.Monad.Indexed where
+module Control.Monad.Indexed 
+	( IxFunctor(..)
+	, IxPointed(..)
+	, IxApplicative(..)
+	, IxMonad(..)
+	, ijoin, (>>>=), (=<<<)
+	, iapIxMonad
+	) where
hunk ./src/Control/Monad/Indexed.hs 21
-import Control.Comonad
-import Control.Arrow
-import Control.Functor.Extras
-import Control.Functor.HigherOrder
hunk ./src/Control/Monad/Indexed.hs 22
-import Control.Monad
hunk ./src/Control/Monad/Indexed.hs 23
-class IxFunctor m => IxMonad m where
-	ireturn :: a -> m i i a
+class IxApplicative m => IxMonad m where
hunk ./src/Control/Monad/Indexed.hs 29
+infixr 1 =<<<
hunk ./src/Control/Monad/Indexed.hs 35
-instance (Functor m, Monad m) => IxMonad (LiftIx m) where
-	ireturn = LiftIx . return
-	ibind f m = LiftIx (lowerIx m >>= lowerIx . f)
+(=<<<) :: IxMonad m => (a -> m j k b) -> m i j a -> m i k b
+(=<<<) = ibind
hunk ./src/Control/Monad/Indexed.hs 38
-instance (IxMonad m) => Monad (LowerIx m i) where
-	return = LowerIx . ireturn
-	m >>= f = LowerIx (liftIx m >>>= liftIx . f)
+iapIxMonad :: IxMonad m => m i j (a -> b) -> m j k a -> m i k b
+iapIxMonad f x = f >>>= \ f' -> x >>>= \x' -> ireturn (f' x')
hunk ./src/Control/Monad/Indexed/Cont.hs 5
--- Copyright 	: 2008 Edward Kmett
---		  2008 Dan Doel
+-- Copyright 	: 2008 Edward Kmett, Dan Doel
hunk ./src/Control/Monad/Indexed/Cont.hs 17
-import Control.Functor.Indexed
hunk ./src/Control/Monad/Indexed/Cont.hs 19
+class IxMonad m => IxMonadCont m where
+	reset :: m a o o -> m r r a
+	shift :: ((a -> m i i o) -> m r j j) -> m r o a
hunk ./src/Control/Monad/Indexed/Cont.hs 28
--- runIxContT :: Monad m => IxContT m r a a -> m r
--- runIxContT m = unIxContT m return
-
hunk ./src/Control/Monad/Indexed/Cont.hs 31
-
-instance Monad m => IxMonad (IxContT m) where
+instance IxPointed (IxContT m) where
hunk ./src/Control/Monad/Indexed/Cont.hs 33
-	ibind f c = IxContT $ \k -> runIxContT c $ \a -> runIxContT (f a) k
hunk ./src/Control/Monad/Indexed/Cont.hs 34
-class IxMonad m => IxContMonad m where
-	reset :: m a o o -> m r r a
-	shift :: ((a -> m i i o) -> m r j j) -> m r o a
+instance Monad m => IxApplicative (IxContT m) where
+	iap = iapIxMonad
hunk ./src/Control/Monad/Indexed/Cont.hs 37
+instance Monad m => IxMonad (IxContT m) where
+	ibind f c = IxContT $ \k -> runIxContT c $ \a -> runIxContT (f a) k
hunk ./src/Control/Monad/Indexed/Cont.hs 40
-instance Monad m => IxContMonad (IxContT m) where
+instance Monad m => IxMonadCont (IxContT m) where
hunk ./src/Control/Monad/Indexed/Cont.hs 44
-newtype IxCont r o a = IxCont (IxContT Identity r o a) deriving (IxFunctor, IxMonad, IxContMonad)
+newtype IxCont r o a = IxCont (IxContT Identity r o a) 
+	deriving (IxFunctor, IxPointed, IxApplicative, IxMonad, IxMonadCont)
hunk ./src/Control/Monad/Indexed/State.hs 14
-import Control.Comonad
-import Control.Arrow
-import Control.Functor.Extras
-import Control.Functor.HigherOrder
-import Control.Functor.Indexed
+import Control.Arrow ((***))
+import Control.Bifunctor (Bifunctor(bimap), first)
hunk ./src/Control/Monad/Indexed/State.hs 19
+class IxMonad m => IxMonadState m where
+	iget :: m i i i
+	iput :: j -> m i j ()
+
+imodify :: IxMonadState m => (i -> j) -> m i j ()
+imodify f = iget >>>= iput . f
+
+igets :: IxMonadState m => (i -> a) -> m i i a
+igets f = iget >>>= ireturn . f
+	
hunk ./src/Control/Monad/Indexed/State.hs 31
+instance Functor (IxState i j) where
+	fmap = imap
+
hunk ./src/Control/Monad/Indexed/State.hs 35
-	imap f (IxState m) = IxState (first f . m)
+	imap f m = IxState (first f . runIxState m)
hunk ./src/Control/Monad/Indexed/State.hs 37
-instance IxMonad IxState where
+instance IxPointed IxState where
hunk ./src/Control/Monad/Indexed/State.hs 39
-	ibind f (IxState m) = IxState $ \s1 -> let (a,s2) = m s1 in runIxState (f a) s2 
+
+instance IxApplicative IxState where
+	iap = iapIxMonad
+
+instance IxMonad IxState where
+	ibind f m = IxState $ \s1 -> let (a,s2) = runIxState m s1 in runIxState (f a) s2 
+
+instance IxMonadState IxState where
+	iget = IxState (\x -> (x,x))
+	iput x = IxState (\_ -> ((),x))
+
+instance Bifunctor (IxState i) where 
+	bimap f g m = IxState $ (g *** f) . runIxState m
+
+newtype IxStateT m i j a = IxStateT { runIxStateT :: i -> m (a, j) }
+
+instance Monad m => Functor (IxStateT m i j) where
+	fmap = imap
+
+instance Monad m => IxFunctor (IxStateT m) where
+	imap f m = IxStateT $ \s -> runIxStateT m s >>= \(x,s') -> return (f x, s')
+
+instance Monad m => IxPointed (IxStateT m) where
+    	ireturn a = IxStateT $ \s -> return (a, s)
+
+instance Monad m => IxApplicative (IxStateT m) where
+   	iap = iapIxMonad 
+
+instance Monad m => IxMonad (IxStateT m) where
+    	ibind k m = IxStateT $ \s -> runIxStateT m s >>= \ ~(a, s') -> runIxStateT (k a) s'
+
+instance Monad m => Bifunctor (IxStateT m i) where
+	bimap f g m = IxStateT $ liftM (g *** f) . runIxStateT m
+
+instance Monad m => IxMonadState (IxStateT m) where
+	iget   = IxStateT $ \s -> return (s, s)
+	iput s = IxStateT $ \_ -> return ((), s)
+
+{-
+instance MonadPlus m => IxMonadPlus (IxStateT m) where
+    izero       = IxStateT $ \_ -> mzero
+    m `iplus` n = IxStateT $ \s -> runIxStateT m s `mplus` runIxStateT n s
+
+instance MonadFix m => IxMonadFix (IxStateT m) where
+    ifix f = StateT $ \s -> mfix $ \ ~(a, _) -> runStateT (f a) s
+-}
hunk ./src/Control/Monad/Parameterized.hs 13
-module Control.Monad.Parameterized where
+module Control.Monad.Parameterized 
+	( Bifunctor(..)
+	, PPointed(..)
+	, PApplicative(..)
+	, PMonad(..)
+	, (>>*=), (=*<<), (>>*)
+	, papPMonad
+	) where
hunk ./src/Control/Monad/Parameterized.hs 22
-import Control.Arrow ((|||), (+++))
-import Control.Monad
hunk ./src/Control/Monad/Parameterized.hs 23
-import Control.Bifunctor.Fix
-import Control.Monad.Parameterized.Class
-import Control.Morphism.Cata
+import Control.Applicative.Parameterized
hunk ./src/Control/Monad/Parameterized.hs 25
-paugment :: PMonad f => (forall c. (f a c -> c) -> c) -> (a -> FixB f b) -> FixB f b
-paugment g k = g (InB . pbind (outB . k))
+infixl 1 >>*=, >>*
+infixr 1 =*<< 
hunk ./src/Control/Monad/Parameterized.hs 28
-instance PMonad f => Monad (FixB f) where
-	return = InB . preturn
-	m >>= k = paugment (flip bicata m) k
+class PApplicative f => PMonad f where
+	pbind :: (a -> f b c) -> f a c -> f b c
+	pbind f = pjoin . bimap f id
+	pjoin :: f (f a b) b -> f a b
+	pjoin = pbind id
+
+papPMonad :: PMonad f => f (a -> b) c -> f a c -> f b c
+papPMonad f x = f >>*= \ f' -> x >>*= \x' -> preturn (f' x')
+
+(>>*=) :: PMonad f => f a c -> (a -> f b c) -> f b c
+(>>*=) = flip pbind
+
+(=*<<) :: PMonad f => (a -> f b c) -> f a c -> f b c
+(=*<<) = pbind
+
+(>>*) :: PMonad f => f a c -> f b c -> f b c 
+m >>* n = m >>*= const n
+
+{- Parameterized monad laws (from <http://crab.rutgers.edu/~pjohann/f14-ghani.pdf>)
+> pbind preturn = id
+> pbind g . preturn = g
+> pbind (pbind g . j) = pbind g . pbind j
+> pmap g . preturn = preturn
+> pbind (pmap g . j) . pmap g = pmap g . pbind j 
+-}
hunk ./src/Control/Monad/Parameterized/Class.hs 1
-{-# OPTIONS_GHC -fglasgow-exts #-}
------------------------------------------------------------------------------
--- |
--- Module      :  Control.Monad.Paramterized.Class
--- Copyright   :  (C) 2008 Edward Kmett
--- License     :  BSD-style (see the file LICENSE)
---
--- Maintainer  :  Edward Kmett <ekmett@gmail.com>
--- Stability   :  experimental
--- Portability :  portable
---
--- The notation >>*= was selected to indicate the kind of the parameter
--- in this case a simple type as opposed to >>*->*= for higher order monads.
-----------------------------------------------------------------------------
-module Control.Monad.Parameterized.Class where
-
-import Control.Arrow ((|||), (+++))
--- import Control.Functor.Exponential
--- import Control.Functor.Contravariant
-import Control.Monad
-import Control.Bifunctor
-import Control.Bifunctor.Fix
-
-{- | Minimum definition:
-
-1. preturn & pbind
-2. preturn & pjoin
-
--}
-	
-class Bifunctor f => PMonad f where
-	preturn :: a -> f a c
-	pbind :: (a -> f b c) -> f a c -> f b c
-	pbind f = pjoin . bimap f id
-	pjoin :: f (f a b) b -> f a b
-	pjoin = pbind id
-
-(>>*=) :: PMonad f => f a c -> (a -> f b c) -> f b c
-(>>*=) = flip pbind
-
-(=*<<) :: PMonad f => (a -> f b c) -> f a c -> f b c
-(=*<<) = pbind
-
--- (>>*) :: PMonad f => f a c -> f b c -> f b c 
-m >>* n = m >>*= const n
-
--- bimapPMonad :: (PMonad f, Functor (f a)) => (a -> c) -> (b -> d) -> f a b -> f c d 
--- bimapPMonad f g xs = second g xs >>*= preturn . f
-
-{- Parameterized monad laws (from <http://crab.rutgers.edu/~pjohann/f14-ghani.pdf>)
-> pbind preturn = id
-> pbind g . preturn = g
-> pbind (pbind g . j) = pbind g . pbind j
-> pmap g . preturn = preturn
-> pbind (pmap g . j) . pmap g = pmap g . pbind j 
--}
-
rmfile ./src/Control/Monad/Parameterized/Class.hs
hunk ./src/Control/Morphism/Ana.hs 23
-import Control.Comonad.Identity ()
hunk ./src/Control/Morphism/Cata.hs 18
-import Control.Comonad.Identity
+import Control.Functor.Pointed
hunk ./src/Control/Morphism/Chrono.hs 19
-import Control.Functor.Fix
hunk ./src/Control/Morphism/Dyna.hs 17
-import Control.Functor.Fix
-import Control.Comonad
hunk ./src/Control/Morphism/Hylo.hs 17
-import Control.Bifunctor.HigherOrder
hunk ./src/Control/Morphism/Hylo.hs 21
-import Control.Functor.Fix
hunk ./src/Control/Morphism/Para.hs 15
-import Control.Comonad
hunk ./src/Control/Morphism/Zygo.hs 16
-import Control.Bifunctor.Pair
-import Control.Comonad
}
