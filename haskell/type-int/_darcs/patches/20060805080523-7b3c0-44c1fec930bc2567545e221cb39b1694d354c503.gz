[Added Type.Hex
ekmett@gmail.com**20060805080523] {
adddir ./src/Type/Hex
hunk ./jugs.cabal 13
-extensions:		MultiParamTypeClasses, FunctionalDependencies, Arrows, TemplateHaskell
-exposed-modules:	Type.Binary, Type.Boolean, Type.Ord
+extensions:		MultiParamTypeClasses, FunctionalDependencies, Arrows, TemplateHaskell, CPP
+exposed-modules:	
+	Data.Hashable,
+	Data.THash,
+	Data.THash.THT,
+	Type.Boolean, 
+	Type.Ord, 
+	Type.Binary, 
+	Type.Binary.Internals, 
+	Type.Binary.TH,
+	Type.Binary.Hex,
+	Type.Binary.Names,
+	Type.Hex,
+	Type.Hex.Stage1,
+	Type.Hex.Stage2,
+	Type.Hex.Stage3,
+	Type.Maybe
hunk ./src/Type/Binary.hs 1
-{-# OPTIONS -fglasgow-exts #-}			-- MPTC, Fundeps
-{-# OPTIONS -fallow-undecidable-instances #-}	-- needed for all type LHSs
-{-# OPTIONS -fth #-}				-- needed for $(tBinary 24)
+{-# GHC_OPTIONS -fglasgow-exts #-}
+{-# GHC_OPTIONS -fth #-}
+{-# GHC_OPTIONS -fallow-undecidable-instances #-}
hunk ./src/Type/Binary.hs 12
--- Portability :  non-portable (FD and MPTC)
+-- Portability :  non-portable (MPTC, FD, TH, undecidable instances, and no constructors)
hunk ./src/Type/Binary.hs 19
--- variables, in which for every element in the set there exists an n
--- such that there exists a B in {T,F} for all n' in N > n x_i = b.
--- for uniqueness we always choose the least such n when representing numbers
--- this allows us to run all computations backwards.
+-- variables, in which for every element in the set there exists an n in N
+-- and a b in {T,F} such that for all n'>=n in N, x_i = b.
+-- 
+-- For uniqueness we always choose the least such n when representing numbers
+-- this allows us to run most computations backwards. When we can't, and such
+-- a fundep would be implied, we obtain it by combining semi-operations that 
+-- together yield the appropriate class fundep list.
hunk ./src/Type/Binary.hs 27
--- The goal here was to pull together all of the good ideas I've seen from
--- various sources, and sprinkle a twos complement negative number 
+-- The goal here was to pull together many of the good ideas I've seen from
+-- various sources, and sprinkle a two's complement negative number 
hunk ./src/Type/Binary.hs 31
--- Reuses T and F from the Type.Boolean as the infinite tail of a 2s 
--- complement binary number. 
+-- Reuses T and F from the Type.Boolean as the infinite tail of the 2s 
+-- complement binary number. I'm particularly fond of the symmetry exhibited
+-- in the full adder.
hunk ./src/Type/Binary.hs 35
--- TODO: TDivMod, TImplies, TXOr (properly), TGCD, 
--- a Template Haskell integer to type binary map
+-- TODO: TDivMod, TImplies, TGCD, TBit, TComplementBit, TSetBit
hunk ./src/Type/Binary.hs 44
-	TNeg, TNot, tNot, tNeg,
+	TNeg, tNeg,
hunk ./src/Type/Binary.hs 49
-	TXOr', tXOr',
-	TNF, tNF
+	TShift, tShift,
+	TNF, tNF,
+	TGetBit, tGetBit,
+	TSetBit, tSetBit,
+	TUnSetBit, tUnSetBit,
+	TChangeBit, tChangeBit,
+	TComplementBit, tComplementBit,
+	TCountBits, tCountBits,
+	-- re-exported from Type.Boolean
+	T, F,
+	TNot, tNot,
+	TAnd, tAnd,
+	TOr, tOr,
+	TXOr, tXOr,
+	TImplies, tImplies,
+	-- re-exported from Type.Ord
+	TEq, tEq,
+	TLt, tLt,
+	TLe, tLe,
+	TGt, tGt,
+	TGe, tGe,
+	-- re-exported from Type.Binary.TH
+	binaryE,
+	binaryT
+	-- re-exported from Type.Binary.Names
hunk ./src/Type/Binary.hs 76
+import Type.Binary.Internals
+import Type.Binary.TH
+import Type.Binary.Names
hunk ./src/Type/Binary.hs 83
-data O a
-data I a
-
--- | Internal closure, not exposed
-data Closure
-class Closed a | -> a
-instance Closed Closure
-
-class (TBool d) => LSB a d a' | a -> d a', d a' -> a
-instance LSB F F F
-instance LSB T T T
-instance LSB (O T) F T
-instance LSB (I F) T F
-instance LSB (O (O n)) F (O n)
-instance LSB (O (I n)) F (I n)
-instance LSB (I (O n)) T (O n)
-instance LSB (I (I n)) T (I n)
-tLSB :: LSB a d a' => a -> d -> a'; tLSB = undefined
-tBSL :: LSB a d a' => a' -> d -> a; tBSL = undefined
-
--- | extract the lsb and assert we aren't at the long tail
-class LSB a d a' => X a d a' | a -> d a', d a' -> a, a a' -> d
-instance (LSB (O a) F a) => X (O a) F a
-instance (LSB (I a) T a) => X (I a) T a
-
--- | assert 2n != n
-class LSB (O a) F a => XO a
-instance (LSB (O a) F a) => XO a
-
--- | assert 2n+1 != n
-class LSB (I a) T a => XI a
-instance (LSB (I a) T a) => XI a
-
-class TSucc n m | n -> m, m -> n
-instance TSucc T F
-instance TSucc F (I F)
-instance TSucc (O T) T
-instance TSucc (O (I n)) (I (I n))
-instance TSucc (O (O n)) (I (O n))
-instance (TSucc n m, XI n, XO m) => TSucc (I n) (O m)
-tSucc :: TSucc n m => n -> m
-tSucc = undefined
-tPred :: TSucc n m => m -> n
-tPred = undefined
-
-instance Show (O F) where show n = "({-error-} O F)";
-instance Show (I T) where show n = "({-error-} I T)";
-instance Show (I F) where show n = "I F";
-instance Show (O T) where show n = "O T";
-instance (Show (I t)) => Show (O (I t)) where show n = "O (" ++ show (undefined::I t) ++ ")"
-instance (Show (I t)) => Show (I (I t)) where show n = "I (" ++ show (undefined::I t) ++ ")" 
-instance (Show (O t)) => Show (O (O t)) where show n = "O (" ++ show (undefined::O t) ++ ")"
-instance (Show (O t)) => Show (I (O t)) where show n = "I (" ++ show (undefined::O t) ++ ")"
-
-class TCBinary c a | a -> c
-instance TCBinary Closure F
-instance TCBinary Closure T
-instance (TCBinary c a, XO a) => TCBinary c (O a)
-instance (TCBinary c a, XI a) => TCBinary c (I a)
-
-class TCBinary Closure a => TBinary a where fromTBinary :: Integral b => a -> b 
-instance TBinary F where fromTBinary _ = fromInteger 0
-instance TBinary T where fromTBinary _ = fromInteger (-1)
-instance (TBinary a, XO a) => TBinary (O a) where fromTBinary _ = let x = fromTBinary (undefined::a) in x+x
-instance (TBinary a, XI a) => TBinary (I a) where fromTBinary _ = let x = fromTBinary (undefined::a) in succ(x+x)
-
-thBinary :: Integral a => a -> TypeQ
-thBinary n = case n of
-		0  -> conT $ mkName "F"
-		-1 -> conT $ mkName "T"
-		n  -> let tf = thBinary $ n `div` 2
-		          oi = conT $ mkName $ if (n `mod` 2) == 0 then "O" else "I" 
-	   	      in appT oi tf
-thNum :: Integral a => a -> ExpQ 
-thNum n = sigE (varE $ mkName "undefined") $ thBinary n
-
-
-instance (TNot a b) => TNot (O a) (I b)
-instance (TNot a b) => TNot (I a) (O b)
-
--- ...
-neg_two  = undefined :: O T
-neg_one	 = undefined :: T
-zero 	 = undefined :: F
-one 	 = undefined :: I F
-two 	 = undefined :: O(I F)
-three	 = undefined :: I(I F)
-four 	 = undefined :: O(O(I F))
-five     = undefined :: I(O(I F))
-six  	 = undefined :: O(I(I F))
-seven 	 = undefined :: I(I(I F))
-eight    = undefined :: O(O(O(I F)))
-nine     = undefined :: I(O(O(I F)))
-ten      = undefined :: O(I(O(I F)))
-eleven   = undefined :: I(I(O(I F)))
-twelve   = undefined :: O(O(I(I F)))
-thirteen = undefined :: I(O(I(I F)))
-fourteen = undefined :: O(O(I(I F)))
-fifteen  = undefined :: I(O(I(I F)))
-sixteen  = undefined :: O(O(O(O(I F))))
-seventeen= undefined :: I(O(O(O(I F))))
-eighteen = undefined :: O(I(O(O(I F))))
-nineteen = undefined :: I(I(O(O(I F))))
-twenty  :: TAdd (O(O(I(O(I F))))) b c => b -> c;	    twenty  = undefined;
-thirty  :: TAdd (O(I(I(I(I F))))) b c => b -> c;	    thirty  = undefined;
-fourty  :: TAdd (O(O(O(I(O(I F)))))) b c => b -> c; 	    fourty  = undefined;
-fifty   :: TAdd (O(I(O(O(I(I F)))))) b c => b -> c; 	    fifty   = undefined;
-sixty   :: TAdd (O(O(I(I(I(I F)))))) b c => b -> c; 	    sixty   = undefined;
-seventy :: TAdd (O(I(I(O(O(O(I F))))))) b c => b -> c;      seventy = undefined;
-eighty  :: TAdd (O(O(O(O(I(O(I F))))))) b c => b -> c;      eighty  = undefined;
-ninety  :: TAdd (O(I(O(I(I(O(I F))))))) b c => b -> c;      ninety  = undefined;
-type Hundred =   O(O(I(O(O(I(I F))))))
-hundred :: (TAdd a' b c, TMul a Hundred a') => a -> b -> c;   hundred = undefined;
-
-instance TEq (I m) (O n) F 
-instance TEq (O m) (I n) F
-instance TEq (O m) F F
-instance TEq (O m) T F
-instance TEq (I m) T F
-instance TEq (I m) F F
-instance (TEq m n b) => TEq (I m) (I n) b
-instance (TEq m n b) => TEq (O m) (O n) b
-
-class TNeg a b | a -> b, b -> a
-instance (TNot a b, TSucc b c) => TNeg a c
-tNeg :: TNeg a b => a -> b; tNeg = undefined
-
-data IsNegative
-data IsZero
-data IsPositive
-
-class TCSign c a | a -> c
-instance TCSign Closure IsNegative
-instance TCSign Closure IsPositive
-instance TCSign Closure IsZero
-
-class TCSign Closure s => TSign s
-instance TSign IsNegative
-instance TSign IsZero
-instance TSign IsPositive
-
-instance TEq IsNegative IsNegative T
-instance TEq IsNegative IsZero F
-instance TEq IsNegative IsPositive F
-instance TEq IsZero IsNegative F
-instance TEq IsZero IsZero T
-instance TEq IsZero IsPositive F
-instance TEq IsPositive IsNegative F
-instance TEq IsPositive IsZero F
-instance TEq IsPositive IsPositive T
-
-class Trichotomy n s | n -> s
-instance Trichotomy T IsNegative
-instance Trichotomy F IsZero
-instance Trichotomy (I F) IsPositive
-instance Trichotomy (O T) IsNegative
-instance (Trichotomy a b, XI a) => Trichotomy (I (I a)) b
-instance (Trichotomy a b, XI a) => Trichotomy (O (I a)) b
-instance (Trichotomy a b, XO a) => Trichotomy (I (O a)) b
-instance (Trichotomy a b, XO a) => Trichotomy (O (O a)) b
-
-class TIsPositive n b | n -> b
-instance (Trichotomy n s, TEq s IsPositive b) => TIsPositive n b
-tIsPositive :: TIsPositive n b => n -> b; tIsPositive = undefined 
-
-class TIsNegative n b | n -> b
-instance (Trichotomy n s, TEq s IsNegative b) => TIsNegative n b
-tIsNegative :: TIsNegative n b => n -> b; tIsNegative = undefined
-
-class TIsZero n b | n -> b
-instance (Trichotomy n s, TEq s IsZero b) => TIsZero n b
-tIsZero :: TIsZero n b => n -> b; tIsZero = undefined 
-
-class TEven a b | a -> b
-instance LSB a b c => TEven a b
-tEven :: (TEven a b) => a -> b; tEven = undefined
-
-class TOdd a b | a -> b
-instance (LSB a b c, TNot b b') => TOdd a b'
-tOdd :: (TOdd a b) => a -> b; tOdd = undefined
-
--- | nice adder with carry. does not yield normal form answers.
-class TAddC a b c d | a b c -> d
-instance TAddC F F F F 
-instance TAddC T F T F
-instance TAddC F T F T 
-instance TAddC T T T T
-instance TAddC T F F T
-instance TAddC F T T F
-instance TAddC F F T (I F) 
-instance TAddC T T F (O T)
-instance TAddC F (O a) F (O a) 
-instance TAddC T (O a) T (O a)
-instance TAddC F (I a) F (I a) 
-instance TAddC T (I a) T (I a)
-instance TAddC (O a) F F (O a) 
-instance TAddC (O a) T T (O a)
-instance TAddC (I a) F F (I a) 
-instance TAddC (I a) T T (I a)
-instance TAddC F (O a) T (I a) 
-instance TAddC T (I a) F (O a)
-instance TAddC (O a) F T (I a) 
-instance TAddC (I a) T F (O a)
-instance TSucc a b => TAddC F (I a) T (O b) 
-instance TSucc b a => TAddC T (O a) F (I b)
-instance TSucc a b => TAddC (I a) F T (O b) 
-instance TSucc b a => TAddC (O a) T F (I b)
-instance TAddC a b F c => TAddC (O a) (O b) F (O c) 
-instance TAddC a b F c => TAddC (O a) (O b) T (I c)
-instance TAddC a b F c => TAddC (I a) (O b) F (I c) 
-instance TAddC a b T c => TAddC (I a) (O b) T (O c)
-instance TAddC a b F c => TAddC (O a) (I b) F (I c) 
-instance TAddC a b T c => TAddC (O a) (I b) T (O c)
-instance TAddC a b T c => TAddC (I a) (I b) F (O c) 
-instance TAddC a b T c => TAddC (I a) (I b) T (I c)
-tAddC :: TAddC a b c d => a -> b -> c -> d
-tAddC = undefined
-
-class TNF' a b c | a -> b c
-instance TNF' F F F
-instance TNF' T T F
-instance TNF' (O F) F F
-instance TNF' (I T) T F
-instance TNF' (I F) (I F) T
-instance TNF' (O T) (O T) T
-instance (TNF' (O a) c b) => TNF' (I (O a)) (I c) T
-instance (TNF' (I a) c b) => TNF' (O (I a)) (O c) T
-instance (TNF' (I a) c b, TIf b (I c) T d) => TNF' (I (I a)) d b
-instance (TNF' (O a) c b, TIf b (O c) F d) => TNF' (O (O a)) d b
-
-class TNF a b | a -> b
-instance TNF' a b c => TNF a b
-tNF :: TNF a b => a -> b; tNF = undefined
-
-class TAdd a b c | a b -> c
-instance (TAddC a b F d, TNF d d') => TAdd a b d'
-tAdd :: (TAdd a b c ) => a -> b -> c; tAdd = undefined
-
-class TSub a b c | a b -> c
-instance (TNeg b b', TAdd a b' c) => TSub a b c
-tSub :: TSub a b c => a -> b -> c; tSub = undefined
-
--- reversible addition and subtraction
-class TRAdd a b c | a b -> c, a c -> b, b c -> a
-instance (TAdd a b c, TNeg b b', TAdd c b' a, TNeg a a', TAdd c a' b) => TRAdd a b c
-tRAdd :: (TRAdd a b c) => a -> b -> c;tRAdd = undefined
-tRSub :: (TRAdd a b c) => c -> a -> b;tRSub = undefined
-
-class TMul a b c | a b -> c
-instance TMul a F F
-instance TNeg a b => TMul a T b
-instance (TMul (O a) b c) => TMul a (O b) c
-instance (TMul (O a) b c, TRAdd a c d) => TMul a (I b) d
-tMul :: TMul a b c => a -> b -> c
-tMul = undefined
-
--- | for non-negative exponents
-class TPow a b c | a b -> c
-instance TPow a F (I F)
-instance (TPow a k c, TMul c c d) => TPow a (O k) d
-instance (TPow a k c, TMul c c d, TMul a d e) => TPow a (I k) e
-tPow :: TPow a b c => a -> b -> c
-tPow = undefined
-
-instance TAnd F (I b) F
-instance TAnd F (O b) F
-instance TAnd (I a) F F
-instance TAnd (O a) F F
-instance TAnd T (I b) (I b)
-instance TAnd T (O b) (O b)
-instance TAnd (I a) T (I a)
-instance TAnd (O a) T (O a)
-instance (TAnd a b c, TNF (I c) c') => TAnd (I a) (I b) c'
-instance (TAnd a b c, TNF (O c) c') => TAnd (O a) (I b) c'
-instance (TAnd a b c, TNF (O c) c') => TAnd (I a) (O b) c'
-instance (TAnd a b c, TNF (O c) c') => TAnd (O a) (O b) c'
-
-instance TOr F (I b) (I b)
-instance TOr F (O b) (O b)
-instance TOr (I a) F (I a)
-instance TOr (O a) F (I a)
-instance TOr T (I b) T
-instance TOr T (O b) T
-instance TOr (I a) T T
-instance TOr (O a) T T 
-instance (TOr a b c, TNF (I c) c') => TOr (I a) (I b) c'
-instance (TOr a b c, TNF (I c) c') => TOr (O a) (I b) c'
-instance (TOr a b c, TNF (I c) c') => TOr (I a) (O b) c'
-instance (TOr a b c, TNF (O c) c') => TOr (O a) (O b) c'
-
--- does not satisfy the rest of the reversibility fundeps of TXOr
-class TXOr' a b c | a b -> c
-instance TXOr' T T F
-instance TXOr' F T T
-instance TXOr' T F T
-instance TXOr' F F F
-instance TXOr' F (I b) (I b)
-instance TXOr' F (O b) (O b)
-instance TXOr' (I b) F (I b)
-instance TXOr' (O b) F (O b)
-instance TNot b c => TXOr' T (I b) (O c)
-instance TNot b c => TXOr' T (O b) (I c)
-instance TNot b c => TXOr' (I b) T (O c)
-instance TNot b c => TXOr' (O b) T (I c)
-instance (TXOr' a b c, TNF (O c) c') => TXOr' (I a) (I b) c'
-instance (TXOr' a b c, TNF (I c) c') => TXOr' (I a) (O b) c'
-instance (TXOr' a b c, TNF (I c) c') => TXOr' (O a) (I b) c'
-instance (TXOr' a b c, TNF (O c) c') => TXOr' (O a) (O b) c'
-tXOr' :: TXOr' a b c => a -> b -> c
-tXOr' = undefined
-
---test_twelve :: $(tBinary 12);
---test_twelve = undefined
-
addfile ./src/Type/Binary/Hex.hs
hunk ./src/Type/Binary/Hex.hs 1
+module Type.Binary.Hex (
+	Ox0, Ox1, Ox2, Ox3, 
+	Ox4, Ox5, Ox6, Ox7,
+	Ox8, Ox9, OxA, OxB,
+	OxC, OxD, OxE, OxF
+) where
+
+import Type.Binary (O(..), I(..))
+
+type Ox0 a = O (O (O (O a)))
+type Ox1 a = I (O (O (O a)))
+type Ox2 a = O (I (O (O a)))
+type Ox3 a = I (I (O (O a)))
+type Ox4 a = O (O (I (O a)))
+type Ox5 a = I (O (I (O a)))
+type Ox6 a = O (I (I (O a)))
+type Ox7 a = I (I (I (O a)))
+type Ox8 a = O (O (O (I a)))
+type Ox9 a = I (O (O (I a)))
+type OxA a = O (I (O (I a)))
+type OxB a = I (I (O (I a)))
+type OxC a = O (O (I (I a)))
+type OxD a = I (O (I (I a)))
+type OxE a = O (I (I (I a)))
+type OxF a = I (I (I (I a)))
+
addfile ./src/Type/Binary/Internals.hs
hunk ./src/Type/Binary/Internals.hs 1
+{-# OPTIONS -fglasgow-exts #-}			-- MPTC, Fundeps
+{-# OPTIONS -fallow-undecidable-instances #-}	-- needed for all type LHSs
+-----------------------------------------------------------------------------
+-- |
+-- Module      :  Type.Binary.Internals
+-- Copyright   :  (C) 2006 Edward Kmett
+-- License     :  BSD-style (see the file libraries/base/LICENSE)
+--
+-- Maintainer  :  Edward Kmett <ekmett@gmail.com>
+-- Stability   :  experimental
+-- Portability :  non-portable (FD and MPTC)
+--
+-- Simple type-level binary numbers, positive and negative with infinite 
+-- precision. This forms a nice commutative ring with multiplicative identity
+-- like we would expect from a representation for Z.
+--
+-- The numbers are represented as a Boolean Ring over a countable set of 
+-- variables, in which for every element in the set there exists an n in N
+-- and a b in {T,F} such that for all n'>=n in N, x_i = b.
+-- 
+-- For uniqueness we always choose the least such n when representing numbers
+-- this allows us to run most computations backwards. When we can't, and such
+-- a fundep would be implied, we obtain it by combining semi-operations that 
+-- together yield the appropriate class fundep list.
+--
+-- The goal here was to pull together many of the good ideas I've seen from
+-- various sources, and sprinkle a two's complement negative number 
+-- representation on top.
+--
+-- Reuses T and F from the Type.Boolean as the infinite tail of the 2s 
+-- complement binary number. I'm particularly fond of the symmetry exhibited
+-- in the full adder.
+--
+-- TODO: TDivMod, TImplies, TGCD, TBit, TComplementBit, TSetBit
+----------------------------------------------------------------------------
+
+module Type.Binary.Internals (
+	O, 
+	I, 
+	T, tT,
+	F, tF,
+	TSucc, tSucc, tPred,
+	TCBinary, TBinary, fromTBinary,
+	TNot, 
+	TNeg, tNeg,
+	TIsNegative, tIsNegative,
+	TIsPositive, tIsPositive,
+	TIsZero, tIsZero,        
+	TEven, tEven,
+	TOdd, tOdd,
+	TAdd, tAdd, tSub,
+	TMul, tMul,
+	TPow, tPow,
+	TAnd, TOr, TXOr, TImplies,
+	tAnd, tOr, tXOr, tImplies,
+	TShift, tShift,
+	TGetBit, tGetBit,
+	TSetBit, tSetBit,
+	TChangeBit, tChangeBit,
+	TUnSetBit, tUnSetBit,
+	TComplementBit, tComplementBit,
+	TCountBits, tCountBits,	
+	TNF, tNF,		-- put a number into normal form
+	t2n, t2np1,		-- prepend a 0 or 1
+	TEq, TLt, tEq, tLt,
+
+	-- from Type.Sign
+	Negative, Positive, SignZero,
+	-- internal interfaces below here
+	-- these require knowledge of the internal representation
+	TShift', 		-- non-normalizing shifter
+	TNF', 			-- case tracking normalizer for a number.
+	TAddC',  		-- non-normalizing full-adder
+	TAdd', tAdd',  		-- semi-adder
+	TSub', tSub',  		-- semi-sub
+	TCountBits',		-- sign-tracking intermediary for TCountBits
+	LSB, tLSB, tBSL,	-- extract the LSB and tail of a number
+	XI, XO			-- indicates that the number can be extended 
+				-- by a I or O without leaving normal form
+) where
+
+import Type.Boolean
+import Type.Ord
+import Type.Sign
+
+data O a
+data I a
+
+-- | Internal closure, not exposed
+data Closure
+class Closed a | -> a
+instance Closed Closure
+
+class (TBool d) => LSB a d a' | a -> d a', d a' -> a
+instance LSB F F F
+instance LSB T T T
+instance LSB (O T) F T
+instance LSB (I F) T F
+instance LSB (O (O n)) F (O n)
+instance LSB (O (I n)) F (I n)
+instance LSB (I (O n)) T (O n)
+instance LSB (I (I n)) T (I n)
+tLSB :: LSB a d a' => a -> d -> a'; tLSB = undefined
+tBSL :: LSB a d a' => a' -> d -> a; tBSL = undefined
+
+-- | extract the lsb and assert we aren't at the long tail
+class LSB a d a' => X a d a' | a -> d a', d a' -> a, a a' -> d
+instance (LSB (O a) F a) => X (O a) F a
+instance (LSB (I a) T a) => X (I a) T a
+
+-- | assert 2n != n
+class LSB (O a) F a => XO a
+instance (LSB (O a) F a) => XO a
+
+-- | assert 2n+1 != n
+class LSB (I a) T a => XI a
+instance (LSB (I a) T a) => XI a
+
+class TSucc n m | n -> m, m -> n
+instance TSucc T F
+instance TSucc F (I F)
+instance TSucc (O T) T
+instance TSucc (O (I n)) (I (I n))
+instance TSucc (O (O n)) (I (O n))
+instance (TSucc n m, XI n, XO m) => TSucc (I n) (O m)
+tSucc :: TSucc n m => n -> m
+tSucc = undefined
+tPred :: TSucc n m => m -> n
+tPred = undefined
+
+instance Show (O F) where show n = "({-error-} O F)";
+instance Show (I T) where show n = "({-error-} I T)";
+instance Show (I F) where show n = "I F";
+instance Show (O T) where show n = "O T";
+instance (Show (I t)) => Show (O (I t)) where show n = "O (" ++ show (undefined::I t) ++ ")"
+instance (Show (I t)) => Show (I (I t)) where show n = "I (" ++ show (undefined::I t) ++ ")" 
+instance (Show (O t)) => Show (O (O t)) where show n = "O (" ++ show (undefined::O t) ++ ")"
+instance (Show (O t)) => Show (I (O t)) where show n = "I (" ++ show (undefined::O t) ++ ")"
+
+class TCBinary c a | a -> c
+instance TCBinary Closure F
+instance TCBinary Closure T
+instance (TCBinary c a, XO a) => TCBinary c (O a)
+instance (TCBinary c a, XI a) => TCBinary c (I a)
+
+class TCBinary Closure a => TBinary a 		where fromTBinary :: Integral b => a -> b 
+instance TBinary F 				where fromTBinary _ = fromInteger 0
+instance TBinary T 				where fromTBinary _ = fromInteger (-1)
+instance (TBinary a, XO a) => TBinary (O a) 	where fromTBinary _ = let x = fromTBinary (undefined::a) in x+x
+instance (TBinary a, XI a) => TBinary (I a) 	where fromTBinary _ = let x = fromTBinary (undefined::a) in succ(x+x)
+
+instance (TNot a b) => TNot (O a) (I b)
+instance (TNot a b) => TNot (I a) (O b)
+
+instance TEq (I m) (O n) F 
+instance TEq (O m) (I n) F
+instance TEq (O m) F F
+instance TEq (O m) T F
+instance TEq (I m) T F
+instance TEq (I m) F F
+instance (TEq m n b) => TEq (I m) (I n) b
+instance (TEq m n b) => TEq (O m) (O n) b
+
+class TNeg a b | a -> b, b -> a
+instance (TNot a b, TSucc b c) => TNeg a c
+tNeg :: TNeg a b => a -> b; tNeg = undefined
+
+{-
+data Negative
+data SignZero
+data Positive
+
+class TCSign c a | a -> c
+instance TCSign Closure Negative
+instance TCSign Closure Positive
+instance TCSign Closure SignZero
+
+class TCSign Closure s => TIs s
+instance TIs Negative
+instance TIs SignZero
+instance TIs Positive
+
+instance TEq Negative Negative T
+instance TEq Negative SignZero F
+instance TEq Negative Positive F
+instance TEq SignZero Negative F
+instance TEq SignZero SignZero T
+instance TEq SignZero Positive F
+instance TEq Positive Negative F
+instance TEq Positive SignZero F
+instance TEq Positive Positive T
+-}
+class Trichotomy n s | n -> s
+instance Trichotomy T Negative
+instance Trichotomy F SignZero
+instance Trichotomy (I F) Positive
+instance Trichotomy (O T) Negative
+instance (Trichotomy a b, XI a) => Trichotomy (I (I a)) b
+instance (Trichotomy a b, XI a) => Trichotomy (O (I a)) b
+instance (Trichotomy a b, XO a) => Trichotomy (I (O a)) b
+instance (Trichotomy a b, XO a) => Trichotomy (O (O a)) b
+
+class TIsPositive n b | n -> b
+instance (Trichotomy n s, TEq s Positive b) => TIsPositive n b
+tIsPositive :: TIsPositive n b => n -> b; tIsPositive = undefined 
+
+class TIsNegative n b | n -> b
+instance (Trichotomy n s, TEq s Negative b) => TIsNegative n b
+tIsNegative :: TIsNegative n b => n -> b; tIsNegative = undefined
+
+class TIsZero n b | n -> b
+instance (Trichotomy n s, TEq s SignZero b) => TIsZero n b
+tIsZero :: TIsZero n b => n -> b; tIsZero = undefined 
+
+class TEven a b | a -> b
+instance LSB a b c => TEven a b
+tEven :: (TEven a b) => a -> b; tEven = undefined
+
+class TOdd a b | a -> b
+instance (LSB a b c, TNot b b') => TOdd a b'
+tOdd :: (TOdd a b) => a -> b; tOdd = undefined
+
+-- | nice adder with carry. does not yield normal form answers.
+class TAddC' a b c d | a b c -> d
+instance TAddC' F F F F 
+instance TAddC' T F T F
+instance TAddC' F T F T 
+instance TAddC' T T T T
+instance TAddC' T F F T
+instance TAddC' F T T F
+instance TAddC' F F T (I F) 
+instance TAddC' T T F (O T)
+instance TAddC' F (O a) F (O a) 
+instance TAddC' T (O a) T (O a)
+instance TAddC' F (I a) F (I a) 
+instance TAddC' T (I a) T (I a)
+instance TAddC' (O a) F F (O a) 
+instance TAddC' (O a) T T (O a)
+instance TAddC' (I a) F F (I a) 
+instance TAddC' (I a) T T (I a)
+instance TAddC' F (O a) T (I a) 
+instance TAddC' T (I a) F (O a)
+instance TAddC' (O a) F T (I a) 
+instance TAddC' (I a) T F (O a)
+instance TSucc a b => TAddC' F (I a) T (O b) 
+instance TSucc b a => TAddC' T (O a) F (I b)
+instance TSucc a b => TAddC' (I a) F T (O b) 
+instance TSucc b a => TAddC' (O a) T F (I b)
+instance TAddC' a b F c => TAddC' (O a) (O b) F (O c) 
+instance TAddC' a b F c => TAddC' (O a) (O b) T (I c)
+instance TAddC' a b F c => TAddC' (I a) (O b) F (I c) 
+instance TAddC' a b T c => TAddC' (I a) (O b) T (O c)
+instance TAddC' a b F c => TAddC' (O a) (I b) F (I c) 
+instance TAddC' a b T c => TAddC' (O a) (I b) T (O c)
+instance TAddC' a b T c => TAddC' (I a) (I b) F (O c) 
+instance TAddC' a b T c => TAddC' (I a) (I b) T (I c)
+
+class TNF' a b c | a -> b c
+instance TNF' F F F
+instance TNF' T T F
+instance TNF' (O F) F F
+instance TNF' (I T) T F
+instance TNF' (I F) (I F) T
+instance TNF' (O T) (O T) T
+instance (TNF' (O a) c b) => TNF' (I (O a)) (I c) T
+instance (TNF' (I a) c b) => TNF' (O (I a)) (O c) T
+instance (TNF' (I a) c b, TIf b (I c) T d) => TNF' (I (I a)) d b
+instance (TNF' (O a) c b, TIf b (O c) F d) => TNF' (O (O a)) d b
+
+instance (TBool d, TNeg b b', TAdd' a b' c, TIsNegative c d) => TLt a b d
+
+class TNF a b | a -> b
+instance TNF' a b c => TNF a b
+tNF   :: TNF a b => a -> b;     tNF = undefined
+t2n   :: TNF (O a) b => a -> b; t2n = undefined
+t2np1 :: TNF (I a) b => a -> b; t2np1 = undefined
+
+class TAdd' a b c | a b -> c
+instance (TAddC' a b F d, TNF d d') => TAdd' a b d'
+tAdd' :: (TAdd' a b c ) => a -> b -> c; tAdd' = undefined
+
+class TSub' a b c | a b -> c
+instance (TNeg b b', TAdd' a b' c) => TSub' a b c
+tSub' :: TSub' a b c => a -> b -> c; tSub' = undefined
+
+-- reversible addition and subtraction, not the default for efficiency reasons.
+class TAdd a b c | a b -> c, a c -> b, b c -> a
+instance (TAdd' a b c, TNeg b b', TAdd' c b' a, TNeg a a', TAdd' c a' b) => TAdd a b c
+tAdd :: (TAdd a b c) => a -> b -> c;tAdd = undefined
+tSub :: (TAdd a b c) => c -> a -> b;tSub = undefined
+
+class TMul a b c | a b -> c
+instance TMul a F F
+instance TNeg a b => TMul a T b
+instance (TMul (O a) b c) => TMul a (O b) c
+instance (TMul (O a) b c, TAdd' a c d) => TMul a (I b) d
+tMul :: TMul a b c => a -> b -> c
+tMul = undefined
+
+-- | for non-negative exponents
+class TPow a b c | a b -> c
+instance TPow a F (I F)
+instance (TPow a k c, TMul c c d) => TPow a (O k) d
+instance (TPow a k c, TMul c c d, TMul a d e) => TPow a (I k) e
+tPow :: TPow a b c => a -> b -> c
+tPow = undefined
+
+instance TAnd F (I b) F
+instance TAnd F (O b) F
+instance TAnd (I a) F F
+instance TAnd (O a) F F
+instance TAnd T (I b) (I b)
+instance TAnd T (O b) (O b)
+instance TAnd (I a) T (I a)
+instance TAnd (O a) T (O a)
+instance (TAnd a b c, TNF (I c) c') => TAnd (I a) (I b) c'
+instance (TAnd a b c, TNF (O c) c') => TAnd (O a) (I b) c'
+instance (TAnd a b c, TNF (O c) c') => TAnd (I a) (O b) c'
+instance (TAnd a b c, TNF (O c) c') => TAnd (O a) (O b) c'
+
+instance TOr F (I b) (I b)
+instance TOr F (O b) (O b)
+instance TOr (I a) F (I a)
+instance TOr (O a) F (I a)
+instance TOr T (I b) T
+instance TOr T (O b) T
+instance TOr (I a) T T
+instance TOr (O a) T T 
+instance (TOr a b c, TNF (I c) c') => TOr (I a) (I b) c'
+instance (TOr a b c, TNF (I c) c') => TOr (O a) (I b) c'
+instance (TOr a b c, TNF (I c) c') => TOr (I a) (O b) c'
+instance (TOr a b c, TNF (O c) c') => TOr (O a) (O b) c'
+
+instance TXOr' F (I b) (I b)
+instance TXOr' F (O b) (O b)
+instance TXOr' (I b) F (I b)
+instance TXOr' (O b) F (O b)
+instance TNot b c => TXOr' T (I b) (O c)
+instance TNot b c => TXOr' T (O b) (I c)
+instance TNot b c => TXOr' (I b) T (O c)
+instance TNot b c => TXOr' (O b) T (I c)
+instance (TXOr' a b c, TNF (O c) c') => TXOr' (I a) (I b) c'
+instance (TXOr' a b c, TNF (I c) c') => TXOr' (I a) (O b) c'
+instance (TXOr' a b c, TNF (I c) c') => TXOr' (O a) (I b) c'
+instance (TXOr' a b c, TNF (O c) c') => TXOr' (O a) (O b) c'
+
+instance TImplies F (I b) T
+instance TImplies F (O b) T
+instance TImplies (I a) F T
+instance TImplies (O a) F T
+instance TImplies T (I b) (I b)
+instance TImplies T (O b) (O b)
+instance TImplies (I a) T (I a)
+instance TImplies (O a) T (O a)
+instance (TImplies a b c, TNF (I c) c') => TImplies (I a) (I b) c'
+instance (TImplies a b c, TNF (I c) c') => TImplies (O a) (I b) c'
+instance (TImplies a b c, TNF (I c) c') => TImplies (I a) (O b) c'
+instance (TImplies a b c, TNF (O c) c') => TImplies (O a) (O b) c'
+
+class TShift' a b c | a b -> c
+instance TShift' F F F
+instance TShift' T F T
+instance TShift' (I a) F (I a)
+instance TShift' (O a) F (O a)
+instance TShift' (I a) T a
+instance TShift' (O a) T a
+instance TShift' F T F
+instance TShift' T T T
+instance (TShift' a b c, TShift' c b d) => TShift' a (O b) d
+instance (TShift' a b c, TShift' c b d) => TShift' a (I b) (O d)
+
+class TShift a b c' | a b -> c'
+instance (TShift' a b c, TNF c c') => TShift a b c'
+tShift :: TShift a b c => a -> b -> c
+tShift = undefined
+
+-- | get bit #b in a as c in {T,F}
+class TGetBit a b c | a b -> c
+instance (TNeg b b', TShift a b' c, LSB c d e) => TGetBit a b d
+tGetBit :: TGetBit a b c => a -> b -> c
+tGetBit = undefined
+
+-- | set bit #b in a to c in {T,F}, yielding d.
+class TSetBit a b c | a b -> c
+instance (TShift (I F) b c, TOr a c d) => TSetBit a b d
+tSetBit :: TSetBit a b c => a -> b -> c
+tSetBit = undefined
+
+class TUnSetBit a b c | a b -> c
+instance (TShift (O T) b c, TAnd a c d) => TUnSetBit a b d
+tUnSetBit :: TUnSetBit a b c => a -> b -> c
+tUnSetBit = undefined
+
+class TChangeBit a b c d | a b c -> d
+instance (TSetBit a b d, TUnSetBit a b e, TIf c d e f) => TChangeBit a b c f
+tChangeBit :: TChangeBit a b c d => a -> b -> c -> d
+tChangeBit = undefined
+
+-- | toggle the value of bit #b in a, yielding c
+class TComplementBit a b c | a b -> c 
+instance (TShift (I F) b c, TXOr' a c d) => TComplementBit a b d
+tComplementBit :: TComplementBit a b c => a -> b -> c
+tComplementBit = undefined
+
+class TCountBits' a b t | a t -> b
+instance TCountBits' T T T
+instance TCountBits' F F F
+instance TCountBits' a n F => TCountBits' (O a) n F
+instance TCountBits' a m F => TCountBits' (I a) m T
+instance (TCountBits' a n F,TSucc n m) => TCountBits' (I a) m F
+instance (TCountBits' a n F,TSucc m n) => TCountBits' (O a) n T
+
+-- | If infinite tail is all 1s, it counts 0 bits, and returns that as a negative number.
+class TCountBits a b | a -> b
+instance (TIsNegative a t, TCountBits' a b t) => TCountBits a b
+tCountBits :: TCountBits a b => a -> b; tCountBits = undefined
addfile ./src/Type/Binary/Names.hs
hunk ./src/Type/Binary/Names.hs 1
+module Type.Binary.Names (
+	neg_two, neg_one, zero, one, two, three, four, five, six, seven, eight, nine, ten,
+	eleven, twelve, thirteen, fourteen, fifteen, sixteen, seventeen, eighteen, nineteen,
+	twenty, thirty, forty, fifty, sixty, seventy, eighty, ninety, hundred,
+	twenty_, thirty_, forty_, fifty_, sixty_, seventy_, eighty_, ninety_
+) where
+import Type.Binary.Internals
+import Type.Boolean
+
+neg_two  = undefined :: O T
+neg_one	 = undefined :: T
+zero 	 = undefined :: F
+one 	 = undefined :: I F
+two 	 = undefined :: O(I F)
+three	 = undefined :: I(I F)
+four 	 = undefined :: O(O(I F))
+five     = undefined :: I(O(I F))
+six  	 = undefined :: O(I(I F))
+seven 	 = undefined :: I(I(I F))
+eight    = undefined :: O(O(O(I F)))
+nine     = undefined :: I(O(O(I F)))
+ten      = undefined :: O(I(O(I F)))
+eleven   = undefined :: I(I(O(I F)))
+twelve   = undefined :: O(O(I(I F)))
+thirteen = undefined :: I(O(I(I F)))
+fourteen = undefined :: O(O(I(I F)))
+fifteen  = undefined :: I(O(I(I F)))
+sixteen  = undefined :: O(O(O(O(I F))))
+seventeen= undefined :: I(O(O(O(I F))))
+eighteen = undefined :: O(I(O(O(I F))))
+nineteen = undefined :: I(I(O(O(I F))))
+twenty  :: TAdd (O(O(I(O(I F))))) b c => b -> c;	    twenty  = undefined; twenty_ = twenty zero
+thirty  :: TAdd (O(I(I(I(I F))))) b c => b -> c;	    thirty  = undefined; thirty_ = thirty zero
+forty   :: TAdd (O(O(O(I(O(I F)))))) b c => b -> c; 	    forty   = undefined; forty_ = forty zero
+fifty   :: TAdd (O(I(O(O(I(I F)))))) b c => b -> c; 	    fifty   = undefined; fifty_ = fifty zero
+sixty   :: TAdd (O(O(I(I(I(I F)))))) b c => b -> c; 	    sixty   = undefined; sixty_ = sixty zero
+seventy :: TAdd (O(I(I(O(O(O(I F))))))) b c => b -> c;      seventy = undefined; seventy_ = seventy zero
+eighty  :: TAdd (O(O(O(O(I(O(I F))))))) b c => b -> c;      eighty  = undefined; eighty_ = eighty zero
+ninety  :: TAdd (O(I(O(I(I(O(I F))))))) b c => b -> c;      ninety  = undefined; ninety_ = ninety zero
+hundred :: (TAdd a' b c, TMul a (O(O(I(O(O(I(I F))))))) a') => a -> b -> c
+hundred = undefined;
hunk ./src/Type/Binary/TH.hs 16
-module Type.Binary.TH (
-	binaryE, binaryT
-) where
+module Type.Binary.TH ( binaryE, binaryT ) where
hunk ./src/Type/Binary/TH.hs 18
-import Type.Binary
+import Type.Binary.Internals
hunk ./src/Type/Binary/TH.hs 26
+-- | $(binaryT n) returns the appropriate TBinary instance
hunk ./src/Type/Binary/TH.hs 33
+-- | $(binaryE n) returns an undefined value of the appropriate TBinary instance
hunk ./src/Type/Boolean.hs 6
--- License     :  BSD-style (see the file libraries/base/LICENSE)
+-- License     :  BSD-style (see the file LICENSE)
hunk ./src/Type/Boolean.hs 19
-    TAnd, TOr, TNot, TXOr, TImplies, TIf,
-    tAnd, tOr, tNot, tXOr, tImplies, tIf
+    TAnd, TOr, TNot, TXOr, TXOr', TImplies, TIf,
+    tAnd, tOr, tNot, tXOr, tXOr', tImplies, tIf,
hunk ./src/Type/Boolean.hs 64
-class TXOr a b c | a b -> c, a c -> b, b c -> a
-instance TXOr F F F
-instance TXOr F T T
-instance TXOr T F T
-instance TXOr T T F
+class TXOr' a b c | a b -> c
+instance TXOr' F F F
+instance TXOr' F T T
+instance TXOr' T F T
+instance TXOr' T T F
+tXOr' :: TXOr' a b c => a -> b -> c
+tXOr' = undefined
+
+
+-- | implemented this way rather than directly so that Binary can extend it properly.
+-- otherwise the normal form restriction makes that nigh impossible.
+class (TXOr' a b c, TXOr' b c a, TXOr' c a b) => TXOr a b c | a b -> c, a c -> b, b c -> a
+instance (TXOr' a b c, TXOr' b c a, TXOr' c a b) => TXOr a b c 
addfile ./src/Type/Hex.hs
hunk ./src/Type/Hex.hs 1
+{-# GHC_OPTIONS -fglasgow-exts #-}
+{-# GHC_OPTIONS -fth #-}
+{-# GHC_OPTIONS -fallow-undecidable-instances #-}
+-----------------------------------------------------------------------------
+-- |
+-- Module      :  Type.Hex
+-- Copyright   :  (C) 2006 Edward Kmett
+-- License     :  BSD-style (see the file libraries/base/LICENSE)
+--
+-- Maintainer  :  Edward Kmett <ekmett@gmail.com>
+-- Stability   :  experimental
+-- Portability :  non-portable (MPTC, FD, TH, undecidable instances, missing constructors)
+--
+-- Type-level hexadecimal numbers, positive and negative with infinite 
+-- precision. Should work out to about 2^72 without changing the default
+-- context length limit in GHC.
+--
+-- TODO: TDivMod, TImplies, TGCD, T*Bit, and the boolean operators
+----------------------------------------------------------------------------
+
+module Type.Hex (
+	THex, fromTHex,		   	   -- Infinite precision binary
+	TIsZero, TIsPositive, TIsNegative, -- Trichotomy
+	tIsZero, tIsPositive, tIsNegative,
+	LSN, tLSN, 
+	TNeg, tNeg,
+	TSucc, tSucc, tPred,
+	TAdd, tAdd, tSub,
+	TMul, tMul,
+	TPow, tPow,
+--	TShift, tShift,
+	TNF, tNF,
+	THexBinary,
+
+--	TGetBit, tGetBit,
+--	TSetBit, tSetBit,
+--	TUnSetBit, tUnSetBit,
+--	TChangeBit, tChangeBit,
+--	TComplementBit, tComplementBit,
+--	TCountBits, tCountBits,
+	-- re-exported from Type.Boolean
+	T, F,
+--	TNot, tNot,
+--	TAnd, tAnd,
+--	TOr, tOr,
+--	TXOr, tXOr,
+--	TImplies, tImplies,
+	-- re-exported from Type.Ord
+	TEq, tEq,
+	TLt, tLt,
+	TLe, tLe,
+	TGt, tGt,
+	TGe, tGe,
+	-- re-exported from Type.Hex.Stage*
+	hexE,
+	hexT
+) where
+
+import Type.Boolean
+import Type.Ord
+import Type.Hex.Stage1
+import Type.Hex.Stage2
+import Type.Hex.Stage3
addfile ./src/Type/Hex/Stage1.hs
hunk ./src/Type/Hex/Stage1.hs 1
+{-# GHC_OPTIONS -fglasgow-exts #-}
+{-# GHC_OPTIONS -fth #-}
+module Type.Hex.Stage1 where
+
+import Type.Boolean
+import Type.Sign
+import Control.Monad
+import Language.Haskell.TH
+
+t = conT $ mkName "T"
+f = conT $ mkName "F"
+
+hex = "0123456789ABCDEF"
+
+xn = map (\x -> mkName $ "D"++return x) hex 
+hn = map (\x -> mkName $ "H"++return x) hex 
+
+x = map conT xn
+h = map conT hn
+xh = zip x h
+
+x0 = tail x
+h0 = tail h
+xh0 = tail xh
+
+xF = init x
+hF = init h
+xhF = zip xF hF
+
+x0F = tail xF
+
+a = mkName "a"; va = varT a
+b = mkName "b"; vb = varT b
+c = mkName "c"; vc = varT c
+d = mkName "d"; vd = varT d
+
+mkXT :: Name -> DecQ
+mkXT n = return $ DataD [] n [a] [] []
+
+mkHT :: Name -> DecQ
+mkHT n = return $ DataD [] n [] [] []
+
+-- imports
+tnot = conT $ mkName "TNot"
+positive = conT $ mkName "Positive"
+negative = conT $ mkName "Negative"
+signzero = conT $ mkName "SignZero"
+
+-- to be fleshed out when available
+class LSN a d a' | a -> d a', d a' -> a
+lsn = conT $ mkName "LSN"
+class Trichotomy n s | n -> s
+trichotomy = conT $ mkName "Trichotomy"
+class TEven a b | a -> b
+teven = conT $ mkName "TEven"
+class TSucc n m | n -> m, m -> n
+tsucc = conT $ mkName "TSucc"
+class TAddC' a b c d | a b c -> d
+taddc' = conT $ mkName "TAddC'"
+class TNF' a b c | a -> b c
+tnf' = conT $ mkName "TNF'"
+class THex a where fromTHex :: Integral b => a -> b
+thex = conT $ mkName "THex"
+class SHR1 a b c | a b -> c
+shr1 = conT $ mkName "SHR1"
+
+
+wrapMI list f = (flip mapM) list $ \v -> do
+	i <- f v
+	return $ InstanceD [] i []
+
+concatMapM f = liftM concat . mapM f
addfile ./src/Type/Hex/Stage2.hs
hunk ./src/Type/Hex/Stage2.hs 1
+{-# GHC_OPTIONS -fglasgow-exts #-}
+{-# GHC_OPTIONS -fth #-}
+{-# GHC_OPTIONS -fallow-undecidable-instances #-}
+{-# GHC_OPTIONS -cpp #-}
+module Type.Hex.Stage2 where
+
+import Type.Boolean
+import Control.Monad
+import Type.Hex.Stage1
+import Language.Haskell.TH
+
+#ifndef __HADDOCK__
+$(mapM mkXT xn)
+$(mapM mkHT hn)
+#endif
+
+-- for testing purposes only, not used in code
+d0 :: a -> D0 a; d0 = undefined
+d1 :: a -> D1 a; d1 = undefined
+d2 :: a -> D2 a; d2 = undefined
+d3 :: a -> D3 a; d3 = undefined
+d4 :: a -> D4 a; d4 = undefined
+d5 :: a -> D5 a; d5 = undefined
+d6 :: a -> D6 a; d6 = undefined
+d7 :: a -> D7 a; d7 = undefined
+d8 :: a -> D8 a; d8 = undefined
+d9 :: a -> D9 a; d9 = undefined
+dA :: a -> DA a; dA = undefined
+dB :: a -> DB a; dB = undefined
+dC :: a -> DC a; dC = undefined
+dD :: a -> DD a; dD = undefined
+dE :: a -> DE a; dE = undefined
+dF :: a -> DF a; dF = undefined
+
+-- | extract the least signficant nybble from a hex number
+instance LSN F H0 F
+instance LSN T HF T
+#ifndef __HADDOCK__
+$( wrapMI xhF $ \(x,h) -> lsn `appT` (appT x t) `appT` h `appT` t)
+$( wrapMI xh0 $ \(x,h) -> lsn `appT` (appT x f) `appT` h `appT` f)
+$( wrapMI (liftM2 (,) xh x) $ \((x,h),x') -> let axa = appT x' va in lsn `appT` (appT x axa) `appT` h `appT` axa)
+#endif
+tLSN :: LSN a d a' => a -> (d,a'); tLSN = undefined
+tNSL :: LSN a d a' => a' -> d -> a; tNSL = undefined
+
+class LSN (D0 a) H0 a => Ext0 a
+instance LSN (D0 a) H0 a => Ext0 a
+class LSN (DF a) HF a => ExtF a
+instance LSN (DF a) HF a => ExtF a
+
+instance THex F                              where fromTHex _ = fromInteger 0
+instance THex T                              where fromTHex _ = fromInteger (-1)
+instance (THex a, Ext0 a) => THex (D0 a)     where fromTHex _ = let x = fromTHex (undefined::a) in 16*x
+instance THex a => THex (D1 a) where fromTHex _ = let x = fromTHex (undefined::a) in 16*x+1
+instance THex a => THex (D2 a) where fromTHex _ = let x = fromTHex (undefined::a) in 16*x+2
+instance THex a => THex (D3 a) where fromTHex _ = let x = fromTHex (undefined::a) in 16*x+3
+instance THex a => THex (D4 a) where fromTHex _ = let x = fromTHex (undefined::a) in 16*x+4
+instance THex a => THex (D5 a) where fromTHex _ = let x = fromTHex (undefined::a) in 16*x+5
+instance THex a => THex (D6 a) where fromTHex _ = let x = fromTHex (undefined::a) in 16*x+6
+instance THex a => THex (D7 a) where fromTHex _ = let x = fromTHex (undefined::a) in 16*x+7
+instance THex a => THex (D8 a) where fromTHex _ = let x = fromTHex (undefined::a) in 16*x+8
+instance THex a => THex (D9 a) where fromTHex _ = let x = fromTHex (undefined::a) in 16*x+9
+instance THex a => THex (DA a) where fromTHex _ = let x = fromTHex (undefined::a) in 16*x+10
+instance THex a => THex (DB a) where fromTHex _ = let x = fromTHex (undefined::a) in 16*x+11
+instance THex a => THex (DC a) where fromTHex _ = let x = fromTHex (undefined::a) in 16*x+12
+instance THex a => THex (DD a) where fromTHex _ = let x = fromTHex (undefined::a) in 16*x+13
+instance THex a => THex (DE a) where fromTHex _ = let x = fromTHex (undefined::a) in 16*x+14
+instance (THex a, ExtF a) => THex (DF a)     where fromTHex _ = let x = fromTHex(undefined::a) in 16*x+15
+
+
+instance TEven F T
+instance TEven T F 
+#ifndef __HADDOCK__
+$( wrapMI (zip x [0..15]) $ \(x,n) -> teven `appT` (appT x va) `appT` (if n `mod` 2 == 0 then t else f) )
+
+$( mapM (\(x,y) -> do
+	c <- tnot `appT` va `appT` vb
+	i <- tnot `appT` (appT x va) `appT` (appT y vb)
+	return $ InstanceD [c] i []) $ zip x (reverse x))
+#endif
+
+class TOdd a b' 
+instance (TEven a b, TNot b b') => TOdd a b'
+
+instance TNF' F F F
+instance TNF' T T F
+instance TNF' (D0 F) F F
+instance TNF' (DF T) T F
+instance (TNF' (DF a) c b, TIf b (DF c) T d) => TNF' (DF (DF a)) d b
+instance (TNF' (D0 a) c b, TIf b (D0 c) F d) => TNF' (D0 (D0 a)) d b
+#ifndef __HADDOCK__
+$( wrapMI x0 $ \x -> tnf' `appT` (appT x f) `appT` (appT x f) `appT` t)
+$( wrapMI xF $ \x -> tnf' `appT` (appT x t) `appT` (appT x t) `appT` t)
+$( let xn = zip x [0..15]
+       xn2 = liftM2 (,) xn xn
+       list' = (flip filter) xn2 $ \((_,n),(_,m)) -> if n == 0 then m /= 0 else (if n == 15 then m /= 15 else True)
+       list = map (\((x,_),(y,_)) -> (x,y)) list'
+   in (flip mapM) list $ \(x,y) -> do
+	pre <- tnf' `appT` (appT x va) `appT` vc `appT` vb
+	post <- tnf' `appT` (appT y (appT x va)) `appT` (appT y vc) `appT` vb
+	return $ InstanceD [pre] post [])
+#endif
addfile ./src/Type/Hex/Stage3.hs
hunk ./src/Type/Hex/Stage3.hs 1
+{-# GHC_OPTIONS -fglasgow-exts #-}
+{-# GHC_OPTIONS -fth #-}
+module Type.Hex.Stage3 where
+
+import Type.Boolean
+import Control.Monad
+import Type.Hex.Stage1
+import Type.Hex.Stage2
+import Type.Sign
+import Type.Ord
+import Data.Bits
+import Language.Haskell.TH
+import qualified Type.Binary as B
+
+instance TSucc T F
+instance TSucc F (D1 F)
+instance TSucc (DE T) T
+instance (TSucc n m, ExtF n, Ext0 m) => TSucc (DF n) (D0 m)
+#ifndef __HADDOCK__
+$( wrapMI (zip (init x0) (tail x0)) $ \(x1,x2) -> tsucc `appT` (appT x1 f) `appT` (appT x2 f))
+$( wrapMI (zip (init xF) (tail xF)) $ \(x1,x2) -> tsucc `appT` (appT x1 t) `appT` (appT x2 t))
+$( wrapMI (liftM2 (,) (zip xF x0) x) $ \((xn,xm),x) -> let b = appT x va in 
+	tsucc `appT` (appT xn b) `appT` (appT xm b))
+#endif
+tSucc :: TSucc n m => n -> m; tSucc = undefined
+tPred :: TSucc n m => m -> n; tPred = undefined
+
+class TNeg a b | a -> b, b -> a
+instance (TNot a b, TSucc b c) => TNeg a c
+tNeg :: TNeg a b => a -> b; tNeg = undefined
+
+--class Trichotomy n s | n -> s
+instance Trichotomy T Negative
+instance Trichotomy F SignZero
+#ifndef __HADDOCK__
+$( wrapMI x0 $ \x -> trichotomy `appT` (appT x f) `appT` positive )
+$( wrapMI xF $ \x -> trichotomy `appT` (appT x t) `appT` negative )
+$( let eda = [(appT extf va,appT tf va),(appT ext0 va, appT tf va)]
+       ext0 = conT $ mkName "Ext0"
+       extf = conT $ mkName "ExtF"
+       tf = conT $ mkName "DF"
+       t0 = conT $ mkName "D0" in
+   (flip mapM) (zip x eda) $ \(x,(ea,da)) -> do
+	tc <- trichotomy `appT` va `appT` vb
+	i <- trichotomy `appT` (appT x da) `appT` vb
+	eq <- ea
+	return $ InstanceD [tc,eq] i [])
+#endif
+
+class TIsPositive n b | n -> b
+instance (Trichotomy n s, TEq s Positive b) => TIsPositive n b
+tIsPositive :: TIsPositive n b => n -> b; tIsPositive = undefined
+
+class TIsNegative n b | n -> b
+instance (Trichotomy n s, TEq s Negative b) => TIsNegative n b
+tIsNegative :: TIsNegative n b => n -> b; tIsNegative = undefined
+
+class TIsZero n b | n -> b
+instance (Trichotomy n s, TEq s SignZero b) => TIsZero n b
+tIsZero :: TIsZero n b => n -> b; tIsZero = undefined
+
+-- output several hundred instances for a full hex adder
+instance TAddC' F F F F
+instance TAddC' T F T F
+instance TAddC' F T F T
+instance TAddC' T T T T
+instance TAddC' T F F T
+instance TAddC' F T T F
+instance TAddC' F F T (D1 F)
+instance TAddC' T T F (DE T)
+instance TSucc a b => TAddC' F (DF a) T (D0 b)
+instance TSucc b a => TAddC' T (D0 a) F (DF b)
+instance TSucc a b => TAddC' (DF a) F T (D0 b)
+instance TSucc b a => TAddC' (D0 a) T F (DF b)
+#ifndef __HADDOCK__
+$( wrapMI (liftM2 (,) [t,f] x) $ \(tf,dx) -> let dxa = appT dx va in
+	taddc' `appT` tf `appT` dxa `appT` tf `appT` dxa)
+$( wrapMI (liftM2 (,) [t,f] x) $ \(tf,dx) -> let dxa = appT dx va in
+	taddc' `appT` dxa `appT` tf `appT` tf `appT` dxa)
+$( wrapMI (zip xF x0) $ \(dn,dm) -> taddc' `appT` f `appT` (appT dn va) `appT` t `appT` (appT dm va))
+$( wrapMI (zip xF x0) $ \(dn,dm) -> taddc' `appT` t `appT` (appT dm va) `appT` f `appT` (appT dn va))
+$( wrapMI (zip xF x0) $ \(dn,dm) -> taddc' `appT` (appT dn va) `appT` f `appT` t `appT` (appT dm va))
+$( wrapMI (zip xF x0) $ \(dn,dm) -> taddc' `appT` (appT dm va) `appT` t `appT` f `appT` (appT dn va))
+$( (flip mapM) (liftM3 (,,) (zip x [0..15]) (zip x [0..15]) [(f,0),(t,1)]) $ \((x0,n0),(x1,n1),(b,c)) -> do
+	let total = n0+n1+c
+	    pcarry = if total > 15 then t else f
+	    x2 = x !! (total `mod` 16)
+	pre <- taddc' `appT` va `appT` vb `appT` pcarry `appT` vc 
+	post <- taddc' `appT` (appT x0 va) `appT` (appT x1 vb) `appT` b `appT` (appT x2 vc)
+	return $ InstanceD [pre] post [])
+#endif
+tAddC' :: TAddC' a b c d => a -> b -> c -> d; tAddC' = undefined
+tAddF' :: TAddC' a b F d => a -> b -> d; tAddF' = undefined
+
+class TNF a b | a -> b
+instance TNF' a b c => TNF a b
+tNF   :: TNF a b => a -> b;     tNF = undefined
+
+class TAdd' a b c | a b -> c
+instance (TAddC' a b F d, TNF d d') => TAdd' a b d'
+tAdd' :: (TAdd' a b c ) => a -> b -> c; tAdd' = undefined
+
+class TSub' a b c | a b -> c
+instance (TNeg b b', TAdd' a b' c) => TSub' a b c
+tSub' :: TSub' a b c => a -> b -> c; tSub' = undefined
+
+-- reversible addition and subtraction
+class TAdd a b c | a b -> c, a c -> b, b c -> a
+instance (TAdd' a b c, TNeg b b', TAdd' c b' a, TNeg a a', TAdd' c a' b) => TAdd a b c
+tAdd :: (TAdd a b c) => a -> b -> c;tAdd = undefined
+tSub :: (TAdd a b c) => c -> a -> b;tSub = undefined
+
+-- | $(hexT n) returns the appropriate THex instance
+hexT :: Integral a => a -> TypeQ
+hexT n = case n of
+    0  -> f
+    -1 -> t
+    n  -> appT (x !! mod (fromIntegral n) 16) $ hexT $ n `div` 16
+
+-- | $(hexE n) returns an undefined value of the appropriate THex instance
+hexE :: Integral a => a -> ExpQ
+hexE n = sigE (varE $ mkName "undefined") $ hexT n
+
+instance THex (D0 a) => Show (D0 a) where show n = "$(hexE "++ (show $ fromTHex n)++")"
+instance THex (D1 a) => Show (D1 a) where show n = "$(hexE "++ (show $ fromTHex n)++")"
+instance THex (D2 a) => Show (D2 a) where show n = "$(hexE "++ (show $ fromTHex n)++")"
+instance THex (D3 a) => Show (D3 a) where show n = "$(hexE "++ (show $ fromTHex n)++")"
+instance THex (D4 a) => Show (D4 a) where show n = "$(hexE "++ (show $ fromTHex n)++")"
+instance THex (D5 a) => Show (D5 a) where show n = "$(hexE "++ (show $ fromTHex n)++")"
+instance THex (D6 a) => Show (D6 a) where show n = "$(hexE "++ (show $ fromTHex n)++")"
+instance THex (D7 a) => Show (D7 a) where show n = "$(hexE "++ (show $ fromTHex n)++")"
+instance THex (D8 a) => Show (D8 a) where show n = "$(hexE "++ (show $ fromTHex n)++")"
+instance THex (D9 a) => Show (D9 a) where show n = "$(hexE "++ (show $ fromTHex n)++")"
+instance THex (DA a) => Show (DA a) where show n = "$(hexE "++ (show $ fromTHex n)++")"
+instance THex (DB a) => Show (DB a) where show n = "$(hexE "++ (show $ fromTHex n)++")"
+instance THex (DC a) => Show (DC a) where show n = "$(hexE "++ (show $ fromTHex n)++")"
+instance THex (DD a) => Show (DD a) where show n = "$(hexE "++ (show $ fromTHex n)++")"
+instance THex (DE a) => Show (DE a) where show n = "$(hexE "++ (show $ fromTHex n)++")"
+instance THex (DF a) => Show (DF a) where show n = "$(hexE "++ (show $ fromTHex n)++")"
+
+
+instance SHR1 H0 F F
+instance SHR1 H1 F (D1 F)
+instance SHR1 H0 T (DE T)
+instance SHR1 H1 T (DE T)
+#ifndef __HADDOCK__
+$( wrapMI (liftM3 (,,) (zip x [0..15]) (zip h [0..1]) (zip [t,f] [15,0])) $ \((d,dn),(c,cn),(tf,tfn)) ->
+        let dlsn = x !! ((dn*2+cn) `mod` 16)
+            dmsn = x !! (((dn `div` 8) + tfn*2) `mod` 16)
+            nmsn = dn `div` 8
+            dcase = if ((tfn .&. 1) `xor` nmsn) /= 0 then appT dmsn tf else tf
+        in shr1 `appT` c `appT` (appT d tf) `appT` (appT dlsn dcase))
+$( 
+        (flip mapM) (liftM3 (,,) (zip x [0..15]) (zip h [0..1]) (zip x [0..15])) $ \((dm,dmi),(c,cn),(dn,dni)) -> do
+        let msb_m = dmi `div` 8
+            dn' = x !! ((msb_m + (dni*2)) `mod` 16)
+            dm' = x !! ((cn + (dmi*2)) `mod` 16)
+            pre_c = h !! msb_m
+            dna = appT dn va
+            dn'b = appT dn' vb
+        pre <- shr1 `appT` pre_c `appT` dna `appT` dn'b
+        post <- shr1 `appT` c `appT` (appT dm dna) `appT` (appT dm' dn'b)
+        return $ InstanceD [pre] post [])
+#endif
+
+-- | A simple peasant multiplier
+class TMul a b c | a b -> c
+instance TMul a F F 
+instance TNeg a b => TMul a T b
+instance TMul (D0 a1) b c => TMul a1 (D0 b) c
+instance ( TMul (D0 a1) b c
+	 , TAdd' a1 c d) => TMul a1 (D1 b) d
+instance ( TMul (D0 a1) b c
+	 , SHR1 H0 a1 a2
+	 , TAdd' a2 c d) => TMul a1 (D2 b) d
+instance ( TMul (D0 a1) b c
+	 , SHR1 H0 a1 a2
+	 , TAdd' a1 a2 a3
+	 , TAdd' a3 c d) => TMul a1 (D3 b) d
+instance ( TMul (D0 a1) b c
+	 , SHR1 H0 a1 a2
+	 , SHR1 H0 a2 a4
+	 , TAdd' a4 c d) => TMul a1 (D4 b) d
+instance ( TMul (D0 a1) b c
+	 , SHR1 H0 a1 a2
+	 , SHR1 H0 a2 a4
+	 , TAdd' a1 a4 a5
+	 , TAdd' a5 c d) => TMul a1 (D5 b) d
+instance ( TMul (D0 a1) b c
+	 , SHR1 H0 a1 a2
+	 , SHR1 H0 a2 a4
+	 , TAdd' a2 a4 a6
+	 , TAdd' a6 c d) => TMul a1 (D6 b) d
+instance ( TMul (D0 a1) b c
+	 , SHR1 H0 a1 a2
+	 , SHR1 H0 a2 a4
+	 , TAdd' a2 a4 a6
+	 , TAdd' a1 a6 a7
+	 , TAdd' a7 c d) => TMul a1 (D7 b) d
+instance ( TMul (D0 a1) b c
+	 , SHR1 H0 a1 a2
+	 , SHR1 H0 a2 a4
+	 , SHR1 H0 a4 a8
+	 , TAdd' a8 c d) => TMul a1 (D8 b) d
+instance ( TMul (D0 a1) b c
+	 , SHR1 H0 a1 a2
+	 , SHR1 H0 a2 a4
+	 , SHR1 H0 a4 a8
+	 , TAdd' a1 a8 a9
+	 , TAdd' a9 c d) => TMul a1 (D9 b) d
+instance ( TMul (D0 a1) b c
+	 , SHR1 H0 a1 a2
+	 , SHR1 H0 a2 a4
+	 , SHR1 H0 a4 a8
+	 , TAdd' a2 a8 aA
+	 , TAdd' aA c d) => TMul a1 (DA b) d
+instance ( TMul (D0 a1) b c
+	 , SHR1 H0 a1 a2
+	 , SHR1 H0 a2 a4
+	 , SHR1 H0 a4 a8
+	 , TAdd' a2 a8 a0 
+	 , TAdd' a1 a0 aB
+	 , TAdd' aB c d) => TMul a1 (DB b) d
+instance ( TMul (D0 a1) b c
+	 , SHR1 H0 a1 a2
+	 , SHR1 H0 a2 a4
+	 , SHR1 H0 a4 a8
+	 , TAdd' a4 a8 aC
+	 , TAdd' aC c d) => TMul a1 (DC b) d
+instance ( TMul (D0 a1) b c
+	 , SHR1 H0 a1 a2
+	 , SHR1 H0 a2 a4
+	 , SHR1 H0 a4 a8
+	 , TAdd' a4 a8 aC
+	 , TAdd' a1 aC aD
+	 , TAdd' aD c d) => TMul a1 (DD b) d
+instance ( TMul (D0 a1) b c
+	 , SHR1 H0 a1 a2
+	 , SHR1 H0 a2 a4
+	 , SHR1 H0 a4 a8
+	 , TAdd' a4 a8 aC
+	 , TAdd' a2 aC aE
+	 , TAdd' aE c d) => TMul a1 (DE b) d
+instance ( TMul (D0 a1) b c
+	 , SHR1 H0 a1 a2
+	 , SHR1 H0 a2 a4
+	 , SHR1 H0 a4 a8
+	 , TAdd' a4 a8 aC
+	 , TAdd' a2 aC aE
+	 , TAdd' a1 aE aF
+	 , TAdd' aF c d) => TMul a1 (DF b) d
+
+tMul :: TMul a b c => a -> b -> c
+tMul = undefined
+
+-- doesn't normalize
+class THex2Binary' a b | a -> b, b -> a
+instance THex2Binary' F F 
+instance THex2Binary' T T
+instance THex2Binary' a b => THex2Binary' (D0 a) (B.O(B.O(B.O(B.O b))))
+instance THex2Binary' a b => THex2Binary' (D1 a) (B.I(B.O(B.O(B.O b))))
+instance THex2Binary' a b => THex2Binary' (D2 a) (B.O(B.I(B.O(B.O b))))
+instance THex2Binary' a b => THex2Binary' (D3 a) (B.I(B.I(B.O(B.O b))))
+instance THex2Binary' a b => THex2Binary' (D4 a) (B.O(B.O(B.I(B.O b))))
+instance THex2Binary' a b => THex2Binary' (D5 a) (B.I(B.O(B.I(B.O b))))
+instance THex2Binary' a b => THex2Binary' (D6 a) (B.O(B.I(B.I(B.O b))))
+instance THex2Binary' a b => THex2Binary' (D7 a) (B.I(B.I(B.I(B.O b))))
+instance THex2Binary' a b => THex2Binary' (D8 a) (B.O(B.O(B.O(B.I b))))
+instance THex2Binary' a b => THex2Binary' (D9 a) (B.I(B.O(B.O(B.I b))))
+instance THex2Binary' a b => THex2Binary' (DA a) (B.O(B.I(B.O(B.I b))))
+instance THex2Binary' a b => THex2Binary' (DB a) (B.I(B.I(B.O(B.I b))))
+instance THex2Binary' a b => THex2Binary' (DC a) (B.O(B.O(B.I(B.I b))))
+instance THex2Binary' a b => THex2Binary' (DD a) (B.I(B.O(B.I(B.I b))))
+instance THex2Binary' a b => THex2Binary' (DE a) (B.O(B.I(B.I(B.I b))))
+instance THex2Binary' a b => THex2Binary' (DF a) (B.I(B.I(B.I(B.I b))))
+
+class THex2Binary a b | a -> b
+instance (THex2Binary' a b, B.TNF b b') => THex2Binary a b'
+tHex2Binary :: THex2Binary a b => a -> b; tHex2Binary = undefined
+
+class TBinary2Hex a b | a -> b
+instance (THex2Binary' a b, TNF a a') => TBinary2Hex b a'
+tBinary2Hex :: TBinary2Hex a b => a -> b; tBinary2Hex = undefined
+
+-- reversible version.
+class THexBinary a b | a -> b, b -> a
+instance (THex2Binary a b, TBinary2Hex b a) => THexBinary a b
+
+-- | peasant exponentiator with Binary exponent
+class TPow' a b c | a b -> c
+instance TPow' a F (D1 F)
+instance (TPow' a k c, TMul c c d) => TPow' a (B.O k) d
+instance (TPow' a k c, TMul c c d, TMul a d e) => TPow' a (B.I k) e
+
+class TPow a b c | a b -> c
+instance (THex2Binary b b', TPow' a b' c) => TPow a b c
+tPow :: TPow a b c => a -> b -> c
+tPow = undefined
+
+-- TODO: And, Or, XOr, Implies
hunk ./src/Type/Ord.hs 7
--- License     :  BSD-style (see the file libraries/base/LICENSE)
+-- License     :  BSD-style (see the file LICENSE)
addfile ./src/Type/Sign.hs
hunk ./src/Type/Sign.hs 1
+module Type.Sign (TSign, Negative, Positive, SignZero) where
+
+-- TODO: order them naturally?
+import Type.Boolean
+import Type.Ord
+
+data Closure
+class Closed a | -> a
+instance Closed Closure
+
+data Negative
+data SignZero
+data Positive
+
+class TCSign c a | a -> c
+instance TCSign Closure Negative
+instance TCSign Closure Positive
+instance TCSign Closure SignZero
+
+class TCSign Closure s => TSign s
+instance TSign Negative
+instance TSign SignZero
+instance TSign Positive
+
+instance TEq Negative Negative T
+instance TEq Negative SignZero F
+instance TEq Negative Positive F
+instance TEq SignZero Negative F
+instance TEq SignZero SignZero T
+instance TEq SignZero Positive F
+instance TEq Positive Negative F
+instance TEq Positive SignZero F
+instance TEq Positive Positive T
}
