[Added Data.THash
ekmett@gmail.com**20060805081023] {
adddir ./src/Data
adddir ./src/Data/THash
addfile ./src/Data/Hashable.hs
hunk ./src/Data/Hashable.hs 1
+-----------------------------------------------------------------------------
+-- |
+-- Module      :  Data.Hashable
+-- Copyright   :  (C) 2006 Edward Kmett
+-- License     :  BSD-style (see the file libraries/base/LICENSE)
+--
+-- Maintainer  :  Edward Kmett <ekmett@gmail.com>
+-- Stability   :  experimental
+-- Portability :  non-portable (requires STM)
+--
+-- A simple class for hashable objects to facilitate the use of "Data.THash".
+-- We try to use a number of non-prime mix functions to better support the
+-- power of 2 hashing function under the hood.
+----------------------------------------------------------------------------
+
+module Data.Hashable (Hashable, hash) where
+
+import Data.Bits
+import Char (ord)
+
+class Hashable a where
+    hash :: a -> Int
+
+instance Hashable Int where
+    {-# INLINE hash #-}
+    hash = ap xor (`shiftR` 16) 
+	. ap (+) (complement . (`shiftL` 11)) 
+	. ap xor (`shiftR` 6) 
+	. ap (+) (`shiftL` 3) 
+	. ap xor (`shiftR` 10)
+	. ap (+) (complement . (`shiftL` 15))
+	where ap x y z = x z $ y z 
+
+-- based on hashString in Data.HashTable
+instance Hashable a => Hashable [a] where
+    {-# INLINE hash #-}
+    hash = foldr f 0 
+	where f c m = hash c + (m * 128) `mod` 1500007
+
+instance Hashable Char where
+    {-# INLINE hash #-}
+    hash = hash . ord  
+
+instance (Hashable a, Hashable b) => Hashable (a,b) where
+    {-# INLINE hash #-}
+    hash (a,b) = hash a - hash b
+	
+instance (Hashable a, Hashable b, Hashable c) => Hashable (a,b,c) where
+    {-# INLINE hash #-}
+    hash (a,b,c) = ha - (hb `xor` hc) + hc
+        where 
+	    ha = hash a
+	    hb = hash b
+	    hc = hash c 
+
+instance (Hashable a, Hashable b, Hashable c, Hashable d) => Hashable (a,b,c,d) where
+    {-# INLINE hash #-}
+    hash (a,b,c,d) = hash (a,b,c) - hash d
+
+instance (Hashable a, Hashable b, Hashable c, Hashable d, Hashable e) => Hashable (a,b,c,d,e) where
+    {-# INLINE hash #-}
+    hash (a,b,c,d,e) = hash ((a,b),c,d,e)
+
addfile ./src/Data/THash.hs
hunk ./src/Data/THash.hs 1
+{-# OPTIONS -fglasgow-exts #-}
+-----------------------------------------------------------------------------
+-- |
+-- Module      :  Data.THash
+-- Copyright   :  (C) 2006 Edward Kmett
+-- License     :  BSD-style (see the file libraries/base/LICENSE)
+--
+-- Maintainer  :  Edward Kmett <ekmett@gmail.com>
+-- Stability   :  experimental
+-- Portability :  non-portable (requires STM)
+--
+-- A simple "STM" based transactional linear hash table based on Witold 1980.
+-- This wraps a "Data.THash.THT" in an simple container. It may be
+-- more appropriate to use the underlying "THT" structure directly if you are
+-- nesting these. The performance hit hasn't yet been measured.
+----------------------------------------------------------------------------
+
+module Data.THash (
+    THash,  
+    new,     -- (k -> Int) ->                               STM (THash k v)
+    newH,    -- Hashable k => 				    STM (THash k v)
+    fromList,-- Eq k => (k -> Int) -> [(k,v)] ->            STM (THash k v)
+    insert,  -- Eq k => THash k v -> k -> v ->              STM (Bool)
+    update,  -- Eq k => THash k v -> k -> v ->              STM ()
+    modify,  -- Eq k => THash k v -> k -> (Maybe v -> v) -> STM ()
+    delete,  -- Eq k => THash k v -> k ->                   STM (Bool)
+    lookup,  -- Eq k => THash k v -> k ->                   STM (Maybe v)
+    mapH,    -- ((k,v) -> r) -> THash k v ->                STM [r]
+    each,    -- THash k v ->                                STM [(k,v)]
+    keys,    -- THash k v ->                                STM [k]
+    values,  -- THash k v ->                                STM [v]
+    hashInt, -- Int -> Int
+    -- hashString -- Int -> Int
+) where 
+
+import qualified Data.THash.THT as THT hiding(THT)
+import Data.Hashable
+import Data.THash.THT (THT)
+import Prelude hiding (lookup)
+import Control.Monad (liftM)
+import Control.Concurrent.STM
+import Control.Concurrent.STM.TVar
+import Data.Bits
+
+-- | A hash with keys of type k to values of type v
+newtype THash k v = THash (TVar (THT k v))
+
+{-# INLINE make #-}
+make :: THT k v -> STM (THash k v)
+make t = do x <- newTVar t; return $ THash x
+
+{-# INLINE get #-}
+get :: THash k v -> STM (THT k v)
+get (THash h) = readTVar h
+
+{-# INLINE set #-}
+set :: THash k v -> THT k v -> STM ()
+set (THash h) = writeTVar h 
+
+{-# INLINE setif #-}
+setif :: THash k v -> (THT k v,Bool) -> STM (Bool)
+setif (THash h) (t,b) 
+    | b == True 
+    = writeTVar h t >> return True
+    | otherwise
+    = return False
+
+{-# INLINE new #-}
+-- | Build an empty hash table
+new :: (k -> Int) -> STM (THash k v)
+new hash = make =<< THT.new hash
+
+{-# INLINE newH #-}
+-- | Build an empty hash table using the default hash function for the key type.
+newH :: Hashable k => STM (THash k v)
+newH = new hash
+
+{-# INLINE fromList #-}
+-- | Build a hash table from a list of @(key,value)@ pairs
+fromList :: Eq k => (k -> Int) -> [(k,v)] ->             STM (THash k v)
+fromList hash list = make =<< THT.fromList hash list
+
+{-# INLINE insert #-}
+-- | Insert a value into the hash table. If a value with the key is present
+-- then nothing is changed and 'False' is returned.
+insert :: Eq k => THash k v -> k -> v ->               STM (Bool)
+insert hash key value = do x <- get hash; y <- THT.insert x key value; setif hash y
+
+{-# INLINE update #-}
+-- | Insert a value into the hash table, replacing any value with the same key that is present.
+update :: Eq k => THash k v -> k -> v ->               STM ()
+update hash key value = do x <- get hash; y <- THT.update x key value; set hash y
+
+{-# INLINE modify #-}
+-- | Update a value in the hash table using the supplied function. 
+modify :: Eq k => THash k v -> k -> (Maybe v -> v) ->  STM ()
+modify hash key f = do x <- get hash; y <- THT.modify x key f ; set hash y
+
+{-# INLINE delete #-}
+-- | Remove a value from the hash table. Returns 'True' to indicate success.
+delete :: Eq k => THash k v -> k ->                    STM (Bool)
+delete hash key = do x <- get hash; y <- THT.delete x key; setif hash y
+
+{-# INLINE lookup #-}
+-- | Lookup a value in the hash table. 
+lookup :: Eq k => THash k v -> k ->                    STM (Maybe v)
+lookup hash key = do x <- get hash; THT.lookup x key
+
+{-# INLINE mapH #-}
+-- | Map a function over all @(key,value)@ functions in the hash table.
+mapH   :: ((k,v) -> r) -> THash k v ->                 STM [r]
+mapH f hash = do x <- get hash; THT.mapH f x 
+
+{-# INLINE each #-}
+-- | @each = mapH id@ and returns all @(key,value)@ pairs in the hash.
+each   :: THash k v -> STM [(k,v)]
+each = mapH id
+
+{-# INLINE keys #-}
+-- | @each = mapH fst@ and returns all keys in the hash.
+keys   :: THash k v -> STM [k]
+keys = mapH fst
+
+{-# INLINE values #-}
+-- | @each = mapH snd@ and returns all values present in the hash.
+values :: THash k v -> STM [v]
+values = mapH snd
+
+{-# INLINE hashInt #-}
+-- | Thomas Wang's 32 bit mix function; more effective than a prime modulus for 
+-- declustering a linear hash, but not good against an adversary, since its easily 
+-- reversed.
+hashInt :: Int -> Int
+hashInt = ap xor (`shiftR` 16) 
+	. ap (+) (complement . (`shiftL` 11)) 
+	. ap xor (`shiftR` 6) 
+	. ap (+) (`shiftL` 3) 
+	. ap xor (`shiftR` 10)
+	. ap (+) (complement . (`shiftL` 15))
+	where ap x y z = x z $ y z 
addfile ./src/Data/THash/THT.hs
hunk ./src/Data/THash/THT.hs 1
+---------------------------------------------------------------------------
+-- |
+-- Module      :  Data.THash.THT
+-- Copyright   :  (C) 2006 Edward Kmett
+-- License     :  BSD-style (see the file libraries/base/LICENSE)
+--
+-- Maintainer  :  Edward Kmett <ekmett@gmail.com>
+-- Stability   :  experimental
+-- Portability :  non-portable (requires STM)
+--
+-- "Data.THash" Internals. Unless you really want to do the plumbing yourself
+-- you probably want to use that instead.
+-- 
+-- There is a nearby point in the design space that generates a traditional
+-- sorted linear hash table which will output keys and values in the same 
+-- order as long as both hashes have the same set of keys, regardless of 
+-- insertion order. To get there we would need to maintain the linked lists 
+-- in sorted order.
+----------------------------------------------------------------------------
+
+module Data.THash.THT (
+    THT,     -- Eq key => THT key value
+    new,     -- (k -> Int) ->                              STM (THT k v)
+    fromList,-- Eq k => (k -> Int) -> [(k,v)] ->           STM (THT k v)
+    insert,  -- Eq k => THT k v -> k -> v ->               STM (THT k v, Bool)
+    update,  -- Eq k => THT k v -> k -> v ->               STM (THT k v)
+    modify,  -- Eq k => THT k v -> k -> (Maybe v -> v) ->  STM (THT k v)
+    delete,  -- Eq k => THT k v -> k ->                    STM (THT k v, Bool)
+    lookup,  -- Eq k => THT k v -> k ->                    STM (Maybe v)
+    mapH,    --((k,v) -> r) -> THT k v ->                  STM [r]
+    each,    -- THT k v ->                                 STM [(k,v)]
+    keys,    -- THT k v ->                                 STM [k]
+    values   -- THT k v ->                                 STM [v]
+) where 
+
+import Prelude
+    ( Show(..), Ord(..), Eq, Bool(..), Maybe(..),
+    , Num, Int
+    , (*), (+), (-), ($), (==), (++), (.), (/=)
+    , mapM_, sequence_, sequence, return, mod, fst, snd, id
+    , otherwise
+    )
+import Data.Array
+import Control.Monad (liftM)
+import Control.Concurrent.STM
+import Control.Concurrent.STM.TVar
+import qualified Data.List as List (partition, lookup, length, concatMap, map, replicate)
+import Foreign (unsafePerformIO)
+
+data THT k v = MkTHT
+    { key_count   :: !Int
+    , slots       :: Array Int (TVar [(k, v)])
+    , split_ptr   :: !Int
+    , max_split   :: !Int
+    , hash        :: k -> Int
+    }
+
+{-# INLINE new #-}
+new :: (k -> Int) -> STM (THT k v)
+new hash = do 
+    slots <- sequence $ List.replicate 4 (newTVar [])
+    return MkTHT
+        { key_count = 0
+        , slots     = listArray (0,3) slots
+        , split_ptr = 0
+        , max_split = 1
+        , hash      = hash 
+        }
+
+{-# INLINE fromList #-}
+fromList :: Eq k => (k -> Int) -> [(k,v)] -> STM(THT k v)
+fromList hash list = do
+    slots <- sequence $ List.replicate max2 (newTVar [])
+    let this = MkTHT
+            { key_count = len
+            , slots     = listArray (0,max2-1) slots
+            , split_ptr = 0
+            , max_split = max
+            , hash      = hash
+            }
+        put (key,value) = do
+            let loc = chain this key
+            list <- readTVar loc
+            writeTVar loc $ (key,value):list
+    mapM_ put list
+    return this
+    where
+    len = List.length list 
+    max = p2 1
+    max2 = max*2
+    p2 m | len < m   = m
+         | otherwise = p2 (m+m)
+
+{-# INLINE split #-}
+split :: THT k v -> STM (THT k v)
+split this
+    | old + 1 < max
+    = split' this { split_ptr = old + 1 }
+    | len < 2
+    = return this
+    | otherwise
+    = do slots' <- grow $ slots this
+         split' this 
+            { split_ptr = max
+            , max_split = max + max
+            , slots     = slots'
+            }
+    where 
+    old = split_ptr this
+    max = max_split this
+    len = key_count this
+    new = old + max
+    split' this' = do 
+        list <- readTVar $ slots this' ! old
+        let bin'    = bin this'
+            (ol,nl) = List.partition (\(k,v) -> old == (locate this' k)) list
+        writeTVar (slots this' ! old) ol -- reverse ol?
+        writeTVar (slots this' ! new) nl -- reverse nl?
+        return this'
+            
+{-# INLINE merge #-}
+merge :: THT k v -> STM (THT k v)
+merge this
+    | split_ptr this /= 0
+    = merge' this{ split_ptr = split_ptr this - 1 }
+    | key_count this < 1
+    = return this
+    | otherwise
+    = merge' this
+        { max_split = m + m
+        , split_ptr = m - 1 
+        }
+    where
+    m = max_split this
+    merge' this' = do
+        ol <- readTVar $ ov
+        nl <- readTVar $ nv
+        writeTVar nv (ol ++ nl) -- merge and reverse?
+        writeTVar ov []
+        return this'
+        where
+        new = split_ptr this'
+        max = max_split this'
+        old = new + max
+        v = slots this'
+        ov = v ! old
+        nv = v ! new
+    
+{-# INLINE lookup #-}
+lookup :: Eq k => THT k v -> k -> STM (Maybe v)
+lookup this key = if (key_count this == 0) 
+    then return Nothing
+    else do
+    list <- readTVar $ chain this key
+    return $ List.lookup key list
+
+{-# INLINE insert #-}
+insert :: Eq k => THT k v -> k -> v -> STM (THT k v, Bool)
+insert this key value = do
+    list <- readTVar $ chain this key
+    case List.lookup key list of 
+        Just _ -> return (this,False)
+        (Nothing) -> do
+            this' <- split this
+            let tvar = chain this' key
+            list' <- readTVar tvar
+            writeTVar tvar $ (key,value):list'
+            return (this',True)
+
+{-# INLINE update #-}
+update :: Eq k => THT k v -> k -> v -> STM (THT k v)
+update this key value = modify this key $ \_ -> value
+
+{-# INLINE modify #-}
+modify :: Eq k => THT k v -> k -> (Maybe v -> v) -> STM (THT k v)
+modify this key f = do
+    list <- readTVar old
+    case List.lookup key list of 
+        Just value -> do 
+            writeTVar old $ List.map fixup list 
+            return this
+        Nothing -> liftM fst . insert this key . f $ Nothing
+    where
+    old = chain this key
+    fixup (k,v) | k == key  = (k, f $ Just v)
+                | otherwise = (k, v)
+
+{-# INLINE delete #-}
+delete :: Eq k => THT k v -> k -> STM (THT k v, Bool)
+delete this key = do 
+    let tvar = chain this key
+    list <- readTVar $ tvar
+    case strip key list of 
+        (list', True) -> do 
+            writeTVar tvar list'
+            this' <- merge this
+            return (this', True)
+        (_, False) -> return (this, False)
+
+{-# INLINE strip #-}
+strip :: Eq k => k -> [(k,v)] -> ([(k,v)],Bool)
+strip key list = strip' key list []
+
+strip' :: Eq k => k -> [(k,v)] -> [(k,v)] -> ([(k,v)],Bool)
+strip' key ((key',val):tail) head
+    | key == key'   = (head ++ tail, True) -- delete
+    | otherwise     = strip' key tail $ (key',val):head
+strip' _ [] head = (head, False) 
+
+{-# INLINE grow #-}
+-- replace a numerically indexed array of TVars of lists with one twice its size.
+grow :: (Ix i, Num i) => Array i (TVar [t]) -> STM (Array i (TVar [t]))
+grow a = do
+    top <- sequence [ newTVar [] | i <- range (l', h') ]
+    return $ listArray (l,h') $ elems a ++ top
+    where
+    (l,h) = bounds a
+    l' = h + 1
+    h' = l' + h - l
+        
+{-# INLINE bin #-}
+-- figure out what bin a given hashed value is mapped to.
+bin :: THT k v -> Int -> Int
+bin this val
+    | x < split_ptr this = val `mod` (m+m)
+    | otherwise          = x
+    where
+    x = val `mod` m 
+    m = max_split this
+
+{-# INLINE locate #-}
+-- translate a key to its current bin
+locate :: THT k v -> k -> Int
+locate this key = bin this $ hash this key
+
+{-# INLINE chain #-}
+-- translate a key to a tvar in which we might find it
+chain :: THT k v -> k -> TVar [(k,v)]
+chain this key = slots this ! locate this key
+
+{-# INLINE mapH #-}
+mapH :: ((k,v) -> r) -> THT k v -> STM [r]
+mapH f this = do 
+    lists <- sequence [ readTVar $ slots this ! i | i <- [0,key_count this] ]
+    return $ List.concatMap (List.map f) lists
+    
+{-# INLINE each #-}
+each :: THT k v -> STM [(k,v)]
+each = mapH id 
+
+{-# INLINE keys #-}
+keys :: THT k v -> STM [k]
+keys = mapH fst
+
+{-# INLINE values #-}
+values :: THT k v -> STM [v]
+values = mapH snd
+
}
