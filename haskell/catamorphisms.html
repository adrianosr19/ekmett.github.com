<html>
<!-- Mirrored from comonad.com/haskell/catamorphisms.html by HTTrack Website Copier/3.x [XR&CO'2013], Tue, 20 Aug 2013 22:07:27 GMT -->
<head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
<link href="http://fonts.googleapis.com/css?family=Gentium+Book+Basic|Actor" rel="stylesheet" type="text/css">
<style type="text/css">
      html,body { font-family: 'Actor', Arial, sans-serif; font-weight: 400; }
      body { width:57.69em; *width:56.3em; min-width:750px; margin:0 auto; text-align:left }
      #main-section {padding-bottom: 2em; font-family: 'Gentium Book Basic', Georgia, serif; font-weight: 400; }
      h1 {font-size: xx-large; }
      h2 {font-size: x-large; }
      h3 {font-size: large; }
      a.embed {padding: 0.5em; border: 1px dashed; margin: 0.5em; background-color: #EEE;}
      .section { margin-bottom: 2em; border-bottom: 1px; border-bottom-color: #333; border-bottom-style: dotted; }
      .comment { margin-left: 1em; margin-bottom: 1em; border-top: 2px solid #CCC; }
      .reply { margin-left: 2em; border-left: 2px solid #CCC; padding-left: 1em }
    </style>
<title>Catamorphisms</title></head>
<body><div><div class="header"><h1>Catamorphisms</h1>
<h2>Folding data structures</h2>
<p>An overview and derivation of the category-theoretic notion of a catamorphism as a recursion scheme, and an exploration of common variations on the theme.</p></div>
<div class="section" id="author-section"><h3>Authors</h3>
<ul id="authors"><li><a rel="author" href="catamorphisms-author.html">Edward Kmett</a></li>
</ul>
</div>
<div class="section" id="footer-section"><p id="pubstate">Published</p>
<p id="license"><a href="http://creativecommons.org/licenses/copyright/3.0">All Rights Reserved</a></p>
<p id="version">Version  7 </p>
<p id="modified">Last edited:  Sep 14, 2011 </p>
<p id="exported">Exported:  May 27, 2012 </p>
<p id="permalink">Original URL:  http://knol.google.com/k/-/-/3qi7x2qrdushx/2 </p></div>
<div class="section" id="main-section"><div xmlns="http://www.w3.org/1999/xhtml" xmlns:jot="http://www.google.com/ns/jotspot/srvtmpl/"><div dir="ltr"><b>Description</b><br />Catamorphisms are generalizations of the concept of a fold in functional programming. A <i>catamorphism</i> deconstructs a data structure with an F-algebra for its underlying functor.<br /><br /><b>History</b><br />The name catamorphism appears to have been chosen by Lambert Meertens <span><a href="#references">[1]</a></span>. The category theoretic machinery behind these was resolved by Grant Malcolm <span><a href="#references">[2]</a></span><span><a href="#references">[3]</a></span>, and they were popularized by Meijer, Fokkinga and Paterson<span><a href="#references">[4]</a></span><span><a href="#references">[5]</a></span>. The name comes from the Greek 'κατα-' meaning "downward or according to". A useful mnemonic is to think of a catastrophe destroying something.<br /><br /><b>Notation</b><br />A catamorphism for some F-algebra (X,f) is denoted (| f |)<sub>F</sub>. When the functor F can be determined unambiguously, it is usually written (|φ|) or <b>cata</b> φ. Due to this choice of notation, a catamorphism is sometimes called a banana and the (|.|) notation is sometimes referred to as banana brackets.<br /><br /><b>Haskell Implementation</b><br /> <blockquote><pre>type Algebra f a = f a -&gt; a </pre><pre>newtype Mu f = InF { outF :: f (Mu f) } <br /></pre><pre>cata :: Functor f =&gt; Algebra f a -&gt; Mu f -&gt; a </pre><pre>cata f = f . fmap (cata f) . outF   </pre></blockquote><b>Alternate Definitions</b> <blockquote><pre>cata f = hylo f outF </pre><pre>cata f = para (f . fmap fst)   </pre></blockquote><b>Duality<br /></b>A catamorphism is the categorical dual of an anamorphism.<br /><br /><b>Derivation</b><br />If (μF,in<sub>F</sub>) is the initial F-algebra for some endofunctor F and (X,φ) is an F-algebra, then there is a unique F-algebra homomorphism from (μF,in<sub>F</sub>) to (X,φ), which we denote (| φ |)<sub>F</sub>. <br /><br />That is to say, the following diagram commutes:<br /><br /> <div style="margin-left:auto;margin-right:auto;text-align:center"><a href="catamorphism-diagram.png" style="background-color:transparent"><img src="catamorphism-diagram.png" /></a></div><br /><b>Laws</b><br /><br /> <table border="1" cellpadding="2" width="80%"> <tbody> <tr> <th>Rule</th> <th>Haskell</th></tr> <tr> <th>cata-cancel</th> <td>cata phi . InF = phi . fmap (cata phi)</td></tr> <tr> <th>cata-refl</th> <td>cata InF = id</td></tr> <tr> <th>cata-fusion</th> <td>f . phi = phi . fmap f =&gt; <br />f . cata phi = cata phi </td></tr> <tr> <th>cata-compose</th> <td>eps :: f :~&gt; g =&gt;<br />cata phi . cata (In . eps) =<br />cata (phi . eps)</td></tr></tbody></table><b><br />Examples</b><br /> <div>&#160;<br />The underlying functor for a string of Chars and its fixed point<br /></div> <blockquote><pre>data StrF x = Cons Char x | Nil </pre><pre>type Str = Mu StrF<br /></pre></blockquote> <blockquote><pre>instance Functor StrF where     </pre><pre>    fmap f (Cons a as) = Cons a (f as)     </pre><pre>    fmap f Nil = Nil </pre></blockquote> <div>The length of a string as a catamorphism.<br /></div> <blockquote><pre>length :: Str -&gt; Int </pre><pre>length = cata phi where     </pre><pre>    phi (Cons a b) = 1 + b     </pre><pre>    phi Nil = 0 &#160;</pre></blockquote> <div>The underlying functor for the natural numbers. <br /></div> <blockquote><pre>data NatF a = S a | Z deriving (Eq,Show) </pre><pre>type Nat = Mu NatF  </pre><pre>instance Functor NatF where      </pre><pre>    fmap f Z = Z      </pre><pre>    fmap f (S z) = S (f z) </pre></blockquote> <div>Addition as a catamorphism. <br /></div> <blockquote><pre>plus :: Nat -&gt; Nat -&gt; Nat </pre><pre>plus n = cata phi where      </pre><pre>    phi Z = n      </pre><pre>    phi (S m) = s m  </pre></blockquote> <div>Multiplication as a catamorphism <br /></div> <blockquote><pre>times :: Nat -&gt; Nat -&gt; Nat </pre><pre>times n = cata phi where      </pre><pre>    phi Z = z      </pre><pre>    phi (S m) = plus n m  </pre><pre>z :: Nat </pre><pre>z = InF Z  </pre><pre>s :: Nat -&gt; Nat </pre><pre>s = InF . S   </pre></blockquote><b>Mendler Style</b><br />A somewhat less common variation on the theme of a catamorphism is a catamorphism as a recursion scheme a la Mendler, which removes the dependency on the underlying type being an instance of Haskell's Functor typeclass <span><a href="#references">[6]</a></span>.<br /><br /> <blockquote><pre>type MendlerAlgebra f c = forall a. (a -&gt; c) -&gt; f a -&gt; c <span><a href="#references">[8]</a></span></pre></blockquote> <blockquote><pre>mcata :: MendlerAlgebra f c -&gt; Mu f -&gt; c </pre><pre>mcata phi = phi (mcata phi) . outF   </pre></blockquote>From which we can derive the original notion of a catamorphism:<br /><br /> <blockquote><pre>cata :: Functor f =&gt; Algebra f c -&gt; Mu f -&gt; c </pre><pre>cata phi = mcata (\f -&gt; phi . fmap f)   </pre></blockquote>This can be seen to be equivalent to the original definition of cata by expanding the definition of mcata.<br /><br />The principal advantage of using Mendler-style is it is independent of the definition of the Functor definition for f.<br /><br /><b>Mendler and the Contravariant Yoneda Lemma</b><br />The definition of a Mendler-style algebra above can be seen as the application of the contravariant version of the Yoneda lemma to the functor in question. <br /><br />In type theoretic terms, the contravariant Yoneda lemma states that there is an isomorphism between (f a) and ∃b. (b -&gt; a, f b), which can be witnessed by the following definitions.<br /><br /> <blockquote><pre>data CoYoneda f a = forall b. CoYoneda (b -&gt; a) (f b)  </pre><pre>toCoYoneda :: f a -&gt; CoYoneda f a </pre><pre>toCoYoneda = CoYoneda id  </pre><pre>fromCoYoneda :: Functor f =&gt; CoYoneda f a -&gt; f a </pre><pre>fromCoYoneda (CoYoneda f v) = fmap&#160; f v   </pre></blockquote>Note that in Haskell using an existential requires the use of <b>data</b>, so there is an extra bottom that can inhabit this type that prevents this from being a true isomorphism.<br /><br />However, when used in the context of a (CoYoneda f)-Algebra, we can rewrite this to use universal quantification because the functor f only occurs in negative position, eliminating the spurious bottom.<br /> <blockquote><pre>Algebra (CoYoneda f) a <br /><span>&#160;&#160; &#160;</span>= (by definition) CoYoneda f a -&gt; a <br /><span>&#160;&#160; &#160;</span>~ (by definition) (exists b. (b -&gt; a, f b)) -&gt; a <br /><span>&#160;&#160; &#160;</span>~ (lifting the existential) forall b. (b -&gt; a, f b) -&gt; a <br /><span>&#160;&#160; &#160;</span>~ (by currying) forall b. (b -&gt; a) -&gt; f b -&gt; a <br /><span>&#160;&#160; &#160;</span>= (by definition) MendlerAlgebra f a</pre></blockquote><b>Generalized Catamorphisms</b><br />Most more advanced recursion schemes for folding structures, such as paramorphisms and zygomorphisms can be seen in a common framework as "generalized" catamorphisms<span><a href="#references">[7]</a></span>. A generalized catamorphism is defined in terms of an F-W-algebra and a distributive law for the comonad W over the functor F which preserves the structure of the comonad W.<br /><br /> <blockquote><pre>type Dist f w = forall a. f (w a) -&gt; w (f a) </pre><pre>type FWAlgebra f w a = f (w a) -&gt; a </pre></blockquote> <blockquote><pre>g_cata :: (Functor f, Comonad w) =&gt; <br />          Dist f w -&gt; FWAlgebra f w a -&gt; Mu f -&gt; a </pre><pre>g_cata k g = extract . c where <br />    c = liftW g . k . fmap (duplicate . c) . outF   </pre></blockquote>However, a generalized catamorphism can be shown to add no more expressive power to the concept of a catamorphism. That said the separation of a number of the "book keeping" concerns by isolating them in a reusable distributive law can ease the development of F-W-algebras.<br /><br />We can transform an F-W-algebra into an F-algebra by including the comonad in the carrier for the algebra and then extracting after we perform this somewhat more stylized catamorphism:<br /><br /> <blockquote><pre>lowerAlgebra :: (Functor f, Comonad w) =&gt; <br />                Dist f w -&gt; FWAlgebra f w a -&gt; Algebra f (w a) </pre><pre>lowerAlgebra k phi = liftW phi . k . fmap duplicate </pre></blockquote> <blockquote><pre>g_cata :: (Functor f, Comonad w) =&gt; <br />          Dist f w -&gt; FWAlgebra f w a -&gt; Mu f -&gt; a </pre><pre>g_cata k phi = extract . cata (lowerAlgebra k phi)   </pre></blockquote><br />and we can trivially transform an Algebra into an F-W-Algebra by mapping the counit of the comonad over F. Then using the trivial identity functor, we can represent every catamorphism as a generalized-catamorphism. <br /> <blockquote><pre>liftAlgebra :: (Functor f, Comonad w) =&gt; </pre><pre><span>&#160;&#160; &#160;</span>Algebra f a -&gt; FWAlgebra f w a</pre><pre><br />liftAlgebra phi = phi . fmap extract</pre><pre><br /><br />cata :: Functor f =&gt; Algebra f a -&gt; Mu f -&gt; a<br />cata f = g_cata (Identity . fmap runIdentity) (liftAlgebra f)<br /></pre></blockquote>Between these two definitions we can see that a generalized catamorphism does not increase the scope of a catamorphism to encompass any more operations, it simply further stylizes the pattern of recursion.<br /><br /></div></div></div>
<div class="section" id="ref-section"><h3>References</h3>
<ol id="refs"><li>L. Meertens. First Steps towards the theory of Rose Trees. Draft Report, CWI, Amsterdam, 1987.
<br>
<a href="#"></a></li> <li>G. Malcolm. PhD. Thesis. University of Gronigen, 1990.
<br>
<a href="#"></a></li> <li>G. Malcolm. Data structures and program transformation. Science of Computer Programming, 14:255--279, 1990.
<br>
<a href="#"></a></li> <li>E. Meijer. Calculating Compilers, Ph.D Thesis, Utrecht State University, 1992.
<br>
<a href="http://research.microsoft.com/~emeijer/Papers/Thesis.pdf">http://research.microsoft.com/~emeijer/Papers/Thesis.pdf</a></li> <li>E. Meijer, M. Fokkinga, R. Paterson, Functional Programming with Bananas, Lenses, Envelopes and Barbed Wire, 5th ACM Conference on Functional Programming Languages and Computer Architecture.
<br>
<a href="http://research.microsoft.com/~emeijer/Papers/fpca91.pdf">http://research.microsoft.com/~emeijer/Papers/fpca91.pdf</a></li> <li>T. Uustalu, V. Vene. Coding Recursion a la Mendler. Proceedings 2nd Workshop on Generic Programming, WGP&#39;2000, Ponte de Lima, Portugal, 6 July 2000
<br>
<a href="http://citeseer.ist.psu.edu/314266.html">http://citeseer.ist.psu.edu/314266.html</a></li> <li>T. Uustalu, V. Vene, A. Pardo. Recursion schemes from Comonads. Nordic Journal of Computing. Volume 8 ,  Issue 3  (Fall 2001). 366--390, 2001 ISSN:1236-6064
<br>
<a href="http://citeseer.ist.psu.edu/uustalu01recursion.html">http://citeseer.ist.psu.edu/uustalu01recursion.html</a></li> <li>E. Kmett. Catamorphism. The Comonad.Reader, 2008.
<br>
<a href="../reader/2008/catamorphism/index.html">http://comonad.com/reader/2008/catamorphism/</a></li></ol></div>
<div class="section" id="comment-section"><h3>Comments</h3>
<div class="comment"><h4>Erratum</h4>
<p>Great article.<br /><br />One very small correction: I think the single occurence of lowerGAlgebra in the code should be lowerAlgebra instead.</p>
<a href="http://knol.google.com/k/-/-/1ndztpgvc6n9d/0">Max Bolingbroke</a> - Mar 2, 2011
<div class="reply"><p>Great article</p>
<a href="http://knol.google.com/k/-/-/1a7pufqnkir3y/0">Anonymous</a> - Mar 2, 2011</div></div> <div class="comment"><h4>Congratulations, Honorable Mention</h4>
<p>Dear Edward --<br /><br />We are very pleased to announce that this Knol is an Honorable Mention badge winner for English Knols created in July 2008. Congratulations. You may view your award at http://knol.google.com/k/peter-baskerville/top-pick-best-knols-of-the-month/14j3i4hyjvi88/60#.<br /><br />Top writers like you may benefit from participation in the &#39;Google Knol LinkedIn Group&#39;, located at http://www.linkedin.com/groups?gid=2185205&amp;trk=hb_side_g. <br /><br />Please consider joining with us to add your point of view. Knol is listening!<br /><br />Great work, keep it up,<br /><br />Murry Shohat and Peter Baskerville</p>
<a href="http://knol.google.com/k/-/-/2srzofgvr8kjr/0">Murry Shohat</a> - Oct 15, 2009
</div> <div class="comment"><h4>&#1054;&#1090;&#1083;&#1080;&#1095;&#1085;&#1072;&#1103; &#1089;&#1090;&#1072;&#1090;&#1100;&#1103;!</h4>
<p>&#1055;&#1086;&#1078;&#1072;&#1083;&#1091;&#1081;, &#1077;&#1078;&#1077;&#1083;&#1080; &#1042;&#1099; &#1085;&#1077;&#1087;&#1088;&#1086;&#1090;&#1080;&#1074;, &#1087;&#1077;&#1088;&#1077;&#1074;&#1077;&#1076;&#1091; &#1077;&#1105; &#1085;&#1072; &#1088;&#1091;&#1089;&#1089;&#1082;&#1080;&#1081; &#1103;&#1079;&#1099;&#1082;. &#1050;&#1072;&#1082;-&#1085;&#1080;&#1073;&#1091;&#1076;&#1100; &#1087;&#1088;&#1080; &#1085;&#1072;&#1083;&#1080;&#1095;&#1080;&#1080; &#1074;&#1088;&#1077;&#1084;&#1077;&#1085;&#1080;.</p>
<a href="http://knol.google.com/k/-/-/35awqcg5z1brp/0">Dark Magus</a> - Mar 4, 2009
<div class="reply"><p>I wrote the review of your knol and made a link from my article.</p>
<a href="http://knol.google.com/k/-/-/35awqcg5z1brp/0">Dark Magus</a> - Mar 3, 2009</div> <div class="reply"><p>Thank you. Here is my own version on the topic (in Russian): http://knol.google.com/k/dark-magus/-/35awqcg5z1brp/276<br /><br />I will translate your knol anyway as the addition to my one.</p>
<a href="http://knol.google.com/k/-/-/35awqcg5z1brp/0">Dark Magus</a> - Mar 3, 2009</div> <div class="reply"><p>You hereby have my permission to translate this knol to Russian.</p>
<a href="catamorphisms-author.html">Edward Kmett</a> - Mar 3, 2009</div></div></div></div></body>
<!-- Mirrored from comonad.com/haskell/catamorphisms.html by HTTrack Website Copier/3.x [XR&CO'2013], Tue, 20 Aug 2013 22:07:27 GMT -->
</html>
